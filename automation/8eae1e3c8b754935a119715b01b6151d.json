[
  {
    "question": "[File: src/net.rs] [Struct: DkgPrivateShares] [Shares Invariant - High] Must shares vector have one entry per src_party_id, matching the comms structure?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_14e05f3a-ef3f-47ad-81e1-a32018dbbcf9?mode=deep",
    "timestamp": "2026-02-06 21:44:00.917290",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Struct: NonceResponse] [Invariant - Critical] Must key_ids.len() == nonces.len() always hold, and is this validated?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_2a7a0b33-7538-486a-8f20-fa72de11157a?mode=deep",
    "timestamp": "2026-02-06 21:44:13.468806",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Struct: SignatureShareResponse] [Invariant - Critical] Must signature_shares.len() match the signer's key count, and is this checked?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_7f8fa76a-3a5f-4615-a8d0-702f9290c55a?mode=deep",
    "timestamp": "2026-02-06 21:44:26.405164",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Function: Signable::sign()] [Error Handling - Medium] Is the Err(e) from ecdsa::Signature::new() properly propagated and handled by callers?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_097ac2ac-501b-4ad8-a01a-4c0da0ceae8a?mode=deep",
    "timestamp": "2026-02-06 21:44:39.871326",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Function: Signable::verify()] [Error vs False - Medium] Does returning false on ecdsa::Signature::try_from() error (line 41) properly distinguish between invalid signature and parsing error?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_7d949e06-78f0-4b70-87a9-658e35377a47?mode=deep",
    "timestamp": "2026-02-06 21:44:53.864764",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Function: Packet::verify()] [Warn vs Reject - Medium] Do warn!() calls indicate the function will return false, or could some paths continue after warning?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_f6146d58-a1ba-4499-874f-58749734a71b?mode=deep",
    "timestamp": "2026-02-06 21:45:08.929184",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [All Structs] [Stack Overflow - Low] Can deeply nested structures cause stack overflow during deserialization?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_1aacab9c-d943-4727-950c-6a2efceef572?mode=deep",
    "timestamp": "2026-02-06 21:45:25.291576",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [All Vec Fields] [Heap Exhaustion - Medium] Can unbounded Vec growth cause heap exhaustion attacks?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_e21916a0-c5b8-4e71-87a8-7e8b904df49b?mode=deep",
    "timestamp": "2026-02-06 21:45:43.502121",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Function: Packet::verify()] [Timing Leak - Medium] Does early return on signer ID lookup leak timing information about valid vs invalid IDs?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_eceaaf9b-a91f-429e-b1ab-a7742a550877?mode=deep",
    "timestamp": "2026-02-06 21:46:01.646160",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Function: Signable::verify()] [Timing Leak - Medium] Does signature verification have constant-time properties or can timing distinguish valid/invalid signatures?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_17e2c2f3-02b0-4fb2-86ff-7a1b27fd2dbf?mode=deep",
    "timestamp": "2026-02-06 21:46:20.825527",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Function: DkgPrivateShares::hash()] [Sort Attack - High] Could a malicious party craft dst_ids that, when sorted (line 210), produce a collision with another party's message?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_c2850298-36c1-4e49-80cb-43aa9f6fcb44?mode=deep",
    "timestamp": "2026-02-06 21:46:41.530707",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Function: NonceResponse::hash()] [Point Order - Medium] Are points D and E hashed in consistent order (line 362-363), or could swapping them produce same hash?",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_b5f829a2-fafc-4cde-8f46-1941293e7e49?mode=deep",
    "timestamp": "2026-02-06 21:47:03.332282",
    "report_generated": false
  },
  {
    "question": "[File: src/net.rs] [Function: SignatureShareResponse::hash()] [Share Order -\n\n### Citations\n\n**File:** src/net.rs (L1-973)\n```rust\nuse std::fmt::Debug;\n\nuse hashbrown::{HashMap, HashSet};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse tracing::warn;\n\nuse crate::{\n    common::{MerkleRoot, PolyCommitment, PublicNonce, SignatureShare, TupleProof},\n    curve::{ecdsa, point::Point, scalar::Scalar},\n    state_machine::PublicKeys,\n};\n\n/// Trait to encapsulate sign/verify, users only need to impl hash\npub trait Signable {\n    /// Hash this object in a consistent way so it can be signed/verified\n    fn hash(&self, hasher: &mut Sha256);\n\n    /// Sign a hash of this object using the passed private key\n    fn sign(&self, private_key: &Scalar) -> Result<Vec<u8>, ecdsa::Error> {\n        let mut hasher = Sha256::new();\n\n        self.hash(&mut hasher);\n\n        let hash = hasher.finalize();\n        match ecdsa::Signature::new(hash.as_slice(), private_key) {\n            Ok(sig) => Ok(sig.to_bytes().to_vec()),\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Verify a hash of this object using the passed public key\n    fn verify(&self, signature: &[u8], public_key: &ecdsa::PublicKey) -> bool {\n        let mut hasher = Sha256::new();\n\n        self.hash(&mut hasher);\n\n        let hash = hasher.finalize();\n        let sig = match ecdsa::Signature::try_from(signature) {\n            Ok(sig) => sig,\n            Err(_) => return false,\n        };\n\n        sig.verify(hash.as_slice(), public_key)\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// A bad private share\npub struct BadPrivateShare {\n    /// the DH shared key between these participants\n    pub shared_key: Point,\n    /// prooof that the shared key is a valid DH tuple as per chaum-pedersen\n    pub tuple_proof: TupleProof,\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// Final DKG status after receiving public and private shares\npub enum DkgFailure {\n    /// DKG threshold not met\n    Threshold,\n    /// Signer was in the wrong internal state to complete DKG\n    BadState,\n    /// DKG public shares were missing from these signer_ids\n    MissingPublicShares(HashSet<u32>),\n    /// DKG public shares were bad from these signer_ids\n    BadPublicShares(HashSet<u32>),\n    /// DKG private shares were missing from these signer_ids\n    MissingPrivateShares(HashSet<u32>),\n    /// DKG private shares were bad from these signer_ids\n    BadPrivateShares(HashMap<u32, BadPrivateShare>),\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// Final DKG status after receiving public and private shares\npub enum DkgStatus {\n    /// DKG completed successfully\n    Success,\n    /// DKG failed\n    Failure(DkgFailure),\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// Encapsulation of all possible network message types\npub enum Message {\n    /// Tell signers to begin DKG by sending DKG public shares\n    DkgBegin(DkgBegin),\n    /// Send DKG public shares\n    DkgPublicShares(DkgPublicShares),\n    /// Tell signers to send DKG private shares\n    DkgPrivateBegin(DkgPrivateBegin),\n    /// Send DKG private shares\n    DkgPrivateShares(DkgPrivateShares),\n    /// Tell signers to compute shares and send DKG end\n    DkgEndBegin(DkgEndBegin),\n    /// Tell coordinator that DKG is complete\n    DkgEnd(DkgEnd),\n    /// Tell signers to send signing nonces\n    NonceRequest(NonceRequest),\n    /// Tell coordinator signing nonces\n    NonceResponse(NonceResponse),\n    /// Tell signers to construct signature shares\n    SignatureShareRequest(SignatureShareRequest),\n    /// Tell coordinator signature shares\n    SignatureShareResponse(SignatureShareResponse),\n}\n\nimpl Signable for Message {\n    fn hash(&self, hasher: &mut Sha256) {\n        match self {\n            Message::DkgBegin(msg) => msg.hash(hasher),\n            Message::DkgPublicShares(msg) => msg.hash(hasher),\n            Message::DkgPrivateBegin(msg) => msg.hash(hasher),\n            Message::DkgPrivateShares(msg) => msg.hash(hasher),\n            Message::DkgEndBegin(msg) => msg.hash(hasher),\n            Message::DkgEnd(msg) => msg.hash(hasher),\n            Message::NonceRequest(msg) => msg.hash(hasher),\n            Message::NonceResponse(msg) => msg.hash(hasher),\n            Message::SignatureShareRequest(msg) => msg.hash(hasher),\n            Message::SignatureShareResponse(msg) => msg.hash(hasher),\n        }\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// DKG begin message from coordinator to signers\npub struct DkgBegin {\n    /// DKG round ID\n    pub dkg_id: u64,\n}\n\nimpl Signable for DkgBegin {\n    fn hash(&self, hasher: &mut Sha256) {\n        hasher.update(",
    "url": "https://deepwiki.com/search/-wsts-security-audit-prompt-se_768e6fed-9fa7-488a-bd72-a0c2812122f3?mode=deep",
    "timestamp": "2026-02-06 21:47:26.321325",
    "report_generated": false
  }
]