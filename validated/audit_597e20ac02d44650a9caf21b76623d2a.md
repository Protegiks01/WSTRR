Audit Report

## Title
Missing Validation of KEX Public Keys in DKG Allows Predictable Shared Secrets Leading to Group Private Key Compromise

## Summary
The DKG protocol does not validate KEX (Key Exchange) public keys received in `DkgPublicShares` messages. A malicious signer can broadcast `Point::identity()` as their KEX public key, forcing all honest signers to compute the same predictable shared secret when encrypting private polynomial shares. This breaks confidentiality, allowing decryption of encrypted shares and complete reconstruction of the group private key, enabling signature forgery.

## Finding Description

The WSTS DKG protocol uses ephemeral KEX keypairs for Diffie-Hellman key exchange to encrypt private polynomial shares during distribution. [1](#0-0) 

**The Vulnerability:**

When signers receive `DkgPublicShares` messages, they store the `kex_public_key` without any validation: [2](#0-1) 

This unvalidated key is then used in Diffie-Hellman exchange to encrypt private shares: [3](#0-2) 

The `make_shared_secret` function performs scalar multiplication without validating the point: [4](#0-3) 

**Why This Breaks Security:**

Due to the fundamental elliptic curve property that `scalar * Point::identity() = Point::identity()`, when a malicious signer broadcasts `kex_public_key = Point::identity()`:

1. Every honest signer computing `shared_secret = their_kex_private * Point::identity()` gets `Point::identity()`
2. The shared secret bytes become predictable: `ansi_x963_derive_key(Point::identity().compress().as_bytes(), "DH_SHARED_SECRET_KEY/")`
3. All honest signers use the SAME shared secret when encrypting shares for the malicious signer's key_ids
4. Anyone (including network eavesdroppers) can compute this shared secret and decrypt the encrypted shares

**Contrast with Existing Protections:**

The codebase correctly validates signing nonces to prevent identity point attacks: [5](#0-4) 

However, no equivalent validation exists for KEX public keys. Test coverage confirms validation exists for invalid nonces: [6](#0-5) 

But no tests validate KEX key rejection (confirmed via codebase search).

The coordinator also stores KEX keys without validation: [7](#0-6) 

**Attack Execution:**

1. Malicious signer controls threshold `T` key_ids (realistic in weighted schemes)
2. Broadcasts `DkgPublicShares` with `kex_public_key = Point::identity()`
3. All honest parties encrypt their polynomial evaluations for those key_ids using the predictable shared secret
4. Attacker (or eavesdropper) decrypts all shares: `f_1(k), f_2(k), ..., f_N(k)` for k in malicious_key_ids
5. With `T` evaluation points, reconstructs each honest party's polynomial via Lagrange interpolation
6. Extracts constant terms `f_i(0)` from each polynomial
7. Sums all constant terms (including attacker's own) to compute the group private key

The group key is computed as the sum of polynomial constant terms: [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability results in complete compromise of the group private key, which directly maps to the critical impacts defined in scope:

1. **"Confirmation of an invalid transaction"** - A compromised group key allows forging valid-looking signatures for arbitrary transactions. The signature verification will pass, but the transaction is unauthorized.

2. **"Direct loss of funds"** - In blockchain systems using WSTS for threshold signatures (e.g., multi-signature wallets, custody solutions), forged signatures authorize unauthorized fund transfers.

**Downstream Impact:**
- All signatures produced by the compromised group can be forged
- Transaction authenticity is invalidated
- No recovery possible without complete DKG restart with new participants
- Affects all parties in the DKG round and all future users of the group key

**Quantified Example:**
In a 5-of-7 threshold setup where a malicious signer controls 5 key_ids:
- Attacker receives encrypted shares from all 7 parties
- With 5 decrypted evaluation points, reconstructs each party's degree-4 polynomial
- Extracts 7 constant terms and sums them to obtain the group private key
- Can now forge signatures for any message

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities Required:**
- Must be a legitimate signer participating in DKG (within threat model)
- Ability to modify outgoing `DkgPublicShares` message (standard signer capability)
- Control of threshold number of key_ids (common in weighted threshold schemes)

**Attack Complexity: LOW**
- Modify single field: `kex_public_key: Point::identity()` 
- Point::identity() is a valid serializable Point value (demonstrated in test code)
- No cryptographic breaks required
- No timing requirements or race conditions
- Attack is deterministic and repeatable

**Economic Feasibility: HIGH**
- If attacker already participates as a signer (zero additional cost)
- In weighted schemes, single signer commonly controls threshold+ key_ids
- Passive eavesdropping suffices (no active MITM needed)

**Detection Risk: LOW**
- No validation exists that would reject the attack
- Appears as normal DKG participation
- Only detected when forged signatures are used, by which point key is compromised

**Realistic Scenarios:**
- Insider threat: Malicious signer in custody setup
- Compromised signer node injecting malicious messages
- Economic incentive: Stealing funds from threshold wallet

## Recommendation

Implement validation for KEX public keys matching the existing `PublicNonce::is_valid()` pattern:

```rust
// In src/state_machine/signer/mod.rs, before line 1020:
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    error!("Invalid KEX public key from signer {}", dkg_public_shares.signer_id);
    return Err(Error::InvalidKexPublicKey(dkg_public_shares.signer_id));
}
```

Apply the same validation in the coordinator: [7](#0-6) 

Add a helper method in `common.rs`:
```rust
pub fn is_valid_kex_public_key(key: &Point) -> bool {
    key != &Point::identity() && key != &G
}
```

**Additional Recommendations:**
1. Add test cases for KEX key validation (similar to nonce validation tests)
2. Validate during decryption that shared_key != Point::identity()
3. Document the KEX key validation requirement

## Proof of Concept

```rust
#[test]
fn test_identity_kex_key_produces_predictable_shared_secret() {
    use crate::curve::{point::{Point, G}, scalar::Scalar};
    use crate::util::make_shared_secret;
    
    // Two different private keys
    let private_key_1 = Scalar::from(123u32);
    let private_key_2 = Scalar::from(456u32);
    
    // Malicious KEX public key
    let malicious_kex_public_key = Point::identity();
    
    // Both honest signers compute shared secrets
    let shared_secret_1 = make_shared_secret(&private_key_1, &malicious_kex_public_key);
    let shared_secret_2 = make_shared_secret(&private_key_2, &malicious_kex_public_key);
    
    // Vulnerability: Both shared secrets are identical and predictable
    assert_eq!(shared_secret_1, shared_secret_2);
    
    // Attacker can compute the same shared secret without knowing any private keys
    let attacker_computed = make_shared_secret(&Scalar::from(999u32), &malicious_kex_public_key);
    assert_eq!(shared_secret_1, attacker_computed);
    
    // This breaks the confidentiality guarantee of Diffie-Hellman key exchange
    // All encrypted shares using this shared secret are compromised
}
```

### Citations

**File:** src/net.rs (L148-149)
```rust
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/state_machine/coordinator/mod.rs (L1594-1597)
```rust
            for nonce in &mut nonce_response.nonces {
                nonce.D = Point::new();
                nonce.E = Point::new();
            }
```

**File:** src/state_machine/coordinator/frost.rs (L317-318)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/v1.rs (L165-166)
```rust
                self.group_key += comm.poly[0];
            }
```
