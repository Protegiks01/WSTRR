# Audit Report

## Title
Unbounded Encrypted Share Size Enables Memory Exhaustion DoS During DKG

## Summary
A malicious signer can send DKG private shares with arbitrarily large encrypted payloads, causing memory and CPU exhaustion in honest signers during decryption. The `decrypt()` function has no size limits, the `DkgPrivateShares` message structure allows unbounded `Vec<u8>` values, and no validation occurs before attempting decryption. This enables a node-level denial-of-service attack that can prevent DKG completion.

## Finding Description

The vulnerability stems from three interconnected weaknesses in the DKG private share processing flow:

**1. Unbounded decrypt() function:**

The `decrypt()` function accepts arbitrary-size input data with no validation. [1](#0-0) 

After extracting a 12-byte nonce, the function passes the remainder directly to AES-GCM decryption via `cipher.decrypt(nonce, cipher_data)?`, which allocates an output buffer proportional to the ciphertext size and processes all data regardless of size.

**2. Unbounded encrypted shares in network messages:**

The `DkgPrivateShares` struct contains `shares: Vec<(u32, HashMap<u32, Vec<u8>>)>` with no size constraints. [2](#0-1) 

Serde deserialization allocates memory for arbitrarily large `Vec<u8>` values without any limits.

**3. Unvalidated decryption during message processing:**

When processing incoming `DkgPrivateShares` messages, signers call `decrypt(&shared_secret, bytes)` directly on network-received data without prior size validation. [3](#0-2) 

The decryption occurs at line 1076 without size checks, and error handling only catches failures after resource consumption has already occurred.

**4. Signature verification lacks size validation:**

The `Packet.verify()` method validates message authenticity but performs no size checks on message content. [4](#0-3) 

**Attack Flow:**
1. Malicious signer (within threshold-1 limit) constructs a `DkgPrivateShares` message with gigabyte-sized `Vec<u8>` values
2. Signs the message with their valid ECDSA key
3. Message passes signature verification (authenticity check doesn't validate size)
4. Honest signers deserialize the packet, allocating memory for large vectors
5. `decrypt()` attempts to process the gigabyte payload
6. Memory allocation for output buffer or CPU processing causes resource exhaustion
7. Signer node becomes unresponsive or crashes

**Why existing protections fail:**
- Signature verification validates authenticity but not content size
- No maximum message or field size limits exist in the codebase
- Error handling happens post-decryption, after resources are consumed
- Serde deserialization allocates memory before any validation occurs

This breaks the security guarantee that honest signers can complete DKG rounds when sufficient participants (threshold) are honest.

## Impact Explanation

**Severity: Low** - Maps to "Any remotely-exploitable denial of service in a node" per the defined scope.

**Specific harm:**
- Individual signer nodes experience memory exhaustion (allocation of gigabyte-sized buffers) or CPU exhaustion (processing large ciphertexts through AES-GCM)
- Targeted signers become unresponsive or crash during DKG
- If enough signers are affected, the DKG round cannot reach threshold and fails to complete
- Group key generation is blocked until the malicious signer is excluded or the attack is mitigated

**Quantified impact:**
In a DKG round with N parties and M key IDs per party, a malicious signer can send NÃ—M encrypted shares to each victim. With 1 GB payloads, this can exceed typical signer node memory limits (4-8 GB), causing immediate failure. Multiple victims can be targeted simultaneously, preventing threshold from being met.

**Scope alignment:**
This is a node-level DoS attack against individual signers during DKG. The attack is limited to preventing DKG completion, which classifies it as Low severity per the defined impact scope.

## Likelihood Explanation

**Probability: Medium to High**

**Required capabilities:**
- Valid signer credentials (ECDSA signing key) - the attacker must be a registered signer
- Network access to send messages to other signers
- Knowledge of DKG round parameters (dkg_id)

These capabilities are within the protocol's threat model, which assumes up to threshold-1 signers may be malicious.

**Attack complexity: Low**

The attack requires only:
1. Constructing a `DkgPrivateShares` message with large `Vec<u8>` values (trivial)
2. Signing with valid ECDSA key (standard protocol operation)
3. Broadcasting during DKG private share phase (normal protocol flow)

No cryptographic breaking, race conditions, or complex timing requirements exist.

**Economic feasibility: High**
- Network bandwidth cost: One-time transmission of large messages
- Computational cost: Minimal (just message signing)
- Can target multiple victims with a single malicious message
- No ongoing resource requirements

**Detection risk: Moderate**

The attack produces observable anomalies (abnormally large messages, resource exhaustion in victims) and the attacker is identifiable via their signer_id in the message. However, damage occurs before detection can prevent it.

**Overall likelihood:** High if an attacker is a registered signer (insider or compromised credentials), Medium when accounting for the prerequisite of having signer status.

## Recommendation

Implement size validation at multiple layers to prevent memory exhaustion attacks:

**1. Add maximum size constant:**
```rust
// In src/util.rs or src/net.rs
pub const MAX_ENCRYPTED_SHARE_SIZE: usize = 1024; // 1KB is sufficient for a Scalar + overhead
```

**2. Validate size before decryption:**
```rust
// In src/util.rs, update decrypt() function
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    // Add size check
    if data.len() > MAX_ENCRYPTED_SHARE_SIZE {
        return Err(EncryptionError::DataTooLarge);
    }
    
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    // ... rest of function
}
```

**3. Validate during message processing:**
```rust
// In src/state_machine/signer/mod.rs, within dkg_private_shares()
for (dst_key_id, bytes) in shares {
    if bytes.len() > MAX_ENCRYPTED_SHARE_SIZE {
        warn!("Oversized encrypted share from signer {src_signer_id}");
        self.invalid_private_shares.insert(
            src_signer_id,
            self.make_bad_private_share(src_signer_id, rng)?,
        );
        continue;
    }
    if key_ids.contains(dst_key_id) {
        match decrypt(&shared_secret, bytes) {
            // ... rest of logic
        }
    }
}
```

**4. Add corresponding error variant:**
```rust
// In src/errors.rs, add to EncryptionError enum
pub enum EncryptionError {
    // ... existing variants
    DataTooLarge,
}
```

## Proof of Concept

```rust
#[test]
fn test_oversized_encrypted_share_dos() {
    use crate::util::{encrypt, decrypt, create_rng, make_shared_secret};
    use crate::curve::{point::Point, scalar::Scalar};
    
    let mut rng = create_rng();
    
    // Create shared secret for encryption
    let x = Scalar::random(&mut rng);
    let y = Scalar::random(&mut rng);
    let X = Point::from(x);
    let Y = Point::from(y);
    let shared_secret = make_shared_secret(&x, &Y);
    
    // Create oversized payload (10 MB)
    let oversized_plaintext = vec![0u8; 10_000_000];
    
    // Encrypt the oversized payload
    let oversized_ciphertext = encrypt(&shared_secret, &oversized_plaintext, &mut rng).unwrap();
    
    // Demonstrate that decrypt() will process this without size validation
    // This allocates ~10 MB and consumes CPU resources
    let result = decrypt(&shared_secret, &oversized_ciphertext);
    
    // Currently succeeds, demonstrating the vulnerability
    assert!(result.is_ok());
    assert_eq!(result.unwrap().len(), 10_000_000);
    
    // With the fix, this would return Err(EncryptionError::DataTooLarge)
}
```

**Notes**

The vulnerability is valid and exploitable within the protocol's threat model. While the WSTS protocol is designed with an optimistic approach that assumes detection and sanctioning of bad actors [5](#0-4) , the lack of size validation allows resource exhaustion to occur before detection mechanisms can activate. The recommended fixes add defense-in-depth protections that align with the protocol's security goals while maintaining compatibility with legitimate operations.

### Citations

**File:** src/util.rs (L102-116)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L1072-1102)
```rust
        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
```

**File:** README.md (L8-8)
```markdown
First, it is optimized for a small number of rounds in the common case where there are no byzantine actors present.  Since the protocol allows detection any bad actors in the system, it makes sense to optimize for the case where there are none.  Such byzantine actors can be sanctioned in a way that severely disincentivezes attempts to subvert the protocol.
```
