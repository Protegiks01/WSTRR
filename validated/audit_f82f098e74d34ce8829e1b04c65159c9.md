# Audit Report

## Title
Missing Nonce Count Validation Allows Denial of Service in Signing Rounds

## Summary
The `gather_nonces()` function in both FROST and FIRE coordinator implementations fails to validate that the number of nonces matches the number of key_ids in each `NonceResponse`. This allows a malicious signer to cause signing rounds to fail by sending mismatched counts, resulting in incorrect aggregate nonce computation and signature verification failures.

## Finding Description

Both coordinator implementations validate that the `key_ids` in a `NonceResponse` match the expected configuration through set equality checks and validate that each individual nonce is valid. However, neither validates that `nonces.len() == key_ids.len()`.

**FROST Coordinator Validation:** The validation checks set equality of key_ids [1](#0-0)  and individual nonce validity [2](#0-1) , but never checks vector length equality.

**FIRE Coordinator Validation:** The same validation pattern exists [3](#0-2) , with identical missing length validation.

**NonceResponse Structure:** The message contains separate vectors for `key_ids` and `nonces` [4](#0-3) , allowing mismatched lengths.

**Aggregate Nonce Computation:** When computing the aggregate nonce, both coordinators use `flat_map` to extract key_ids and nonces into separate vectors [5](#0-4) , then pass these to `compute::intermediate()`.

**Silent Truncation:** In `compute::intermediate()`, binding values are computed for all party_ids, but the `zip` operation silently truncates to the shorter length [6](#0-5) , producing an incorrect aggregate nonce when lengths mismatch.

A malicious signer can send a `NonceResponse` with `key_ids: vec![1, 2, 3]` and `nonces: vec![nonce1, nonce2]`. This passes all validation checks, but causes the coordinator to compute an aggregate nonce missing the third key's contribution. When honest signers receive the `SignatureShareRequest` containing this malformed response [7](#0-6) , they extract the same mismatched vectors [8](#0-7)  and compute signature shares based on the same incorrect aggregate nonce. The v1 signer's `sign()` method computes the aggregate nonce identically [9](#0-8) , leading to an invalid final signature that fails verification.

## Impact Explanation

This vulnerability enables a **Low severity** denial of service attack as defined in scope: "Any remotely-exploitable denial of service in a node."

Any signer can unilaterally abort signing rounds by sending mismatched nonce counts. The attack affects all signature types (FROST, Schnorr, Taproot) and requires the coordinator to restart the signing round. While this disrupts signing operations, it cannot cause consensus failures, chain splits, or funds loss. A malicious signer frequently included in signing committees could create sustained DOS, impacting all nodes relying on the coordinator for signing operations.

## Likelihood Explanation

**Likelihood: High**

The attack requires minimal capabilities:
- Must be a registered signer (within threat model)
- No cryptographic breaks required
- Trivial complexity: simply send a `NonceResponse` with mismatched vector lengths
- 100% success rate for any signing round the attacker participates in
- Low detection risk: malformed responses pass all validation checks
- Minimal cost: single malformed message per signing round

## Recommendation

Add validation in both coordinators after the set equality check:

```rust
if nonce_response.nonces.len() != nonce_response.key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id,
        nonces_len = nonce_response.nonces.len(),
        key_ids_len = nonce_response.key_ids.len(),
        "Nonce count does not match key_id count"
    );
    return Ok(());
}
```

This should be added in:
- `src/state_machine/coordinator/frost.rs` after line 521
- `src/state_machine/coordinator/fire.rs` after line 889

## Proof of Concept

```rust
#[test]
fn test_mismatched_nonce_count_truncation() {
    use wsts::compute;
    use wsts::common::PublicNonce;
    use wsts::curve::point::Point;
    
    // Simulate malicious NonceResponse: 3 key_ids but only 2 nonces
    let key_ids = vec![1u32, 2u32, 3u32];
    let nonces = vec![
        PublicNonce { D: Point::generator(), E: Point::generator() },
        PublicNonce { D: Point::generator(), E: Point::generator() },
    ];
    let msg = b"test message";
    
    // This should fail but doesn't - demonstrates the truncation
    let (r_vec, _aggregate_nonce) = compute::intermediate(msg, &key_ids, &nonces);
    
    // Proof: r_vec only has 2 elements despite 3 key_ids
    assert_eq!(r_vec.len(), 2); // Should be 3, but zip truncates
    assert_ne!(r_vec.len(), key_ids.len()); // Invariant violation
}
```

### Citations

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L523-533)
```rust
            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/frost.rs (L738-747)
```rust
        let party_ids = self
            .public_nonces
            .values()
            .flat_map(|pn| pn.key_ids.clone())
            .collect::<Vec<u32>>();
        let nonces = self
            .public_nonces
            .values()
            .flat_map(|pn| pn.nonces.clone())
            .collect::<Vec<PublicNonce>>();
```

**File:** src/state_machine/coordinator/fire.rs (L881-901)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/net.rs (L320-323)
```rust
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
```

**File:** src/net.rs (L390-391)
```rust
    /// Nonces responses used for this signature
    pub nonce_responses: Vec<NonceResponse>,
```

**File:** src/compute.rs (L86-92)
```rust
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();
```

**File:** src/state_machine/signer/mod.rs (L781-804)
```rust
        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/v1.rs (L714-714)
```rust
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
```
