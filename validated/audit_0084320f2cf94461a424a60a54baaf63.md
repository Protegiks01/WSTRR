Based on my systematic validation of this security claim against the WSTS codebase, I can confirm this is a **VALID Low severity vulnerability**.

# Audit Report

## Title
Signature Share Reordering Denial of Service in v1 Implementation

## Summary
A malicious v1 signer controlling multiple keys can cause signing rounds to fail by deliberately reordering signature shares within their `SignatureShareResponse` message. The coordinator validates only the set of key IDs without checking positional correspondence to nonces, allowing incorrect nonce-share pairings during aggregation that cause signature verification to fail.

## Finding Description

The v1 implementation allows signers to control multiple `Party` objects, each representing a key share. [1](#0-0)  When signing, the signer generates nonces and signature shares by iterating over parties in a deterministic order, establishing positional correspondence where `nonces[i]` pairs with `shares[i]`. [2](#0-1) [3](#0-2) 

However, the coordinator's validation only verifies that the set of key IDs matches the expected configuration using `HashSet` comparison, without validating ordering or positional correspondence between the previously-received nonces and the newly-received signature shares. [4](#0-3) 

When aggregating signatures, the coordinator flattens nonces and shares separately from different messages. [5](#0-4) 

The aggregator then extracts party IDs from the signature shares and uses `compute::intermediate()` to calculate binding values, which pairs nonces with binding computations by position using `zip()`. [6](#0-5) [7](#0-6) 

**Attack Path:**

1. Malicious signer generates nonces `[N1, N3, N5]` for keys `[1, 3, 5]` in order
2. Signer generates shares `[S1, S3, S5]` correctly
3. **Signer reorders shares to `[S3, S1, S5]` before sending**
4. Coordinator validates key ID set `{1, 3, 5}` matches - passes validation
5. During aggregation:
   - `nonces = [N1, N3, N5]` (from original order)
   - `sig_shares = [S3, S1, S5]` (reordered)
   - `party_ids = [3, 1, 5]` (extracted from reordered shares)
6. `compute::intermediate()` calculates:
   - `Rs[0] = N1.D + binding(3, ...) * N1.E` (wrong: key 3's binding with key 1's nonce)
   - `Rs[1] = N3.D + binding(1, ...) * N3.E` (wrong: key 1's binding with key 3's nonce)
7. Signature verification fails, aborting the signing round

The packet signature verification does not prevent this because the attacker signs their own reordered message with their own key. [8](#0-7) 

## Impact Explanation

This vulnerability enables a **denial-of-service attack** on signing operations. The impact severity is **Low** according to the defined scope: "Any remotely-exploitable denial of service in a node."

**Specific consequences:**
- Each attack causes one signing round to fail
- All participants waste computational resources on failed aggregation
- The attack can be repeated to prevent signature generation
- The malicious signer is identified via `check_signature_shares`, but the damage (failed round) has already occurred [9](#0-8) 

**Affected configurations:**
- Systems using the optional `with_v1` feature flag
- Signers controlling multiple keys (common in v1 weighted threshold architecture)

**Not affected:**
The v2 implementation is not vulnerable because each signer returns exactly one nonce and one signature share, eliminating the possibility of reordering. [10](#0-9) 

The attack does not shut down the network entirely, cause loss of funds, create chain splits, or compromise cryptographic guarantees.

## Likelihood Explanation

**Required attacker capabilities:**
1. Must be a legitimate participant who passed DKG and holds valid private keys (insider threat, explicitly within threat model)
2. Must control multiple keys in the v1 architecture
3. Must be selected for the signing committee
4. Must have network access to send messages to the coordinator

**Attack complexity:** Low - The attacker generates valid signature shares using normal signing logic, then simply reorders elements in the `signature_shares` vector before sending and signs the reordered message with their own key.

**Economic feasibility:** High - No additional computational cost beyond normal participation, minimal cost to attacker while wasting resources of all participants.

**Detection:** Immediate but post-impact - `check_signature_shares` identifies the malicious signer after aggregation fails, but detection occurs after the signing round has already failed.

**Overall probability:** Low-to-Medium - Requires insider access (legitimate signer), requires v1 feature adoption (v2 is default), and conditional on signer controlling multiple keys.

## Recommendation

The coordinator should validate positional correspondence between nonces and signature shares. Specifically, in `gather_sig_shares`, after validating the key ID set, add validation that ensures the order of key IDs in `SignatureShareResponse` matches the order in the previously received `NonceResponse` from the same signer.

Alternatively, the protocol could require that signature shares and nonces include explicit key ID arrays that must match positionally, and reject messages where the ordering differs from the nonce message.

## Proof of Concept

A complete PoC would require setting up a v1 DKG round with a malicious signer controlling multiple keys, then having that signer reorder their signature shares before sending. The test would verify that:
1. The coordinator accepts the reordered signature shares (passes validation)
2. The aggregation fails with signature verification error
3. `check_signature_shares` identifies the malicious signer
4. The signing round has failed despite detection

The core vulnerability can be demonstrated by showing that `gather_sig_shares` validation uses `HashSet` comparison which ignores ordering, while `compute::intermediate` uses positional pairing via `zip()`.

### Citations

**File:** src/v1.rs (L325-326)
```rust
        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &signers, nonces);
```

**File:** src/v1.rs (L466-470)
```rust
        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, None))
        }
```

**File:** src/v1.rs (L514-526)
```rust
/// A set of encapsulated FROST parties
pub struct Signer {
    /// The associated signer ID
    id: u32,
    /// The total number of keys
    num_keys: u32,
    /// The threshold of the keys needed to make a valid signature
    threshold: u32,
    /// The aggregate group public key
    group_key: Point,
    /// The parties which this object encapsulates
    parties: Vec<Party>,
}
```

**File:** src/v1.rs (L676-685)
```rust
    fn gen_nonces<RNG: RngCore + CryptoRng>(
        &mut self,
        secret_key: &Scalar,
        rng: &mut RNG,
    ) -> Vec<PublicNonce> {
        self.parties
            .iter_mut()
            .map(|p| p.gen_nonce(secret_key, rng))
            .collect()
    }
```

**File:** src/v1.rs (L707-719)
```rust
    fn sign(
        &self,
        msg: &[u8],
        _signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
        self.parties
            .iter()
            .map(|p| p.sign_precomputed(msg, key_ids, nonces, &aggregate_nonce))
            .collect()
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1121-1135)
```rust
            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** src/net.rs (L583-598)
```rust
            Message::SignatureShareResponse(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!(
                            "Received a SignatureShareResponse message with an invalid signature."
                        );
                        return false;
                    }
                } else {
                    warn!(
                        "Received a SignatureShareResponse message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/v2.rs (L271-275)
```rust
        SignatureShare {
            id: self.party_id,
            z_i: z,
            key_ids: self.key_ids.clone(),
        }
```
