Audit Report

## Title
Unbounded DKG Encrypted Share Size Enables Memory and CPU Exhaustion DoS

## Summary
The `encrypt()` and `decrypt()` functions accept arbitrarily large inputs without size validation. A malicious signer can exploit this during DKG by sending oversized encrypted shares in `DkgPrivateShares` messages, causing honest nodes to exhaust memory and CPU resources, effectively denying service to the DKG protocol.

## Finding Description

The vulnerability exists in the encryption/decryption flow used for DKG private share distribution.

The `encrypt()` function in `src/util.rs` accepts an unbounded `data: &[u8]` parameter with no size validation. [1](#0-0) 

Similarly, the `decrypt()` function accepts unbounded input, performing only minimal validation (checking for nonce presence). [2](#0-1) 

During DKG, the `DkgPrivateShares` message structure stores encrypted shares as unbounded `Vec<u8>` values. [3](#0-2) 

In legitimate usage, signers encrypt 32-byte Scalars, resulting in ~60-byte ciphertexts. [4](#0-3) 

However, when honest nodes receive `DkgPrivateShares` messages, they immediately clone and store the entire message in memory without any size validation. [5](#0-4) 

The handler then attempts to decrypt each encrypted share, passing the unbounded bytes directly to the `decrypt()` function. [6](#0-5) 

The coordinator similarly stores the entire message without size checks. [7](#0-6) 

**Root Cause**: The codebase assumes encrypted shares will be ~60 bytes but enforces no validation. There are no size checks at any layer - not in the encryption functions, not in the message structure, not in serde deserialization, and not in the state machine handlers.

**Attack Propagation**: A malicious signer constructs a `DkgPrivateShares` message with oversized `Vec<u8>` values (e.g., 10 MB per share), signs it with their valid private key (passes signature verification at line 467 of signer/mod.rs), and broadcasts it. [8](#0-7)  All recipients deserialize, store, and attempt to decrypt the oversized blobs, exhausting memory and CPU resources.

## Impact Explanation

**Specific Harm**: A malicious signer can send `DkgPrivateShares` messages containing arbitrarily large encrypted blobs, causing:

1. **Memory Exhaustion**: With typical DKG parameters (10 keys, 4 parties), a single malicious message could contain 40 oversized shares. At 10 MB per share, that's 400 MB per message. The `.clone()` operation creates full copies in memory. Multiple malicious messages quickly exhaust available RAM.

2. **CPU Exhaustion**: AES-GCM decryption is O(n) in ciphertext size. Attempting to decrypt 10 MB blobs instead of 32 bytes causes significant CPU delays. Processing 40 such blobs per message effectively stalls the DKG process.

3. **Network Bandwidth Saturation**: Transmitting hundreds of MB per DKG message saturates network bandwidth.

**Who is Affected**: All honest signers and the coordinator receiving the malicious messages. In a network with resource-constrained nodes, this impacts the majority of participants.

**Severity Justification**: This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." A malicious signer can remotely crash or severely degrade honest nodes during DKG, preventing the system from generating valid signing keys.

## Likelihood Explanation

**Required Attacker Capabilities**: 
- Position as a registered signer with valid message signing keys
- Ability to send messages during DKG private share distribution phase
- No cryptographic breaks required

**Attack Complexity**: Low. The attacker:
1. Constructs a `DkgPrivateShares` message with oversized `Vec<u8>` values
2. Signs it with their valid private key (passes authentication)
3. Broadcasts to honest signers and coordinator

**Economic Feasibility**: Minimal cost. Creating large byte arrays and signing messages requires negligible resources compared to victim impact.

**Detection Risk**: Medium. Oversized messages are detectable if monitored, but the protocol currently has no such monitoring.

**Estimated Probability**: High. Any malicious signer can execute this attack during any DKG round. The only prerequisite is being registered as a signer, which is assumed possible in the threat model.

## Recommendation

Implement maximum size validation for encrypted shares at multiple layers:

1. **In `decrypt()` function**: Add a maximum ciphertext size check (e.g., 1024 bytes for overhead):
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    const MAX_ENCRYPTED_SHARE_SIZE: usize = 1024; // generous overhead
    if data.len() > MAX_ENCRYPTED_SHARE_SIZE {
        return Err(EncryptionError::OversizedCiphertext);
    }
    // ... existing code
}
```

2. **In `DkgPrivateShares` handler**: Validate share sizes before processing:
```rust
for (party_id, shares) in &dkg_private_shares.shares {
    for (dst_key_id, bytes) in shares {
        if bytes.len() > MAX_ENCRYPTED_SHARE_SIZE {
            warn!("Oversized encrypted share from signer {}", src_signer_id);
            return Ok(vec![]);
        }
        // ... existing decryption code
    }
}
```

3. **At deserialization layer**: Consider using a bounded deserializer or enforcing packet size limits at the network layer.

## Proof of Concept

```rust
#[test]
fn test_oversized_dkg_private_shares_dos() {
    use crate::net::{DkgPrivateShares, Message, Packet};
    use crate::util::create_rng;
    use crate::curve::scalar::Scalar;
    use hashbrown::HashMap;
    
    // Create a malicious DkgPrivateShares with 10MB shares
    let oversized_blob = vec![0u8; 10 * 1024 * 1024]; // 10 MB
    
    let mut shares_map = HashMap::new();
    shares_map.insert(0u32, oversized_blob.clone());
    shares_map.insert(1u32, oversized_blob.clone());
    shares_map.insert(2u32, oversized_blob.clone());
    
    let malicious_msg = DkgPrivateShares {
        dkg_id: 0,
        signer_id: 0,
        shares: vec![(0, shares_map)],
    };
    
    // Sign with valid key (passes authentication)
    let mut rng = create_rng();
    let private_key = Scalar::random(&mut rng);
    let signature = malicious_msg.sign(&private_key).unwrap();
    
    let packet = Packet {
        msg: Message::DkgPrivateShares(malicious_msg),
        sig: signature,
    };
    
    // This packet would be processed by honest nodes, causing:
    // 1. 30MB+ memory allocation for storage (3 shares Ã— 10MB each)
    // 2. CPU exhaustion attempting AES-GCM decryption on 30MB+ data
    // 3. Effective DoS on resource-constrained nodes
    
    assert!(packet.msg.is_dkg_private_shares());
}
```

## Notes

This vulnerability demonstrates a fundamental lack of input validation for network messages. While signature verification ensures message authenticity, it provides no protection against resource exhaustion attacks from authenticated-but-malicious signers. The attack is within the protocol threat model (malicious signers up to threshold-1 are assumed possible) and requires no cryptographic breaks. The fix requires adding size constraints at multiple layers to ensure defense in depth.

### Citations

**File:** src/util.rs (L80-99)
```rust
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
}
```

**File:** src/util.rs (L102-116)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L934-945)
```rust
            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
```

**File:** src/state_machine/signer/mod.rs (L1058-1064)
```rust
        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1074-1097)
```rust
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/frost.rs (L360-363)
```rust
            self.ids_to_await.remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```
