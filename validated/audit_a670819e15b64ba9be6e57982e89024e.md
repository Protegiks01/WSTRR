# Audit Report

## Title
Incomplete Private Share Validation Allows DKG Denial of Service with Accountability Evasion

## Summary
The `dkg_ended()` method in the Signer state machine fails to validate that all party IDs declared in a signer's `DkgPublicShares` are present in their `DkgPrivateShares`. Additionally, when `compute_secrets()` detects missing shares and returns `DkgError::MissingPrivateShares`, the error handling only processes `DkgError::BadPrivateShares`, resulting in no accountability information. This allows a malicious signer to repeatedly cause DKG failures without being identified or excluded.

## Finding Description

The vulnerability exists in two parts:

**1. Missing Validation Logic**

The validation at lines 567-582 checks that each present `(src_party_id, shares_map)` tuple in `DkgPrivateShares.shares` contains encrypted shares for all of the receiver's destination key IDs. However, it never validates that the set of `src_party_id` values in `DkgPrivateShares.shares` matches the complete set of party IDs that the sender declared in their `DkgPublicShares.comms`. [1](#0-0) 

The validation iterates over the party IDs that ARE present and checks their completeness per destination, but does not verify that all expected party IDs are present in the first place.

**2. Inadequate Error Handling**

When the later `compute_secrets()` call detects missing shares (as it properly checks all party IDs from the commitments), it returns `DkgError::MissingPrivateShares`. However, the error handling at lines 622-650 only processes `DkgError::BadPrivateShares`. The `MissingPrivateShares` error falls into the else branch at line 640, which merely logs a warning without populating the `bad_private_shares` HashMap, resulting in `DkgFailure::BadPrivateShares({})` - an empty accountability map. [2](#0-1) 

**Attack Execution:**

1. Malicious signer sends `DkgPublicShares` with `comms: Vec<(party_id, PolyCommitment)>` declaring party IDs [1, 2, 3]
2. These commitments are validated and stored in `self.commitments` during the public shares phase
3. Malicious signer sends `DkgPrivateShares` with `shares: Vec<(u32, HashMap<u32, Vec<u8>>)>` containing only entries for party IDs [1, 2], omitting party 3
4. The validation passes because it only checks that parties 1 and 2 have complete share maps
5. Later, `compute_secret()` checks for shares from all party IDs in the commitments (including party 3) and detects the missing shares, returning `DkgError::MissingPrivateShares` [3](#0-2) 

6. The error handling fails to attribute this to the malicious signer, returning an empty map
7. DKG fails with no accountability, allowing the attacker to repeat indefinitely

## Impact Explanation

**Severity: Low** - "Any remotely-exploitable denial of service in a node"

This vulnerability enables persistent denial of service against DKG initialization:

- **DKG Failure Rate:** 100% when attacked - the missing shares cause `compute_secret()` to fail
- **Scope of Impact:** All signers participating in the DKG are affected, as DKG requires successful completion by all honest participants
- **Persistence:** The attacker is not identified in the `DkgEnd` message, preventing automatic exclusion mechanisms
- **Recovery:** Requires manual intervention to identify and exclude the malicious signer through out-of-band analysis

In WSTS-based threshold signature systems, DKG is a prerequisite for all signing operations. Blocking DKG completion prevents the establishment of the threshold signing group, which in systems like Stacks/sBTC would block peg-in/peg-out operations and multi-signature transaction capabilities. While this does not cause fund loss, it constitutes a critical availability attack on the signing infrastructure.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Capabilities:** Must be a designated signer in the DKG protocol - no additional privileges required
- **Attack Complexity:** Trivial - the attacker simply constructs `DkgPrivateShares` with a subset of their declared party IDs
- **Detection Difficulty:** Low - the empty `bad_private_shares` map provides no forensic information about which signer caused the failure
- **Economic Cost:** Negligible - requires only normal DKG participation
- **Success Rate:** Near 100% - the validation bypass is deterministic and the error handling consistently fails to attribute fault

The threat model explicitly allows for malicious signers up to threshold-1, making this attack realistic within the protocol's security assumptions.

## Recommendation

Implement two fixes:

**Fix 1: Add Completeness Validation**

Before calling `compute_secrets()`, validate that the set of party IDs in `DkgPrivateShares.shares` matches the set declared in `DkgPublicShares.comms` for each signer:

```rust
// After line 582, add:
if let Some(public_shares) = self.dkg_public_shares.get(signer_id) {
    let expected_party_ids: HashSet<u32> = public_shares.comms.iter()
        .map(|(party_id, _)| *party_id)
        .collect();
    
    if let Some(private_shares) = self.dkg_private_shares.get(signer_id) {
        let provided_party_ids: HashSet<u32> = private_shares.shares.iter()
            .map(|(party_id, _)| *party_id)
            .collect();
        
        if expected_party_ids != provided_party_ids {
            missing_private_shares.insert(*signer_id);
        }
    }
}
```

**Fix 2: Handle MissingPrivateShares Errors**

Modify the error handling to process `DkgError::MissingPrivateShares` by mapping party IDs to signer IDs using `public_keys.signer_key_ids`:

```rust
// In the error handling after line 625, replace the match with:
for (_my_party_id, dkg_error) in dkg_error_map {
    match dkg_error {
        DkgError::BadPrivateShares(party_ids) => {
            // existing handling...
        }
        DkgError::MissingPrivateShares(missing) => {
            for (_, src_party_id) in missing {
                // Map party_id to signer_id using public_keys.signer_key_ids
                if let Some(signer_id) = self.find_signer_for_party(src_party_id) {
                    bad_private_shares.insert(
                        signer_id,
                        self.make_bad_private_share(signer_id, rng)?,
                    );
                }
            }
        }
        _ => {
            warn!("Got unexpected dkg_error {dkg_error:?}");
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_incomplete_private_shares_dos() {
    use crate::state_machine::signer::Signer;
    use crate::v2;
    use crate::net::{DkgPublicShares, DkgPrivateShares};
    use rand_core::OsRng;
    
    let mut rng = OsRng;
    
    // Setup: Create two signers with v2 (single party per signer)
    // Signer 0: party_id 0, key_id 0
    // Signer 1: party_id 1, key_id 1  
    let mut signer0 = Signer::<v2::Signer>::new(
        0, 1, 2, 2, 0, vec![0],
        Default::default(), Default::default(),
        &mut rng,
    ).unwrap();
    
    // In v1, this would be more severe as one signer controls multiple parties
    // For PoC with v2, we demonstrate the validation bypass:
    
    // Attacker creates DkgPublicShares with valid commitments
    let public_shares = DkgPublicShares {
        dkg_id: 1,
        signer_id: 1,
        comms: vec![(1, signer0.signer.get_poly_commitments(&[1u8], &mut rng)[0].clone())],
        kex_public_key: Point::generator(),
    };
    
    // Attacker creates DkgPrivateShares but with EMPTY shares vec
    // This bypasses validation at line 569 (empty check) but would be caught
    // The more subtle attack in v1 is omitting some parties while including others
    let private_shares = DkgPrivateShares {
        dkg_id: 1,
        signer_id: 1,
        shares: vec![], // Omitting shares entirely
    };
    
    // Process these messages through signer state machine
    // The validation at lines 567-582 will mark this as missing
    // But if shares were partially provided, the validation would miss it
    
    // This demonstrates that:
    // 1. Empty shares are caught by line 569
    // 2. But partial omission (e.g., party 1,2 sent but not party 3) bypasses validation
    // 3. Later compute_secrets() detects it but error handling fails to attribute fault
}
```

**Note:** A complete PoC would require setting up the full DKG flow with v1::Signer (multiple parties per signer) and demonstrating the partial omission attack. The key insight is that the validation loop at line 573 iterates over `&shares.shares` - only the party IDs that ARE present - and never checks whether all expected party IDs are present.

### Citations

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L622-650)
```rust
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
```

**File:** src/v2.rs (L146-163)
```rust
        let mut missing_shares = Vec::new();
        for dst_key_id in &self.key_ids {
            for src_key_id in public_shares.keys() {
                match private_shares.get(dst_key_id) {
                    Some(shares) => {
                        if shares.get(src_key_id).is_none() {
                            missing_shares.push((*dst_key_id, *src_key_id));
                        }
                    }
                    None => {
                        missing_shares.push((*dst_key_id, *src_key_id));
                    }
                }
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }
```
