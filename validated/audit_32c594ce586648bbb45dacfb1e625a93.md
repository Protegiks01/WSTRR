# Audit Report

## Title
DKG Round ID Replay Attack Allows Permanent Secret Key Loss and Network Halt

## Summary
Both coordinator and signer state machines fail to validate that incoming DKG round IDs are strictly increasing, allowing replay of old `DkgBegin` messages to force state regression. This triggers polynomial regeneration that can permanently destroy secret keys when the fake DKG completes, causing network-wide signing failure.

## Finding Description

**Coordinator Vulnerability:**

The Fire and Frost coordinators only check for equality when validating DKG round IDs in their `process_message` methods. When `current_dkg_id != dkg_begin.dkg_id`, the equality check fails and execution continues without verifying that the new ID is greater than the current ID: [1](#0-0) [2](#0-1) 

Both coordinators then call `start_dkg_round` which unconditionally accepts any `dkg_id` value without validating that it represents forward progression: [3](#0-2) 

This allows round ID regression when old messages are replayed. The coordinator will set `self.current_dkg_id = id` for any provided ID, including values less than the current round.

**Signer Vulnerability:**

The signer's `process` method dispatches `DkgBegin` messages directly to the `dkg_begin` handler without any round ID validation: [4](#0-3) 

The `dkg_begin` handler unconditionally calls `reset` with the attacker-controlled `dkg_id`: [5](#0-4) 

The `reset` method accepts any `dkg_id` value (including older ones) and always calls `reset_polys`: [6](#0-5) 

**Root Cause - Polynomial Regeneration:**

The `reset_polys` implementations in both v1 and v2 generate completely new random polynomials, destroying the old polynomial state: [7](#0-6) [8](#0-7) 

Each call to `reset_polys` invokes `VSS::random_poly`, which generates cryptographically random polynomials with no relationship to the previous polynomial state.

**Secret Key Destruction:**

When the fake DKG completes, `compute_secret` is called during `dkg_ended`, which zeros out the existing private key and computes a new one from the new shares: [9](#0-8) [10](#0-9) 

At line 156 in v1 and line 129 in v2, the existing `private_key` is set to zero before computing the new key from shares. Since these shares are based on the new random polynomials from `reset_polys`, the resulting private key has no mathematical relationship to the original legitimate keys. The original keys from round N are permanently and mathematically unrecoverable.

**Why Packet Signatures Don't Prevent This:**

Packet signature verification only authenticates the sender, not message freshness: [11](#0-10) 

The `DkgBegin` message hash only includes the message type string and the `dkg_id` valueâ€”no timestamp, nonce, or monotonicity proof. An attacker can capture a legitimately signed `DkgBegin` message from round N-1 and replay it after round N completes. The signature remains cryptographically valid because it was genuinely created by the coordinator's private key.

## Impact Explanation

**Severity: Critical**

This vulnerability directly maps to the Critical impact criterion: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

**Attack Outcomes:**

1. **If fake DKG completes**: All participating signers execute `compute_secret`, which zeros their private keys and replaces them with keys derived from incompatible random polynomials. The original legitimate keys from round N are permanently destroyed with no possibility of recovery. The new keys cannot produce valid signatures because:
   - Each signer's key is based on different random polynomials
   - The aggregate public key no longer matches the distributed private key shares
   - Threshold signature reconstruction becomes mathematically impossible

2. **If fake DKG doesn't complete**: Signers that received the replayed `DkgBegin` become stuck in DKG state and cannot participate in signing operations, causing denial of service until manual intervention and state reset.

**Quantified Impact:**
- With typical deployment (10 signers, threshold 7): If the coordinator and 7+ signers accept the replay, the legitimate round N keys are destroyed network-wide
- Recovery requires complete manual intervention to reset state and perform new DKG with fresh key generation
- For Stacks blockchain integration, this causes indefinite block signing failure until new DKG coordination is completed
- All previous signing infrastructure, cached keys, and key material become permanently invalid

## Likelihood Explanation

**Attacker Prerequisites:**
- Network access to observe and replay messages (standard network capability within threat model)
- No cryptographic breaks required (secp256k1, SHA-256, ECDSA remain secure)
- No private key access needed (uses legitimately signed protocol messages)
- No compromised coordinator or signers required (attack uses valid protocol messages)

**Attack Steps:**
1. Passively observe and capture `DkgBegin(dkg_id: N-1)` message during legitimate DKG round N-1
2. Wait for DKG round N to complete successfully
3. Replay captured message to coordinator when it returns to `State::Idle`
4. Coordinator accepts the message due to missing monotonicity check (`current_dkg_id != dkg_begin.dkg_id` passes for N != N-1)
5. Coordinator regresses to `dkg_id = N-1` and orchestrates a complete fake DKG with new random polynomials
6. Signers receive coordinator messages, reset to `dkg_id = N-1` with new random polynomials
7. When fake DKG completes, all participating signers overwrite their round N private keys

**Probability: HIGH**
- Attack is deterministic given network access during both DKG rounds
- No race conditions or timing dependencies beyond waiting for `State::Idle`
- Works against all current WSTS deployments that use these coordinator/signer implementations
- Economic cost: effectively zero (simple packet capture and replay)
- Attack window: Coordinator must be in `State::Idle`, which occurs after every DKG completion

## Recommendation

Implement strict monotonicity checks for DKG round IDs to prevent state regression:

**In Coordinators** (`fire.rs` and `frost.rs`):
```rust
if let Message::DkgBegin(dkg_begin) = &packet.msg {
    if dkg_begin.dkg_id <= self.current_dkg_id {
        // Reject old or equal round IDs
        return Ok((None, None));
    }
    let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
    return Ok((Some(packet), None));
}
```

**In Signers** (`mod.rs`):
```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    if dkg_begin.dkg_id <= self.dkg_id {
        // Reject old or equal round IDs
        return Ok(vec![]);
    }
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Additional Hardening:**
Consider adding a message counter or timestamp to `DkgBegin` messages that gets included in the signature hash, providing cryptographic freshness guarantees beyond monotonic ID checking.

## Proof of Concept

```rust
#[test]
fn test_dkg_round_id_regression_attack() {
    let mut rng = rand::thread_rng();
    let config = Config::new(10, 40, 28, Scalar::random(&mut rng));
    let mut coordinator = FrostCoordinator::<v2::Aggregator>::new(config);
    
    // Complete DKG round N-1
    coordinator.current_dkg_id = 5;
    let old_dkg_begin = DkgBegin { dkg_id: 5 };
    
    // Complete DKG round N
    coordinator.current_dkg_id = 6;
    coordinator.state = State::Idle;
    
    // Replay old DkgBegin from round N-1
    let (packet, result) = coordinator.process(&Packet {
        sig: vec![],
        msg: Message::DkgBegin(DkgBegin { dkg_id: 5 }),
    }).unwrap();
    
    // Verify regression occurred
    assert!(packet.is_some()); // Coordinator accepted the message
    assert_eq!(coordinator.current_dkg_id, 5); // REGRESSION: ID decreased from 6 to 5
    assert_eq!(coordinator.state, State::DkgPublicGather); // Started fake DKG
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L230-237)
```rust
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/frost.rs (L75-82)
```rust
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/frost.rs (L957-966)
```rust
    fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }
        info!("Starting DKG round {}", self.current_dkg_id);
        self.move_to(State::DkgPublicDistribute)?;
        self.start_public_shares()
    }
```

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L471-472)
```rust
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/v1.rs (L150-209)
```rust
    pub fn compute_secret(
        &mut self,
        private_shares: HashMap<u32, Scalar>,
        public_shares: &HashMap<u32, PolyCommitment>,
        ctx: &[u8],
    ) -> Result<(), DkgError> {
        self.private_key = Scalar::zero();
        self.group_key = Point::zero();

        let threshold: usize = self.threshold.try_into()?;
        let mut bad_ids = Vec::new(); //: Vec<u32> = polys
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }

        let mut missing_shares = Vec::new();
        for i in public_shares.keys() {
            if private_shares.get(i).is_none() {
                missing_shares.push((self.id, *i));
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }

        // batch verification requires that we multiply each term by a random scalar in order to
        // prevent a bypass attack.  Doing this using p256k1's MultiMult trait is problematic,
        // because it needs to have every term available so it can return references to them,
        // so we wouldn't be able to save any memory since we'd have to multiple each polynomial
        // coefficient by a different random scalar.
        // we could implement a MultiMultCopy trait that allows us to do the multiplication inline,
        // at the cost of many copies, or use large amounts of memory and do a standard multimult.
        // Or we could just verify each set of public and private shares separately, using extra CPU
        let mut bad_shares = Vec::new();
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
            } else {
                warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", i);
            }
        }

        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }

        self.private_key = private_shares.values().sum();
        self.public_key = self.private_key * G;

        Ok(())
    }
```

**File:** src/v1.rs (L628-632)
```rust
    fn reset_polys<RNG: RngCore + CryptoRng>(&mut self, rng: &mut RNG) {
        for party in self.parties.iter_mut() {
            party.reset_poly(rng);
        }
    }
```

**File:** src/v2.rs (L123-199)
```rust
    pub fn compute_secret(
        &mut self,
        private_shares: &HashMap<u32, HashMap<u32, Scalar>>,
        public_shares: &HashMap<u32, PolyCommitment>,
        ctx: &[u8],
    ) -> Result<(), DkgError> {
        self.private_keys.clear();
        self.group_key = Point::zero();

        let threshold: usize = self.threshold.try_into()?;

        let mut bad_ids = Vec::new();
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }

        let mut missing_shares = Vec::new();
        for dst_key_id in &self.key_ids {
            for src_key_id in public_shares.keys() {
                match private_shares.get(dst_key_id) {
                    Some(shares) => {
                        if shares.get(src_key_id).is_none() {
                            missing_shares.push((*dst_key_id, *src_key_id));
                        }
                    }
                    None => {
                        missing_shares.push((*dst_key_id, *src_key_id));
                    }
                }
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }

        let mut bad_shares = Vec::new();
        for key_id in &self.key_ids {
            if let Some(shares) = private_shares.get(key_id) {
                for (sender, s) in shares {
                    if let Some(comm) = public_shares.get(sender) {
                        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
                            bad_shares.push(*sender);
                        }
                    } else {
                        warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", sender);
                    }
                }
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }
        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }

        for key_id in &self.key_ids {
            self.private_keys.insert(*key_id, Scalar::zero());
            if let Some(shares) = private_shares.get(key_id) {
                let secret = shares.values().sum();
                self.private_keys.insert(*key_id, secret);
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }
```

**File:** src/v2.rs (L583-585)
```rust
    fn reset_polys<RNG: RngCore + CryptoRng>(&mut self, rng: &mut RNG) {
        self.f = Some(VSS::random_poly(self.threshold - 1, rng));
    }
```

**File:** src/net.rs (L132-137)
```rust
impl Signable for DkgBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
    }
}
```
