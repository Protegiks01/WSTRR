# Audit Report

## Title
Memory Exhaustion via Unbounded PolyCommitment Vectors in DKG Public Shares

## Summary
A malicious DKG participant can exploit the lack of size validation on the `comms` vector in `DkgPublicShares` messages to cause memory and CPU exhaustion on all participating nodes (coordinator and signers), preventing DKG completion.

## Finding Description

During the DKG protocol, signers broadcast `DkgPublicShares` messages containing a vector of polynomial commitments in the `comms: Vec<(u32, PolyCommitment)>` field. [1](#0-0) 

Each `PolyCommitment` contains an `ID` struct [2](#0-1)  with `id: Scalar`, `kG: Point`, and `kca: Scalar` fields [3](#0-2) , plus a `poly: Vec<Point>` vector.

**Vulnerability on Coordinator:**

When the coordinator receives `DkgPublicShares`, it performs minimal validation (DKG ID, signer ID existence, and duplicate message detection) and directly clones and stores the entire message without any size check on the `comms` vector. [4](#0-3) 

**Vulnerability on Signers:**

Signers iterate through ALL entries in the `comms` vector to validate each `party_id` using `SignerType::validate_party_id`, then store the entire message without size limits. [5](#0-4) 

Later during DKG finalization, signers again iterate through all entries in the `comms` vector to validate polynomial commitments. [6](#0-5) 

The coordinator also iterates through all entries when validating reported bad shares. [7](#0-6) 

**Why Existing Validations Fail:**

For v2, the `validate_party_id` check only verifies `signer_id == party_id`. [8](#0-7)  This allows a malicious signer to send millions of duplicate entries all with their own valid `party_id` (which equals their `signer_id`), and all entries pass validation.

The duplicate detection logic only prevents duplicate `DkgPublicShares` messages from the same `signer_id`, not duplicate entries within a single message. [9](#0-8) [10](#0-9) 

While the HashMap insertion at line 560 will deduplicate entries with the same party_id, the resource exhaustion occurs before this deduplication can help - the message has already been received, cloned, stored in full, and all entries have been iterated through during validation.

**Attack Execution:**

A malicious authorized participant modifies their client to populate the `comms` vector with millions of duplicate `(party_id, PolyCommitment)` tuples using valid party IDs they control. For v2, they use their own `signer_id` as the `party_id` for all entries. The message passes signature verification and all existing validations, but causes resource exhaustion on all receiving nodes.

## Impact Explanation

**Severity: Low** - This is a remotely-exploitable denial of service in nodes participating in DKG.

**Specific Impacts:**
- **Memory Exhaustion:** With 1 million duplicate entries and threshold=3, each malicious signer causes ~200 MB memory consumption per receiving node (ID struct ~97 bytes + polynomial ~99 bytes + overhead)
- **CPU Exhaustion:** Validation loops iterate through all entries, causing millions of unnecessary operations
- **DKG Failure:** The DKG process cannot complete, preventing new distributed key generation
- **Service Disruption:** Nodes may need to be restarted and the malicious participant excluded

**Why Not Higher Severity:**
- Does not affect existing signing operations (DKG only)
- Does not cause fund loss or produce invalid signatures
- Requires being an authorized DKG participant (limited attack surface)
- Recoverable by restarting nodes and excluding the attacker
- Does not permanently shut down the network

## Likelihood Explanation

**Required Attacker Capabilities:**
- Must be an authorized DKG participant with valid `signer_id` and configured public keys
- Ability to construct and send network messages (trivial for any participant)

**Attack Complexity: Low**
1. Modify client to create `DkgPublicShares` message
2. Populate `comms` with millions of duplicate tuples using valid `party_id` values
3. Sign and send via normal protocol flow

**Probability: High** - Any authorized participant who turns malicious can reliably execute this attack with minimal effort. The attack is easily detectable through network monitoring and memory/CPU metrics, allowing operators to identify and exclude the malicious party.

## Recommendation

Add size validation on the `comms` vector in `DkgPublicShares` messages:

1. **In message validation:** Add a check that `comms.len()` does not exceed the expected number of parties for the signer. For v2, this should be exactly 1. For v1, this should equal the number of key IDs the signer controls.

2. **In coordinator's `gather_public_shares` method:** Before cloning and storing the message, validate:
```rust
let expected_comms_count = match signer_type {
    v2 => 1,
    v1 => self.config.public_keys.signer_key_ids.get(&signer_id).map(|ids| ids.len()).unwrap_or(0),
};
if dkg_public_shares.comms.len() > expected_comms_count {
    warn!("DkgPublicShares has too many comms entries");
    return Ok(());
}
```

3. **In signer's `dkg_public_share` method:** Add the same check before processing the message.

4. **Add duplicate detection within a single message:** Check for duplicate `party_id` values in the `comms` vector before processing.

## Proof of Concept

```rust
#[test]
fn test_unbounded_comms_dos() {
    use crate::net::{DkgPublicShares, Message};
    use crate::common::PolyCommitment;
    use crate::schnorr::ID;
    use crate::curve::{point::Point, scalar::Scalar};
    
    // Create a malicious DkgPublicShares with 1 million duplicate entries
    let malicious_party_id = 5u32;
    let mut comms = Vec::new();
    
    // Create a single PolyCommitment
    let poly_commitment = PolyCommitment {
        id: ID {
            id: Scalar::from(malicious_party_id),
            kG: Point::default(),
            kca: Scalar::from(1u32),
        },
        poly: vec![Point::default(), Point::default(), Point::default()],
    };
    
    // Duplicate it 1 million times
    for _ in 0..1_000_000 {
        comms.push((malicious_party_id, poly_commitment.clone()));
    }
    
    let malicious_message = DkgPublicShares {
        dkg_id: 1,
        signer_id: malicious_party_id,
        comms,
        kex_public_key: Point::default(),
    };
    
    // This message will pass v2 validation (signer_id == party_id)
    // but causes ~200 MB memory allocation and millions of validation iterations
    assert_eq!(malicious_message.comms.len(), 1_000_000);
}
```

### Citations

**File:** src/net.rs (L141-150)
```rust
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/schnorr.rs (L16-23)
```rust
pub struct ID {
    /// The ID
    pub id: Scalar,
    /// The public schnorr response
    pub kG: Point,
    /// The aggregate of the schnorr committed values
    pub kca: Scalar,
}
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/signer/mod.rs (L551-563)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L976-1026)
```rust
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/v2.rs (L644-650)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        _signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        signer_id == party_id
    }
```
