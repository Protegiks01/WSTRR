After conducting a thorough validation against the WSTS codebase, I can confirm this is a **valid vulnerability**.

# Audit Report

## Title
Unbounded Encrypted Share Size Enables Memory Exhaustion DoS During DKG

## Summary
The WSTS library lacks size validation on encrypted DKG private shares, allowing a malicious signer to cause memory and CPU exhaustion in honest signers by sending arbitrarily large encrypted payloads during the DKG private share distribution phase, resulting in denial-of-service attacks that prevent DKG completion.

## Finding Description

The vulnerability exists through three contributing factors:

**1. Unbounded decrypt() function:**
The `decrypt()` function accepts arbitrary-size input without validation. [1](#0-0)  The function extracts a 12-byte nonce and passes remaining ciphertext directly to AES-GCM decryption, which allocates memory for output buffers based on ciphertext size and processes all data regardless of size.

**2. Unconstrained encrypted share structure:**
The `DkgPrivateShares` message structure contains a `shares` field of type `Vec<(u32, HashMap<u32, Vec<u8>>)>` where the inner `Vec<u8>` can be arbitrarily large with no size constraints. [2](#0-1)  Serde deserialization allocates memory for vectors of any size.

**3. Unvalidated decryption in message processing:**
When signers process incoming `DkgPrivateShares` messages, they call `decrypt(&shared_secret, bytes)` where `bytes` comes directly from the network message without size validation. [3](#0-2)  Error handling only catches failures after decryption attempts, by which point memory allocation and CPU-intensive operations have already consumed resources. The coordinator has the same vulnerability when validating bad private share complaints. [4](#0-3) 

**Attack Execution:**
A malicious signer constructs a `DkgPrivateShares` message with gigabyte-sized `Vec<u8>` values, signs it with their valid ECDSA key, and broadcasts during the DKG private share phase. [5](#0-4)  When honest signers receive this message: (1) signature verification passes, (2) serde deserializes large vectors allocating memory, (3) the signer calls `decrypt(&shared_secret, bytes)` for each encrypted share, (4) AES-GCM allocates output buffers and processes the entire large ciphertext, (5) memory and CPU are exhausted before error handling can reject the malicious data.

**Why existing protections fail:**
Message signature verification validates authenticity but not content size. [6](#0-5)  No packet size limits exist in the network layer. Error handling occurs after resource consumption. The protocol assumes shares will be reasonably sized (~60 bytes: 32-byte scalar + 12-byte nonce + 16-byte auth tag) but enforces no such constraint.

## Impact Explanation

This vulnerability maps to **Low** severity: "Any remotely-exploitable denial of service in a node."

A malicious signer can cause DoS in honest signers by sending DKG private share messages with extremely large encrypted payloads (e.g., 1 GB per share). When victims decrypt these payloads, memory exhaustion occurs from allocating AES-GCM output buffers and CPU exhaustion from processing large ciphertexts, potentially causing the signer's message processing to block or crash.

With multiple key IDs, an attacker can exhaust memory on typical signer nodes (4-8 GB). Multiple signers can be targeted simultaneously, preventing the threshold from being met and causing the DKG round to fail, blocking group key generation.

The attack causes DoS in individual signer nodes during DKG but does not directly impact the blockchain, cause consensus failures, or lead to loss of funds. It prevents successful DKG completion but does not compromise cryptographic security or allow unauthorized operations.

## Likelihood Explanation

**Required attacker capabilities:**
- Must be a registered signer with valid ECDSA signing key (within protocol threat model of up to threshold-1 malicious signers)
- Must have network access to send messages to other signers
- Must know DKG round parameters (dkg_id)

**Attack complexity:** Low. The attacker constructs a `DkgPrivateShares` message with large `Vec<u8>` values (e.g., 1 GB of random bytes), signs with their valid ECDSA key, and broadcasts during the DKG private share phase.

**Economic feasibility:** Trivial. Requires minimal resources: network bandwidth for large messages (one-time cost), no computational work beyond message signing, can target multiple victims with one malicious message.

**Detection risk:** Moderate. Produces observable network anomalies (large message sizes) and visible resource exhaustion in victim nodes. However, damage occurs before detection can prevent it.

**Overall likelihood:** High if attacker gains signer credentials. Medium overall when factoring in the prerequisite of being a registered signer.

## Recommendation

Implement size validation for encrypted shares at multiple layers:

1. **Add maximum share size constant and validation in decrypt():**
   - Define `const MAX_ENCRYPTED_SHARE_SIZE: usize = 128;` (generous buffer over expected 60 bytes)
   - Add size check before decryption in `src/util.rs`

2. **Validate share sizes when processing DkgPrivateShares:**
   - In `src/state_machine/signer/mod.rs` at line ~1074, validate `bytes.len()` before calling `decrypt()`
   - In `src/state_machine/coordinator/fire.rs` at line ~709, validate size before decryption

3. **Add serde validation attributes:**
   - Consider using `#[serde(deserialize_with = "validate_share_size")]` on the `shares` field in `DkgPrivateShares`

## Proof of Concept

```rust
#[cfg(test)]
fn test_large_encrypted_share_dos() {
    use crate::util::decrypt;
    use crate::net::DkgPrivateShares;
    
    // Create a 100MB encrypted payload (simulating malicious share)
    let malicious_bytes = vec![0u8; 100_000_000];
    let shared_secret = [0u8; 32];
    
    // This will allocate significant memory and CPU before failing
    let result = decrypt(&shared_secret, &malicious_bytes);
    assert!(result.is_err()); // Eventually fails, but resources already consumed
}
```

### Citations

**File:** src/util.rs (L102-116)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L458-480)
```rust
    pub fn process<R: RngCore + CryptoRng>(
        &mut self,
        packet: &Packet,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
            Message::DkgPrivateShares(dkg_private_shares) => {
                self.dkg_private_shares(dkg_private_shares, rng)
            }
```

**File:** src/state_machine/signer/mod.rs (L1072-1102)
```rust
        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L703-749)
```rust
                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
```
