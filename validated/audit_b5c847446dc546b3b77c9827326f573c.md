# Audit Report

## Title
Non-Participating Signers Can Force DKG Failure Through Stale Invalid Share Records

## Summary
The `dkg_ended()` function contains a logic flaw where it checks if `invalid_private_shares` is empty without filtering by the set of participating signers from the current DKG round. A malicious signer can exploit this by sending invalid private shares to victims, then intentionally failing to complete the DKG themselves. The stale invalid share record persists and causes all victims to report DKG failure, even when all actual participating signers have valid shares.

## Finding Description

The vulnerability exists in the DKG end validation logic. When a signer receives the `DkgEndBegin` message, it constructs a set of participating signers from the coordinator's message: [1](#0-0) 

The code then carefully validates shares only from each participating signer in this set: [2](#0-1) 

However, after all these validations pass for participating signers, the code performs an unfiltered check on `invalid_private_shares`: [3](#0-2) 

This check at line 611 does not filter by the participating signers in `signer_ids_set`. If `invalid_private_shares` contains any entry from a non-participating signer, the DKG immediately fails at lines 653-659.

The `invalid_private_shares` map is populated during private share distribution when decryption or scalar parsing fails: [4](#0-3) 

While the `reset()` function clears this map, it only does so at DKG initiation: [5](#0-4) 

Once malformed shares are recorded in lines 1083-1086 or 1091-1094, they persist throughout the entire DKG round until the next `reset()`.

**Attack Scenario:**
1. Attacker sends malformed encrypted shares to all victims during private share distribution
2. Victims decrypt and fail to parse the shares, inserting attacker's ID into `invalid_private_shares` 
3. Attacker intentionally fails to send shares to coordinator (timeout or disconnect)
4. Coordinator creates `DkgEndBegin` with only responsive signers, excluding the attacker: [6](#0-5) 

5. Victims validate shares from participating signers - all checks pass (lines 551-609)
6. But the check at line 611 fails due to attacker's stale record in `invalid_private_shares`
7. All victims report `BadPrivateShares` failure (lines 653-659)
8. Coordinator receives failures and validates the bad share claims, but since the attacker is not in `dkg_private_shares` (didn't send shares to coordinator), it incorrectly marks victims as malicious: [7](#0-6) 

The coordinator expects to find the attacker's shares in `dkg_private_shares` to verify the victim's claim, but since the attacker never sent shares to the coordinator, this lookup fails and the victim is blamed.

## Impact Explanation

This vulnerability causes **complete DKG denial of service**. A single malicious signer can prevent any DKG from completing, regardless of how many honest signers participate or whether the threshold is met.

**Severity: Medium to High**

This maps to **Medium** severity under "Any transient consensus failures" - the inability to complete DKG is a consensus failure that prevents key generation and rotation.

Could escalate to **High** severity under "Any unintended chain split or network partition" - if the system cannot generate signing keys, different nodes may end up with different key material or fail to agree on a group key, leading to network partition.

**Security Guarantee Violated:**
The DKG protocol should tolerate up to `threshold - 1` malicious signers and still complete successfully. This vulnerability allows a single malicious signer who is **not even participating** in the final DKG round to cause complete failure, violating the fundamental threshold security model.

**Who Is Affected:**
- All signers attempting to complete DKG are blocked
- New deployments cannot generate initial keys
- Existing deployments cannot rotate keys
- Systems cannot recover from lost/compromised keys without manual intervention

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- Attacker must be a registered signer (realistic threat model assumption)
- Send malformed encrypted shares (random bytes or use wrong encryption key)
- Disconnect or timeout on subsequent coordinator messages
- No cryptographic breaks required
- No special hardware or computational resources needed

**Success Rate: ~100%**

The vulnerability is deterministic due to the logic flaw:
- Guaranteed to work every time
- No race conditions or timing dependencies
- No randomness in victim behavior
- Only defense is manual exclusion of attacker by administrators

**Detection Challenges:**
The attack is detectable in logs (victims will show warnings about invalid shares), but attribution is complex. The coordinator's validation logic may incorrectly blame victims rather than the actual attacker who didn't participate, making it difficult to identify the true malicious party.

## Recommendation

Filter `invalid_private_shares` by the participating signers before checking for DKG failure. The fix should be applied at line 611:

```rust
let dkg_end = if self.invalid_private_shares.iter().any(|(signer_id, _)| signer_ids_set.contains(signer_id)) {
    // Only fail if there are invalid shares from PARTICIPATING signers
    let relevant_invalid_shares: HashMap<u32, BadPrivateShare> = self.invalid_private_shares
        .iter()
        .filter(|(signer_id, _)| signer_ids_set.contains(signer_id))
        .map(|(k, v)| (*k, v.clone()))
        .collect();
    
    DkgEnd {
        dkg_id: self.dkg_id,
        signer_id: self.signer_id,
        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
            relevant_invalid_shares,
        )),
    }
} else {
    // Proceed with compute_secrets as normal
    match self.signer.compute_secrets(
        &self.decrypted_shares,
        &self.commitments,
        &self.dkg_id.to_be_bytes(),
    ) {
        // ... rest of the logic
    }
}
```

This ensures that only invalid shares from signers who are actually participating in this DKG round can cause failure, while stale records from non-participating signers are ignored.

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a coordinator and multiple signers
2. Have attacker signer send malformed encrypted shares to victim signers
3. Have attacker fail to send shares to coordinator
4. Coordinator sends `DkgEndBegin` excluding the attacker
5. Victim signers attempt `dkg_ended()` and fail despite all participating signers having valid shares
6. Assert that DKG fails with `BadPrivateShares` containing the non-participating attacker's ID

The vulnerability is confirmed by the code analysis showing the unfiltered check at line 611 that does not account for non-participating signers.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L529-534)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L551-583)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L611-660)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };
```

**File:** src/state_machine/signer/mod.rs (L1076-1096)
```rust
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L448-475)
```rust
    /// Ask signers to compute shares and send DKG end
    pub fn start_dkg_end(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting DkgEnd Distribution"
        );

        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
        let dkg_end_begin_msg = Packet {
            sig: dkg_end_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgPrivateBegin"),
            msg: Message::DkgEndBegin(dkg_end_begin),
        };
        self.move_to(State::DkgEndGather)?;
        self.dkg_end_start = Some(Instant::now());
        Ok(dkg_end_begin_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L695-701)
```rust
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };
```
