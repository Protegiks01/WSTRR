# Audit Report

## Title
Unauthenticated KEX Public Key Allows Private Share Decryption via Low-Order Point Attack

## Summary
The `kex_public_key` field in `DkgPublicShares` messages is not authenticated by the message signature, allowing a network adversary to replace it with `Point::identity()`. This causes all private shares encrypted for the victim to use a constant, publicly-computable shared secret, enabling complete decryption. With threshold parties compromised, an attacker can reconstruct the group secret key and forge signatures unilaterally.

## Finding Description

The vulnerability stems from a critical authentication gap in the DKG protocol's encrypted share distribution mechanism. The attack exploits two fundamental flaws:

**1. Missing Authentication**

The `Signable` implementation for `DkgPublicShares` only includes `dkg_id`, `signer_id`, and `comms` in the signature hash, completely omitting `kex_public_key`: [1](#0-0) 

This allows an attacker to modify `kex_public_key` without invalidating the message signature, which is verified during packet processing: [2](#0-1) 

**2. Missing Validation**

When `DkgPublicShares` messages are received, the `kex_public_key` is stored directly without any validation: [3](#0-2) 

Unlike `PublicNonce` which explicitly validates against `Point::identity()`: [4](#0-3) 

No such protection exists for `kex_public_key`.

**Attack Execution**

A man-in-the-middle attacker intercepts a legitimate `DkgPublicShares` message and replaces the victim's `kex_public_key` with `Point::identity()`. When other signers encrypt private shares for the victim, they compute: [5](#0-4) 

The `make_shared_secret` function performs Diffie-Hellman without validation: [6](#0-5) 

When `public_key = Point::identity()`, the computation yields:
```
shared_key = private_key * Point::identity() = Point::identity()
shared_secret = ansi_x963_derive_key(Point::identity().compress().as_bytes(), "DH_SHARED_SECRET_KEY/")
```

This produces a **constant value that anyone can compute**, allowing the attacker to decrypt all shares sent to the victim using standard AES-GCM decryption.

**Secret Reconstruction**

Each decrypted share reveals polynomial evaluations `f_j(i_victim)` for all sending parties `j`. The victim's final secret is: [7](#0-6) 

By compromising threshold number of parties' KEX keys, the attacker obtains threshold secrets `{(i_k, s_k)}`. Using Lagrange interpolation on these points, the attacker reconstructs the group secret `f(0)` and can forge signatures without any honest participation.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability completely breaks the fundamental security guarantee of the threshold signature scheme. The impact maps directly to the Critical category:

1. **"Any confirmation of an invalid transaction"** - With the reconstructed group secret, the attacker can forge valid signatures on arbitrary messages without threshold participation, allowing confirmation of fraudulent transactions.

2. **"Any causing the direct loss of funds"** - In systems using WSTS for custody (e.g., Bitcoin multisig, Stacks STX pools), the compromised group key enables the attacker to create valid spending transactions and steal all protected funds.

3. **Threshold Security Violation** - The core property that at least `t` honest parties must participate in signing is completely bypassed.

The attack provides the adversary with complete unilateral signing capability, equivalent to having compromised all threshold parties simultaneously.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to succeed because:

**Attacker Capabilities (Within Threat Model)**

The WSTS Security Model explicitly states: "Network Adversary | Adversary can observe, delay, or reorder messages but cannot forge signatures without private keys." The attack requires only message observation and modificationâ€”no signature forgery is needed because `kex_public_key` is unauthenticated.

**Attack Complexity: LOW**

- No cryptographic breaks required (secp256k1, SHA-256, AES-GCM remain secure)
- Simple field replacement in intercepted messages
- Computing `Point::identity()` is trivial
- Deriving the constant shared secret requires only standard cryptographic operations
- Lagrange interpolation is a well-known algorithm

**Detection Risk: LOW**

The attack is difficult to detect because:
- Modified messages pass signature verification (verified code path above)
- Encryption/decryption operations complete successfully
- No error conditions are triggered
- The victim may not realize their shares are compromised until after DKG completes

**Economic Feasibility: HIGH**

- Requires only network-level access (no specialized hardware)
- Can be executed in a single DKG round
- Success probability approaches 100% given the complete lack of validation

**Realistic Deployment Scenario**

In typical WSTS deployments where signers communicate over networks (even if VPN-protected), a compromised network device, malicious ISP, or sophisticated attacker with network access can execute this attack.

## Recommendation

**Immediate Fix**

Include `kex_public_key` in the signature hash by modifying the `Signable` implementation:

```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
        // ADD THIS LINE:
        hasher.update(self.kex_public_key.compress().as_bytes());
    }
}
```

**Defense in Depth**

Add point validation when storing KEX public keys:

```rust
// In dkg_public_share method, after line 1017:
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    warn!(%signer_id, "Invalid KEX public key (identity or generator)");
    return Ok(vec![]);
}

for key_id in signer_key_ids {
    self.kex_public_keys
        .insert(*key_id, dkg_public_shares.kex_public_key);
}
```

Also validate in `make_shared_secret`:

```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    if *public_key == Point::identity() || *public_key == G {
        panic!("Invalid public key for shared secret computation");
    }
    let shared_key = private_key * public_key;
    make_shared_secret_from_key(&shared_key)
}
```

## Proof of Concept

```rust
#[test]
fn test_kex_public_key_identity_attack() {
    use wsts::curve::{point::Point, scalar::Scalar};
    use wsts::util::{make_shared_secret, ansi_x963_derive_key};
    
    // Demonstrate that Point::identity() produces constant shared secret
    
    // Simulate two different senders with different private keys
    let sender1_private = Scalar::random(&mut OsRng);
    let sender2_private = Scalar::random(&mut OsRng);
    
    // Attacker sets victim's kex_public_key to Point::identity()
    let victim_compromised_key = Point::identity();
    
    // Both senders compute "shared" secret with victim
    let shared_secret_1 = make_shared_secret(&sender1_private, &victim_compromised_key);
    let shared_secret_2 = make_shared_secret(&sender2_private, &victim_compromised_key);
    
    // The "secrets" are identical and predictable
    assert_eq!(shared_secret_1, shared_secret_2);
    
    // Attacker can compute the same constant without any private keys
    let attacker_computed_secret = ansi_x963_derive_key(
        Point::identity().compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes()
    );
    
    assert_eq!(shared_secret_1, attacker_computed_secret);
    
    // All shares encrypted with this "secret" are now public
    println!("Attack successful: All shares encrypted for victim are decryptable");
}
```

This test demonstrates that when `kex_public_key = Point::identity()`, all senders derive the same constant shared secret that an attacker can independently compute, proving the confidentiality breach.

### Citations

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/v2.rs (L188-192)
```rust
        for key_id in &self.key_ids {
            self.private_keys.insert(*key_id, Scalar::zero());
            if let Some(shares) = private_shares.get(key_id) {
                let secret = shares.values().sum();
                self.private_keys.insert(*key_id, secret);
```
