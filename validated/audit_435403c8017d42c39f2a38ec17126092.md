# Audit Report

## Title
Coordinator Panic Due to Premature Wait List Removal in Signature Share Gathering

## Summary
The FIRE coordinator removes signers from the wait list before validating their signature share responses. When validation subsequently fails, the signer remains in `public_nonces` but is absent from `signature_shares`, causing a panic during aggregation when the coordinator attempts unsafe bracket notation access on the BTreeMap.

## Finding Description

The vulnerability exists in the `gather_sig_shares` function where the coordinator processes `SignatureShareResponse` messages. The critical flaw is the order of operations:

**1. Premature Wait List Removal**: The coordinator removes the signer from `sign_wait_signer_ids` immediately after confirming they are in the wait list, but BEFORE performing any validation checks. [1](#0-0) 

**2. Post-Removal Validation**: Multiple validation checks occur AFTER the wait list removal, any of which can fail and return errors including missing public key checks, missing key IDs checks, and mismatched key IDs checks. [2](#0-1) 

**3. Conditional Insertion**: The signature share is only inserted into `signature_shares` if ALL validations pass. [3](#0-2) 

**4. Error Handling Preserves Corrupted State**: When validation fails, the error is caught and returned as an `OperationResult::SignError`, but the coordinator state remains in `SigShareGather` with the signer already removed from the wait list but absent from `signature_shares`. [4](#0-3) 

**5. Unsafe Aggregation Access**: When the wait list becomes empty (after other signers successfully complete), aggregation iterates over ALL signers in `public_nonces` and accesses `signature_shares[i]` using bracket notation. Since `signature_shares` is a BTreeMap, this panics when the key doesn't exist. [5](#0-4) 

The root cause is a broken invariant: the code assumes `public_nonces.keys()` equals `signature_shares.keys()` during aggregation, but the premature wait list removal breaks this assumption.

**Attack Scenario:**
1. Attacker (registered signer) sends valid nonces during nonce gathering → added to `public_nonces`
2. Attacker sends `SignatureShareResponse` with malformed data (e.g., key_ids that don't match config)
3. Coordinator removes attacker from wait list before validation
4. Validation fails, function returns error
5. Attacker NOT added to `signature_shares`, but already removed from wait list
6. Other honest signers send valid responses and complete successfully
7. Wait list becomes empty, triggering aggregation
8. Aggregation tries to access `signature_shares[attacker_id]` → **panic!**

**Confirmation via FROST Comparison**: The FROST coordinator does NOT have this vulnerability because it performs validation first, then insertion, and only then removes from the wait list. [6](#0-5) 

## Impact Explanation

This vulnerability allows a single malicious signer to crash the coordinator node through a Rust panic, resulting in process termination. The impact aligns with **Low severity** under the scope definition: "Any remotely-exploitable denial of service in a node."

The coordinator process must be restarted to resume operations, and the affected signing round must be retried. While disruptive to availability, this does not cause direct loss of funds, enable invalid signature acceptance, trigger consensus failures, or create persistent corruption.

## Likelihood Explanation

**Likelihood: High (~100% success rate)**

The attack is deterministic and trivial to execute:

**Required Capabilities:**
- Attacker must be a registered signer in the WSTS configuration (within protocol threat model - up to threshold-1 malicious signers allowed)
- Must participate in nonce gathering phase with valid nonces
- Must send a malformed `SignatureShareResponse`

**Attack Complexity:** Very low
- No cryptographic operations required beyond normal protocol participation
- No timing dependencies or race conditions
- Single malformed packet triggers the vulnerability
- Example trigger: Send signature shares with `key_ids` that don't match the configured `signer_key_ids`

**Success Probability:** ~100% deterministic - the panic will occur reliably when the wait list empties

## Recommendation

Move the wait list removal to occur AFTER all validation checks and successful insertion into `signature_shares`. This ensures the invariant `public_nonces.keys() == signature_shares.keys()` is maintained.

The fix should reorder operations as follows:
1. Perform all validation checks (public key exists, key IDs exist, key IDs match)
2. Insert into `signature_shares` only if all validations pass
3. Remove from `sign_wait_signer_ids` only after successful insertion

This matches the correct implementation pattern already used in the FROST coordinator.

## Proof of Concept

A test would demonstrate this vulnerability by:
1. Setting up a coordinator with multiple signers
2. Having one signer send valid nonces (gets added to `public_nonces`)
3. Having that signer send a `SignatureShareResponse` with mismatched `key_ids` to trigger validation failure
4. Having other signers complete successfully
5. Observing the panic when aggregation attempts to access the missing entry in `signature_shares`

The panic would occur at the line using bracket notation to access the BTreeMap, confirming the vulnerability.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L328-332)
```rust
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1076)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };

        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1131-1135)
```rust
            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/state_machine/coordinator/frost.rs (L652-656)
```rust
            self.signature_shares.insert(
                sig_share_response.signer_id,
                sig_share_response.signature_shares.clone(),
            );
            self.ids_to_await.remove(&sig_share_response.signer_id);
```
