# Audit Report

## Title
Duplicate key_ids in NonceResponse Bypass HashSet Validation, Causing Denial of Service via Incorrect Lagrange Interpolation

## Summary
A malicious signer can inject duplicate `key_ids` into their `NonceResponse` message, bypassing coordinator validation that uses HashSet comparison. These duplicates propagate through the signing protocol and cause incorrect Lagrange coefficient computation, resulting in guaranteed signature verification failure. A single compromised signer can prevent all threshold signatures from succeeding indefinitely.

## Finding Description

**Root Cause:**
The `NonceResponse` struct stores `key_ids` as a `Vec<u32>` [1](#0-0) , but the coordinator validates it by converting to `HashSet<u32>` before comparison [2](#0-1) . This HashSet conversion silently removes duplicates, allowing a malicious `NonceResponse` with `key_ids = [1, 1, 2, 3]` to pass validation when the config expects `{1, 2, 3}`.

**Attack Path:**

1. **Validation Bypass**: The coordinator's `gather_nonces` method accepts the malicious NonceResponse because the HashSet comparison matches after duplicate removal, despite the underlying Vec containing duplicates [2](#0-1) .

2. **Duplicate Preservation**: The validated NonceResponse (with duplicates intact in the Vec field) is stored in coordinator state via `.clone()` [3](#0-2) .

3. **Propagation to Signers**: When building `SignatureShareRequest`, the coordinator collects all stored NonceResponse objects using `.values().cloned().collect()`, preserving the duplicate key_ids [4](#0-3) .

4. **Signer Extraction**: Signers extract key_ids by flat-mapping over all nonce_responses, which preserves all duplicates [5](#0-4) .

5. **Incorrect Lagrange Computation**: The `lambda()` function iterates over ALL elements in the key_ids slice [6](#0-5) . When a key_id appears multiple times, it multiplies by the same factor repeatedly, producing incorrect coefficients. For `lambda(2, [1, 1, 2, 3])`, the duplicate causes the sign to flip from -3 to +3.

6. **Wrong Signature Shares**: Each signer computes their signature share using the incorrect lambda values [7](#0-6) .

7. **Coordinator Aggregation with Same Duplicates**: The coordinator extracts key_ids from nonce_responses using the same flat_map pattern, resulting in the same duplicate key_ids [8](#0-7) .

8. **Verification Failure**: The aggregated signature fails final Schnorr verification [9](#0-8)  because the Lagrange interpolation property is violated. While `check_signature_shares` also uses the same duplicate key_ids [10](#0-9)  (making individual shares appear valid), the final aggregate fails because the mathematical relationship `z*G = R + c*GroupPublicKey` does not hold when lambda coefficients are incorrect.

**Why Existing Mitigations Fail:**
- The `NonceResponse.hash()` method includes all key_ids (with duplicates), allowing malicious signers to sign messages with duplicates [11](#0-10) .
- The error returned is `AggregatorError::BadGroupSig` [12](#0-11) , which does not identify the malicious signer, and the coordinator does not mark signers as malicious based on signature verification failures.

## Impact Explanation

This vulnerability enables a **complete denial of service** with a single compromised signer, mapping to **Low Severity**: "Any remotely-exploitable denial of service in a node."

**Quantified Impact:**
- **Immediate**: 100% signature failure rate while malicious signer participates
- **Persistent**: The malicious signer is not detected or excluded from the signing set, causing repeated failures across all signing rounds
- **Threshold Violation**: In threshold signature schemes, the system should tolerate up to (threshold-1) Byzantine participants. A single malicious signer causing complete system failure violates this security guarantee.

In Stacks integration contexts where WSTS signatures are required for transaction confirmation, this could escalate to **Critical Severity** ("Any network to shut down or otherwise not confirm new valid transactions for multiple blocks").

## Likelihood Explanation

**Required Attacker Capabilities:**
- Control of a single signer's private key (within the protocol threat model of up to threshold-1 malicious signers)
- Ability to send network messages (normal protocol participation)
- No cryptographic breaks required

**Attack Complexity:**
Very low. The attacker modifies their `NonceResponse.key_ids` field to include duplicates before signing and sending the message. The message passes signature verification because the hash includes all elements including duplicates.

**Detection and Exclusion:**
None. The malicious message passes all validation checks. The coordinator logs signature failures but does not identify the root cause or exclude the malicious signer from future rounds.

**Probability:**
High. Any compromised signer can trivially execute this attack with 100% success rate until manual intervention.

## Recommendation

Add duplicate detection to the NonceResponse validation in the coordinator's `gather_nonces` method:

```rust
// After line 885, before comparing HashSets:
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response contains duplicate key_ids");
    return Ok(());
}
```

Additionally, add similar checks in:
1. SignatureShareResponse validation
2. Signer-side validation when receiving SignatureShareRequest
3. Consider deduplicating key_ids before passing to lambda() as a defense-in-depth measure

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_dos() {
    use crate::common::PublicNonce;
    use crate::compute::lambda;
    use crate::curve::scalar::Scalar;
    
    // Demonstrate incorrect lambda computation with duplicates
    let correct_key_ids = vec![1u32, 2, 3];
    let duplicate_key_ids = vec![1u32, 1, 2, 3];
    
    // For key_id = 2:
    let correct_lambda = lambda(2, &correct_key_ids);
    let duplicate_lambda = lambda(2, &duplicate_key_ids);
    
    // correct: lambda(2, [1,2,3]) = (1/(1-2)) * (3/(3-2)) = -1 * 3 = -3
    // duplicate: lambda(2, [1,1,2,3]) = (1/(1-2)) * (1/(1-2)) * (3/(3-2)) = -1 * -1 * 3 = 3
    
    assert_ne!(correct_lambda, duplicate_lambda, "Lambda values should differ");
    
    // Verify the sign flip that breaks verification
    let expected_correct = Scalar::from(3u32).negate(); // -3
    let expected_duplicate = Scalar::from(3u32); // 3
    
    assert_eq!(correct_lambda, expected_correct);
    assert_eq!(duplicate_lambda, expected_duplicate);
}
```

### Citations

**File:** src/net.rs (L309-326)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/net.rs (L349-368)
```rust
impl Signable for NonceResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }

        for nonce in &self.nonces {
            hasher.update(nonce.D.compress().as_bytes());
            hasher.update(nonce.E.compress().as_bytes());
        }

        hasher.update(self.message.as_slice());
    }
}
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-982)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L393-404)
```rust
            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }
```

**File:** src/v2.rs (L410-416)
```rust
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
        } else {
            AggregatorError::BadGroupSig
        }
```

**File:** src/common.rs (L245-250)
```rust
    pub fn verify(&self, public_key: &Point, msg: &[u8]) -> bool {
        let c = challenge(public_key, &self.R, msg);
        let R = &self.z * G + (-c) * public_key;

        R == self.R
    }
```
