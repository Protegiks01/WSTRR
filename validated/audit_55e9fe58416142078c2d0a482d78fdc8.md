# Audit Report

## Title
Incomplete Party ID Validation in DKG Private Shares Allows Undetected Malicious Signer Attacks

## Summary
The DKG protocol contains a critical validation gap enabling malicious signers to send incomplete private shares without detection. The vulnerability spans multiple validation stages: shallow entry checking in `can_dkg_end()`, incomplete validation in `dkg_ended()`, and improper error handling that ignores `DkgError::MissingPrivateShares`. This allows malicious signers to repeatedly cause DKG failures without being identified.

## Finding Description

The vulnerability exists across four interconnected validation stages:

**Stage 1: Shallow Entry Check**

The `can_dkg_end()` function only verifies that a signer_id key exists in the `dkg_private_shares` HashMap, without checking if all expected party_ids from that signer are present: [1](#0-0) 

**Stage 2: Incomplete Share Validation**

The `dkg_ended()` function validates that party_ids which ARE present contain shares for all required destination key_ids, but fails to check whether ALL expected party_ids from the sender are included: [2](#0-1) 

The validation iterates through `self.signer.get_key_ids()` (receiver's keys) and checks if present source party_ids contain shares for those destinations. It does NOT verify that all expected source party_ids from `signer_key_ids[signer_id]` are present in the shares vector.

**Stage 3: Error Detection but Improper Handling**

The `compute_secrets` function properly detects missing party_ids and returns `DkgError::MissingPrivateShares`: [3](#0-2) 

However, the error handling in `dkg_ended()` only processes the `DkgError::BadPrivateShares` variant. Other error types, including `MissingPrivateShares`, are logged as "unexpected" but NOT added to the `bad_private_shares` map: [4](#0-3) 

This results in a `DkgEnd` message with `DkgFailure::BadPrivateShares(empty_map)` being sent to the coordinator.

**Stage 4: Coordinator Processing Failure**

When the coordinator receives a BadPrivateShares failure with an empty map, the loop that identifies malicious signers doesn't execute: [5](#0-4) 

Additionally, the coordinator has a handler for `MissingPrivateShares` failures but doesn't mark anyone as malicious: [6](#0-5) 

**Why Existing Validations Fail**

The `DkgPrivateShares` structure contains a shares vector of (party_id, destination_shares) tuples: [7](#0-6) 

When processing incoming shares, validation occurs via `validate_party_id`: [8](#0-7) 

The v1 implementation checks if party_id is in the sender's key_ids set: [9](#0-8) 

This validates that PRESENT party_ids belong to the sender, not that ALL expected party_ids are present.

**Attack Flow:**

1. Malicious signer with `signer_key_ids[malicious_id] = {10, 11, 12}` sends valid `DkgPublicShares` with commitments for all three party_ids
2. Sends `DkgPrivateShares` containing shares only from party_ids {10, 11}, deliberately omitting party_id 12
3. Validation at lines 1047-1056 passes since both 10 and 11 belong to the sender
4. Incomplete message stored at line 1064
5. `can_dkg_end()` returns true (key exists)
6. `dkg_ended()` validation at lines 567-582 doesn't detect missing party_id 12
7. `compute_secrets` detects missing party_id 12, returns `DkgError::MissingPrivateShares`
8. Error handling at line 626 only processes `BadPrivateShares`, logs warning but doesn't process error
9. Empty `bad_private_shares` map sent to coordinator
10. Coordinator's loop at line 654 doesn't execute, no malicious signer identified

## Impact Explanation

This vulnerability breaks the Byzantine fault tolerance mechanism of the DKG protocol. The security guarantee that malicious participants will be identified and prevented from participating in future rounds is violated.

**Concrete Protocol Impact:**
- DKG fails to complete, preventing distributed key generation
- Signature generation cannot proceed without completed DKG
- Malicious signer never added to `malicious_dkg_signer_ids` list
- Attack can be repeated every DKG round indefinitely
- All honest participants affected by the DoS

This maps to **Medium** severity: "Any transient consensus failures." While this doesn't directly cause invalid signatures or permanent chain splits, it prevents the cryptographic infrastructure from being established, causing a transient denial of service on signing functionality required for block production.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized participant in the DKG protocol (within threat model)
- Must construct and send `DkgPrivateShares` messages with a subset of their party_ids
- No special cryptographic capabilities required

**Attack Complexity:**
Low. The attacker:
1. Generates valid `DkgPublicShares` for all their party_ids (normal protocol behavior)
2. Constructs `DkgPrivateShares` with only a subset of party_ids in the shares vector
3. Sends both messages through normal protocol channels

**Economic Feasibility:**
Very high. The attack is essentially free - requires no additional computational resources beyond normal DKG participation. The attacker incurs no penalty since they're never detected.

**Detection Risk:**
Very low. The malicious signer is never identified by the coordinator. The only evidence is a log warning about "unexpected dkg_error" in honest signers' logs, which doesn't identify the attacker.

**Estimated Probability:**
Near certain (>95%) for v1 implementations where signers can control multiple party_ids. Any malicious DKG participant can successfully execute this attack. In v2 mode where `party_id == signer_id`, the attack surface is reduced but the error handling bug still exists for other error types.

## Recommendation

**Fix 1: Add Complete Party ID Validation in dkg_ended()**

After line 566, add validation to ensure all expected party_ids from the sender are present:

```rust
if let Some(shares) = self.dkg_private_shares.get(signer_id) {
    // Validate that ALL expected party_ids from this signer are present
    if let Some(expected_party_ids) = self.public_keys.signer_key_ids.get(signer_id) {
        let received_party_ids: HashSet<u32> = shares.shares.iter()
            .map(|(party_id, _)| *party_id)
            .collect();
        
        for expected_party_id in expected_party_ids {
            if !received_party_ids.contains(expected_party_id) {
                missing_private_shares.insert(*signer_id);
                break;
            }
        }
    }
    
    // existing validation for destination shares...
}
```

**Fix 2: Process All DkgError Variants in Error Handling**

Update lines 622-650 to handle all error types:

```rust
Err(dkg_error_map) => {
    let mut bad_private_shares = HashMap::new();
    for (my_party_id, dkg_error) in dkg_error_map {
        match dkg_error {
            DkgError::BadPrivateShares(party_ids) => {
                // existing logic
            }
            DkgError::MissingPrivateShares(missing_pairs) => {
                // Extract signer_ids from missing pairs and add to bad_private_shares
                for (_dst_id, src_party_id) in missing_pairs {
                    if let Some((party_signer_id, _shared_key)) = 
                        &self.decryption_keys.get(&src_party_id)
                    {
                        bad_private_shares.insert(
                            *party_signer_id,
                            self.make_bad_private_share(*party_signer_id, rng)?,
                        );
                    }
                }
            }
            _ => {
                warn!("Got unexpected dkg_error {dkg_error:?}");
            }
        }
    }
    // ... rest of code
}
```

**Fix 3: Coordinator Handling of Empty BadPrivateShares**

Add check at line 653:

```rust
DkgFailure::BadPrivateShares(bad_shares) => {
    if bad_shares.is_empty() {
        warn!("Signer {signer_id} reported BadPrivateShares with empty map, marking as malicious");
        malicious_signers.insert(*signer_id);
        continue;
    }
    // existing loop...
}
```

**Fix 4: Coordinator Handling of MissingPrivateShares**

Update lines 768-770:

```rust
DkgFailure::MissingPrivateShares(missing_signers) => {
    // Mark the signer who reported this as potentially malicious,
    // or investigate which signers actually sent incomplete shares
    for missing_signer_id in missing_signers {
        malicious_signers.insert(*missing_signer_id);
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_incomplete_party_id_attack() {
    let mut rng = rand::thread_rng();
    let threshold = 2;
    let num_signers = 3;
    let num_keys = 9; // 3 keys per signer in v1 mode
    
    // Create v1 signers where signer 0 controls party_ids {0, 1, 2}
    let mut signer0 = v1::Signer::new(0, &[0, 1, 2], num_signers, num_keys, threshold, &mut rng);
    let mut signer1 = v1::Signer::new(1, &[3, 4, 5], num_signers, num_keys, threshold, &mut rng);
    
    let dkg_id = 1;
    
    // Signer 0 sends valid public shares for all 3 party_ids
    let public_shares_0 = signer0.get_poly_commitments(&dkg_id.to_be_bytes(), &mut rng);
    assert_eq!(public_shares_0.len(), 3); // All 3 party_ids
    
    // Signer 0 gets shares for all party_ids
    let all_shares_0 = signer0.get_shares();
    assert_eq!(all_shares_0.len(), 3); // Contains party_ids 0, 1, 2
    
    // ATTACK: Malicious signer 0 only sends shares from party_ids 0 and 1
    // Deliberately omit party_id 2
    let mut incomplete_shares = Vec::new();
    for (party_id, shares) in &all_shares_0 {
        if *party_id < 2 { // Only include party_ids 0 and 1, skip 2
            incomplete_shares.push((*party_id, shares.clone()));
        }
    }
    
    assert_eq!(incomplete_shares.len(), 2); // Only 2 out of 3 party_ids
    
    // This incomplete message would pass validation in dkg_private_shares()
    // because validate_party_id only checks that present party_ids belong to sender
    
    // When compute_secrets is called, it would fail with MissingPrivateShares
    // But error handling doesn't process this, sending empty BadPrivateShares instead
    // Coordinator never identifies signer 0 as malicious
    
    // The attack succeeds: DKG fails but attacker is not detected
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L622-650)
```rust
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L705-710)
```rust
                    for signer_id in &dkg_end_begin.signer_ids {
                        if !self.dkg_private_shares.contains_key(signer_id) {
                            debug!("can_dkg_end: false, missing private shares from signer {signer_id}");
                            return false;
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L1047-1056)
```rust
        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }
```

**File:** src/v1.rs (L172-179)
```rust
        let mut missing_shares = Vec::new();
        for i in public_shares.keys() {
            if private_shares.get(i).is_none() {
                missing_shares.push((self.id, *i));
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
```

**File:** src/v1.rs (L696-705)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        match signer_key_ids.get(&signer_id) {
            Some(key_ids) => key_ids.contains(&party_id),
            None => false,
        }
    }
```

**File:** src/state_machine/coordinator/fire.rs (L652-654)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
```

**File:** src/state_machine/coordinator/fire.rs (L768-770)
```rust
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```
