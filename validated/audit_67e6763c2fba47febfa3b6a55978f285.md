# Audit Report

## Title
Unvalidated Private Shares Included in DKG Key Derivation

## Summary
The `compute_secret()` function in both v1 and v2 implementations fails to reject private shares that lack corresponding public commitments. Instead of returning an error, it only logs a warning and includes these unvalidated shares in the final private key computation, breaking the Verifiable Secret Sharing (VSS) property of DKG and producing cryptographic keys where `private_key * G ≠ group_key`, causing all signatures to fail.

## Finding Description

This vulnerability exploits a validation gap in the DKG key derivation process where private shares are checked against public commitments but not properly rejected when no commitment exists.

**Core Vulnerability in v1 Implementation:**

The validation loop in `compute_secret()` checks each private share against public commitments, but when no corresponding commitment exists, it only logs a warning without adding the party to `bad_shares`: [1](#0-0) 

Subsequently, ALL private shares are summed into the final private key, including those without validated commitments: [2](#0-1) 

**Core Vulnerability in v2 Implementation:**

The same validation gap exists where missing commitments only trigger warnings: [3](#0-2) 

And all shares are summed regardless: [4](#0-3) 

**Attack Vector Through State Machine:**

The vulnerability is exploitable through the DKG protocol flow:

1. When signers receive `DkgPrivateShares` messages, they decrypt and store ALL shares in `decrypted_shares` from any sender: [5](#0-4) 

2. The coordinator determines which signers to include based ONLY on who sent `DkgPrivateShares` TO THE COORDINATOR: [6](#0-5) 

3. In `dkg_ended()`, honest signers only process commitments from signers in the coordinator's `signer_ids` list: [7](#0-6) 

4. However, `compute_secrets()` is called with ALL `decrypted_shares`, including from attackers excluded by the coordinator: [8](#0-7) 

**Attack Execution:**

An attacker exploits this by:
- Sending `DkgPublicShares` and `DkgPrivateShares` peer-to-peer to honest signers (stored in their `decrypted_shares`)
- Selectively NOT sending `DkgPrivateShares` to the coordinator (or sending corrupted ones)
- Coordinator excludes attacker from `DkgEndBegin.signer_ids`
- Honest signers only add commitments from `signer_ids` to `self.commitments`
- But `decrypted_shares` still contains attacker's private shares
- `compute_secret()` warns but includes these unvalidated shares in the final key

**Why VSS is Broken:**

The group public key is computed as the sum of polynomial constant terms from only validated commitments: [9](#0-8) 

But the private key includes ALL private shares. This creates a mathematical inconsistency where `private_key * G ≠ group_key`, violating the fundamental discrete logarithm relationship required for valid signatures.

## Impact Explanation

**Severity: Medium** - Transient consensus failure

This vulnerability produces unusable cryptographic keys:
- **Group Public Key** = sum of validated polynomial constants (excluding attacker)
- **Group Private Key** = sum of all private shares (including attacker's unverified shares)

Since `private_key * G ≠ group_key`, all signatures produced will be INVALID and rejected by verifiers.

**Quantified Impact:**
- DKG round appears to succeed (returns `DkgStatus::Success`)
- All subsequent signing attempts produce mathematically invalid signatures
- Threshold signature scheme becomes completely non-functional
- Affects all honest parties in the compromised DKG round
- Requires a new DKG round to restore functionality

This causes temporary inability to sign transactions/blocks but does not directly cause fund loss, chain splits, or permanent damage, aligning with Medium severity for "any transient consensus failures."

## Likelihood Explanation

**Likelihood: Medium-High**

**Required Attacker Capabilities:**
1. Network access to send P2P messages to honest signers (standard network participation)
2. Ability to selectively filter messages to the coordinator (achievable via firewall rules, routing manipulation, or network partitioning)
3. Basic understanding of DKG protocol message timing

**Attack Feasibility:**
- **Complexity: Medium** - Requires understanding DKG flow but no cryptographic breaks
- **Economic Cost: Low** - Standard network participation, no stake required
- **Detection Risk: Low** - Attack succeeds during DKG phase; only discovered when signatures fail verification
- **Network Requirements: Feasible** - Selective message delivery is realistic in P2P networks through standard network-level controls

The attack can be executed repeatedly with minimal cost and is difficult to attribute since the DKG round reports success.

## Recommendation

Add validation in `compute_secret()` to reject private shares that lack corresponding public commitments:

**For v1.rs (lines 191-198):**
```rust
let mut bad_shares = Vec::new();
for (i, s) in private_shares.iter() {
    if let Some(comm) = public_shares.get(i) {
        if s * G != compute::poly(&self.id(), &comm.poly)? {
            bad_shares.push(*i);
        }
    } else {
        // FIXED: Add to bad_shares instead of just warning
        bad_shares.push(*i);
    }
}
```

**For v2.rs (lines 168-175):**
```rust
for (sender, s) in shares {
    if let Some(comm) = public_shares.get(sender) {
        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
            bad_shares.push(*sender);
        }
    } else {
        // FIXED: Add to bad_shares instead of just warning
        bad_shares.push(*sender);
    }
}
```

This ensures that only private shares with corresponding validated public commitments are included in the final private key, preserving the VSS property.

## Proof of Concept

```rust
#[test]
fn test_unvalidated_shares_included_in_dkg() {
    use crate::v1::Party;
    use crate::util::create_rng;
    use crate::curve::point::G;
    use hashbrown::HashMap;
    
    let mut rng = create_rng();
    let ctx = 0u64.to_be_bytes();
    
    // Create honest party and attacker
    let mut honest_party = Party::new(1, 3, 2, &mut rng);
    let honest_party2 = Party::new(2, 3, 2, &mut rng);
    let attacker = Party::new(99, 3, 2, &mut rng);
    
    // Get commitments from honest parties only (attacker excluded by coordinator)
    let comm1 = honest_party.get_poly_commitment(&ctx, &mut rng).unwrap();
    let comm2 = honest_party2.get_poly_commitment(&ctx, &mut rng).unwrap();
    let mut public_shares = HashMap::new();
    public_shares.insert(comm1.id.id.get_u32(), comm1);
    public_shares.insert(comm2.id.id.get_u32(), comm2);
    
    // Get private shares including attacker (attacker sent P2P to honest signer)
    let shares1 = honest_party2.get_shares();
    let shares2 = honest_party2.get_shares();
    let attacker_shares = attacker.get_shares();
    let mut private_shares = HashMap::new();
    private_shares.insert(comm1.id.id.get_u32(), shares1.get(&1).copied().unwrap());
    private_shares.insert(comm2.id.id.get_u32(), shares2.get(&1).copied().unwrap());
    private_shares.insert(99, attacker_shares.get(&1).copied().unwrap()); // No commitment!
    
    // Bug: compute_secret returns Ok despite missing commitment
    let result = honest_party.compute_secret(private_shares, &public_shares, &ctx);
    assert!(result.is_ok());
    
    // Verify the key inconsistency
    let expected_group_key = honest_party.group_key;
    let actual_derived_key = honest_party.private_key * G;
    
    // VULNERABILITY: Keys are inconsistent, signatures will fail
    assert_ne!(actual_derived_key, expected_group_key);
}
```

### Citations

**File:** src/v1.rs (L165-165)
```rust
                self.group_key += comm.poly[0];
```

**File:** src/v1.rs (L191-198)
```rust
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
            } else {
                warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", i);
            }
```

**File:** src/v1.rs (L205-205)
```rust
        self.private_key = private_shares.values().sum();
```

**File:** src/v2.rs (L168-175)
```rust
                for (sender, s) in shares {
                    if let Some(comm) = public_shares.get(sender) {
                        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
                            bad_shares.push(*sender);
                        }
                    } else {
                        warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", sender);
                    }
```

**File:** src/v2.rs (L191-191)
```rust
                let secret = shares.values().sum();
```

**File:** src/state_machine/signer/mod.rs (L551-566)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L612-615)
```rust
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
```

**File:** src/state_machine/signer/mod.rs (L1072-1102)
```rust
        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L449-475)
```rust
    pub fn start_dkg_end(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting DkgEnd Distribution"
        );

        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
        let dkg_end_begin_msg = Packet {
            sig: dkg_end_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgPrivateBegin"),
            msg: Message::DkgEndBegin(dkg_end_begin),
        };
        self.move_to(State::DkgEndGather)?;
        self.dkg_end_start = Some(Instant::now());
        Ok(dkg_end_begin_msg)
    }
```
