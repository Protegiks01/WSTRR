# Audit Report

## Title
Missing Length Validation in NonceResponse Enables Network-Wide Signing Denial of Service

## Summary
The coordinator's `gather_nonces()` function fails to validate that `key_ids` and `nonces` arrays in `NonceResponse` messages have matching lengths. When a malicious signer sends mismatched arrays, this propagates to all honest signers using v1::Signer who panic during signature share computation, causing complete signing round failure.

## Finding Description

The vulnerability exists in the signing flow where a malicious signer can send a `NonceResponse` with mismatched `key_ids` and `nonces` array lengths, causing all v1 signers to panic.

**Attack Flow:**

1. The `NonceResponse` structure allows separate `key_ids` and `nonces` vectors with no length constraint enforced at the type level. [1](#0-0) 

2. The coordinator's `gather_nonces()` validates that key_ids match the configuration (as a set) and that each nonce is valid, but does NOT validate that `key_ids.len() == nonces.len()`. The FROST coordinator checks key_ids against config at line 518 (set equality) and validates nonces at lines 523-533, but never compares array lengths. [2](#0-1) 

The FIRE coordinator has identical validation gaps. [3](#0-2) 

3. The malformed `NonceResponse` is stored by the coordinator and later broadcast to all signers in a `SignatureShareRequest` containing the `nonce_responses` vector. [4](#0-3) 

4. When signers receive the request, they flatten the arrays separately using `flat_map`, which propagates the length mismatch. Nonces are flattened first, then key_ids are flattened separately. [5](#0-4) 

5. The signer calls the underlying signer trait's `sign()`, `sign_taproot()`, or `sign_schnorr()` methods with the mismatched key_ids and nonces arrays. [6](#0-5) 

6. For v1::Signer, all three signing methods call `compute::aggregate_nonce()` with `.unwrap()`, which will panic on error. [7](#0-6) [8](#0-7) [9](#0-8) 

7. `compute::aggregate_nonce()` creates `scalars` with length `2 * party_ids.len()` (via flat_map producing 2 scalars per party_id) and `points` with length `2 * nonces.len()` (via flat_map producing 2 points per nonce). When these lengths don't match, `Point::multimult()` returns an error, and the `.unwrap()` causes a panic. [10](#0-9) 

**Root Cause:**

The protocol assumes that key_ids and nonces arrays will always have matching lengths, but this invariant is not enforced at the message validation layer. The coordinator accepts malformed messages that violate this assumption. The panic on `.unwrap()` in v1::Signer converts a validation failure into a crash affecting all honest v1 signers.

**Example Attack:**

A malicious Signer 2 (configured with key_ids {3, 4, 5}) sends:
```rust
NonceResponse {
    dkg_id: correct_id,
    sign_id: correct_id, 
    sign_iter_id: correct_iter,
    signer_id: 2,
    key_ids: vec![3, 4, 5],  // 3 key IDs
    nonces: vec![n1, n2],     // 2 nonces (mismatched!)
    message: msg.clone(),
}
```

The coordinator validates:
- signer_id 2 exists? ✓
- key_ids {3,4,5} == config {3,4,5}? ✓ (set comparison passes)
- Each nonce valid? ✓
- **Length match? (NOT CHECKED)**

The malformed response is accepted and broadcast. When honest v1 signers process it, they panic.

## Impact Explanation

**Severity: Low**

A single malicious signer can cause all honest signers using v1::Signer to panic during signature share computation, preventing any signing round from completing. This constitutes a remotely-exploitable denial of service affecting all v1 nodes.

The impact aligns with **Low** severity per the defined scope:
- "Any remotely-exploitable denial of service in a node"
- "Any network denial of service impacting more than 10 percent of miners that does not shut down the network"

**Specific Consequences:**
- One malicious signer blocks 100% of signing operations for v1 deployments
- All honest v1 signers crash when processing the malformed request
- Block production halts if WSTS v1 is used for blockchain signing
- Transaction signing becomes unavailable until nodes restart

This does not cause fund loss, chain splits, or invalid transaction confirmation, distinguishing it from higher severity categories. Note that v2::Signer is not affected by the panic issue as it uses `compute::intermediate()` instead of `aggregate_nonce()`.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Must be a registered signer (within protocol threat model - up to threshold-1 malicious signers allowed)
- Must have network access to send messages to coordinator
- No cryptographic breaks required
- No compromised keys or special privileges needed

**Attack Complexity:**
Very low. The attacker simply constructs a NonceResponse with mismatched array lengths and sends it through normal message channels. The coordinator will accept it if the key_ids match the configured set and nonces are valid points.

**Detection:**
Moderate difficulty. The malformed message passes all coordinator validation checks. The panic in signers may appear as an implementation bug rather than a deliberate attack. Only by examining the NonceResponse arrays would the mismatch be visible.

**Probability:**
High if any signer is malicious. The attack is deterministic, requires no special timing, and works on every signing round. It can also occur accidentally if a buggy signer implementation generates mismatched arrays.

## Recommendation

Add explicit length validation in the coordinator's `gather_nonces()` function:

```rust
// After line 533 in frost.rs (and line 901 in fire.rs), add:
if nonce_response.key_ids.len() != nonce_response.nonces.len() {
    warn!(
        signer_id = %nonce_response.signer_id,
        key_ids_len = nonce_response.key_ids.len(),
        nonces_len = nonce_response.nonces.len(),
        "NonceResponse has mismatched key_ids and nonces array lengths"
    );
    return Ok(());
}
```

Additionally, consider replacing `.unwrap()` calls in v1::Signer with proper error handling:

```rust
// In src/v1.rs line 714:
let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces)
    .map_err(|e| /* convert to appropriate error type */)?;
```

This provides defense in depth by both preventing malformed messages at the coordinator and handling errors gracefully at the signer.

## Proof of Concept

```rust
#[test]
fn test_mismatched_nonce_response_causes_panic() {
    use wsts::common::PublicNonce;
    use wsts::compute;
    use wsts::curve::scalar::Scalar;
    
    // Create mismatched arrays like a malicious signer would send
    let key_ids = vec![1u32, 2u32, 3u32];  // 3 key IDs
    let nonces = vec![
        PublicNonce::random(),
        PublicNonce::random(),  // Only 2 nonces
    ];
    let msg = b"test message";
    
    // This will panic due to mismatched array lengths
    // scalars.len() = 2 * 3 = 6
    // points.len() = 2 * 2 = 4
    // Point::multimult will error, .unwrap() will panic
    let result = std::panic::catch_unwind(|| {
        compute::aggregate_nonce(msg, &key_ids, &nonces).unwrap()
    });
    
    assert!(result.is_err(), "Expected panic due to mismatched array lengths");
}
```

This test demonstrates that calling `aggregate_nonce()` with mismatched array lengths will panic, confirming the vulnerability when such arrays reach v1::Signer through the message flow.

## Notes

This vulnerability specifically affects v1::Signer implementations. The v2::Signer uses `compute::intermediate()` which employs `zip()` on party_ids and nonces, truncating to the shorter length rather than panicking. However, this could still result in incorrect signature computation if arrays are mismatched. The coordinator validation should be fixed regardless of which signer version is deployed.

### Citations

**File:** src/net.rs (L311-326)
```rust
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/net.rs (L381-395)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Signature share request message from coordinator to signers
pub struct SignatureShareRequest {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Nonces responses used for this signature
    pub nonce_responses: Vec<NonceResponse>,
    /// Bytes to sign
    pub message: Vec<u8>,
    /// What type of signature to create
    pub signature_type: SignatureType,
```

**File:** src/state_machine/coordinator/frost.rs (L502-533)
```rust
            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L870-901)
```rust
            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L781-804)
```rust
        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L808-818)
```rust
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/v1.rs (L707-719)
```rust
    fn sign(
        &self,
        msg: &[u8],
        _signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
        self.parties
            .iter()
            .map(|p| p.sign_precomputed(msg, key_ids, nonces, &aggregate_nonce))
            .collect()
    }
```

**File:** src/v1.rs (L721-737)
```rust
    fn sign_taproot(
        &self,
        msg: &[u8],
        _signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
        merkle_root: Option<[u8; 32]>,
    ) -> Vec<SignatureShare> {
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
        let tweak = compute::tweak(&self.parties[0].group_key, merkle_root);
        self.parties
            .iter()
            .map(|p| {
                p.sign_precomputed_with_tweak(msg, key_ids, nonces, &aggregate_nonce, Some(tweak))
            })
            .collect()
    }
```

**File:** src/v1.rs (L739-750)
```rust
    fn sign_schnorr(
        &self,
        msg: &[u8],
        _signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
        self.parties
            .iter()
            .map(|p| {
                p.sign_precomputed_with_tweak(
```

**File:** src/compute.rs (L100-121)
```rust
pub fn aggregate_nonce(
    msg: &[u8],
    party_ids: &[u32],
    nonces: &[PublicNonce],
) -> Result<Point, PointError> {
    let compressed_nonces: Vec<(Compressed, Compressed)> = nonces
        .iter()
        .map(|nonce| (nonce.D.compress(), nonce.E.compress()))
        .collect();
    let scalars: Vec<Scalar> = party_ids
        .iter()
        .flat_map(|&i| {
            [
                Scalar::from(1),
                binding_compressed(&id(i), &compressed_nonces, msg),
            ]
        })
        .collect();
    let points: Vec<Point> = nonces.iter().flat_map(|nonce| [nonce.D, nonce.E]).collect();

    Point::multimult(scalars, points)
}
```
