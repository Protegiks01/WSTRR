# Audit Report

## Title
Unauthenticated DH Public Key Exchange Allows Complete DKG Compromise via MITM Attack

## Summary
The DKG protocol's ephemeral Diffie-Hellman public keys (`kex_public_key`) used for encrypting private shares are not included in the message signature hash, allowing a network attacker to perform a man-in-the-middle attack by replacing these keys, decrypt all private shares, and reconstruct the group private key to gain complete control over the threshold signature scheme.

## Finding Description

The WSTS DKG protocol uses ephemeral Diffie-Hellman key exchange to encrypt private polynomial shares during distribution. Each signer generates a `kex_private_key` and broadcasts the corresponding `kex_public_key` in their `DkgPublicShares` message.

**The Critical Flaw:**

The `hash()` function for `DkgPublicShares` only includes `dkg_id`, `signer_id`, and polynomial commitments (`comms`), but completely omits the `kex_public_key` field from signature computation. [1](#0-0) 

**Attack Execution Path:**

1. A signer creates their `DkgPublicShares` message with `kex_public_key = kex_private_key * G` [2](#0-1) 

2. The message is signed, but since `kex_public_key` is not in the hash, the signature doesn't authenticate this field.

3. A network attacker intercepts the message and replaces `kex_public_key` with their own `kex_public_key_attacker` while keeping the original signature intact.

4. Recipients verify the signature (which passes validation) and directly store the attacker's public key without any authentication of this field. [3](#0-2) 

5. When signers encrypt private shares for distribution, they retrieve and use the attacker's public key to compute the shared secret. [4](#0-3) 

6. The attacker intercepts encrypted shares and decrypts them using their `kex_private_key_attacker` and the sender's legitimate `kex_public_key`. The Diffie-Hellman property ensures both parties derive the same shared secret: `kex_private_key_sender * kex_public_key_attacker == kex_private_key_attacker * kex_public_key_sender`. [5](#0-4) 

7. Legitimate recipients cannot decrypt the shares because they use different keys, causing decryption failures, but the attacker already possesses all private shares.

8. With threshold-many replaced keys, the attacker collects threshold-many shares from each sender, uses Lagrange interpolation to reconstruct each sender's polynomial secret (f_i(0)), and sums them to obtain the complete group private key.

**Why Existing Protections Fail:**

The protocol includes packet signature verification that validates messages are from legitimate signers. [6](#0-5) 

However, this verification is ineffective because the signature hash does not cover `kex_public_key`. The coordinator's `gather_public_shares` function performs no validation of this field and directly stores the received value. [7](#0-6) 

The `TupleProof` mechanism is only used reactively for post-failure blame assignment, not for attack prevention. [8](#0-7) 

## Impact Explanation

This vulnerability breaks the fundamental security guarantee of the DKG protocol: that no single party knows the complete private key. An attacker with network MITM capability can:

1. **Reconstruct the Group Private Key**: By intercepting and decrypting private shares from threshold-many parties, the attacker can compute the complete group private key using standard polynomial interpolation.

2. **Forge Threshold Signatures**: With the group private key, the attacker can sign arbitrary messages without requiring participation from any legitimate signers, completely bypassing the threshold signature security model.

3. **Steal All Protected Funds**: WSTS is explicitly designed for cryptocurrency applications using Bitcoin's secp256k1 curve. [9](#0-8) 

The attacker can create valid signatures for unauthorized transactions and drain all funds controlled by the compromised multisig.

This maps to **Critical** severity: "Any causing the direct loss of funds other than through any form of freezing." The attacker gains permanent, undetectable control over all assets protected by the threshold signature scheme.

## Likelihood Explanation

**Attacker Requirements:**
- Network-level position to intercept and modify messages between signers
- Ability to perform active packet modification in real-time
- No cryptographic keys or insider access required

**Threat Model Alignment:**

WSTS explicitly uses cryptographic signatures for message authentication and AES-GCM encryption for private share confidentiality, demonstrating that network attacks are within the expected threat model. [10](#0-9) 

The existence of the `kex_public_key` field and ephemeral DH key exchange mechanism indicates the protocol designers anticipated untrusted network environments.

**Attack Feasibility:**

The attack is feasible through multiple realistic vectors:
- Malicious ISP or hosting provider
- BGP hijacking for cross-datacenter communications
- Compromised network infrastructure or VPN providers
- State-level adversaries with network access

**Detection Difficulty:**

The attack is extremely difficult to detect because:
- All signature verifications pass normally
- No protocol violations occur until the decryption phase
- The attack occurs during initial DKG setup, not during regular signing operations
- Once the attacker has the key, there's no cryptographic evidence of compromise

The likelihood is **Medium to High** depending on deployment characteristics, but given the Critical impact, this constitutes a severe security vulnerability requiring immediate remediation.

## Recommendation

Include `kex_public_key` in the `hash()` function for `DkgPublicShares`:

```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // FIX: Add kex_public_key to the hash
        hasher.update(self.kex_public_key.compress().as_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

This ensures the signature authenticates the `kex_public_key`, preventing MITM replacement attacks.

## Proof of Concept

```rust
#[test]
fn test_kex_public_key_mitm_attack() {
    // 1. Legitimate signer creates DkgPublicShares with their kex_public_key
    let kex_private_key = Scalar::random(&mut OsRng);
    let legitimate_kex_public_key = &kex_private_key * G;
    
    let mut dkg_public_shares = DkgPublicShares {
        dkg_id: 1,
        signer_id: 1,
        comms: vec![],
        kex_public_key: legitimate_kex_public_key,
    };
    
    // 2. Sign the message with legitimate data
    let network_private_key = Scalar::random(&mut OsRng);
    let signature = dkg_public_shares.sign(&network_private_key).unwrap();
    
    // 3. ATTACKER: Replace kex_public_key with attacker's key
    let attacker_kex_private_key = Scalar::random(&mut OsRng);
    let attacker_kex_public_key = &attacker_kex_private_key * G;
    dkg_public_shares.kex_public_key = attacker_kex_public_key;
    
    // 4. Verify that signature still validates (VULNERABILITY)
    let network_public_key = ecdsa::PublicKey::new(&network_private_key).unwrap();
    assert!(dkg_public_shares.verify(&signature, &network_public_key));
    
    // 5. Victim stores attacker's key and uses it for encryption
    // This demonstrates the kex_public_key is not authenticated by the signature
}
```

### Citations

**File:** src/net.rs (L139-163)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}

impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/net.rs (L526-538)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
```

**File:** src/state_machine/signer/mod.rs (L872-877)
```rust
        let mut public_share = DkgPublicShares {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            comms: Vec::new(),
            kex_public_key: self.kex_private_key * G,
        };
```

**File:** src/state_machine/signer/mod.rs (L934-942)
```rust
            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1132-1147)
```rust
    fn make_bad_private_share<R: RngCore + CryptoRng>(
        &self,
        signer_id: u32,
        rng: &mut R,
    ) -> Result<BadPrivateShare, Error> {
        let a = self.kex_private_key;
        let A = a * G;
        let B = self.get_kex_public_key(signer_id)?;
        let K = a * B;
        let tuple_proof = TupleProof::new(&a, &A, &B, &K, rng);

        Ok(BadPrivateShare {
            shared_key: K,
            tuple_proof,
        })
    }
```

**File:** src/util.rs (L47-52)
```rust
/// Do a Diffie-Hellman key exchange to create a shared secret from the passed private/public keys
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L79-99)
```rust
/// Encrypt the passed data using the key
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
}
```

**File:** src/state_machine/coordinator/fire.rs (L477-507)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
```

**File:** README.md (L6-6)
```markdown
[```WSTS```](https://tmurl.net/wsts) is a system for making ```Weighted Schnorr Threshold Signatures```, aka ```WileyProofs```.  It allows a group of ```signers```, each of whom controls a set of ```keys```, to make a valid ```Schnorr``` signature, as long as ```T``` (the ```threshold```) of them complete the protocol honestly.  While there are many other threshold signature schemes, ```WSTS``` has several features which make it particularly useful in a cryptocurrency context.
```
