Based on my systematic validation of this security claim against the WSTS codebase, I can confirm this is a **valid Low severity vulnerability**.

# Audit Report

## Title
Signature Share Reordering Denial of Service in v1 Implementation

## Summary
A malicious v1 signer controlling multiple keys can cause signing rounds to fail by deliberately reordering signature shares within their `SignatureShareResponse` message. The coordinator validates only the set of key IDs without checking positional correspondence to nonces, allowing incorrect nonce-share pairings during aggregation that cause signature verification to fail.

## Finding Description

The v1 implementation allows signers to control multiple `Party` objects, each representing a key share. When signing, the signer generates nonces and signature shares by iterating over parties in a deterministic order, establishing positional correspondence where `nonces[i]` pairs with `shares[i]`. [1](#0-0) 

However, the coordinator's validation only verifies that the set of key IDs matches the expected configuration using `HashSet` comparison, without validating ordering or positional correspondence between the previously-received nonces and the newly-received signature shares: [2](#0-1) 

The same vulnerable validation exists in the Fire coordinator: [3](#0-2) 

When aggregating signatures, the coordinator flattens nonces and shares separately from different messages: [4](#0-3) 

The aggregator then extracts party IDs from the signature shares and uses `compute::intermediate()` to calculate binding values, which pairs nonces with binding computations by position using `zip()`: [5](#0-4) [6](#0-5) 

**Attack Path:**

1. Malicious signer generates nonces `[N1, N3, N5]` for keys `[1, 3, 5]` in order
2. Signer generates shares `[S1, S3, S5]` correctly
3. **Signer reorders shares to `[S3, S1, S5]` before sending**
4. Coordinator validates key ID set `{1, 3, 5}` matches - passes validation
5. During aggregation:
   - `nonces = [N1, N3, N5]` (from original order)
   - `sig_shares = [S3, S1, S5]` (reordered)
   - `party_ids = [3, 1, 5]` (extracted from reordered shares)
6. `compute::intermediate()` calculates:
   - `Rs[0] = N1.D + binding(3, ...) * N1.E` (wrong: key 3's binding with key 1's nonce)
   - `Rs[1] = N3.D + binding(1, ...) * N3.E` (wrong: key 1's binding with key 3's nonce)
7. Signature verification fails, aborting the signing round

The packet signature verification does not prevent this because the attacker signs their own reordered message with their own key, which passes verification. [7](#0-6) 

## Impact Explanation

This vulnerability enables a **denial-of-service attack** on signing operations. The impact severity is **Low** according to the defined scope: "Any remotely-exploitable denial of service in a node."

**Specific consequences:**
- Each attack causes one signing round to fail
- All participants waste computational resources on failed aggregation
- The attack can be repeated indefinitely to prevent signature generation
- The malicious signer is identified via `check_signature_shares`, but the damage (failed round) has already occurred

**Affected configurations:**
- Systems using the optional `with_v1` feature flag: [8](#0-7) [9](#0-8) 

- Signers controlling multiple keys (common in v1 weighted threshold architecture)

**Not affected:**
The v2 implementation is not vulnerable because each signer returns exactly one nonce and one signature share, eliminating the possibility of reordering: [10](#0-9) [11](#0-10) 

The attack does not:
- Shut down the network entirely
- Cause loss of funds
- Create chain splits
- Compromise cryptographic guarantees
- Affect nodes not using v1

## Likelihood Explanation

**Required attacker capabilities:**
1. Must be a legitimate participant who passed DKG and holds valid private keys (insider threat, explicitly within threat model)
2. Must control multiple keys in the v1 architecture
3. Must be selected for the signing committee
4. Must have network access to send messages to the coordinator

**Attack complexity:** Low
- Attacker receives `SignatureShareRequest` normally
- Generates valid signature shares using normal signing logic
- Simply reorders elements in the `signature_shares` vector before sending
- Signs the reordered message with their own key

**Economic feasibility:** High
- No additional computational cost beyond normal participation
- Minimal cost to attacker while wasting resources of all participants

**Detection:** Immediate but post-impact
- `check_signature_shares` identifies the malicious signer after aggregation fails
- Detection occurs after the signing round has already failed
- Attacker can repeat on subsequent rounds

**Overall probability:** Low-to-Medium
- Requires insider access (legitimate signer)
- Requires v1 feature adoption (v2 is default)
- Conditional on signer controlling multiple keys

## Recommendation

Add positional validation to ensure signature shares maintain the same order as nonces. The coordinator should:

1. Store the original order of key_ids from `NonceResponse` for each signer
2. When validating `SignatureShareResponse`, verify that the order of key_ids in signature shares matches the order from the corresponding nonces
3. Reject any `SignatureShareResponse` where the ordering doesn't match

Alternatively, change the aggregation logic to match shares with nonces by key_id lookup rather than positional correspondence, though this would require protocol changes.

## Proof of Concept

```rust
#[cfg(feature = "with_v1")]
#[test]
fn reordering_attack_causes_aggregation_failure() {
    use crate::v1;
    use crate::traits::{Aggregator, Signer};
    use crate::util::create_rng;
    
    let mut rng = create_rng();
    let msg = b"test message";
    let N: u32 = 10;
    let T: u32 = 7;
    
    // Create signers with multiple key_ids
    let signer_ids: Vec<Vec<u32>> = vec![
        vec![1, 2, 3],  // Signer 0 controls keys 1,2,3
        vec![4, 5],     // Signer 1 controls keys 4,5
        vec![6, 7, 8],  // Signer 2 controls keys 6,7,8
        vec![9, 10],    // Signer 3 controls keys 9,10
    ];
    
    let mut signers: Vec<v1::Signer> = signer_ids
        .iter()
        .enumerate()
        .map(|(id, ids)| v1::Signer::new(id.try_into().unwrap(), ids, N, T, &mut rng))
        .collect();
    
    // Run DKG
    let comms = match v1::test_helpers::dkg(&mut signers, &mut rng) {
        Ok(comms) => comms,
        Err(e) => panic!("DKG failed: {:?}", e),
    };
    
    // Generate nonces and shares normally
    let (nonces, mut sig_shares) = v1::test_helpers::sign(msg, &mut signers, &mut rng);
    
    // Attack: Reorder the signature shares from signer 0
    // Signer 0 has 3 shares (for keys 1,2,3) at indices 0,1,2
    // Swap them to create misalignment
    sig_shares.swap(0, 1);  // Swap shares for keys 1 and 2
    
    // Try to aggregate
    let mut aggregator = v1::Aggregator::new(N, T);
    aggregator.init(&comms).expect("aggregator init failed");
    
    // This should fail because nonces and shares are mismatched
    let result = aggregator.sign(msg, &nonces, &sig_shares, &[]);
    assert!(result.is_err(), "Aggregation should fail with reordered shares");
}
```

This test demonstrates that reordering signature shares causes aggregation to fail, confirming the DoS vulnerability.

### Citations

**File:** src/v1.rs (L321-327)
```rust
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }

        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &signers, nonces);
        let mut z = Scalar::zero();
```

**File:** src/v1.rs (L676-685)
```rust
    fn gen_nonces<RNG: RngCore + CryptoRng>(
        &mut self,
        secret_key: &Scalar,
        rng: &mut RNG,
    ) -> Vec<PublicNonce> {
        self.parties
            .iter_mut()
            .map(|p| p.gen_nonce(secret_key, rng))
            .collect()
    }
```

**File:** src/state_machine/coordinator/frost.rs (L631-641)
```rust
            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L664-684)
```rust
        if self.ids_to_await.is_empty() {
            // Calculate the aggregate signature
            let nonce_responses = (0..self.config.num_signers)
                .map(|i| self.public_nonces[&i].clone())
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = &self
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** src/net.rs (L583-598)
```rust
            Message::SignatureShareResponse(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!(
                            "Received a SignatureShareResponse message with an invalid signature."
                        );
                        return false;
                    }
                } else {
                    warn!(
                        "Received a SignatureShareResponse message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** Cargo.toml (L16-16)
```text
with_v1 = []
```

**File:** src/lib.rs (L29-31)
```rust
#[cfg(feature = "with_v1")]
#[allow(clippy::op_ref)]
pub mod v1;
```

**File:** src/v2.rs (L210-218)
```rust
    pub fn sign(
        &self,
        msg: &[u8],
        party_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> SignatureShare {
        self.sign_with_tweak(msg, party_ids, key_ids, nonces, None)
    }
```

**File:** src/v2.rs (L271-276)
```rust
        SignatureShare {
            id: self.party_id,
            z_i: z,
            key_ids: self.key_ids.clone(),
        }
    }
```
