# Audit Report

## Title
Identity Point Attack on DKG Private Share Encryption Enables Complete Key Material Extraction

## Summary
The DKG private share encryption mechanism fails to validate that `kex_public_key` is not the identity point, allowing a malicious signer to force predictable shared secrets and decrypt all private shares sent by honest signers. This completely compromises the distributed key generation protocol, enabling reconstruction of the group private key and theft of all funds controlled by the threshold signature scheme.

## Finding Description

The vulnerability arises from three compounding failures in the DKG private share encryption mechanism:

**Failure 1: Missing Identity Point Validation**

When a signer receives a `DkgPublicShares` message, the `kex_public_key` field is stored directly without validating that it is not the identity point. [1](#0-0) 

The codebase demonstrates awareness of identity point attacks through explicit validation for nonces, but this same protection is absent for `kex_public_key`. [2](#0-1) 

**Failure 2: Signature Hash Excludes kex_public_key**

The `DkgPublicShares::hash()` implementation for signature verification explicitly excludes the `kex_public_key` field from the hash computation. [3](#0-2) 

This allows a malicious signer to set their `kex_public_key` to the identity point in their own properly-signed message without detection, as the signature remains valid.

**Failure 3: Unvalidated Diffie-Hellman Computation**

When encrypting private shares for a recipient, the sender performs Diffie-Hellman key exchange without validating the recipient's public key. [4](#0-3) 

The underlying `make_shared_secret` function performs scalar multiplication without input validation. [5](#0-4) 

The shared secret is then derived using ANSI X9.63 KDF from the resulting point's compressed bytes. [6](#0-5) 

**Attack Mechanism:**

By the mathematical property of elliptic curves, for any scalar `s`: `s * Point::identity() = Point::identity()`. Therefore:

1. Malicious signer broadcasts `DkgPublicShares` with `kex_public_key = Point::identity()`
2. Honest signers accept this without validation
3. When encrypting shares, honest signers compute: `shared_secret = their_kex_private_key * Point::identity() = Point::identity()`
4. The shared secret derived from the identity point is deterministic and publicly computable
5. The attacker decrypts all shares sent to them using this known secret
6. With threshold `t` shares, the attacker reconstructs the group private key via Lagrange interpolation

**Why Existing Validations Fail:**

During `dkg_ended()`, polynomial commitment verification occurs after share decryption. [7](#0-6) 

This verification checks share correctness (whether `s * G == poly(id)`) but not confidentiality. [8](#0-7) 

The attacker uses their own valid polynomial, so their shares pass verification. The attack targets the **confidentiality** of shares sent by others to the attacker, not the correctness of the attacker's own shares.

## Impact Explanation

This vulnerability maps to **Critical** severity as defined in the scope: "causing the direct loss of funds other than through any form of freezing."

**Specific Impacts:**

1. **Complete Private Key Extraction**: In a threshold t-of-n setup where n > t, the attacker (as one of n signers) receives private shares from n-1 honest signers. For a typical 3-of-5 configuration, the attacker receives 4 shares, exceeding the threshold of 3.

2. **Group Private Key Reconstruction**: With t or more shares, the attacker performs Lagrange interpolation to reconstruct the complete group private key, bypassing all threshold signature security properties.

3. **Unconditional Fund Theft**: With the group private key, the attacker can:
   - Sign arbitrary Bitcoin/cryptocurrency transactions
   - Steal 100% of funds controlled by the compromised group key
   - Confirm invalid transactions on Stacks blockchain
   - Impersonate the entire signing group indefinitely

4. **Scope of Damage**: All participants in any DKG session where the malicious signer participates are compromised.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a legitimate registered signer in the DKG protocol (standard participant role, within threat model)
- Possesses valid `signer_id` and signing key (normal operational requirement)
- No special network position or privileged access required

**Attack Complexity: Trivial**
- The attack requires only setting `kex_public_key = Point::identity()` in the attacker's own `DkgPublicShares` message
- No cryptographic primitives need to be broken
- No brute-force computation required
- Single message modification is sufficient

**Detection Resistance:**
- Encrypted shares decrypt successfully (no errors raised)
- Polynomial commitments validate correctly (attacker's own polynomial is legitimate)
- No warning messages generated
- The attack is completely silent until funds are stolen

**Economic Viability:**
- Attack cost: Only the cost of becoming a registered signer
- Attack gain: All funds controlled by the group key
- For any non-trivial fund amounts, the attack provides overwhelming economic incentive

**Probability Assessment:**
Given a motivated attacker with signer access, this attack succeeds with 100% probability. The vulnerability is deterministic, and no defensive measures are in place.

## Recommendation

Add identity point validation when storing the `kex_public_key`:

```rust
// In src/state_machine/signer/mod.rs, around line 1019-1021
for key_id in signer_key_ids {
    // Validate kex_public_key is not the identity point
    if dkg_public_shares.kex_public_key == Point::identity() {
        warn!(%signer_id, "Received identity point as kex_public_key");
        return Ok(vec![]);
    }
    self.kex_public_keys
        .insert(*key_id, dkg_public_shares.kex_public_key);
}
```

Additionally, include `kex_public_key` in the signature hash to prevent tampering:

```rust
// In src/net.rs, around line 152-163
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        hasher.update(self.kex_public_key.compress().as_bytes()); // ADD THIS LINE
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_identity_point_kex_attack() {
    use crate::curve::point::Point;
    use crate::util::make_shared_secret;
    use crate::curve::scalar::Scalar;
    
    // Honest signer generates their kex private key
    let mut rng = create_rng();
    let honest_kex_private = Scalar::random(&mut rng);
    
    // Attacker uses identity point as their kex public key
    let malicious_kex_public = Point::identity();
    
    // Honest signer computes shared secret for encrypting shares to attacker
    let shared_secret_1 = make_shared_secret(&honest_kex_private, &malicious_kex_public);
    
    // Attacker computes the same shared secret without knowing honest signer's private key
    // Any scalar multiplied by identity point yields identity point
    let zero_scalar = Scalar::from(0u32);
    let shared_secret_2 = make_shared_secret(&zero_scalar, &Point::identity());
    
    // Both shared secrets are identical and predictable
    assert_eq!(shared_secret_1, shared_secret_2);
    
    // This demonstrates that the attacker can decrypt any shares encrypted
    // for them without needing the honest signer's private key
}
```

## Notes

This vulnerability breaks the fundamental security guarantee of DKG: that private shares remain confidential during distribution. The attack exploits the mathematical property that scalar multiplication with the identity point always yields the identity point, making the derived shared secret deterministic and publicly computable. The threshold signature scheme's security model assumes that an attacker controlling fewer than t signers cannot reconstruct the group private key, but this vulnerability allows a single malicious signer to extract t or more shares, completely bypassing this protection.

### Citations

**File:** src/state_machine/signer/mod.rs (L612-616)
```rust
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
```

**File:** src/state_machine/signer/mod.rs (L941-942)
```rust
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1019-1021)
```rust
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L55-60)
```rust
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/v2.rs (L169-172)
```rust
                    if let Some(comm) = public_shares.get(sender) {
                        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
                            bad_shares.push(*sender);
                        }
```
