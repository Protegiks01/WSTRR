After performing strict validation against the WSTS codebase, I can confirm this is a **valid vulnerability**. All claims have been verified with code evidence.

---

# Audit Report

## Title
Remote Denial of Service via Empty Polynomial Commitment in DKG Public Shares

## Summary
A malicious signer can send a `DkgPublicShares` message containing a `PolyCommitment` with an empty `poly` vector, causing all nodes that process this message during DKG validation to panic and crash. This enables a single compromised signer to deny service to all participants in a DKG round.

## Finding Description

The vulnerability exists due to an ordering issue in polynomial commitment validation. The `PolyCommitment::verify()` method unconditionally accesses the first element of the `poly` vector without bounds checking: [1](#0-0) 

The `check_public_shares()` function calls `verify()` before checking the polynomial length. Due to Rust's short-circuit evaluation of `&&`, if `verify()` panics on an empty vector, the length check never executes: [2](#0-1) 

**Attack Flow:**

1. A malicious signer constructs a `PolyCommitment` with `poly: Vec::new()` (empty vector)
2. The malicious signer includes this in a `DkgPublicShares` message and signs it with their valid ECDSA key
3. When signers receive this message, they store it without validating the polynomial commitment structure: [3](#0-2) 

The `dkg_public_share()` method only validates signer_id, party_id, and checks for duplicates - it does not validate the polynomial commitment contents: [4](#0-3) 

4. Later, during the DKG end phase, signers validate stored public shares by calling `check_public_shares()`: [5](#0-4) 

5. When `check_public_shares()` calls `verify()` on the malicious commitment, it attempts to access `self.poly[0]` on an empty vector, causing an immediate panic

6. Coordinators are also vulnerable when verifying reported bad shares during `BadPublicShares` processing: [6](#0-5) 

Additionally, the coordinator's `set_key_and_party_polynomials()` method also accesses `poly[0]` without bounds checking: [7](#0-6) 

**Why Existing Mitigations Fail:**
- Packet signature verification only authenticates sender identity, not polynomial validity
- The check at line 553 in `dkg_ended()` only verifies if the `comms` vector is empty, not if individual `PolyCommitment.poly` vectors are empty
- No validation of polynomial structure occurs at message receipt
- The length check in `check_public_shares()` is unreachable due to panic

## Impact Explanation

This vulnerability maps to **Low** severity per the scope definition: "Any remotely-exploitable denial of service in a node."

**Specific Harm:**
- All honest signers that received the malicious message will crash simultaneously when `dkg_ended()` is called
- The coordinator will also crash if it attempts to verify the malicious public shares
- This prevents completion of the DKG round and denial of threshold key generation

**Quantified Impact:**
- Single malicious signer can crash all N-1 honest signers plus the coordinator
- Affects every participant that progresses to the DKG validation phase
- Requires restarting all affected nodes and reinitiating the DKG round
- Attack can be repeated for each subsequent DKG attempt

While this affects multiple nodes simultaneously, the impact is strictly denial of service without consensus failures, fund loss, or persistent state corruption.

## Likelihood Explanation

**Probability: High (100% success rate if executed)**

**Required Attacker Capabilities:**
- Control of one signer with valid ECDSA signing keys for packet authentication (within protocol threat model)
- Ability to craft and send network messages
- No cryptographic breaks required

**Attack Complexity: Low**

The attacker needs to:
1. Create a `PolyCommitment` struct with `poly: Vec::new()` (empty vector)
2. Create a valid `ID` struct (values don't matter since `verify()` panics before checking the proof)
3. Include it in a `DkgPublicShares` message
4. Sign the packet with their network private key
5. Broadcast the message to all participants

**Detection:**
High detectability - the panic will be visible in all affected node logs with stack traces pointing to the vector index access, making post-mortem analysis straightforward.

## Recommendation

Fix the ordering issue by validating the polynomial length before calling `verify()`:

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.poly.len() == threshold && poly_comm.verify(ctx)
}
```

Additionally, add bounds checking in `PolyCommitment::verify()` as a defense-in-depth measure:

```rust
impl PolyCommitment {
    pub fn verify(&self, ctx: &[u8]) -> bool {
        if self.poly.is_empty() {
            return false;
        }
        self.id.verify(&self.poly[0], ctx)
    }
}
```

Consider adding validation at message receipt time in `dkg_public_share()` to reject malformed commitments early:

```rust
for (party_id, comm) in &dkg_public_shares.comms {
    if !SignerType::validate_party_id(...) {
        // existing check
    }
    if comm.poly.is_empty() {
        warn!("signer sent empty polynomial commitment");
        return Ok(vec![]);
    }
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_empty_poly_panic() {
    use crate::common::PolyCommitment;
    use crate::schnorr::ID;
    use crate::curve::scalar::Scalar;
    use crate::util::create_rng;
    
    let mut rng = create_rng();
    let ctx = 0u64.to_be_bytes();
    
    // Create a PolyCommitment with an empty poly vector
    let empty_comm = PolyCommitment {
        id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
        poly: Vec::new(), // Empty vector
    };
    
    // This will panic with "index out of bounds: the len is 0 but the index is 0"
    empty_comm.verify(&ctx);
}
```

## Notes

This vulnerability breaks the availability guarantee of WSTS nodes. While the protocol threat model allows for up to threshold-1 malicious signers, it does not anticipate that a single malicious signer can crash all other participants. The fix is straightforward: validate polynomial length before attempting to access elements.

### Citations

**File:** src/common.rs (L37-39)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/signer/mod.rs (L556-558)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
```

**File:** src/state_machine/signer/mod.rs (L987-1002)
```rust
        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L1023-1024)
```rust
        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L633-637)
```rust
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
```

**File:** src/state_machine/coordinator/fire.rs (L1389-1391)
```rust
        let computed_key = party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```
