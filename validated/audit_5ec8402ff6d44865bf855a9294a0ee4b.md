# Audit Report

## Title
Duplicate Key IDs in NonceResponse Break Lagrange Interpolation and Cause Signing Denial of Service

## Summary
A malicious signer can send a `NonceResponse` message with duplicate `key_ids` that bypasses coordinator validation using HashSet comparison, causing all participants to compute incorrect Lagrange coefficients. This breaks the mathematical correctness of threshold signature aggregation, resulting in signing round failures that block transaction confirmation.

## Finding Description

The vulnerability exists in the coordinator's validation logic for `NonceResponse.key_ids` in both FROST and FIRE coordinators. The validation converts the received `key_ids` Vec to a HashSet for set equality comparison, which inadvertently allows duplicate values to pass validation. [1](#0-0) [2](#0-1) 

**Attack Flow:**

1. A malicious signer crafts a `NonceResponse` with duplicate `key_ids` (e.g., `[1, 1, 2]` instead of `[1, 2]`). Since the `NonceResponse` implements the `Signable` trait and includes `key_ids` in its hash, the signer can sign this malicious message with their network private key. [3](#0-2) 

2. The coordinator's validation converts the key_ids to a HashSet: `HashSet([1,1,2])` equals `{1,2}`, which matches the expected configured keys `{1,2}`, so validation passes. However, the original NonceResponse with duplicates is stored unchanged. [4](#0-3) 

3. When creating the `SignatureShareRequest`, the coordinator collects all stored NonceResponses (preserving duplicates) and sends them to all signers. [5](#0-4) [6](#0-5) 

4. Each signer flattens the key_ids from all NonceResponses WITHOUT de-duplication, resulting in a key_ids array containing duplicates. [7](#0-6) 

5. Signers compute their signature shares using these duplicate key_ids for Lagrange interpolation. The `compute::lambda` function iterates over ALL values in the key_ids array, including duplicates. [8](#0-7) [9](#0-8) 

For example, if `key_ids = [1, 2, 2, 3]` and computing `lambda(1, key_ids)`, the loop multiplies by `2/(2-1)` twice (once for each instance of 2), producing an incorrect coefficient. This breaks the mathematical correctness of Lagrange interpolation.

6. The coordinator also flattens key_ids without de-duplication for aggregation. [10](#0-9) [11](#0-10) 

7. The aggregator sums all signature shares to create the final signature, then verifies it against the group public key. Because all signers used incorrect Lagrange coefficients, the aggregated signature is mathematically invalid and verification fails. [12](#0-11) [13](#0-12) 

8. The `check_signature_shares` method is called to diagnose the failure, but it uses the same flattened key_ids array with duplicates for Lagrange computation, so it computes the same incorrect expected values. Since all signers used the same incorrect lambdas, individual share checks pass, and the function returns `AggregatorError::BadGroupSig` without identifying any specific malicious party. [14](#0-13) [15](#0-14) 

## Impact Explanation

This vulnerability causes a **remotely-exploitable denial of service** (Low severity per scope definition):

- A single malicious signer can block any signing round by including duplicate key_ids in their NonceResponse
- All participants compute invalid signature shares due to incorrect Lagrange coefficients
- Signature aggregation deterministically fails verification
- The signing round aborts without producing a valid signature
- Transaction confirmation is prevented until the malicious signer is identified and removed
- The attack can be repeated indefinitely on subsequent rounds

The impact aligns with "Any remotely-exploitable denial of service in a node" and potentially "Any network denial of service impacting more than 10 percent of miners that does not shut down the network" if the malicious signer controls sufficient stake.

## Likelihood Explanation

**High likelihood:**

- **Attacker capabilities:** Requires being a registered signer (within threat model) with standard network message capabilities
- **Attack complexity:** Trivial - craft NonceResponse with duplicate key_ids, sign it, and send
- **Success rate:** 100% - duplicates deterministically break Lagrange interpolation
- **Detection difficulty:** Low to moderate - requires inspecting NonceResponse message contents to identify duplicate key_ids
- **Economic cost:** Zero - no additional resources beyond normal signer operations

The attack is within the protocol threat model (malicious signer up to threshold-1) and can be executed through normal message flow.

## Recommendation

Add explicit duplicate detection in the NonceResponse validation logic. Replace the HashSet-based validation with a check that ensures the key_ids Vec contains no duplicates:

```rust
// In both fire.rs and frost.rs gather_nonces methods:

// Check for duplicates in key_ids
let nonce_response_key_ids: HashSet<u32> = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect();

if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id, 
        "Nonce response key_ids contains duplicates"
    );
    return Ok(());
}

// Then check that the set matches config
if *signer_key_ids != nonce_response_key_ids {
    warn!(
        signer_id = %nonce_response.signer_id, 
        "Nonce response key_ids didn't match config"
    );
    return Ok(());
}
```

Additionally, consider adding defensive de-duplication in the flattening operations to prevent any duplicate key_ids from affecting Lagrange computations, though fixing the validation is the primary mitigation.

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_break_lagrange() {
    use crate::compute;
    
    // Correct Lagrange computation with unique key_ids
    let unique_key_ids = vec![1u32, 2, 3];
    let lambda_correct = compute::lambda(1, &unique_key_ids);
    
    // Incorrect Lagrange computation with duplicate key_ids
    let duplicate_key_ids = vec![1u32, 2, 2, 3]; // Duplicate 2
    let lambda_incorrect = compute::lambda(1, &duplicate_key_ids);
    
    // The Lagrange coefficients should differ
    assert_ne!(
        lambda_correct, 
        lambda_incorrect,
        "Duplicate key_ids produce different Lagrange coefficients"
    );
    
    // Demonstrate the mathematical error:
    // lambda(1, [1,2,3]) should be: (2/(2-1)) * (3/(3-1)) = 2 * 1.5 = 3
    // lambda(1, [1,2,2,3]) incorrectly computes: (2/(2-1)) * (2/(2-1)) * (3/(3-1)) = 2 * 2 * 1.5 = 6
    // This breaks the correctness of Lagrange interpolation
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-977)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L571-573)
```rust
        let nonce_responses = (0..self.config.num_signers)
            .map(|i| self.public_nonces[&i].clone())
            .collect::<Vec<NonceResponse>>();
```

**File:** src/state_machine/coordinator/frost.rs (L675-678)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/net.rs (L357-359)
```rust
        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L70-79)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L328-330)
```rust
        for sig_share in sig_shares {
            z += sig_share.z_i;
        }
```

**File:** src/v2.rs (L403-403)
```rust
                cx += compute::lambda(*key_id, key_ids) * c * public_key;
```

**File:** src/v2.rs (L414-416)
```rust
        } else {
            AggregatorError::BadGroupSig
        }
```

**File:** src/v2.rs (L457-461)
```rust
        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```
