# Audit Report

## Title
Missing sign_iter_id Validation in FIRE Coordinator Allows Stale Signature Shares After Timeout Retry

## Summary
The FIRE coordinator's `gather_sig_shares()` function fails to validate the `sign_iter_id` field in `SignatureShareResponse` messages, despite correctly incrementing this field during timeout retries. This allows malicious signers to submit signature shares from previous signing iterations, causing signature verification failures and denial of service.

## Finding Description

The FIRE coordinator implements timeout retry logic that increments `sign_iter_id` when signature gathering times out and restarts from the nonce request phase. [1](#0-0) 

The `sign_iter_id` field is incremented using `wrapping_add(1)` in the `request_nonces()` method to distinguish retry attempts. [2](#0-1) 

The `gather_nonces()` function correctly validates that incoming `NonceResponse` messages match the current `sign_iter_id`, rejecting stale responses from previous iterations. [3](#0-2) 

However, the `gather_sig_shares()` function only validates `dkg_id` and `sign_id` fields but completely omits validation of the `sign_iter_id` field. [4](#0-3) 

The `SignatureShareResponse` message structure includes the `sign_iter_id` field. [5](#0-4) 

This inconsistency breaks the cryptographic binding between nonces and signature shares. In FROST, signature shares are computed using binding values that are cryptographically derived from the complete set of public nonces. [6](#0-5) 

The binding value computation iterates through all public nonces, meaning different nonce sets produce different binding values. When signers compute signature shares, they use the formula `r = d + ρ * e` where ρ is the binding value. [7](#0-6) 

**Attack Scenario:**
1. Initial signing iteration N: Coordinator sends `SignatureShareRequest` with `sign_iter_id = N` containing nonces from iteration N.
2. Malicious Signer B participates normally, computes their signature share for iteration N, but withholds it.
3. A different signer times out, triggering the retry mechanism.
4. Retry iteration N+1: Coordinator increments `sign_iter_id` to N+1, transitions to `NonceRequest` state, and requests new nonces.
5. Signer B (not marked malicious since they responded to nonces in iteration N) sends new nonces for iteration N+1.
6. Coordinator sends `SignatureShareRequest` with `sign_iter_id = N+1` containing the NEW nonces from iteration N+1.
7. Malicious Signer B sends their OLD signature share from iteration N (computed with binding values from iteration N nonces).
8. The coordinator accepts this stale signature share because `gather_sig_shares()` doesn't validate `sign_iter_id`.
9. During aggregation, the intermediate values are computed using nonces from iteration N+1. [8](#0-7) 
10. The verification equation `z_i * G = R_i + c * λ_i * Y_i` fails because R_i was computed with iteration N+1 binding values, but z_i was computed with iteration N binding values. [9](#0-8) 
11. The aggregator's `sign()` method detects verification failure and returns an error. [10](#0-9) 

The FROST coordinator is not vulnerable because it lacks the `process_timeout()` method entirely and never increments `sign_iter_id` after the initial signing round.

## Impact Explanation

This vulnerability causes **transient consensus failures** (Medium severity per the defined scope). When triggered, signing rounds fail despite having sufficient honest signers because the aggregated signature cannot be verified.

In the Stacks blockchain context where WSTS is used for threshold signing, this prevents block signing or transaction confirmation until the malicious signer is identified and excluded. The disruption is temporary because:
- No funds are directly lost
- No permanent chain splits occur  
- No cryptographic keys are compromised
- The system can recover by excluding the malicious signer

However, the attack can repeatedly disrupt operations if the malicious signer continues to participate, potentially affecting multiple blocks before detection. The coordinator collects all signature shares and attempts aggregation before detecting the issue. [11](#0-10) 

## Likelihood Explanation

**High likelihood when timeout conditions are met:**

1. **Attacker Capabilities**: A malicious signer within the threshold (explicitly allowed by the threat model). The attacker only needs to store signature shares from previous iterations and replay them during retries.

2. **Attack Complexity**: Low. This is a simple message replay attack requiring no cryptographic expertise. The attacker saves their `SignatureShareResponse` from iteration N and resends it in iteration N+1.

3. **Preconditions**: The coordinator must have `sign_timeout` configured and timeouts must occur. This is common in production deployments where network latency or temporary unavailability causes timeouts.

4. **Detection Difficulty**: Low detection risk. Failed signature verifications appear identical to legitimate failures, making malicious behavior difficult to distinguish without detailed `sign_iter_id` logging.

5. **Economic Feasibility**: Highly feasible. No additional resources required beyond normal protocol participation.

## Recommendation

Add `sign_iter_id` validation in the `gather_sig_shares()` function to match the validation in `gather_nonces()`:

```rust
fn gather_sig_shares(
    &mut self,
    packet: &Packet,
    signature_type: SignatureType,
) -> Result<(), Error> {
    let Message::SignatureShareResponse(sig_share_response) = &packet.msg else {
        return Ok(());
    };

    // ... existing checks ...

    if sig_share_response.dkg_id != self.current_dkg_id {
        return Err(Error::BadDkgId(
            sig_share_response.dkg_id,
            self.current_dkg_id,
        ));
    }
    if sig_share_response.sign_id != self.current_sign_id {
        return Err(Error::BadSignId(
            sig_share_response.sign_id,
            self.current_sign_id,
        ));
    }
    // ADD THIS CHECK:
    if sig_share_response.sign_iter_id != self.current_sign_iter_id {
        return Err(Error::BadSignIterId(
            sig_share_response.sign_iter_id,
            self.current_sign_iter_id,
        ));
    }

    // ... rest of function ...
}
```

## Proof of Concept

The following test demonstrates the vulnerability:

```rust
#[test]
fn test_stale_signature_share_accepted() {
    // Setup coordinator with timeout configured
    let mut coordinator = setup_fire_coordinator_with_timeout();
    
    // Iteration N: Complete nonce gathering
    let nonce_responses_n = gather_nonces_iteration_n(&mut coordinator);
    
    // Malicious signer computes and stores signature share for iteration N
    let stale_sig_share = compute_signature_share_iteration_n(&nonce_responses_n);
    
    // Trigger timeout by withholding other signatures
    trigger_signature_timeout(&mut coordinator);
    
    // Iteration N+1: Coordinator increments sign_iter_id and requests new nonces
    assert_eq!(coordinator.current_sign_iter_id, N + 1);
    let nonce_responses_n_plus_1 = gather_nonces_iteration_n_plus_1(&mut coordinator);
    
    // Malicious signer sends OLD signature share from iteration N
    let result = coordinator.gather_sig_shares(&stale_sig_share, signature_type);
    
    // BUG: Coordinator accepts stale signature share (should reject)
    assert!(result.is_ok());
    
    // Attempt aggregation - will fail verification
    let aggregation_result = coordinator.aggregate_signatures();
    assert!(aggregation_result.is_err()); // Verification fails
}
```

This test proves that `gather_sig_shares()` accepts signature shares with mismatched `sign_iter_id`, leading to aggregation failures.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L173-204)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L814-828)
```rust
    fn request_nonces(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.message_nonces.clear();
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
        info!(
            sign_id = %self.current_sign_id,
            sign_iter_id = %self.current_sign_iter_id,
            "Requesting Nonces"
        );
        let nonce_request = NonceRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            message: self.message.clone(),
            signature_type,
        };
```

**File:** src/state_machine/coordinator/fire.rs (L856-860)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L1027-1038)
```rust
        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1113-1169)
```rust
        if message_nonce.sign_wait_signer_ids.is_empty() {
            // Calculate the aggregate signature
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();

            debug!(
                "aggregator.sign({}, {:?}, {:?}, {})",
                bs58::encode(&self.message).into_string(),
                nonces.len(),
                shares.len(),
                self.party_polynomials.len(),
            );

            self.aggregator.init(&self.party_polynomials)?;

            if let SignatureType::Taproot(merkle_root) = signature_type {
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    &shares,
                    &key_ids,
                    merkle_root,
                )?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else if let SignatureType::Schnorr = signature_type {
                let schnorr_proof =
                    self.aggregator
                        .sign_schnorr(&self.message, &nonces, &shares, &key_ids)?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else {
                let signature = self
                    .aggregator
                    .sign(&self.message, &nonces, &shares, &key_ids)?;
                debug!("Signature ({}, {})", signature.R, signature.z);
                self.signature = Some(signature);
            }
```

**File:** src/net.rs (L437-448)
```rust
pub struct SignatureShareResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Signature shares from this Signer
    pub signature_shares: Vec<SignatureShare>,
}
```

**File:** src/compute.rs (L15-33)
```rust
#[allow(non_snake_case)]
/// Compute a binding value from the party ID, public nonces, and signed message using XMD-based expansion.
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```

**File:** src/v2.rs (L257-257)
```rust
        let mut r = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
```

**File:** src/v2.rs (L309-309)
```rust
        let (_Rs, R) = compute::intermediate(msg, &party_ids, nonces);
```

**File:** src/v2.rs (L406-408)
```rust
            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/v2.rs (L457-461)
```rust
        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```
