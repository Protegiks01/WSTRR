# Audit Report

## Title
Missing Length Validation in NonceResponse Enables Network-Wide Signing Denial of Service

## Summary
The coordinator's `gather_nonces()` function fails to validate that `key_ids` and `nonces` arrays in `NonceResponse` messages have matching lengths. When a malicious signer sends mismatched arrays, this propagates to all honest signers who panic during signature share computation, causing complete signing round failure.

## Finding Description

The vulnerability exists in the signing flow where a malicious signer can send a `NonceResponse` with mismatched `key_ids` and `nonces` array lengths.

**Attack Flow:**

1. The `NonceResponse` structure allows separate `key_ids` and `nonces` vectors with no length constraint enforced at the type level. [1](#0-0) 

2. The coordinator's `gather_nonces()` validates that key_ids match the configuration and that each nonce is valid, but does NOT validate that `key_ids.len() == nonces.len()`: [2](#0-1) 

3. The malformed `NonceResponse` is stored and later broadcast to all signers in a `SignatureShareRequest`: [3](#0-2) 

4. When signers receive the request, they flatten the arrays separately using `flat_map`, which propagates the length mismatch: [4](#0-3) [5](#0-4) 

5. The signer calls `sign()` with mismatched key_ids and nonces arrays: [6](#0-5) 

6. The v1 `Signer::sign()` implementation calls `aggregate_nonce()` with `.unwrap()`: [7](#0-6) 

7. `compute::aggregate_nonce()` creates `scalars` with length `2 * party_ids.len()` and `points` with length `2 * nonces.len()`: [8](#0-7) 

When these lengths don't match, `Point::multimult()` returns an error, and the `.unwrap()` causes a panic. The same issue exists in `sign_taproot()` and `sign_schnorr()`: [9](#0-8) [10](#0-9) 

**Root Cause:**

The protocol assumes that key_ids and nonces arrays will always have matching lengths, but this invariant is not enforced at the message validation layer. The coordinator accepts malformed messages that violate this assumption, and the panic on `.unwrap()` converts a validation failure into a crash.

## Impact Explanation

**Severity: Low**

A single malicious signer can cause all honest signers to panic during signature share computation, preventing any signing round from completing. This constitutes a remotely-exploitable denial of service affecting all nodes.

The impact aligns with **Low** severity as defined in scope:
- "Any remotely-exploitable denial of service in a node"
- "Any network denial of service impacting more than 10 percent of miners that does not shut down the network"

**Specific Consequences:**
- One malicious signer blocks 100% of signing operations
- All honest signers crash when processing the malformed request
- Block production halts if WSTS is used for blockchain signing
- Transaction signing becomes unavailable

This does not cause fund loss, chain splits, or invalid transaction confirmation, distinguishing it from higher severity categories.

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Must be a registered signer (within protocol threat model)
- Must have network access to send messages to coordinator
- No cryptographic breaks required

**Attack Complexity:**
Very low. The attacker simply constructs:
```rust
NonceResponse {
    key_ids: vec![id1, id2, id3],
    nonces: vec![nonce1, nonce2],  // intentionally shorter
    // ... other fields
}
```

**Detection:**
Moderate difficulty. The malformed message is observable in logs, but may appear as an implementation bug rather than a deliberate attack.

**Probability:**
High if any signer is malicious or has buggy nonce generation logic. The attack is deterministic and requires no special timing.

## Recommendation

Add length validation in the coordinator's `gather_nonces()` function:

```rust
// In src/state_machine/coordinator/frost.rs, after line 521
if nonce_response.key_ids.len() != nonce_response.nonces.len() {
    warn!(
        signer_id = %nonce_response.signer_id,
        "Nonce response key_ids and nonces length mismatch"
    );
    return Ok(());
}
```

Additionally, replace `.unwrap()` with proper error handling in v1::Signer:

```rust
// In src/v1.rs, replace lines 714, 729, 746
let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces)
    .map_err(|e| /* return error instead of panic */)?;
```

## Proof of Concept

```rust
#[test]
fn test_mismatched_nonce_response_causes_panic() {
    use wsts::state_machine::signer::Signer;
    use wsts::v1::Signer as V1Signer;
    use wsts::net::{NonceResponse, SignatureShareRequest, SignatureType};
    
    // Setup: Create a signer
    let mut rng = create_rng();
    let signer = /* initialize signer */;
    
    // Create malformed NonceResponse with mismatched lengths
    let malformed_response = NonceResponse {
        dkg_id: 0,
        sign_id: 0,
        sign_iter_id: 0,
        signer_id: 0,
        key_ids: vec![1, 2, 3],  // 3 elements
        nonces: vec![nonce1, nonce2],  // 2 elements - MISMATCH
        message: vec![],
    };
    
    // Create SignatureShareRequest with the malformed response
    let request = SignatureShareRequest {
        dkg_id: 0,
        sign_id: 0,
        sign_iter_id: 0,
        nonce_responses: vec![malformed_response],
        message: b"test".to_vec(),
        signature_type: SignatureType::Frost,
    };
    
    // This will panic when aggregate_nonce is computed
    // Expected: Should return error instead of panic
    let result = signer.sign_share_request(&request, &mut rng);
    
    // Currently panics due to .unwrap() on line 714 of src/v1.rs
    assert!(result.is_err(), "Should handle mismatched lengths gracefully");
}
```

### Citations

**File:** src/net.rs (L310-327)
```rust
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}

```

**File:** src/state_machine/coordinator/frost.rs (L502-533)
```rust
            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/frost.rs (L571-586)
```rust
        let nonce_responses = (0..self.config.num_signers)
            .map(|i| self.public_nonces[&i].clone())
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
            message: self.message.clone(),
            signature_type,
        };
        let sig_share_request_msg = Packet {
            sig: sig_share_request
                .sign(&self.config.message_private_key)
                .expect(""),
            msg: Message::SignatureShareRequest(sig_share_request),
```

**File:** src/state_machine/signer/mod.rs (L781-785)
```rust
        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L817-817)
```rust
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
```

**File:** src/v1.rs (L714-714)
```rust
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
```

**File:** src/v1.rs (L729-729)
```rust
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
```

**File:** src/v1.rs (L746-746)
```rust
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
```

**File:** src/compute.rs (L109-120)
```rust
    let scalars: Vec<Scalar> = party_ids
        .iter()
        .flat_map(|&i| {
            [
                Scalar::from(1),
                binding_compressed(&id(i), &compressed_nonces, msg),
            ]
        })
        .collect();
    let points: Vec<Point> = nonces.iter().flat_map(|nonce| [nonce.D, nonce.E]).collect();

    Point::multimult(scalars, points)
```
