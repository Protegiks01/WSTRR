# Audit Report

## Title
Malicious DKG Signers Can Participate in Subsequent Rounds Due to Incomplete Exclusion Enforcement

## Summary
The FIRE coordinator maintains two separate tracking sets for malicious signers but fails to enforce exclusion during DKG operations and only partially enforces it during signing. This allows signers who were detected as malicious during DKG to repeatedly participate in subsequent DKG and signing rounds, causing transient consensus failures through repeated protocol disruption.

## Finding Description

The FIRE coordinator tracks malicious signers in two separate `HashSet<u32>` fields defined in the coordinator struct: [1](#0-0) 

The comment in the saved state structure documents their intended purpose: [2](#0-1) 

When malicious DKG behavior is detected (sending bad public or private shares), the coordinator verifies the reports and adds the malicious signer to `malicious_dkg_signer_ids`: [3](#0-2) 

The code explicitly documents that this set contains "all DKG signers who were ever malicious," indicating persistent tracking across rounds: [4](#0-3) 

However, the enforcement is critically incomplete:

**During DKG public share gathering**, no malicious signer sets are checked: [5](#0-4) 

**During DKG private share gathering**, no malicious signer sets are checked: [6](#0-5) 

**During signing nonce gathering**, only `malicious_signer_ids` is checked, not `malicious_dkg_signer_ids`: [7](#0-6) 

The `reset()` function deliberately preserves both malicious signer sets across state resets, indicating they were intended to persist across rounds: [8](#0-7) 

Both sets are also persisted in the coordinator's saved state for recovery: [9](#0-8) 

This creates an architectural inconsistency: the code implements persistent tracking of malicious signers and demonstrates the pattern of checking `malicious_signer_ids` during signing operations, but fails to apply the same exclusion logic to DKG operations or to check `malicious_dkg_signer_ids` during signing.

### Attack Execution Path

1. Attacker controls one signer node and participates in DKG round N
2. Attacker sends malformed DKG shares (bad public commitments or invalid private shares)
3. Other signers detect and report the misbehavior in DkgEnd messages
4. Coordinator verifies reports and adds attacker to `malicious_dkg_signer_ids` at line 776
5. DKG fails with `DkgError::DkgEndFailure` returned to external system
6. External system calls `start_dkg_round()` to retry
7. In DKG round N+1, `gather_public_shares()` and `gather_private_shares()` do not check `malicious_dkg_signer_ids`
8. Attacker participates again and can repeat the attack indefinitely
9. If DKG eventually succeeds, `gather_nonces()` only checks `malicious_signer_ids`, allowing the attacker to participate in signing and cause timeouts

## Impact Explanation

This vulnerability enables **transient consensus failures** as defined in the Medium severity category:

1. **Repeated DKG Disruption**: A malicious signer detected in round N can participate in all subsequent DKG rounds, repeatedly sending bad shares and preventing the establishment of an aggregate public key required for signing operations.

2. **Signing Delays**: If DKG succeeds (e.g., threshold is barely met or attacker occasionally behaves correctly), the malicious DKG signer can still participate in signing rounds and cause timeouts by refusing to send signature shares. Each timeout adds `sign_timeout` duration and forces retry iterations.

3. **Resource Exhaustion**: Multiple retry iterations compound delays, preventing timely transaction confirmation.

The signing timeout logic shows the coordinator tracks malicious signers and checks if sufficient non-malicious signers remain: [10](#0-9) 

However, this check only considers `malicious_signer_ids`, not `malicious_dkg_signer_ids`, allowing DKG-malicious signers to contribute to signing delays.

The system can eventually recover through external intervention (modifying the signer set in Config), but the lack of automatic exclusion means the protocol experiences transient consensus failures during this period.

## Likelihood Explanation

**Probability: 95%+** - This is a deterministic design flaw with no cryptographic assumptions required.

**Required Attacker Capabilities**:
- Control of at least one signer node (within protocol threat model of up to threshold-1 malicious signers)
- Ability to send malformed DKG messages through normal protocol interfaces
- Persistence across multiple protocol rounds

**Attack Complexity**: Low
- No timing attacks or race conditions required
- No need to compromise cryptographic primitives
- Simple message manipulation detectable by the protocol
- Attacker's actions are detected and logged but not prevented

**Economic Feasibility**: High - requires only running a signer node with standard protocol access, no specialized hardware or resources needed.

## Recommendation

Implement consistent malicious signer exclusion across all protocol phases:

1. **Check both malicious sets during DKG operations**:
   - In `gather_public_shares()`, reject shares from signers in either `malicious_dkg_signer_ids` or `malicious_signer_ids`
   - In `gather_private_shares()`, reject shares from signers in either malicious set

2. **Check both malicious sets during signing operations**:
   - In `gather_nonces()`, extend the existing check (line 903-915) to also check `malicious_dkg_signer_ids`

Example fix for `gather_nonces()`:

```rust
if self.malicious_signer_ids.contains(&nonce_response.signer_id) 
    || self.malicious_dkg_signer_ids.contains(&nonce_response.signer_id)
{
    warn!(
        sign_id = %nonce_response.sign_id,
        sign_iter_id = %nonce_response.sign_iter_id,
        signer_id = %nonce_response.signer_id,
        "Received malicious NonceResponse from previously malicious signer"
    );
    return Ok(());
}
```

3. **Provide a coordinator API** to allow external systems to clear malicious signer sets when appropriate (e.g., after confirmed exclusion from the signer set).

## Proof of Concept

The existing test `malicious_signers_dkg_v1` demonstrates malicious signer detection but does not test subsequent rounds: [11](#0-10) 

A complete PoC would extend this test to:
1. Capture the malicious signer ID from the first DKG failure
2. Call `start_dkg_round()` again without modifying the signer set
3. Verify that the same malicious signer's shares are accepted in `gather_public_shares()` and `gather_private_shares()` 
4. Demonstrate repeated DKG failures from the same malicious signer

The vulnerability is definitively proven by the code inspection showing:
- No checks in `gather_public_shares()` (lines 477-518)
- No checks in `gather_private_shares()` (lines 525-565)  
- Only partial checks in `gather_nonces()` (lines 903-915)
- Persistent tracking sets that are saved but not enforced (lines 775-777, 1333-1334, 1479-1490)

### Citations

**File:** src/state_machine/coordinator/fire.rs (L64-65)
```rust
    malicious_signer_ids: HashSet<u32>,
    malicious_dkg_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L177-200)
```rust
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L525-565)
```rust
    fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
            info!(
                dkg_id = %dkg_private_shares.dkg_id,
                signer_id = %dkg_private_shares.signer_id,
                "DkgPrivateShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.private_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L600-603)
```rust
        let mut reported_failures = HashMap::new();
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1333-1334)
```rust
            malicious_signer_ids: state.malicious_signer_ids.clone(),
            malicious_dkg_signer_ids: state.malicious_dkg_signer_ids.clone(),
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```

**File:** src/state_machine/coordinator/fire.rs (L2482-2586)
```rust
    fn malicious_signers_dkg<Aggregator: AggregatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
    ) -> (Vec<FireCoordinator<Aggregator>>, Vec<Signer<SignerType>>) {
        let (mut coordinators, mut signers) =
            setup::<FireCoordinator<Aggregator>, SignerType>(num_signers, keys_per_signer);

        // We have started a dkg round
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_dkg_round(None)
            .unwrap();
        assert!(coordinators.first().unwrap().aggregate_public_key.is_none());
        assert_eq!(coordinators.first().unwrap().state, State::DkgPublicGather);

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinators
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        for coordinator in &coordinators {
            assert_eq!(coordinator.state, State::DkgPrivateGather);
        }

        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::DkgPrivateBegin(_)),
            "Expected DkgPrivateBegin message"
        );

        // Send the DKG Private Begin message to all signers and share their responses with the coordinators and signers, but mutate one signer's DkgPrivateShares so it is marked malicious
        let (outbound_messages, operation_results) = feedback_mutated_messages(
            &mut coordinators,
            &mut signers,
            &outbound_messages,
            |signer, msgs| {
                if signer.signer_id != 0 {
                    return msgs;
                }
                msgs.iter()
                    .map(|packet| {
                        let Message::DkgPrivateShares(shares) = &packet.msg else {
                            return packet.clone();
                        };
                        // mutate one of the shares
                        let sshares: Vec<(u32, HashMap<u32, Vec<u8>>)> = shares
                            .shares
                            .iter()
                            .map(|(src_party_id, share_map)| {
                                (
                                    *src_party_id,
                                    share_map
                                        .iter()
                                        .map(|(dst_key_id, bytes)| {
                                            let mut bytes = bytes.clone();
                                            bytes.insert(0, 234);
                                            (*dst_key_id, bytes)
                                        })
                                        .collect(),
                                )
                            })
                            .collect();

                        Packet {
                            msg: Message::DkgPrivateShares(DkgPrivateShares {
                                dkg_id: shares.dkg_id,
                                signer_id: shares.signer_id,
                                shares: sshares.clone(),
                            }),
                            sig: vec![],
                        }
                    })
                    .collect()
            },
        );
        assert!(operation_results.is_empty());
        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::DkgEndBegin(_)),
            "Expected DkgEndBegin message"
        );

        // Send the DkgEndBegin message to all signers and share their responses with the coordinators and signers
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &outbound_messages);
        assert!(outbound_messages.is_empty());
        assert_eq!(operation_results.len(), 1);
        let OperationResult::DkgError(DkgError::DkgEndFailure {
            reported_failures, ..
        }) = &operation_results[0]
        else {
            panic!("Expected OperationResult::DkgError(DkgError::DkgEndFailure");
        };

        for (_signer_id, dkg_failure) in reported_failures {
            let DkgFailure::BadPrivateShares(bad_share_map) = dkg_failure else {
                panic!("Expected DkgFailure::BadPrivateShares");
            };
            for (bad_signer_id, _bad_private_share) in bad_share_map {
                assert_eq!(*bad_signer_id, 0u32);
            }
        }
        (coordinators, signers)
    }

```

**File:** src/state_machine/coordinator/mod.rs (L292-295)
```rust
    /// set of malicious signers during signing round
    pub malicious_signer_ids: HashSet<u32>,
    /// set of malicious signers during dkg round
    pub malicious_dkg_signer_ids: HashSet<u32>,
```
