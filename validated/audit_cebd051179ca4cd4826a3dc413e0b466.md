Audit Report

## Title
Coordinator Fails to Attribute Blame for Missing Private Shares Enabling Persistent DKG Denial of Service

## Summary
The FIRE coordinator fails to validate `DkgFailure::MissingPrivateShares` reports during the DKG end phase, leaving only a TODO comment where extensive validation logic should exist. A malicious signer can exploit this by selectively omitting encrypted shares for certain key_ids, causing honest signers to report failures that the coordinator cannot attribute to any party. This enables persistent DKG denial of service as the unidentified malicious signer can participate in retry attempts and repeat the attack indefinitely.

## Finding Description

The vulnerability exists in the `gather_dkg_end` function where the coordinator processes DKG failure reports from signers. [1](#0-0) 

When signers report `DkgFailure::MissingPrivateShares`, the coordinator performs no validation and does not add any signer to the `malicious_signers` set. This contrasts sharply with the extensive validation performed for `DkgFailure::BadPrivateShares`: [2](#0-1) 

**Attack Mechanism:**

During `dkg_private_begin`, an honest signer constructs a `DkgPrivateShares` message by iterating through active key_ids and encrypting shares: [3](#0-2) 

A malicious signer can modify this logic to selectively omit certain `dst_key_id` values from the `encrypted_shares` HashMap, effectively withholding shares from targeted participants.

Honest signers detect this during `dkg_ended` by checking if all their key_ids have corresponding encrypted shares: [4](#0-3) 

When honest signers report this failure, the coordinator collects the reports but cannot distinguish between a malicious dealer who actually withheld shares and a malicious reporter making false claims: [5](#0-4) 

Since no signer is added to `malicious_signers` for this failure type, the coordinator returns an error without attribution: [6](#0-5) 

**Why Validation is Possible:**

The coordinator has all data necessary to validate these claims. It stores all `DkgPrivateShares` messages: [7](#0-6) 

The coordinator could validate by checking whether the accused signer's `DkgPrivateShares.shares` HashMap contains encrypted shares for all expected key_ids of all active signers, similar to how it validates `BadPrivateShares` claims. The `DkgPrivateShares` structure stores shares as `Vec<(u32, HashMap<u32, Vec<u8>>)>` where the HashMap maps dst_key_id to encrypted shares.

## Impact Explanation

The vulnerability enables a **persistent denial of service** on DKG operations:

1. **DKG Operation Failure**: Any DKG round with the malicious signer fails, as honest signers correctly detect and report missing shares.

2. **No Blame Attribution**: The malicious signer is not identified or added to `malicious_dkg_signer_ids`: [8](#0-7) 

3. **Persistent Attack**: Without identifying the malicious signer, retry attempts include the same attacker, leading to repeated failures.

This maps to **LOW to MEDIUM** severity:
- **LOW**: "Any network denial of service impacting more than 10 percent of miners" - A single malicious signer can prevent all N signers from completing DKG, clearly exceeding the 10% threshold.
- **MEDIUM**: "Any transient consensus failures" - If DKG cannot complete, threshold signature operations cannot proceed, potentially causing transient consensus failures in systems depending on WSTS for distributed signing.

Note: The claim of HIGH severity based on "network partition" is not supported by the code. The attack causes DKG to fail uniformly for all participants rather than creating incompatible signing groups, as there is a single coordinator architecture where all signers see the same failure state.

## Likelihood Explanation

The attack is **highly likely** to succeed if an attacker controls a signer identity:

1. **Trivial Execution**: The attacker simply modifies the `encrypted_shares` HashMap construction to skip certain `dst_key_id` values or manually constructs a `DkgPrivateShares` message with incomplete mappings.

2. **No Special Capabilities Required**: Requires only control of a participating signer identity and ability to send protocol messages - no cryptographic breaks, key theft, or timing attacks needed.

3. **Deterministic Success**: Every execution succeeds as long as at least one honest signer is missing shares and reports the failure.

4. **Zero Detection Risk**: The coordinator explicitly does not attribute blame for this failure type, making the attacker unidentifiable through the protocol.

5. **Sustainable Attack**: Since `malicious_dkg_signer_ids` is never updated for this failure type, the same attacker can participate in unlimited retry attempts.

## Recommendation

Implement validation logic for `DkgFailure::MissingPrivateShares` similar to the existing validation for `DkgFailure::BadPrivateShares`. The coordinator should:

1. Extract the reporting signer's key_ids from `self.config.public_keys.signer_key_ids`
2. Retrieve the accused signer's `DkgPrivateShares` from `self.dkg_private_shares`
3. Verify that for each party_id in the accused signer's shares, the HashMap contains entries for all of the reporting signer's key_ids
4. If shares are actually missing, mark the accused signer as malicious
5. If shares are present, mark the reporting signer as malicious for false claims

```rust
DkgFailure::MissingPrivateShares(missing_shares) => {
    for accused_signer_id in missing_shares {
        let Some(reporting_signer_key_ids) = 
            self.config.public_keys.signer_key_ids.get(signer_id) else {
            continue;
        };
        
        let Some(accused_private_shares) = 
            self.dkg_private_shares.get(accused_signer_id) else {
            // Accused signer didn't send shares at all - they are malicious
            malicious_signers.insert(*accused_signer_id);
            continue;
        };
        
        let mut actually_missing = false;
        for (_, key_shares) in &accused_private_shares.shares {
            for key_id in reporting_signer_key_ids {
                if !key_shares.contains_key(key_id) {
                    actually_missing = true;
                    break;
                }
            }
            if actually_missing { break; }
        }
        
        if actually_missing {
            warn!("Signer {signer_id} reported MissingPrivateShares from {accused_signer_id}, shares are actually missing, mark {accused_signer_id} as malicious");
            malicious_signers.insert(*accused_signer_id);
        } else {
            warn!("Signer {signer_id} reported MissingPrivateShares from {accused_signer_id} but shares are present, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        }
    }
}
```

## Proof of Concept

A complete PoC would require a test showing:
1. Create a FIRE coordinator and multiple signers
2. Start DKG and have signers send DkgPublicShares
3. Have one malicious signer create a `DkgPrivateShares` message with incomplete HashMap (omitting certain dst_key_ids)
4. Have honest signers detect and report `MissingPrivateShares`
5. Verify coordinator returns `DkgError::DkgEndFailure` with empty `malicious_signers` field
6. Verify the malicious signer's ID is not in `malicious_dkg_signer_ids`, allowing them to participate in retries

The core vulnerability is confirmed through code inspection showing the missing validation logic at the specified line.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L41-41)
```rust
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L600-610)
```rust
        let mut reported_failures = HashMap::new();
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
        let threshold: usize = self.config.threshold.try_into().unwrap();
        if self.dkg_wait_signer_ids.is_empty() {
            // if there are any errors, mark signers malicious and retry
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L768-770)
```rust
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L783-788)
```rust
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L932-948)
```rust
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
```
