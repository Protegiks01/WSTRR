# Audit Report

## Title
Missing DKG Round ID Validation Enables Replay Attack and Denial of Service

## Summary
The signer's `dkg_public_share()` function accepts `DkgPublicShares` messages without validating that the message's `dkg_id` matches the current DKG round ID (`self.dkg_id`). This allows a malicious participant to replay legitimately-signed messages from previous DKG rounds, causing cryptographic verification to fail during finalization and forcing the DKG round to abort.

## Finding Description

The vulnerability exists in the signer state machine's message processing logic. When a signer receives a `DkgPublicShares` message, the `dkg_public_share()` function performs validations for signer ID existence, party ID ownership, and duplicate detection by signer_id, but critically omits validation of the `dkg_id` field. [1](#0-0) 

In contrast, the coordinator properly validates this field before processing: [2](#0-1) 

**Attack Mechanism:**

The `DkgPublicShares` struct contains a `dkg_id` field that identifies the DKG round: [3](#0-2) 

This field is included in the message's cryptographic hash for signature verification: [4](#0-3) 

When a malicious participant replays a `DkgPublicShares` message from DKG round N during round M (where M > N):

1. **Message signature remains valid** because it was legitimately created by the attacker in round N, covering all fields including the old `dkg_id`.

2. **Duplicate detection fails to prevent the attack** because it only checks by `signer_id`, not by `(signer_id, dkg_id)` pair: [5](#0-4) 

3. **Replayed shares are stored** without validation. Later, during `dkg_ended()`, polynomial commitments are verified using the **current** `dkg_id` as context: [6](#0-5) 

4. **Verification fails** because the Schnorr proof in the polynomial commitment was bound to the old `dkg_id` context. The Schnorr proof verification includes the context parameter: [7](#0-6) [8](#0-7) 

5. **DKG fails** when verification fails, marking the signer as having "bad public shares": [9](#0-8) [10](#0-9) 

**Security Guarantee Violation:**

The DKG protocol assumes all `DkgPublicShares` messages processed in a given round belong to that round. The missing `dkg_id` validation creates a time-of-check to time-of-use vulnerability where cryptographically invalid shares (from the wrong round) are accepted during message reception but only detected during finalization, causing the entire DKG round to fail.

## Impact Explanation

This vulnerability enables a **remotely-exploitable denial of service** attack on the DKG process, mapping to **Low severity**: "Any remotely-exploitable denial of service in a node."

**Concrete Impact:**
- Any past participant can force current DKG rounds to fail
- All signers receiving replayed messages will report DKG failure
- Minimal attacker resources required (storing and replaying a small message)
- No funds are directly lost, no invalid signatures are accepted, and no chain consensus is affected
- DKG failure prevents threshold signing setup but does not affect existing keys or ongoing operations

**Deployment Context:**
In WSTS deployments (e.g., Stacks/sBTC), DKG failure blocks the creation of new distributed keys required for threshold operations. However, it does not shut down the network or compromise existing keys.

## Likelihood Explanation

**Likelihood: High (conditional on network topology)**

**Attacker Capabilities:**
- Must be a legitimate participant in at least one DKG round (within WSTS threat model of up to t-1 malicious signers)
- Must have network access to send messages to signers
- No compromised private keys or broken cryptography required

**Attack Complexity: Very Low**
1. Participate legitimately in any DKG round N
2. Save the signed `DkgPublicShares` message
3. During subsequent DKG round M, replay the saved message to target signers
4. DKG fails during finalization with no immediate detection

**Economic Feasibility: Minimal**
- One-time participation cost to become a legitimate signer
- Storage of small messages (~1-10 KB per message)
- Negligible network bandwidth for replay

**Detection Difficulty:** 
Replayed messages have valid signatures and are indistinguishable from legitimate messages until Schnorr proof verification during `dkg_ended()`. By then, the DKG round has already progressed to the finalization phase.

**Deployment Dependency:**
The vulnerability is exploitable if the deployment architecture allows peer-to-peer message delivery between signers. The WSTS library documentation describes broadcast to "all other signers and the coordinator," and the signer's `process()` function accepts packets from any authenticated source. If deployments enforce coordinator-only message routing, the coordinator's `dkg_id` validation mitigates this attack.

## Recommendation

Add `dkg_id` validation in the signer's `dkg_public_share()` function to match the coordinator's validation:

```rust
pub fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Add dkg_id validation
    if dkg_public_shares.dkg_id != self.dkg_id {
        warn!(
            received_dkg_id = %dkg_public_shares.dkg_id,
            current_dkg_id = %self.dkg_id,
            "Received DkgPublicShares with mismatched dkg_id"
        );
        return Ok(vec![]);
    }

    // ... rest of existing validation logic
}
```

This ensures consistent validation across both coordinator and signer state machines, preventing replay attacks from previous DKG rounds.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_dkg_public_shares_replay_attack() {
        // This test demonstrates that a DkgPublicShares message from
        // round N can be accepted by a signer in round M, causing DKG to fail
        
        // Setup: Create a signer in DKG round 1
        let mut rng = rand::thread_rng();
        let network_key = Scalar::random(&mut rng);
        let public_keys = create_test_public_keys();
        
        let mut signer = Signer::<v2::Party>::new(
            3, 3, 3, 3, 0,
            vec![0, 1, 2],
            network_key,
            public_keys,
            &mut rng
        ).unwrap();
        
        // Simulate DKG round 1: signer creates and saves public shares
        signer.dkg_id = 1;
        let round1_shares = create_dkg_public_shares(1, 1, &mut rng);
        
        // Move to DKG round 2
        signer.reset(2, &mut rng);
        assert_eq!(signer.dkg_id, 2);
        
        // Attack: Replay the round 1 shares to round 2
        // The function should reject this but currently accepts it
        let result = signer.dkg_public_share(&round1_shares);
        
        // BUG: This should fail but succeeds, storing mismatched shares
        assert!(result.is_ok());
        assert!(signer.dkg_public_shares.contains_key(&1));
        
        // Later during dkg_ended(), verification will fail
        // because the Schnorr proof was bound to dkg_id=1 but
        // verification uses dkg_id=2
    }
}
```

The test demonstrates that the signer accepts `DkgPublicShares` with a mismatched `dkg_id`, which will later cause DKG finalization to fail when the Schnorr proof verification detects the context mismatch.

### Citations

**File:** src/state_machine/signer/mod.rs (L556-563)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L593-598)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
```

**File:** src/state_machine/signer/mod.rs (L973-1026)
```rust
    /// handle incoming DkgPublicShares
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/fire.rs (L479-484)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/net.rs (L141-150)
```rust
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/schnorr.rs (L47-59)
```rust
    /// Compute the schnorr challenge
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }
```

**File:** src/schnorr.rs (L61-65)
```rust
    /// Verify the proof
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```
