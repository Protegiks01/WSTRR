# Audit Report

## Title
Missing Nonce Count Validation Allows Denial of Service in Signing Rounds

## Summary
The `gather_nonces()` function in both FROST and FIRE coordinator implementations fails to validate that the number of nonces matches the number of key_ids in each `NonceResponse`. This allows a malicious signer to cause signing rounds to fail by sending mismatched counts, resulting in incorrect aggregate nonce computation and signature verification failures.

## Finding Description

Both coordinator implementations validate that the `key_ids` in a `NonceResponse` match the expected configuration through set equality checks and validate that each individual nonce is valid. However, neither validates that `nonces.len() == key_ids.len()`.

**NonceResponse Structure:** The message contains separate vectors for `key_ids` and `nonces`, allowing mismatched lengths: [1](#0-0) 

**FROST Coordinator Validation:** The validation checks set equality of key_ids and individual nonce validity, but never checks vector length equality: [2](#0-1) 

**FIRE Coordinator Validation:** The same validation pattern exists with identical missing length validation: [3](#0-2) 

**Aggregate Nonce Computation:** When computing the aggregate nonce, both coordinators use `flat_map` to extract key_ids and nonces into separate vectors, then pass these to `compute::intermediate()`.

FROST coordinator: [4](#0-3) 

FIRE coordinator: [5](#0-4) 

**Silent Truncation:** In `compute::intermediate()`, binding values are computed for all party_ids, but the `zip` operation silently truncates to the shorter length, producing an incorrect aggregate nonce when lengths mismatch: [6](#0-5) 

A malicious signer can send a `NonceResponse` with `key_ids: vec![1, 2, 3]` and `nonces: vec![nonce1, nonce2]`. This passes all validation checks, but causes the coordinator to compute an aggregate nonce missing the third key's contribution. When the coordinator transitions to signature share gathering, it includes this malformed response in the `SignatureShareRequest`: [7](#0-6) 

When honest signers receive the `SignatureShareRequest`, they extract the same mismatched vectors and compute signature shares based on the same incorrect aggregate nonce: [8](#0-7) 

The v1 signer's `sign()` method uses `compute::aggregate_nonce()` which has the same vulnerability pattern, computing from mismatched party_ids and nonces: [9](#0-8) 

The aggregate nonce function creates scalars for all party_ids but only has points for the provided nonces: [10](#0-9) 

This results in an invalid final signature that fails verification.

## Impact Explanation

This vulnerability enables a **Low severity** denial of service attack as defined in scope: "Any remotely-exploitable denial of service in a node."

Any signer can unilaterally abort signing rounds by sending mismatched nonce counts. The attack affects all signature types (FROST, Schnorr, Taproot) and requires the coordinator to restart the signing round. While this disrupts signing operations, it cannot cause consensus failures, chain splits, or funds loss. A malicious signer frequently included in signing committees could create sustained DoS, impacting all nodes relying on the coordinator for signing operations.

## Likelihood Explanation

**Likelihood: High**

The attack requires minimal capabilities:
- Must be a registered signer (within threat model)
- No cryptographic breaks required
- Trivial complexity: simply send a `NonceResponse` with mismatched vector lengths
- 100% success rate for any signing round the attacker participates in
- Low detection risk: malformed responses pass all validation checks
- Minimal cost: single malformed message per signing round

## Recommendation

Add length validation in both `gather_nonces()` implementations to ensure `nonces.len() == key_ids.len()`:

```rust
// After existing key_ids validation, add:
if nonce_response.nonces.len() != nonce_response.key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id,
        nonces_len = %nonce_response.nonces.len(),
        key_ids_len = %nonce_response.key_ids.len(),
        "Nonce count doesn't match key_ids count"
    );
    return Ok(());
}
```

This should be added in:
- `src/state_machine/coordinator/frost.rs` after line 521
- `src/state_machine/coordinator/fire.rs` after line 889

## Proof of Concept

```rust
#[test]
fn test_mismatched_nonce_count_dos() {
    use crate::net::NonceResponse;
    use crate::common::PublicNonce;
    use crate::compute;
    
    // Simulate malicious signer sending 3 key_ids but only 2 nonces
    let key_ids = vec![1, 2, 3];
    let nonces = vec![
        PublicNonce { D: Point::generator(), E: Point::generator() },
        PublicNonce { D: Point::generator(), E: Point::generator() },
    ];
    let msg = b"test message";
    
    // This should compute aggregate nonce with all 3 key contributions
    // but will silently truncate to only 2 due to zip
    let (r_vec, aggregate_r) = compute::intermediate(msg, &key_ids, &nonces);
    
    // Verify truncation occurred - only 2 contributions instead of 3
    assert_eq!(r_vec.len(), 2, "Expected truncation to 2 contributions");
    assert_ne!(r_vec.len(), key_ids.len(), "Vulnerability: missing contribution");
}
```

### Citations

**File:** src/net.rs (L309-326)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/state_machine/coordinator/frost.rs (L502-533)
```rust
            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/frost.rs (L565-592)
```rust
    fn request_sig_shares(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.signature_shares.clear();
        info!(
            sign_id = %self.current_sign_id,
            "Requesting Signature Shares"
        );
        let nonce_responses = (0..self.config.num_signers)
            .map(|i| self.public_nonces[&i].clone())
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
            message: self.message.clone(),
            signature_type,
        };
        let sig_share_request_msg = Packet {
            sig: sig_share_request
                .sign(&self.config.message_private_key)
                .expect(""),
            msg: Message::SignatureShareRequest(sig_share_request),
        };
        self.ids_to_await = (0..self.config.num_signers).collect();
        self.move_to(State::SigShareGather(signature_type))?;

        Ok(sig_share_request_msg)
    }
```

**File:** src/state_machine/coordinator/frost.rs (L736-751)
```rust
    fn compute_aggregate_nonce(&self) -> Point {
        // XXX this needs to be key_ids for v1 and signer_ids for v2
        let party_ids = self
            .public_nonces
            .values()
            .flat_map(|pn| pn.key_ids.clone())
            .collect::<Vec<u32>>();
        let nonces = self
            .public_nonces
            .values()
            .flat_map(|pn| pn.nonces.clone())
            .collect::<Vec<PublicNonce>>();
        let (_, R) = compute::intermediate(&self.message, &party_ids, &nonces);

        R
    }
```

**File:** src/state_machine/coordinator/fire.rs (L870-901)
```rust
            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1177-1198)
```rust
    fn compute_aggregate_nonce(&self) -> Point {
        // XXX this needs to be key_ids for v1 and signer_ids for v2
        let public_nonces = self
            .message_nonces
            .get(&self.message)
            .cloned()
            .unwrap_or_default()
            .public_nonces;
        let party_ids = public_nonces
            .values()
            .cloned()
            .flat_map(|pn| pn.key_ids)
            .collect::<Vec<u32>>();
        let nonces = public_nonces
            .values()
            .cloned()
            .flat_map(|pn| pn.nonces)
            .collect::<Vec<PublicNonce>>();
        let (_, R) = compute::intermediate(&self.message, &party_ids, &nonces);

        R
    }
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** src/compute.rs (L100-121)
```rust
pub fn aggregate_nonce(
    msg: &[u8],
    party_ids: &[u32],
    nonces: &[PublicNonce],
) -> Result<Point, PointError> {
    let compressed_nonces: Vec<(Compressed, Compressed)> = nonces
        .iter()
        .map(|nonce| (nonce.D.compress(), nonce.E.compress()))
        .collect();
    let scalars: Vec<Scalar> = party_ids
        .iter()
        .flat_map(|&i| {
            [
                Scalar::from(1),
                binding_compressed(&id(i), &compressed_nonces, msg),
            ]
        })
        .collect();
    let points: Vec<Point> = nonces.iter().flat_map(|nonce| [nonce.D, nonce.E]).collect();

    Point::multimult(scalars, points)
}
```

**File:** src/state_machine/signer/mod.rs (L781-818)
```rust
        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/v1.rs (L707-719)
```rust
    fn sign(
        &self,
        msg: &[u8],
        _signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
        self.parties
            .iter()
            .map(|p| p.sign_precomputed(msg, key_ids, nonces, &aggregate_nonce))
            .collect()
    }
```
