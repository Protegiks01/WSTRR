# Audit Report

## Title
Incorrect Malicious Signer Identification Due to Unauthenticated SignatureShare.id Field in v2

## Summary
The v2 coordinator fails to validate that the `id` field within `SignatureShare` objects matches the authenticated `signer_id` of the message sender. A malicious signer can exploit this by creating signature shares with a victim's party ID, causing signature verification to fail and blame to be incorrectly assigned to an innocent party. This breaks the protocol's blame assignment mechanism and enables framing attacks.

## Finding Description

**Root Cause:**

The vulnerability exists in v2's signature share validation logic. While the coordinator authenticates message senders and validates their `key_ids`, it never checks that `SignatureShare.id` matches the sender's identity.

The SignatureShare structure contains an `id` field representing the party ID: [1](#0-0) 

In v2, parties create signature shares with their party_id: [2](#0-1) 

The coordinator validates `key_ids` but not the `id` field: [3](#0-2) 

The coordinator stores shares indexed by the authenticated signer_id: [4](#0-3) 

However, during aggregation, party IDs are extracted directly from `SignatureShare.id` for binding computation: [5](#0-4) 

When verification fails, blame is assigned based on `SignatureShare.id`: [6](#0-5) 

**Attack Flow:**

1. Malicious signer creates SignatureShare with `id: victim_party_id` instead of `id: self.party_id`
2. Keeps `key_ids` correct to pass coordinator validation
3. Coordinator accepts the share (key_ids validation passes)
4. Aggregator uses wrong party_id for binding computation
5. Binding values mismatch, signature verification fails
6. Victim's party_id appears in `BadPartySigs` error instead of attacker's

**Why v1 is not affected:**

In v1, each party controls exactly one key where `id == key_id`: [7](#0-6) 

When the coordinator validates `key_ids`, it implicitly validates `id` since they must be equal. In v2, party_id and key_ids are independent, allowing the attack.

## Impact Explanation

**Severity: Medium** - This qualifies as "transient consensus failures" per the defined scope.

The vulnerability enables a compromised signer to:
1. Cause signature operations to fail by providing mismatched party IDs
2. Frame innocent signers through incorrect blame assignment
3. Potentially trigger exclusion of honest parties if systems trust the blame mechanism
4. Cause repeated signing failures until the issue is detected

In a system with 10 signers and threshold 7, an attacker controlling 1 signer could frame 3 honest signers across multiple rounds, reducing available signers to 6 (below threshold), causing temporary loss of signing capability.

The impact is limited to transient failures (not permanent) because the vulnerability requires active exploitation and can be mitigated once detected through correlation of packet-level sender IDs with signature share IDs.

## Likelihood Explanation

**Likelihood: High (if signer compromised)**

Required capabilities:
- Control of one signer node (within protocol threat model)
- Ability to modify signer software to set incorrect `id` field
- No additional cryptographic secrets needed

Attack complexity is **low** - requires only changing line 272 in `v2::Party::sign_with_tweak()` from `id: self.party_id` to `id: victim_party_id`.

The attack:
- Can be executed repeatedly
- Has no timing constraints
- Requires no special resources beyond compromising a single signer
- Is difficult to detect without explicit logging correlation

Detection requires correlating packet-level authenticated sender IDs with the `SignatureShare.id` values inside packets, which is not performed by default.

## Recommendation

Add validation in the coordinator's `gather_sig_shares()` method to verify that `SignatureShare.id` matches the expected party_id for the authenticated signer:

```rust
// In gather_sig_shares() after key_ids validation
for sig_share in &sig_share_response.signature_shares {
    // In v2, party_id should equal signer_id
    if sig_share.id != sig_share_response.signer_id {
        warn!(
            signer_id = %sig_share_response.signer_id,
            sig_share_id = %sig_share.id,
            "SignatureShare.id doesn't match authenticated signer_id"
        );
        return Err(Error::BadPartyIdForSigner(sig_share_response.signer_id));
    }
}
```

Alternatively, use the existing `validate_party_id` function: [8](#0-7) 

This validation should be added after the existing key_ids check in both FIRE and FROST coordinator implementations.

## Proof of Concept

```rust
#[test]
fn test_malicious_signature_share_id_v2() {
    // Setup: Create a v2 configuration with 3 signers, threshold 2
    // Each signer controls different key_ids
    
    // 1. Run DKG to establish keys
    // 2. Start signing round with signers 0, 1, 2
    // 3. Signer 0 (malicious) creates SignatureShare with:
    //    - id: 1 (victim's party_id, not 0)
    //    - key_ids: [0, 1] (correct for signer 0)
    //    - z_i: correctly computed value
    
    // 4. Coordinator accepts share (key_ids validation passes)
    // 5. Aggregation uses party_ids [1, 1, 2] instead of [0, 1, 2]
    // 6. Binding computation fails due to duplicate/wrong party_id
    // 7. Signature verification fails
    // 8. BadPartySigs error contains party_id 1 (victim)
    //    instead of party_id 0 (actual malicious signer)
    
    // Assert: Blame is assigned to party_id 1 instead of party_id 0
}
```

The PoC demonstrates that by manipulating only the `id` field while keeping `key_ids` correct, a malicious signer can cause verification failures blamed on an innocent party.

### Citations

**File:** src/common.rs (L211-220)
```rust
#[derive(Clone, Deserialize, Serialize, PartialEq)]
/// A share of the party signature with related values
pub struct SignatureShare {
    /// The ID of the party
    pub id: u32,
    /// The party signature
    pub z_i: Scalar,
    /// The key IDs of the party
    pub key_ids: Vec<u32>,
}
```

**File:** src/v2.rs (L271-275)
```rust
        SignatureShare {
            id: self.party_id,
            z_i: z,
            key_ids: self.key_ids.clone(),
        }
```

**File:** src/v2.rs (L359-360)
```rust
        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (Rs, R) = compute::intermediate(msg, &party_ids, nonces);
```

**File:** src/v2.rs (L406-408)
```rust
            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/v2.rs (L644-650)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        _signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        signer_id == party_id
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/v1.rs (L224-228)
```rust
        SignatureShare {
            id: self.id,
            z_i: z,
            key_ids: vec![self.id],
        }
```
