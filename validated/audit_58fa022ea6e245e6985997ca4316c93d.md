# Audit Report

## Title
Unbounded Nested Loop DOS in DkgPrivateShares Hash Function

## Summary
The `DkgPrivateShares::hash()` function processes unbounded nested data structures during signature verification, enabling denial-of-service attacks. An attacker can send malicious packets with excessive nested structures that consume substantial CPU and memory resources before signature validation rejects them, potentially preventing DKG completion and causing transient consensus failures.

## Finding Description

The `DkgPrivateShares` structure contains an unbounded `shares` field of type `Vec<(u32, HashMap<u32, Vec<u8>>)>` with no size constraints. [1](#0-0) 

The vulnerability occurs in the hash implementation's nested loops that iterate over all entries in the `shares` Vec and all keys in each HashMap, hashing each `dst_id` and encrypted share bytes without any bounds checking. [2](#0-1) 

The critical security flaw is that hashing occurs during signature verification BEFORE the signature is validated. The `Signable::verify()` trait method calls `self.hash(&mut hasher)` at line 36 before `sig.verify()` at line 44. [3](#0-2) 

This means an attacker can send malicious `DkgPrivateShares` packets without valid signatures, and the expensive nested loop processing occurs before the system rejects the invalid signature. The packet verification flow in the signer's `process()` function confirms this occurs early in message handling. [4](#0-3) 

The attack vector exists because:
1. No bounds on the number of elements in the `shares` Vec
2. No bounds on the number of entries in each HashMap
3. No bounds on the size of each `Vec<u8>` encrypted share value
4. No size validation before deserialization or hashing
5. Hashing occurs before signature verification can reject invalid packets

## Impact Explanation

An attacker can prevent DKG completion by DOSing multiple signers during the private shares exchange phase. In legitimate use, the nested structure should contain modest sizes (5-15 parties, 10-150 keys, ~64 byte shares). An attacker can instead send packets with 10,000+ Vec entries, 10,000+ HashMap entries per Vec element, and 1KB+ per encrypted share value, resulting in millions of hash operations and multi-gigabyte memory consumption per malicious packet.

All signers participating in DKG rounds are affected. If enough signers are DOSed that the DKG threshold cannot be met, the entire DKG round fails, preventing the distributed key generation required for threshold signing operations. This constitutes a **transient consensus failure** (Medium severity) because the protocol cannot progress until DKG completes, though it can be retried.

The attack is repeatable - the attacker can send unlimited malicious packets, continuously preventing DKG completion until operational mitigations (rate limiting, firewall rules) are deployed outside the WSTS codebase.

## Likelihood Explanation

Attack likelihood is **Very High** due to:

**Low Complexity**: The attacker only needs to construct a `DkgPrivateShares` struct with large nested structures, serialize it, and send it to target signers. No valid cryptographic signature is required because the DOS occurs during signature verification itself.

**Minimal Cost**: The attack requires only network bandwidth to send packets. The impact is asymmetric - the attacker sends one packet while the victim processes millions of operations. This is a classic amplification attack.

**No Authentication Required**: The DOS happens before signature verification rejects the packet, so the attacker doesn't need any valid signing keys.

**No Built-in Defenses**: The codebase contains no size limits on deserialization, no bounds checking on data structures, and no rate limiting. Grep search confirms no `MAX_SIZE` or similar bounds exist in the codebase.

**High Detection Risk**: While signature verification will eventually reject invalid packets, the resource exhaustion happens first. The victim experiences CPU/memory consumption before rejecting each malicious packet.

## Recommendation

Implement size limits at multiple defensive layers:

1. **Add bounds to the DkgPrivateShares structure**:
```rust
const MAX_SHARES: usize = 100;
const MAX_KEYS_PER_SHARE: usize = 200;
const MAX_ENCRYPTED_SHARE_SIZE: usize = 256;

impl DkgPrivateShares {
    pub fn validate_bounds(&self) -> Result<(), Error> {
        if self.shares.len() > MAX_SHARES {
            return Err(Error::ExcessiveShares);
        }
        for (_, share_map) in &self.shares {
            if share_map.len() > MAX_KEYS_PER_SHARE {
                return Err(Error::ExcessiveKeys);
            }
            for encrypted_share in share_map.values() {
                if encrypted_share.len() > MAX_ENCRYPTED_SHARE_SIZE {
                    return Err(Error::ExcessiveShareSize);
                }
            }
        }
        Ok(())
    }
}
```

2. **Validate bounds during deserialization** before any processing occurs.

3. **Call validation before signature verification** in `Packet::verify()` to reject oversized packets before expensive hashing.

4. **Add transport-level size limits** on packet deserialization to prevent memory exhaustion during parsing.

5. **Implement rate limiting** at the application layer to prevent repeated attacks.

## Proof of Concept

```rust
#[test]
fn test_dkg_private_shares_dos() {
    use wsts::net::{DkgPrivateShares, Signable};
    use sha2::Sha256;
    use hashbrown::HashMap;
    
    // Construct malicious DkgPrivateShares with excessive nested structures
    let mut malicious_shares = Vec::new();
    for src_id in 0..1000 {  // 1000 Vec entries
        let mut share_map = HashMap::new();
        for dst_id in 0..1000 {  // 1000 HashMap entries each
            share_map.insert(dst_id, vec![0u8; 1024]);  // 1KB per share
        }
        malicious_shares.push((src_id, share_map));
    }
    
    let malicious_msg = DkgPrivateShares {
        dkg_id: 1,
        signer_id: 0,
        shares: malicious_shares,
    };
    
    // This hash operation processes 1000 * 1000 = 1M entries
    // Each entry hashes ~1KB, resulting in ~1GB of data processed
    let start = std::time::Instant::now();
    let mut hasher = Sha256::new();
    malicious_msg.hash(&mut hasher);
    let duration = start.elapsed();
    
    // Demonstrates the DOS - this single hash operation takes significant time
    println!("DOS hash operation took: {:?}", duration);
    assert!(duration.as_secs() > 0, "Hash operation should take measurable time");
}
```

This test demonstrates that a malicious `DkgPrivateShares` message causes expensive hash operations that consume substantial resources before signature verification can reject the packet.

### Citations

**File:** src/net.rs (L14-46)
```rust
/// Trait to encapsulate sign/verify, users only need to impl hash
pub trait Signable {
    /// Hash this object in a consistent way so it can be signed/verified
    fn hash(&self, hasher: &mut Sha256);

    /// Sign a hash of this object using the passed private key
    fn sign(&self, private_key: &Scalar) -> Result<Vec<u8>, ecdsa::Error> {
        let mut hasher = Sha256::new();

        self.hash(&mut hasher);

        let hash = hasher.finalize();
        match ecdsa::Signature::new(hash.as_slice(), private_key) {
            Ok(sig) => Ok(sig.to_bytes().to_vec()),
            Err(e) => Err(e),
        }
    }

    /// Verify a hash of this object using the passed public key
    fn verify(&self, signature: &[u8], public_key: &ecdsa::PublicKey) -> bool {
        let mut hasher = Sha256::new();

        self.hash(&mut hasher);

        let hash = hasher.finalize();
        let sig = match ecdsa::Signature::try_from(signature) {
            Ok(sig) => sig,
            Err(_) => return false,
        };

        sig.verify(hash.as_slice(), public_key)
    }
}
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L201-217)
```rust
impl Signable for DkgPrivateShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PRIVATE_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // make sure we hash consistently by sorting the keys
        for (src_id, share) in &self.shares {
            hasher.update(src_id.to_be_bytes());
            let mut dst_ids = share.keys().cloned().collect::<Vec<u32>>();
            dst_ids.sort();
            for dst_id in &dst_ids {
                hasher.update(dst_id.to_be_bytes());
                hasher.update(&share[dst_id]);
            }
        }
    }
}
```

**File:** src/state_machine/signer/mod.rs (L457-480)
```rust
    /// process the passed incoming message, and return any outgoing messages needed in response
    pub fn process<R: RngCore + CryptoRng>(
        &mut self,
        packet: &Packet,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
            Message::DkgPrivateShares(dkg_private_shares) => {
                self.dkg_private_shares(dkg_private_shares, rng)
            }
```
