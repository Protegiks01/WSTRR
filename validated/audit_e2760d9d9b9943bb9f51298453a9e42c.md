# Audit Report

## Title
Duplicate key_ids in NonceResponse Bypass Validation and Corrupt Lagrange Interpolation

## Summary
The validation logic for `key_ids` in `NonceResponse` and `SignatureShareResponse` converts the incoming `Vec<u32>` to a `HashSet` before comparing with the configuration, which silently removes duplicates. However, the original `Vec` with duplicates is stored and later propagated to all signers, corrupting Lagrange interpolation coefficients and causing complete signing round failure. A single malicious signer can exploit this to trigger denial of service.

## Finding Description

**Root Cause - HashSet Validation Fails to Detect Duplicates:**

The coordinator validates NonceResponse key_ids by converting the Vec to a HashSet and comparing against configured signer_key_ids. [1](#0-0) 

If a malicious signer sends `NonceResponse { key_ids: vec![1, 1, 2], ... }`, the validation creates `HashSet {1, 2}`, compares it with the configured `{1, 2}`, and passes. However, the original `Vec [1, 1, 2]` with duplicates is stored in `self.public_nonces`. [2](#0-1) 

Identical validation logic exists for SignatureShareResponse. [3](#0-2) 

**Propagation to All Signers:**

The coordinator constructs SignatureShareRequest using all stored NonceResponses from `self.public_nonces`. [4](#0-3) 

Each signer receives the request and reconstructs the global key_ids list by flattening all key_ids from all nonce_responses. [5](#0-4) 

If any NonceResponse contains duplicate key_ids, the resulting global list contains duplicates. This corrupted list is passed to every signer's sign function, affecting all participants.

**Corruption in Lagrange Interpolation:**

The lambda function computes Lagrange interpolation coefficients by iterating over all j in key_ids and multiplying factors. [6](#0-5) 

When signers compute signature shares, they call lambda with the corrupted global key_ids for each of their own key_ids. [7](#0-6) 

If `key_ids = [1, 1, 2, 3]` contains a duplicate, computing `lambda(3, [1, 1, 2, 3])` multiplies the factor `1/(1-3)` twice instead of once, producing an incorrect coefficient. All signers compute wrong `z_i` values, causing the aggregated signature to fail verification.

**Aggregation Failure and Misidentification:**

The coordinator attempts signature aggregation and verification. [8](#0-7) 

When verification fails, the coordinator calls `check_signature_shares` to identify malicious parties. [9](#0-8) 

However, if the malicious signer also includes duplicates in their `SignatureShare.key_ids`, the check uses the same corrupted lambda coefficients. This may cause the malicious signer's share to validate incorrectly, while honest signers' shares fail verification, leading to misidentification.

**Configuration Validation is Insufficient:**

The `PublicKeys::validate()` method only validates that configured key_ids are in range. [10](#0-9) 

It uses `signer_key_ids: HashMap<u32, HashSet<u32>>` where HashSet cannot contain duplicates, so the configuration itself is protected. However, runtime validation of incoming messages fails to detect duplicates in the original Vec before converting to HashSet.

## Impact Explanation

**Denial of Service Impact:**

A single malicious signer can cause complete signing round failure by including duplicate key_ids in their NonceResponse. All participating signers will compute signature shares using incorrect Lagrange coefficients, causing the aggregated signature to fail verification. The signing round cannot complete until the malicious signer is identified and removed, then the entire round must restart.

**Severity Assessment:**

This vulnerability maps to **Low severity** per the defined scope: "Any remotely-exploitable denial of service in a node" since it causes signing operations to fail. If WSTS is integrated into consensus-critical operations like block signing or transaction confirmation, it could escalate to **Medium severity**: "Any transient consensus failures."

**Quantified Impact:**
- Attack affects all signers in the protocol, not just the malicious party
- Recovery requires identifying and removing the malicious signer
- With n=10 keys and threshold t=7, a malicious signer controlling 2 keys can prevent any signing round from succeeding
- Attack requires only a single corrupted NonceResponse message

## Likelihood Explanation

**High Likelihood:**

The vulnerability is extremely simple to exploit. A malicious signer only needs to duplicate values in their key_ids Vec:
```rust
NonceResponse { key_ids: vec![1, 1, 2], ... }  // instead of vec![1, 2]
```

**Attacker Requirements:**
- Must be a valid signer in the WSTS protocol with legitimate credentials (within threat model)
- Requires ability to send network messages (standard protocol capability)
- No need to compromise cryptographic keys or break underlying primitives

**Success Probability:**
Near 100% - the validation logic deterministically fails to catch duplicates in Vecs by converting to HashSet before comparison.

**Detection Difficulty:**
Low detection risk during attack. The coordinator will detect signature failure but the validation logs only show "key_ids didn't match config" without specifying the cause. Post-attack forensics requires examining raw message contents.

## Recommendation

Add explicit duplicate detection before the HashSet comparison in both NonceResponse and SignatureShareResponse validation:

```rust
// For NonceResponse validation
let nonce_response_key_ids_set = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

// Check for duplicates
if nonce_response_key_ids_set.len() != nonce_response.key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id,
        "Nonce response key_ids contains duplicates"
    );
    return Ok(());
}

if *signer_key_ids != nonce_response_key_ids_set {
    warn!(
        signer_id = %nonce_response.signer_id,
        "Nonce response key_ids didn't match config"
    );
    return Ok(());
}
```

Apply the same fix to SignatureShareResponse validation by checking that the flattened key_ids HashSet has the same length as the total count of key_ids across all signature shares.

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_corruption() {
    // Setup: Create a coordinator and signers with weighted keys
    // Signer 0 controls key_ids [1, 2]
    // Malicious signer sends NonceResponse with key_ids: vec![1, 1, 2]
    
    let mut malicious_nonce_response = NonceResponse {
        dkg_id: 0,
        sign_id: 0,
        sign_iter_id: 0,
        signer_id: 0,
        key_ids: vec![1, 1, 2], // DUPLICATE key_id 1
        nonces: vec![/* valid nonces */],
        message: vec![/* message */],
    };
    
    // The validation will convert vec![1, 1, 2] to HashSet {1, 2}
    // and compare with configured {1, 2} - passes validation
    
    // Later, when signers compute signature shares:
    // key_ids = [1, 1, 2, ...] (flattened from all nonce responses)
    // lambda(2, [1, 1, 2, ...]) will multiply factor for j=1 twice
    // Result: incorrect Lagrange coefficient
    
    // Expected: Signature aggregation fails with all signers having wrong z_i
    // Expected: check_signature_shares may misidentify honest signers
}
```

### Citations

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L542-543)
```rust
            self.public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/frost.rs (L571-578)
```rust
        let nonce_responses = (0..self.config.num_signers)
            .map(|i| self.public_nonces[&i].clone())
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
```

**File:** src/state_machine/coordinator/frost.rs (L631-641)
```rust
            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L393-408)
```rust
            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/v2.rs (L448-461)
```rust
    fn sign(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
    ) -> Result<Signature, AggregatorError> {
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, key_ids, None)?;

        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```

**File:** src/state_machine/mod.rs (L106-136)
```rust
    pub fn validate(&self, num_signers: u32, num_keys: u32) -> Result<(), SignerError> {
        for (signer_id, _key) in &self.signers {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }
        }

        for (key_id, _key) in &self.key_ids {
            if !validate_key_id(*key_id, num_keys) {
                return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
            }
        }

        for (signer_id, key_ids) in &self.signer_key_ids {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }

            for key_id in key_ids {
                if !validate_key_id(*key_id, num_keys) {
                    return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
                }
            }
        }

        Ok(())
    }
```
