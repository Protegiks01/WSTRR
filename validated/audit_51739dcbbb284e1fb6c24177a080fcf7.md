# Audit Report

## Title
Coordinator Panic Due to Premature Wait List Removal in Signature Share Validation

## Summary
The `gather_sig_shares()` function in FireCoordinator removes signers from the wait list before validating their signature shares, creating a state inconsistency. A malicious signer can send an invalid `SignatureShareResponse` that causes validation failure after wait list removal, resulting in missing entries in `signature_shares`. When aggregation triggers, the code uses the bracket operator to access the missing shares, causing a panic and coordinator crash.

## Finding Description

The vulnerability exists in the signature share gathering logic where state mutations occur before validation completes.

During the nonce gathering phase, when a signer provides valid nonces, their ID is inserted into the `public_nonces` map: [1](#0-0) 

When signature shares are requested, the `signature_shares` map is cleared: [2](#0-1) 

In the `gather_sig_shares()` function, the coordinator immediately removes the signer from the wait list upon receiving a response: [3](#0-2) 

After this premature removal, multiple validation checks occur that can return errors, including checks for missing public keys, missing key IDs, and mismatched key IDs: [4](#0-3) 

Only if all validations pass are the signature shares inserted into the map: [5](#0-4) 

This creates a critical state inconsistency: if validation fails after line 1044, the signer's ID remains in `public_nonces` but is absent from `signature_shares`, and they have been removed from `sign_wait_signer_ids`.

When all remaining signers respond and the wait list becomes empty, aggregation triggers. The code iterates over all signers in `public_nonces` and uses the bracket operator to access their shares: [6](#0-5) 

Since `signature_shares` is defined as a `BTreeMap`: [7](#0-6) 

The bracket operator panics when a key is not present, causing an unrecoverable coordinator crash.

**Attack Scenario:**
1. Malicious signer participates normally through DKG and nonce generation phases (their ID is in `public_nonces`)
2. Signer sends a `SignatureShareResponse` with `key_ids` that don't match their configured `key_ids`
3. Coordinator removes them from wait list (line 1044)
4. Validation fails (line 1075), function returns error
5. Signer's shares are never added to `signature_shares`
6. Other honest signers respond successfully
7. Wait list becomes empty, triggering aggregation at line 1113
8. Aggregation code at line 1134 tries to access missing shares using bracket operator
9. Coordinator panics and crashes

**Comparison with FROST:**
The FROST coordinator implementation correctly prevents this vulnerability by inserting shares FIRST, then removing from the wait list ONLY after successful validation: [8](#0-7) 

Additionally, FROST's validation failures return `Ok(())` rather than errors, keeping the signer in the wait list.

## Impact Explanation

This vulnerability allows a malicious or faulty signer to crash the coordinator node, causing denial of service. The impact is classified as **Low severity** per the audit scope definition: "Any remotely-exploitable denial of service in a node."

**Concrete Harms:**
- Coordinator node crashes and requires manual restart
- Current signing round fails completely for all participants
- All participants must restart the signing protocol from the beginning
- In deployments with multiple coordinator instances, each can be crashed independently
- Repeated attacks can prevent signing operations from ever completing

**Affected Parties:**
- Coordinator node operators running FireCoordinator
- Users waiting for threshold signatures to complete
- Systems depending on WSTS for critical operations (e.g., Stacks blockchain transaction signing)

While this does not lead to invalid signatures, fund loss, or consensus failures, it represents a remotely-exploitable availability attack that can disrupt time-sensitive operations.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a registered signer with assigned `key_ids` in the coordinator's configuration
- Must successfully complete DKG phase
- Must successfully complete nonce generation phase for the target signing round
- Must be selected for the signing committee

**Attack Complexity:**
The attack is trivial to execute. The attacker simply:
1. Participates normally through DKG and nonce phases (standard protocol behavior)
2. Constructs a `SignatureShareResponse` with `key_ids` that don't match their configured `key_ids`
3. Sends the invalid response and waits for other signers to respond

**Economic Feasibility:**
Very feasible. No special computational resources, stake, or economic investment required beyond being a protocol participant. The attack can be repeated across multiple signing rounds.

**Detection:**
The validation error is logged when it occurs, but the panic happens later during aggregation, potentially making root cause analysis difficult without detailed trace logs.

**Estimated Probability:**
- High if an attacker is already a signer
- Medium-to-High in systems where signer registration is permissioned but signers may become compromised
- Within the protocol's threat model of up to threshold-1 malicious signers

## Recommendation

Move the wait list removal to occur AFTER successful validation and insertion, matching the FROST coordinator's pattern:

```rust
// Perform all validations first
if sig_share_response.dkg_id != self.current_dkg_id {
    return Err(Error::BadDkgId(...));
}
// ... other validation checks ...

// Only after validation passes, insert shares
self.signature_shares.insert(
    sig_share_response.signer_id,
    sig_share_response.signature_shares.clone(),
);

// THEN remove from wait list
response_info
    .sign_wait_signer_ids
    .remove(&sig_share_response.signer_id);
```

Alternatively, use safe map access methods like `.get()` instead of the bracket operator during aggregation, though this would only prevent the panic without addressing the underlying state inconsistency.

## Proof of Concept

```rust
#[test]
fn test_premature_wait_list_removal_panic() {
    // Setup: Create a FireCoordinator with 3 signers, threshold 2
    let (mut coordinator, mut signers) = setup::<FireCoordinator<v2::Aggregator>, v2::Signer>(3, 2);
    
    // Run DKG successfully
    run_dkg(&mut coordinator, &mut signers);
    
    // Start signing round and collect nonces from all signers
    coordinator.start_signing_round(...);
    for signer in &mut signers {
        let nonce = signer.gen_nonce();
        coordinator.process(nonce);
    }
    
    // Malicious signer (signer 0) sends invalid SignatureShareResponse
    // with key_ids that don't match configured key_ids
    let mut invalid_response = signers[0].sign(...);
    invalid_response.signature_shares[0].key_ids = vec![999]; // Invalid key_id
    
    // Coordinator processes invalid response - removes from wait list then fails validation
    let result = coordinator.process(invalid_response);
    assert!(result.is_err()); // Validation error returned
    
    // Honest signers (1 and 2) respond correctly
    coordinator.process(signers[1].sign(...));
    coordinator.process(signers[2].sign(...));
    
    // This should panic because signer 0 is in public_nonces but not signature_shares
    // The bracket operator at line 1134 will panic when trying to access signature_shares[0]
}
```

**Notes:**
- The vulnerability is exploitable within the protocol's threat model (up to threshold-1 malicious signers)
- The fix should maintain the invariant that a signer is only removed from the wait list after their shares are successfully validated and stored
- The FROST coordinator provides a reference implementation of the correct ordering

### Citations

**File:** src/state_machine/coordinator/fire.rs (L45-45)
```rust
    signature_shares: BTreeMap<u32, Vec<SignatureShare>>,
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L965-965)
```rust
        self.signature_shares.clear();
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1076)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };

        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1131-1135)
```rust
            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/state_machine/coordinator/frost.rs (L652-656)
```rust
            self.signature_shares.insert(
                sig_share_response.signer_id,
                sig_share_response.signature_shares.clone(),
            );
            self.ids_to_await.remove(&sig_share_response.signer_id);
```
