# Audit Report

## Title
Coordinator Panic Due to Premature Wait List Removal in Signature Share Validation

## Summary
The `gather_sig_shares()` function in FireCoordinator removes signers from the wait list before validating their signature shares, creating a state inconsistency. A malicious signer can send an invalid `SignatureShareResponse` that causes validation failure after wait list removal, resulting in missing entries in `signature_shares`. When aggregation triggers, the code uses the bracket operator to access the missing shares, causing a panic and coordinator crash.

## Finding Description

The vulnerability exists in the signature share gathering logic where state mutations occur before validation completes. The function removes a signer from the wait list [1](#0-0)  before performing validation checks [2](#0-1) .

If any validation check fails (such as the key_ids mismatch check [3](#0-2) ), the function returns an error without inserting the signer's shares into `signature_shares` [4](#0-3) .

This creates a critical state inconsistency: the signer's ID remains in `public_nonces` (from the nonce generation phase) but is absent from `signature_shares`. The signer has also been removed from `sign_wait_signer_ids`, so they are no longer considered "waiting".

When all remaining signers respond and the wait list becomes empty [5](#0-4) , the aggregation logic triggers. The code iterates over all signers in `public_nonces` and uses the bracket operator to access their shares [6](#0-5) . Since Rust's `BTreeMap` bracket operator panics when a key is not present [7](#0-6) , this causes an unrecoverable coordinator crash.

**Attack Scenario:**
1. Malicious signer participates normally through DKG and nonce generation phases (their ID is in `public_nonces`)
2. Signer sends a `SignatureShareResponse` with `key_ids` that don't match their configured `key_ids`
3. Coordinator removes them from wait list (line 1044)
4. Validation fails at line 1075, function returns error
5. Signer's shares are never added to `signature_shares`
6. Other honest signers respond successfully
7. Wait list becomes empty, triggering aggregation
8. Aggregation code tries to access missing shares using bracket operator
9. Coordinator panics and crashes

**Comparison with FROST:**
The FROST coordinator implementation correctly prevents this vulnerability by removing from the wait list ONLY after successful validation and insertion [8](#0-7) .

**Why Existing Protections Fail:**
- The wait list check [9](#0-8)  prevents duplicate processing but not premature removal
- Error handling [10](#0-9)  catches the validation error but doesn't restore corrupted state
- Timeout mechanism [11](#0-10)  only marks signers still in the wait list as malicious
- Duplicate check [12](#0-11)  doesn't prevent the initial state corruption

## Impact Explanation

This vulnerability allows a malicious or faulty signer to crash the coordinator node, causing denial of service. The impact is classified as **Low severity** per the audit scope definition: "Any remotely-exploitable denial of service in a node."

**Concrete Harms:**
- Coordinator node crashes and requires manual restart
- Current signing round fails completely for all participants
- All participants must restart the signing protocol from the beginning
- In deployments with multiple coordinator instances, each can be crashed independently
- Repeated attacks can prevent signing operations from ever completing

**Affected Parties:**
- Coordinator node operators running FireCoordinator
- Users waiting for threshold signatures to complete
- Systems depending on WSTS for critical operations (e.g., Stacks blockchain transaction signing)

While this does not lead to invalid signatures, fund loss, or consensus failures, it represents a remotely-exploitable availability attack that can disrupt time-sensitive operations.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a registered signer with assigned `key_ids` in the coordinator's configuration
- Must successfully complete DKG phase
- Must successfully complete nonce generation phase for the target signing round
- Must be selected for the signing committee

**Attack Complexity:**
The attack is trivial to execute. The attacker simply:
1. Participates normally through DKG and nonce phases (standard protocol behavior)
2. Constructs a `SignatureShareResponse` with `key_ids` that don't match their configured `key_ids`
3. Sends the invalid response and waits for other signers to respond

**Economic Feasibility:**
Very feasible. No special computational resources, stake, or economic investment required beyond being a protocol participant. The attack can be repeated across multiple signing rounds.

**Detection:**
The validation error is logged when it occurs, but the panic happens later during aggregation, potentially making root cause analysis difficult without detailed trace logs.

**Estimated Probability:**
- High if an attacker is already a signer
- Medium-to-High in systems where signer registration is permissioned but signers may become compromised
- Within the protocol's threat model of up to threshold-1 malicious signers

## Recommendation

Move the wait list removal to occur AFTER all validation checks and successful insertion into `signature_shares`, following the pattern used in the FROST coordinator implementation.

**Recommended Fix:**
In `src/state_machine/coordinator/fire.rs`, move lines 1042-1044 to after line 1091 (after the successful insertion into `signature_shares`). The corrected sequence should be:

1. Check if signer is in wait list (lines 1015-1025) - keep as is
2. Perform all validation checks (lines 1027-1076) - keep as is
3. Check for duplicates (lines 1078-1086) - keep as is
4. Insert into `signature_shares` (lines 1088-1091) - keep as is
5. **THEN** remove from wait list (move lines 1042-1044 here)
6. Update received key_ids (lines 1093-1097) - keep as is

This ensures the wait list state is only modified after validation succeeds and shares are safely stored, maintaining consistency between `public_nonces` and `signature_shares`.

## Proof of Concept

```rust
#[test]
fn test_coordinator_panic_premature_waitlist_removal() {
    // This test demonstrates the panic by simulating:
    // 1. A signer that completed nonce phase (exists in public_nonces)
    // 2. That signer sends invalid SignatureShareResponse with mismatched key_ids
    // 3. Other signers respond successfully
    // 4. Aggregation triggers and panics when accessing missing signature_shares[signer_id]
    
    // Setup: Create coordinator with 3 signers, threshold 2
    // Step 1: Complete DKG phase for all signers
    // Step 2: Complete nonce generation for all signers (all in public_nonces)
    // Step 3: Malicious signer 0 sends SignatureShareResponse with wrong key_ids
    //         - This triggers removal from sign_wait_signer_ids at line 1044
    //         - Validation fails at line 1075, returns BadKeyIDsForSigner
    //         - Signer 0's shares are never inserted into signature_shares
    // Step 4: Honest signers 1 and 2 send valid SignatureShareResponses
    //         - sign_wait_signer_ids becomes empty
    //         - Aggregation triggers at line 1113
    // Step 5: Line 1134 iterates over public_nonces (includes signer 0)
    //         - Tries to access self.signature_shares[0] using bracket operator
    //         - PANIC: key 0 not found in BTreeMap
    
    // Expected: Coordinator panics with "key not found" when accessing signature_shares[0]
}
```

The proof of concept demonstrates that when a signer's ID exists in `public_nonces` but not in `signature_shares` due to premature wait list removal, the bracket operator at line 1134 will panic, crashing the coordinator.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L45-45)
```rust
    signature_shares: BTreeMap<u32, Vec<SignatureShare>>,
```

**File:** src/state_machine/coordinator/fire.rs (L178-186)
```rust
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L328-332)
```rust
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
```

**File:** src/state_machine/coordinator/fire.rs (L1015-1025)
```rust
        let waiting = response_info
            .sign_wait_signer_ids
            .contains(&sig_share_response.signer_id);

        if !waiting {
            warn!(
                "Sign round {} SignatureShareResponse for round {} from signer {} not in the wait list",
                self.current_sign_id, sig_share_response.sign_id, sig_share_response.signer_id,
            );
            return Ok(());
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1076)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };

        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1082-1085)
```rust
        if have_shares {
            info!(signer_id = %sig_share_response.signer_id, "received duplicate SignatureShareResponse");
            // XXX should this be an error?  We should have already removed signer from wait set
            return Ok(());
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1113-1113)
```rust
        if message_nonce.sign_wait_signer_ids.is_empty() {
```

**File:** src/state_machine/coordinator/fire.rs (L1131-1135)
```rust
            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/state_machine/coordinator/frost.rs (L652-656)
```rust
            self.signature_shares.insert(
                sig_share_response.signer_id,
                sig_share_response.signature_shares.clone(),
            );
            self.ids_to_await.remove(&sig_share_response.signer_id);
```
