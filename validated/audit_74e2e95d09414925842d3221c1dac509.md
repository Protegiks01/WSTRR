# Audit Report

## Title
Unvalidated DKG Failure Reports Enable DoS and False Accusations Against Honest Signers

## Summary
The FIRE and FROST coordinators fail to validate `MissingPublicShares` and `MissingPrivateShares` failure reports during DKG finalization. A malicious signer can exploit this by falsely claiming they did not receive shares from honest signers, causing DKG to fail indefinitely without marking anyone as malicious. This enables denial-of-service attacks and false accusations against honest participants.

## Finding Description

The `DkgFailure` enum defines six failure types that signers can report during DKG finalization, including `MissingPublicShares`, `BadPublicShares`, `MissingPrivateShares`, and `BadPrivateShares`. [1](#0-0) 

When signers send `DkgEnd` messages, the coordinator's `gather_dkg_end` function processes these failure reports. For `BadPublicShares` failures, the FIRE coordinator cryptographically validates the claims by checking polynomial commitments against the threshold requirement. [2](#0-1) 

Similarly, for `BadPrivateShares` failures, the coordinator performs cryptographic validation using Chaum-Pedersen tuple proofs and verifies shares against polynomial commitments. [3](#0-2) 

However, for `MissingPublicShares` and `MissingPrivateShares` failures, no validation occurs - the code contains only empty comments stating "this shouldn't happen, maybe mark signer malicious?" [4](#0-3) 

The FROST coordinator similarly lacks any validation logic for these failure types, simply collecting reported failures without verification. [5](#0-4) 

**Root Cause:**

The coordinator stores all received public and private shares locally in dedicated data structures. [6](#0-5) 

These shares are populated when the coordinator receives `DkgPublicShares` messages [7](#0-6)  and `DkgPrivateShares` messages. [8](#0-7) 

When a signer reports missing shares from another signer, the coordinator has sufficient information to validate the claim by checking whether it received shares from the accused signer. However, no such validation is implemented.

**Exploit Mechanism:**

Signers detect missing shares by iterating through expected signers and checking their local storage during `dkg_ended()`. If shares are not found in local maps, they report the signer IDs as missing. [9](#0-8) 

A malicious signer can exploit this by:
1. Receiving shares from honest signers (broadcast to all participants)
2. Intentionally not storing them in local maps (or deleting them)
3. Having `dkg_ended()` automatically report missing shares from honest signers
4. Causing DKG to fail with no consequences

When DKG fails due to these reports, the error is returned with an empty `malicious_signers` set, as this set is only populated when cryptographic validation identifies truly malicious behavior. [10](#0-9) 

The `malicious_dkg_signer_ids` field is only populated from the validated `malicious_signers` set. [11](#0-10) 

Furthermore, `malicious_dkg_signer_ids` is not used to exclude signers from future DKG rounds - when starting new DKG rounds, all signers from 0 to num_signers are included unconditionally. [12](#0-11) 

## Impact Explanation

This vulnerability enables a denial-of-service attack that prevents DKG completion indefinitely:

1. **DKG Cannot Complete**: Without successful DKG, no aggregate public key is generated, preventing all threshold signature operations. The protocol returns to Idle state only after successful DKG completion.

2. **False Accusations**: Honest signers are falsely blamed in the `reported_failures` map returned to the application via `DkgError::DkgEndFailure`. [13](#0-12) 

3. **No Attack Detection**: The `malicious_signers` set remains empty, providing no mechanism for the application to identify or exclude the malicious reporter versus the falsely accused honest signers.

4. **Repeatable Attack**: Since `malicious_dkg_signer_ids` is not populated and not used for exclusion when starting new DKG rounds, the attacker can repeat the attack indefinitely on every DKG retry.

**Severity Assessment**: This maps to **Low** severity per the defined scope: "Any remotely-exploitable denial of service in a node." The attack prevents DKG completion but does not compromise keys, enable fund theft, or cause chain splits.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a participating signer (within protocol threat model of up to threshold-1 malicious signers)
- No special cryptographic knowledge required
- No additional network access needed beyond normal protocol participation

**Attack Complexity:**
The attack is trivial to execute because the honest signer code automatically generates the false report when shares are not in local storage. A malicious signer simply needs to receive shares but not store them in their local `dkg_public_shares` or `dkg_private_shares` maps, or delete them before calling `dkg_ended()`.

**Detection Difficulty:**
The false reports are indistinguishable from legitimate network failure reports without the missing validation logic. Operators cannot identify the malicious actor because the coordinator has the information to validate but does not use it, leaving the `malicious_signers` set empty.

**Success Rate:**
100% - The lack of validation guarantees every false report will cause DKG failure without identifying the malicious reporter.

## Recommendation

Implement validation for `MissingPublicShares` and `MissingPrivateShares` similar to the existing validation for `BadPublicShares` and `BadPrivateShares`:

```rust
DkgFailure::MissingPublicShares(missing_signer_ids) => {
    for missing_signer_id in missing_signer_ids {
        // Check if coordinator received shares from the allegedly missing signer
        if self.dkg_public_shares.contains_key(missing_signer_id) {
            // Reporter is lying - coordinator has shares from this signer
            warn!("Signer {signer_id} reported MissingPublicShares from {missing_signer_id} but coordinator received shares, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        } else {
            // Legitimate report - coordinator also didn't receive shares
            warn!("Signer {missing_signer_id} failed to send public shares");
            malicious_signers.insert(*missing_signer_id);
        }
    }
}

DkgFailure::MissingPrivateShares(missing_signer_ids) => {
    for missing_signer_id in missing_signer_ids {
        // Check if coordinator received shares from the allegedly missing signer
        if self.dkg_private_shares.contains_key(missing_signer_id) {
            // Reporter is lying - coordinator has shares from this signer
            warn!("Signer {signer_id} reported MissingPrivateShares from {missing_signer_id} but coordinator received shares, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        } else {
            // Legitimate report - coordinator also didn't receive shares
            warn!("Signer {missing_signer_id} failed to send private shares");
            malicious_signers.insert(*missing_signer_id);
        }
    }
}
```

Additionally, use `malicious_dkg_signer_ids` to exclude malicious signers from future DKG rounds by filtering them when setting `dkg_wait_signer_ids`.

## Proof of Concept

The existing test suite demonstrates the vulnerability. The `empty_private_shares` test shows that when a signer sends empty shares, all other signers report `MissingPrivateShares` and DKG fails, but no signer is marked as malicious. [14](#0-13) 

This test can be modified to verify the fix by asserting that the malicious signer (who sent empty shares) is correctly identified in the `malicious_signers` set after implementing the validation logic above.

### Citations

**File:** src/net.rs (L59-72)
```rust
pub enum DkgFailure {
    /// DKG threshold not met
    Threshold,
    /// Signer was in the wrong internal state to complete DKG
    BadState,
    /// DKG public shares were missing from these signer_ids
    MissingPublicShares(HashSet<u32>),
    /// DKG public shares were bad from these signer_ids
    BadPublicShares(HashSet<u32>),
    /// DKG private shares were missing from these signer_ids
    MissingPrivateShares(HashSet<u32>),
    /// DKG private shares were bad from these signer_ids
    BadPrivateShares(HashMap<u32, BadPrivateShare>),
}
```

**File:** src/state_machine/coordinator/fire.rs (L40-41)
```rust
    dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L395-417)
```rust
    /// Ask signers to send DKG public shares
    pub fn start_public_shares(&mut self) -> Result<Packet, Error> {
        self.dkg_public_shares.clear();
        self.party_polynomials.clear();
        self.dkg_wait_signer_ids = (0..self.config.num_signers).collect();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting Public Share Distribution"
        );
        let dkg_begin = DkgBegin {
            dkg_id: self.current_dkg_id,
        };
        let dkg_begin_packet = Packet {
            sig: dkg_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgBegin"),
            msg: Message::DkgBegin(dkg_begin),
        };

        self.move_to(State::DkgPublicGather)?;
        self.dkg_public_start = Some(Instant::now());
        Ok(dkg_begin_packet)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L600-603)
```rust
        let mut reported_failures = HashMap::new();
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/frost.rs (L400-417)
```rust
        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
```

**File:** src/state_machine/signer/mod.rs (L551-608)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }

        if !missing_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPublicShares(missing_public_shares)),
            }));
        }

        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }

        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
```

**File:** src/state_machine/mod.rs (L50-55)
```rust
    DkgEndFailure {
        /// failures reported by signers during DkgEnd
        reported_failures: HashMap<u32, DkgFailure>,
        /// signers who were discovered to be malicious during this DKG round
        malicious_signers: HashSet<u32>,
    },
```

**File:** src/state_machine/coordinator/mod.rs (L1777-1879)
```rust
    pub fn empty_private_shares<Coordinator: CoordinatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
    ) {
        let (mut coordinators, mut signers) =
            setup::<Coordinator, SignerType>(num_signers, keys_per_signer);

        // We have started a dkg round
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_dkg_round(None)
            .unwrap();
        assert!(coordinators
            .first_mut()
            .unwrap()
            .get_aggregate_public_key()
            .is_none());
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::DkgPublicGather
        );

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        for coordinator in coordinators.iter() {
            assert_eq!(coordinator.get_state(), State::DkgPrivateGather);
        }

        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::DkgPrivateBegin(_)),
            "Expected DkgPrivateBegin message"
        );

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) = feedback_mutated_messages(
            &mut coordinators,
            &mut signers,
            &[outbound_messages[0].clone()],
            |signer, packets| {
                if signer.signer_id != 0 {
                    return packets.clone();
                }
                packets
                    .iter()
                    .map(|packet| {
                        let Message::DkgPrivateShares(shares) = &packet.msg else {
                            return packet.clone();
                        };
                        let private_shares = crate::net::DkgPrivateShares {
                            dkg_id: shares.dkg_id,
                            signer_id: shares.signer_id,
                            shares: vec![],
                        };
                        Packet {
                            msg: Message::DkgPrivateShares(private_shares),
                            sig: vec![],
                        }
                    })
                    .collect()
            },
        );
        assert_eq!(operation_results.len(), 0);
        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(&outbound_messages[0].msg, Message::DkgEndBegin(_)),
            "Expected DkgEndBegin message"
        );

        // Send the DkgEndBegin message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &outbound_messages);
        assert_eq!(outbound_messages.len(), 0);
        assert_eq!(operation_results.len(), 1);
        let OperationResult::DkgError(DkgError::DkgEndFailure {
            reported_failures, ..
        }) = &operation_results[0]
        else {
            panic!(
                "Expected OperationResult::DkgError(DkgError::DkgEndFailure) got {:?}",
                operation_results[0]
            );
        };
        assert_eq!(
            reported_failures.len(),
            num_signers as usize,
            "Expected {num_signers} DkgFailures got {}",
            reported_failures.len()
        );
        let expected_signer_ids = (0..1).collect::<HashSet<u32>>();
        for dkg_failure in reported_failures {
            let (_, DkgFailure::MissingPrivateShares(signer_ids)) = dkg_failure else {
                panic!("Expected DkgFailure::MissingPublicShares got {dkg_failure:?}");
            };
            assert_eq!(
                expected_signer_ids, *signer_ids,
                "Expected signer_ids {expected_signer_ids:?} got {signer_ids:?}"
            );
        }
    }
```
