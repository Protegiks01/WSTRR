# Audit Report

## Title
Missing DKG Round ID Validation in Signer DkgPrivateShares Processing Enables Denial of Service

## Summary
The signer's `dkg_private_shares` function lacks validation of the `dkg_id` field in incoming `DkgPrivateShares` messages, allowing attackers with network access to replay messages from previous DKG rounds. This creates a targeted denial-of-service attack vector that forces DKG failures through cryptographic validation mismatches.

## Finding Description

The signer state machine processes `DkgPrivateShares` messages without validating that the message's `dkg_id` matches the current round. [1](#0-0) 

This contrasts sharply with the coordinator's implementation, which explicitly validates the round ID before processing: [2](#0-1) 

The signer only checks for duplicate messages from the same `src_signer_id` within the current session: [3](#0-2) 

**Attack Execution Path:**

1. **Capture Phase**: Attacker passively captures valid, signed `DkgPrivateShares` messages from DKG Round N (dkg_id=N)

2. **Reset Phase**: New DKG Round N+1 begins. The `dkg_begin` function calls `reset()` which clears all DKG state and sets the new `dkg_id`: [4](#0-3) [5](#0-4) 

3. **Replay Attack**: Before legitimate Round N+1 messages arrive, attacker replays captured Round N messages. Messages pass signature verification since they are validly signed: [6](#0-5) 

4. **Acceptance**: Signer accepts and stores the replayed shares without checking `dkg_id`

5. **Duplicate Blocking**: When legitimate Round N+1 messages arrive, they are rejected as duplicates

6. **Validation Failure**: During `dkg_ended`, the signer validates old shares against new polynomial commitments. The Schnorr ID proofs in commitments are cryptographically bound to the specific `dkg_id` via the challenge hash: [7](#0-6) [8](#0-7) 

7. **DKG Failure**: Validation fails because Round N shares don't match Round N+1 commitments, triggering `BadPrivateShares` errors: [9](#0-8) 

**Root Cause**: Asymmetric validation logic—coordinators enforce round ID matching while signers do not, creating an exploitable inconsistency in the protocol's defense-in-depth strategy.

## Impact Explanation

This vulnerability enables **targeted denial-of-service attacks** against the DKG protocol with the following impacts:

- **DKG Round Failures**: Each successful replay forces a complete DKG round restart
- **Service Degradation**: Repeated attacks can sustain denial of service, delaying key generation indefinitely
- **Operational Impact**: In threshold signing systems (e.g., Stacks blockchain), delayed DKG prevents signature generation, blocking transaction processing
- **Misattribution**: Failures manifest as `BadPrivateShares` errors that may be incorrectly attributed to Byzantine signers rather than network attacks

**Severity Classification**: **Low** - This directly maps to the defined scope category "Any remotely-exploitable denial of service in a node." The vulnerability does NOT compromise cryptographic correctness—the Schnorr proof binding prevents incorrect key derivation, limiting impact to availability rather than integrity.

## Likelihood Explanation

**Attacker Requirements**:
- Network man-in-the-middle position or message injection capability on signer communication paths
- Passive capture of `DkgPrivateShares` messages from any previous DKG round  
- Ability to delay or intercept legitimate current-round messages (timing attack)

**Attack Complexity**: **Medium**
- Requires network-level access (realistic on RPC/P2P ports per threat model)
- No cryptographic breaks needed
- Attack window exists between `dkg_begin` reset and legitimate message arrival
- Repeatable across multiple rounds

**Detection**: Attacks manifest as `BadPrivateShares` validation failures, but may be misdiagnosed as malicious signer behavior rather than network-layer attacks.

**Probability**: **High** for attackers with network access; **Low** otherwise.

## Recommendation

Add explicit `dkg_id` validation in the signer's `dkg_private_shares` function, matching the coordinator's implementation:

```rust
pub fn dkg_private_shares<R: RngCore + CryptoRng>(
    &mut self,
    dkg_private_shares: &DkgPrivateShares,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Add this validation at the start
    if dkg_private_shares.dkg_id != self.dkg_id {
        warn!(
            received_dkg_id = %dkg_private_shares.dkg_id,
            current_dkg_id = %self.dkg_id,
            "DkgPrivateShares with mismatched dkg_id"
        );
        return Ok(vec![]);
    }
    
    // ... existing validation logic
}
```

This change:
- Provides defense-in-depth by preventing replay attacks at message acceptance
- Aligns signer and coordinator validation logic
- Fails fast before expensive decryption operations
- Improves diagnostics by rejecting wrong-round messages explicitly

## Proof of Concept

```rust
#[test]
fn test_dkg_id_replay_attack() {
    use crate::state_machine::signer::*;
    use rand_core::OsRng;
    
    let mut rng = OsRng;
    let private_key = Scalar::random(&mut rng);
    let public_keys = /* setup test public keys */;
    
    // Create signer for Round 1
    let mut signer = Signer::<v1::Signer>::new(
        1, 1, 2, 2, 0, vec![1], private_key, public_keys, &mut rng
    ).unwrap();
    
    // Simulate DKG Round 1 (dkg_id=100)
    let dkg_begin_r1 = DkgBegin { dkg_id: 100, /* ... */ };
    signer.dkg_begin(&dkg_begin_r1, &mut rng).unwrap();
    
    // Capture a valid DkgPrivateShares message from Round 1
    let old_message = DkgPrivateShares {
        dkg_id: 100,
        signer_id: 1,
        shares: vec![/* ... */],
    };
    signer.dkg_private_shares(&old_message, &mut rng).unwrap();
    assert_eq!(signer.dkg_private_shares.len(), 1);
    
    // Start DKG Round 2 (dkg_id=200) - this clears state
    let dkg_begin_r2 = DkgBegin { dkg_id: 200, /* ... */ };
    signer.dkg_begin(&dkg_begin_r2, &mut rng).unwrap();
    assert_eq!(signer.dkg_id, 200);
    assert_eq!(signer.dkg_private_shares.len(), 0); // State cleared
    
    // VULNERABILITY: Replay old message from Round 1
    // This should be rejected but is currently accepted
    signer.dkg_private_shares(&old_message, &mut rng).unwrap();
    
    // Attack succeeds: old message accepted despite wrong dkg_id
    assert_eq!(signer.dkg_private_shares.len(), 1);
    assert_eq!(signer.dkg_private_shares[&1].dkg_id, 100); // Wrong round!
    
    // When dkg_ended runs, validation will fail causing DoS
}
```

This test demonstrates that the signer accepts `DkgPrivateShares` messages with mismatched `dkg_id` values, enabling the replay attack.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-431)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
```

**File:** src/state_machine/signer/mod.rs (L463-469)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/signer/mod.rs (L557-557)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
```

**File:** src/state_machine/signer/mod.rs (L612-649)
```rust
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
```

**File:** src/state_machine/signer/mod.rs (L844-849)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
```

**File:** src/state_machine/signer/mod.rs (L1029-1110)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/fire.rs (L527-531)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
```

**File:** src/schnorr.rs (L48-58)
```rust
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
```
