# Audit Report

## Title
Duplicate key_ids in NonceResponse Bypass Validation and Corrupt Lagrange Interpolation

## Summary
The coordinator's validation of `key_ids` in `NonceResponse` messages converts the `Vec<u32>` to a `HashSet<u32>` before comparing with the configuration, which silently removes duplicates. However, the original Vec with duplicates is stored and propagated to all signers, where it corrupts Lagrange interpolation coefficient calculations. A single malicious signer can inject duplicate key_ids that pass validation but cause complete signing round failure for all participants.

## Finding Description

The vulnerability exists in the coordinator's validation logic for incoming `NonceResponse` messages. When a signer responds with nonces, the coordinator validates that the provided `key_ids` match the configured keys for that signer.

**Root Cause - Validation Bypass:**

The FROST coordinator performs validation by converting the received key_ids Vec to a HashSet and comparing it with the configured signer_key_ids: [1](#0-0) 

Similarly, the FIRE coordinator uses the same flawed approach: [2](#0-1) 

The HashSet conversion silently removes duplicates during the `collect()` operation. If a malicious signer sends `NonceResponse { key_ids: vec![1, 1, 2], ... }`, the validation creates `HashSet {1, 2}`, which matches the configured `{1, 2}`, so validation passes. However, the original Vec `[1, 1, 2]` with duplicates remains in the message structure.

**Storage and Propagation:**

The coordinator stores the original, unmodified NonceResponse: [3](#0-2) 

When constructing the SignatureShareRequest to send to all signers, the coordinator includes all stored NonceResponses: [4](#0-3) 

This propagates the corrupted key_ids to every participating signer.

**Duplicate Extraction by Signers:**

Each signer extracts the global key_ids list by concatenating all key_ids from all nonce responses using flat_map: [5](#0-4) 

The `flat_map` operation preserves duplicates. If any NonceResponse contains `[1, 1, 2]`, these duplicates appear in the global key_ids list passed to the signing function.

**Lagrange Coefficient Corruption:**

The lambda function computes Lagrange interpolation coefficients without validating for duplicates: [6](#0-5) 

When signers compute their signature shares, they call lambda with the corrupted global key_ids: [7](#0-6) 

The lambda function iterates over all j values in key_ids and multiplies `j/(j-i)` for each occurrence. If key_ids contains `[1, 1, 2, 3]` and we compute `lambda(3, [1, 1, 2, 3])`, the term `1/(1-3)` is multiplied **twice**, producing an incorrect coefficient. For example:
- Corrupted: `lambda(3, [1,1,2,3]) = (1/(1-3)) * (1/(1-3)) * (2/(2-3)) = 1/4 * (-1/2) = -1/8`
- Correct: `lambda(3, [1,2,3]) = (1/(1-3)) * (2/(2-3)) = (-1/2) * (-2) = 1`

This breaks the fundamental mathematical property of Lagrange interpolation required for threshold signature correctness.

**Impact on All Signers:**

All participating signers (both honest and malicious) compute their signature shares using the incorrect Lagrange coefficients. The aggregated signature will fail verification. The coordinator's `check_signature_shares` function may also fail to correctly identify the malicious party since it likely uses the same corrupted key_ids for verification, potentially misidentifying honest signers as malicious.

This vulnerability breaks WSTS's security guarantee that Byzantine behavior should be detected and isolated. According to the Security Model, the protocol should handle up to t-1 malicious parties and "identify and report malicious participants" through the failure detection mechanism. However, this validation flaw allows a single malicious signer to cause system-wide failure that affects all participants, not just their own contribution.

## Impact Explanation

**Severity: Medium** ("Any transient consensus failures")

A single malicious signer can prevent any signing round from completing successfully by including duplicate key_ids in their NonceResponse. This causes:

1. **Complete signing round failure**: All signers compute incorrect signature shares due to corrupted Lagrange coefficients, causing the aggregated signature to fail verification
2. **System-wide impact**: Affects all honest signers, not just the malicious party
3. **Difficult recovery**: The coordinator's logs only show "Nonce response key_ids didn't match config" without specifying the reason, making it difficult to identify which signer provided duplicates
4. **Transient consensus failure**: If WSTS is used for block signing or transaction confirmation in a blockchain system, preventing signature generation causes transient consensus failures until the malicious signer is identified and removed

The impact qualifies as Medium severity under the scope definition because it causes "transient consensus failures" - the system can recover by identifying and excluding the malicious signer, but requires intervention.

## Likelihood Explanation

**Likelihood: High**

The attack has near-certain success probability because:

1. **Low attacker requirements**: The attacker must only be a valid signer with legitimate credentials (within the threat model of up to t-1 malicious signers)
2. **Trivial attack complexity**: The attacker simply needs to craft a NonceResponse message with duplicate values in the key_ids Vec (e.g., `vec![1, 1, 2]` instead of `vec![1, 2]`) and sign it with their private key
3. **Deterministic success**: The validation logic will always fail to detect duplicates due to the HashSet conversion
4. **Minimal cost**: No computational resources required beyond normal message sending
5. **Low detection risk**: The coordinator cannot easily determine which signer provided duplicates without examining raw message contents, as the warning logs do not specify the validation failure reason

The validation flaw is fundamental to the current implementation and affects both FROST and FIRE coordinators.

## Recommendation

Add explicit duplicate detection to the key_ids validation logic before converting to HashSet:

```rust
// Check for duplicates in key_ids
let nonce_response_key_ids_set: HashSet<u32> = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect();

if nonce_response_key_ids_set.len() != nonce_response.key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id, 
        "Nonce response contains duplicate key_ids"
    );
    return Ok(());
}

if *signer_key_ids != nonce_response_key_ids_set {
    warn!(
        signer_id = %nonce_response.signer_id, 
        "Nonce response key_ids didn't match config"
    );
    return Ok(());
}
```

Apply the same fix to both coordinators:
- [1](#0-0) 
- [2](#0-1) 

Also apply similar validation to SignatureShareResponse handling:
- [8](#0-7) 
- [9](#0-8) 

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_bypass_validation() {
    use hashbrown::HashSet;
    
    // Malicious signer sends duplicate key_ids
    let malicious_key_ids = vec![1u32, 1u32, 2u32];
    
    // Coordinator's current validation logic
    let received_set: HashSet<u32> = malicious_key_ids.iter().cloned().collect();
    let configured_set: HashSet<u32> = vec![1u32, 2u32].into_iter().collect();
    
    // Validation PASSES despite duplicates
    assert_eq!(received_set, configured_set);
    
    // But the lambda function will use the corrupted Vec
    let lambda_result = compute_lambda_with_duplicates(3, &[1, 1, 2, 3]);
    let lambda_correct = compute_lambda_with_duplicates(3, &[1, 2, 3]);
    
    // Coefficients are incorrect
    assert_ne!(lambda_result, lambda_correct);
}

fn compute_lambda_with_duplicates(i: u32, key_ids: &[u32]) -> f64 {
    let mut lambda = 1.0;
    for j in key_ids {
        if i != *j {
            lambda *= (*j as f64) / ((*j as i32 - i as i32) as f64);
        }
    }
    lambda
}
```

This test demonstrates that:
1. The HashSet comparison passes even with duplicates in the Vec
2. The lambda function produces different (incorrect) results when duplicates are present in the key_ids list

### Citations

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L542-543)
```rust
            self.public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/frost.rs (L571-573)
```rust
        let nonce_responses = (0..self.config.num_signers)
            .map(|i| self.public_nonces[&i].clone())
            .collect::<Vec<NonceResponse>>();
```

**File:** src/state_machine/coordinator/frost.rs (L631-640)
```rust
            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1063-1077)
```rust
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }

```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```
