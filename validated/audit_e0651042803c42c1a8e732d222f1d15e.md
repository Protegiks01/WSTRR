# Audit Report

## Title
Missing DKG Round ID Validation in Signer DkgPrivateShares Processing Enables Denial of Service

## Summary
The signer's `dkg_private_shares` function lacks validation of the `dkg_id` field in incoming `DkgPrivateShares` messages, creating an asymmetry with coordinator implementations that explicitly validate round IDs. This enables network-level replay attacks that force DKG round failures through cryptographic validation mismatches, constituting a remotely-exploitable denial of service.

## Finding Description

**Asymmetric Validation Gap:**

The signer state machine processes `DkgPrivateShares` messages without validating that the message's `dkg_id` matches the current round. The `dkg_private_shares` function only checks for duplicate `signer_id` within the current session and validates party IDs, but never compares the incoming `dkg_id` against `self.dkg_id`. [1](#0-0) 

In stark contrast, both coordinator implementations (FIRE and FROST) explicitly validate the round ID before processing, returning `Error::BadDkgId` on mismatch: [2](#0-1) [3](#0-2) 

**Attack Execution Path:**

1. **Capture Phase**: Attacker passively captures legitimate `DkgPrivateShares` messages from DKG Round N. These messages are properly signed and contain `dkg_id=N` in their structure. [4](#0-3) 

2. **Reset Phase**: When DKG Round N+1 begins, the `dkg_begin` function calls `reset()` which clears all DKG state including `dkg_private_shares` and `kex_public_keys`, and sets the new `dkg_id`: [5](#0-4) [6](#0-5) 

3. **Public Share Exchange**: New `DkgPublicShares` for Round N+1 are exchanged, populating `kex_public_keys` with new ephemeral keys.

4. **Replay Attack**: Attacker replays captured Round N messages. The packet verification only validates the signature authenticity, not the round ID: [7](#0-6) [8](#0-7) 

5. **Acceptance Without Validation**: The replayed message passes all checks:
   - Signature verification passes (validly signed in Round N)
   - Signer ID exists in configuration
   - Duplicate check passes (storage was cleared by `reset()`)
   - **Critical gap**: No validation that `dkg_private_shares.dkg_id == self.dkg_id`

6. **Decryption Failure**: The signer attempts to decrypt the old shares using the new shared secret. Since the shared secret is computed using NEW keys (`self.kex_private_key` from Round N+1 and `kex_public_key` from NEW `DkgPublicShares`), but the shares were encrypted with OLD keys from Round N, decryption fails: [9](#0-8) 

7. **Legitimate Message Blocking**: When legitimate Round N+1 messages arrive, they are rejected as duplicates because `dkg_private_shares` already contains an entry for that `signer_id`.

8. **DKG Failure**: During `dkg_ended`, the invalid shares cause `BadPrivateShares` errors to be reported: [10](#0-9) 

The attack exploits round isolation failure—different DKG rounds should be cryptographically separated, but the lack of `dkg_id` validation allows cross-round message injection. While the Schnorr ID proofs in polynomial commitments are correctly bound to the `dkg_id` via the challenge hash (preventing incorrect key derivation), this doesn't prevent the DoS: [11](#0-10) [12](#0-11) 

## Impact Explanation

This vulnerability enables **targeted denial-of-service attacks** with the following impacts:

- **DKG Round Failures**: Each successful replay forces a complete DKG round restart, as the victim signer reports `BadPrivateShares` failures
- **Service Degradation**: Repeated attacks across multiple rounds can indefinitely delay key generation
- **Operational Impact**: In threshold signing systems (e.g., Stacks blockchain), DKG failures prevent signature generation, blocking transaction processing
- **Misattribution**: Honest signers are incorrectly accused of sending bad shares, when the root cause is a network-layer replay attack

**Severity: Low** - This directly maps to the scope definition: "Any remotely-exploitable denial of service in a node." The vulnerability does NOT compromise cryptographic correctness—the Schnorr proof binding and key exchange mismatch prevent incorrect key derivation, limiting the impact to availability rather than integrity.

## Likelihood Explanation

**Attacker Requirements**:
- Network position to capture and replay messages (man-in-the-middle or injection capability)
- Passive capture of `DkgPrivateShares` messages from any previous DKG round
- Timing: Replay must occur after new `DkgPublicShares` are exchanged but before legitimate `DkgPrivateShares` arrive

**Attack Complexity: Medium**
- Network-level access is realistic on RPC/P2P ports (within threat model)
- No cryptographic breaks required—exploits legitimate, validly-signed messages
- Attack window exists in every DKG round between public and private share phases
- Repeatable across multiple rounds for sustained DoS

**Detection Difficulty**: Attacks manifest as `BadPrivateShares` validation failures that may be incorrectly attributed to Byzantine signer behavior rather than network attacks, making detection and diagnosis challenging.

**Probability: High** for attackers with network access; **Low** otherwise.

## Recommendation

Add `dkg_id` validation to the signer's `dkg_private_shares` function to match coordinator implementations:

```rust
pub fn dkg_private_shares<R: RngCore + CryptoRng>(
    &mut self,
    dkg_private_shares: &DkgPrivateShares,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Add dkg_id validation
    if dkg_private_shares.dkg_id != self.dkg_id {
        warn!(
            "Received DkgPrivateShares with mismatched dkg_id: {} (expected {})",
            dkg_private_shares.dkg_id,
            self.dkg_id
        );
        return Ok(vec![]);
    }
    
    // ... rest of existing logic
}
```

This establishes symmetric validation across coordinators and signers, enforcing round isolation and preventing replay attacks.

## Proof of Concept

```rust
#[test]
fn test_dkg_private_shares_replay_attack() {
    use crate::state_machine::signer::Signer;
    use crate::net::{DkgPrivateShares, DkgBegin};
    use crate::util::create_rng;
    
    let mut rng = create_rng();
    let mut signer = /* initialize test signer */;
    
    // Round 1: Capture DkgPrivateShares
    let dkg_begin_round1 = DkgBegin { dkg_id: 1, /* ... */ };
    signer.dkg_begin(&dkg_begin_round1, &mut rng).unwrap();
    
    let old_shares = DkgPrivateShares {
        dkg_id: 1,  // Round 1
        signer_id: 0,
        shares: vec![/* ... */],
    };
    
    // Round 2: Reset to new round
    let dkg_begin_round2 = DkgBegin { dkg_id: 2, /* ... */ };
    signer.dkg_begin(&dkg_begin_round2, &mut rng).unwrap();
    
    // Attack: Replay old message with dkg_id=1 in round with dkg_id=2
    // Expected: Should reject due to dkg_id mismatch
    // Actual: Accepts message without validation
    let result = signer.dkg_private_shares(&old_shares, &mut rng);
    
    // Vulnerability: Old message is accepted despite dkg_id mismatch
    assert!(result.is_ok());
    assert!(signer.dkg_private_shares.contains_key(&0));
    
    // Legitimate round 2 message would now be rejected as duplicate
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L417-431)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
```

**File:** src/state_machine/signer/mod.rs (L463-479)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
            Message::DkgPrivateShares(dkg_private_shares) => {
                self.dkg_private_shares(dkg_private_shares, rng)
```

**File:** src/state_machine/signer/mod.rs (L611-660)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };
```

**File:** src/state_machine/signer/mod.rs (L849-850)
```rust
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;
```

**File:** src/state_machine/signer/mod.rs (L1029-1064)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1069-1095)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L527-532)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/state_machine/coordinator/frost.rs (L338-343)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-548)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
```

**File:** src/schnorr.rs (L48-59)
```rust
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```
