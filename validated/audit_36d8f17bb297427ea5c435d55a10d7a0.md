# Audit Report

## Title
Malicious Signers Not Marked When Providing Invalid Signature Shares

## Summary
The FIRE coordinator fails to mark signers as malicious when they provide cryptographically invalid signature shares. The aggregator correctly identifies bad parties via `BadPartySigs` error, but the coordinator never extracts this information to update `malicious_signer_ids`, allowing malicious signers to repeatedly participate in signing rounds and permanently prevent signature completion.

## Finding Description

The vulnerability exists in the signature share gathering and aggregation logic within the FIRE coordinator. The coordinator maintains two separate tracking mechanisms for signers:

1. `sign_wait_signer_ids` - tracks which signers we're waiting for responses from
2. `malicious_signer_ids` - tracks which signers should be excluded from future rounds

When a signature share response is received, the signer is immediately removed from `sign_wait_signer_ids` before any validation of the signature share content: [1](#0-0) 

Once all expected signers have responded, the coordinator attempts signature aggregation: [2](#0-1) 

The aggregator's `sign` methods correctly verify the aggregated signature. When verification fails, they call `check_signature_shares` to identify which parties provided invalid shares: [3](#0-2) 

The `check_signature_shares` function validates each signature share using the equation `z_i * G == (r_sign * Rs[i] + cx_sign * cx)` and collects failing party IDs: [4](#0-3) 

However, when this `BadPartySigs` error propagates back through the coordinator's `process_message` flow, it is simply wrapped and returned as an `OperationResult` without any code to extract the bad party IDs and update `malicious_signer_ids`: [5](#0-4) 

The timeout handler attempts to mark non-responsive signers as malicious, but it only marks signers still remaining in `sign_wait_signer_ids`: [6](#0-5) 

Since the malicious signer was already removed from `sign_wait_signer_ids` when they responded (even with invalid data), the timeout handler cannot catch them.

In subsequent signing rounds, the coordinator filters signers based only on `malicious_signer_ids`: [7](#0-6) 

Since `malicious_signer_ids` was never updated with the bad party IDs from the `BadPartySigs` error, the malicious signer can participate again, repeating the attack indefinitely.

## Impact Explanation

This vulnerability enables a persistent denial of service attack that can permanently prevent signature completion. A single malicious signer can block all signing operations by repeatedly providing invalid signature shares. Each invalid share causes the entire signing round to fail and restart, but since the malicious signer is never marked as such, they continue participating in every subsequent attempt.

In blockchain contexts using WSTS (such as Stacks), this directly prevents transaction confirmation and block production, as threshold signatures are required for these operations. The network cannot produce new blocks or confirm transactions as long as the malicious signer continues providing invalid shares.

This aligns with **HIGH** severity per the scope definition: "shut down the network or otherwise not confirm new valid transactions for multiple blocks." The attack can be sustained indefinitely with minimal effort from the attacker.

## Likelihood Explanation

The attack has **VERY HIGH** likelihood of success (>95%) due to minimal requirements:

**Required Capabilities:**
- Control of at least one signer in the signing committee
- Ability to execute normal signing protocol (generate valid nonces)
- Ability to craft invalid signature shares (trivial: modify `z_i` by adding any scalar value)

**Attack Complexity:** LOW
1. Participate normally in nonce exchange
2. Compute valid signature share `z_i`
3. Modify the share (e.g., `z_i = z_i + Scalar::from(1)`)
4. Submit the invalid share
5. Repeat in every signing iteration (never filtered out)

The existing test suite confirms that invalid signature shares are correctly detected and return `BadPartySigs` error, but no test verifies that this information is used to prevent future participation: [8](#0-7) 

**Detection Risk:** LOW - While `BadPartySigs` errors identify the malicious party, the coordinator doesn't act on this information. External monitoring would require manual implementation.

**Economic Feasibility:** No additional cost beyond normal signer participation, making it economically viable for adversaries seeking network disruption or transaction censorship.

## Recommendation

The coordinator should extract the bad party IDs from `BadPartySigs` errors and add them to `malicious_signer_ids`. Modify the error handling in `process_message`:

```rust
State::SigShareGather(signature_type) => {
    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
        // Extract bad party IDs from aggregator errors
        if let Error::Aggregator(AggregatorError::BadPartySigs(bad_parties)) = &e {
            for party_id in bad_parties {
                warn!("Marking party {} as malicious due to invalid signature share", party_id);
                self.malicious_signer_ids.insert(*party_id);
            }
            
            // Check if we still have enough non-malicious signers
            let num_malicious_keys = self.compute_num_key_ids(self.malicious_signer_ids.iter())?;
            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                return Ok((
                    None,
                    Some(OperationResult::SignError(SignError::InsufficientSigners(
                        self.malicious_signer_ids.iter().copied().collect()
                    ))),
                ));
            }
            
            // Restart signing round without malicious signers
            self.move_to(State::NonceRequest(signature_type))?;
            let packet = self.request_nonces(signature_type)?;
            return Ok((Some(packet), None));
        }
        
        return Ok((
            None,
            Some(OperationResult::SignError(SignError::Coordinator(e))),
        ));
    }
    // ... rest of logic
}
```

## Proof of Concept

```rust
#[test]
fn test_malicious_signer_marked_after_bad_signature_share() {
    // Setup: Run DKG with 3 signers, threshold 2
    let (mut coordinators, mut signers) = run_dkg::<FireCoordinator<v2::Aggregator>, v2::Signer>(3, 1);
    
    let msg = b"test message".to_vec();
    
    // First signing attempt with mutated signature share from signer 0
    let message = coordinators[0].start_signing_round(&msg, SignatureType::Frost, None).unwrap();
    let (outbound, _) = feedback_messages(&mut coordinators, &mut signers, &[message]);
    
    // Mutate signer 0's signature share
    let (_, results) = feedback_mutated_messages(&mut coordinators, &mut signers, &outbound, |s, p| {
        if s.signer_id == 0 {
            // Mutate signature share
            mutate_signature_shares(p)
        } else {
            p.clone()
        }
    });
    
    // Verify BadPartySigs error was returned
    assert!(matches!(
        results[0],
        OperationResult::SignError(SignError::Coordinator(
            Error::Aggregator(AggregatorError::BadPartySigs(_))
        ))
    ));
    
    // Second signing attempt - signer 0 should be excluded
    let message = coordinators[0].start_signing_round(&msg, SignatureType::Frost, None).unwrap();
    let (outbound, _) = feedback_messages(&mut coordinators, &mut signers, &[message]);
    
    // Verify signer 0 was filtered out (only 2 signers received nonce request)
    assert_eq!(count_nonce_responses(&outbound), 2);
    
    // Complete signing without signer 0 should succeed
    let (_, results) = feedback_messages(&mut coordinators, &mut signers, &outbound);
    assert!(matches!(results[0], OperationResult::Sign(_) | OperationResult::SignSchnorr(_)));
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L178-186)
```rust
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L328-333)
```rust
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1145-1169)
```rust
            self.aggregator.init(&self.party_polynomials)?;

            if let SignatureType::Taproot(merkle_root) = signature_type {
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    &shares,
                    &key_ids,
                    merkle_root,
                )?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else if let SignatureType::Schnorr = signature_type {
                let schnorr_proof =
                    self.aggregator
                        .sign_schnorr(&self.message, &nonces, &shares, &key_ids)?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else {
                let signature = self
                    .aggregator
                    .sign(&self.message, &nonces, &shares, &key_ids)?;
                debug!("Signature ({}, {})", signature.R, signature.z);
                self.signature = Some(signature);
            }
```

**File:** src/v2.rs (L406-413)
```rust
            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
```

**File:** src/v2.rs (L457-461)
```rust
        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```

**File:** src/state_machine/coordinator/mod.rs (L1338-1343)
```rust
        let OperationResult::SignError(SignError::Coordinator(Error::Aggregator(
            AggregatorError::BadPartySigs(parties),
        ))) = &operation_results[0]
        else {
            panic!("Expected OperationResult::SignError(SignError::Coordinator(Error::Aggregator(AggregatorError::BadPartySigs(parties))))");
        };
```
