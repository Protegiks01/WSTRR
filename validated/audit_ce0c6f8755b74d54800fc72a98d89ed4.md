# Audit Report

## Title
Coordinator State Corruption Leading to Denial of Service via Invalid Signature Share Handling

## Summary
The FIRE coordinator's `gather_sig_shares` method removes signers from the wait list before validating their signature shares, causing a panic during aggregation when validation fails. This creates a remotely-exploitable denial of service where any authorized malicious signer can crash the coordinator node.

## Finding Description

The vulnerability exists in the FIRE coordinator's signature share gathering logic due to incorrect operation ordering in the `gather_sig_shares` method.

**Complete Attack Flow:**

1. **Setup Phase**: A malicious signer participates normally in DKG and sends a valid `NonceResponse`. The coordinator stores their nonce and adds them to the wait list: [1](#0-0) [2](#0-1) 

2. **Attack Phase**: When the coordinator requests signature shares, the malicious signer responds with a `SignatureShareResponse` containing intentionally invalid data (e.g., mismatched `key_ids`). The `gather_sig_shares` method processes this response with the following critical flaw in operation ordering:

   - First validates that the signer is in the wait list and checks `dkg_id`/`sign_id`: [3](#0-2) 

   - **Critical Bug**: Removes the signer from `sign_wait_signer_ids` BEFORE completing all validations: [4](#0-3) 

   - Performs additional validation checks AFTER removal that can fail: [5](#0-4) 

   - Only inserts shares into `signature_shares` if ALL validations pass: [6](#0-5) 

3. **Error Handling**: When validation fails (e.g., `BadKeyIDsForSigner`), the error is caught in the main processing loop and returned as a `SignError`, but the corrupted state persists: [7](#0-6) 

4. **Panic Trigger**: When all signers have been processed (`sign_wait_signer_ids` is empty), aggregation is triggered: [8](#0-7) 

5. **Crash**: The aggregation code collects shares by iterating over `public_nonces` and indexing into `signature_shares` using Rust's BTreeMap indexing operator `[]`: [9](#0-8) 

   When the code attempts `self.signature_shares[i]` for a signer ID that sent nonces but whose shares failed validation, Rust's BTreeMap indexing operator panics because the key doesn't exist.

**Root Cause**: The wait list modification violates atomicity. The signer is marked as "processed" (removed from wait list) before the operation completes successfully (shares inserted into `signature_shares`). This creates an inconsistent state where `public_nonces` contains a signer ID that doesn't exist in `signature_shares`.

The `signature_shares` field is defined as a `BTreeMap<u32, Vec<SignatureShare>>`: [10](#0-9) 

## Impact Explanation

This vulnerability enables a **Low severity** remotely-exploitable denial of service per the audit scope definition: "Any remotely-exploitable denial of service in a node."

**Specific harm:**
- The coordinator process panics and terminates immediately
- All honest signers' computational work (nonce generation, share computation) is wasted
- The entire signing round must be restarted from scratch
- Repeated attacks can prevent signature generation indefinitely
- If this affects critical operations (e.g., Stacks block signing), it could escalate to network-level DoS

**Who is affected:** Any deployment using the FIRE coordinator for WSTS threshold signatures, including Stacks 2.1+ signer nodes.

While this doesn't directly cause fund loss or chain splits, the ability to prevent signature generation could have cascading effects in production systems that rely on these signatures for consensus or block production.

## Likelihood Explanation

**Likelihood: High**

**Required attacker capabilities:**
- Must be a valid signer with a registered `signer_id` in the coordinator's configuration (within threat model)
- Must have successfully participated in DKG (to send nonces)
- No cryptographic breaks required

**Attack complexity:** Low
1. Participate normally in DKG and receive signing requests
2. Send valid `NonceResponse` when requested
3. When `SignatureShareRequest` arrives, send `SignatureShareResponse` with intentionally invalid `key_ids` (e.g., use wrong key IDs, empty set, or IDs not in configuration)

**Economic feasibility:** Free to execute once positioned as an authorized signer

**Detection:** The coordinator crash is immediately visible, but identifying the specific malicious signer may be difficult if multiple signers are participating, as the panic occurs during aggregation after all responses are collected.

The attack is trivial for any authorized signer to execute and requires no special resources or cryptographic capabilities beyond the normal protocol participation.

## Recommendation

Fix the atomicity violation by deferring the wait list removal until after all validations pass. Move the `sign_wait_signer_ids.remove()` call to just before the `signature_shares.insert()` operation:

```rust
// Perform all validations first
if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
    warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
    return Err(Error::MissingPublicKeyForSigner(sig_share_response.signer_id));
};

// ... other validations ...

if *signer_key_ids != sig_share_response_key_ids {
    warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
    return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
}

// Only after ALL validations pass, remove from wait list and insert shares
response_info.sign_wait_signer_ids.remove(&sig_share_response.signer_id);

self.signature_shares.insert(
    sig_share_response.signer_id,
    sig_share_response.signature_shares.clone(),
);
```

This ensures the operation is atomic: either all validations pass and both state updates occur, or validation fails and no state is modified.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "no entry found for key")]
fn test_signature_share_validation_panic() {
    use crate::state_machine::coordinator::fire::Coordinator as FireCoordinator;
    use crate::v2::Aggregator;
    
    let mut coordinator = FireCoordinator::<Aggregator>::new(/* ... */);
    
    // 1. Setup: Send valid NonceResponse to add signer to public_nonces and wait list
    let nonce_response = NonceResponse { /* valid data */ };
    coordinator.gather_nonces(&nonce_packet, SignatureType::Frost).unwrap();
    
    // 2. Attack: Send SignatureShareResponse with mismatched key_ids
    let bad_sig_share = SignatureShareResponse {
        signer_id: 0,
        key_ids: vec![999], // Invalid key_id not in config
        /* ... */
    };
    
    // This will remove signer from wait list but fail validation
    let _ = coordinator.gather_sig_shares(&bad_packet, SignatureType::Frost);
    
    // 3. Trigger: Send valid response from another signer to empty the wait list
    coordinator.gather_sig_shares(&valid_packet, SignatureType::Frost).unwrap();
    
    // 4. Panic occurs during aggregation when indexing signature_shares
    // with a signer_id that's in public_nonces but not in signature_shares
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L45-45)
```rust
    signature_shares: BTreeMap<u32, Vec<SignatureShare>>,
```

**File:** src/state_machine/coordinator/fire.rs (L327-333)
```rust
                State::SigShareGather(signature_type) => {
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L940-942)
```rust
            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1015-1038)
```rust
        let waiting = response_info
            .sign_wait_signer_ids
            .contains(&sig_share_response.signer_id);

        if !waiting {
            warn!(
                "Sign round {} SignatureShareResponse for round {} from signer {} not in the wait list",
                self.current_sign_id, sig_share_response.sign_id, sig_share_response.signer_id,
            );
            return Ok(());
        }

        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1076)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };

        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1113-1114)
```rust
        if message_nonce.sign_wait_signer_ids.is_empty() {
            // Calculate the aggregate signature
```

**File:** src/state_machine/coordinator/fire.rs (L1131-1135)
```rust
            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```
