# Audit Report

## Title
Non-Participating Signers Can Abort DKG Through Invalid Private Shares

## Summary
The `dkg_ended()` function in the signer state machine fails the entire DKG round if `invalid_private_shares` contains any entries, without filtering by the final participating set defined in `DkgEndBegin.signer_ids`. This allows a malicious signer to cause DKG denial-of-service by sending corrupted private shares while avoiding inclusion in the coordinator's final participant list.

## Finding Description

The vulnerability exists in the signer's `dkg_ended()` function where the decision to compute secrets checks if `invalid_private_shares` is completely empty, without filtering by the final participating signer set: [1](#0-0) 

This check evaluates the entire `invalid_private_shares` map across ALL signers who sent private shares, not just those in the coordinator-defined participating set received in `DkgEndBegin.signer_ids`.

**Attack Flow:**

1. **Signer exclusion from participating set**: When a malicious signer doesn't send `DkgPublicShares`, the FIRE coordinator's `start_private_shares()` only includes signers who successfully provided public shares in `DkgPrivateBegin.signer_ids`: [2](#0-1) 

2. **Unrestricted private share acceptance**: The signer's `dkg_private_shares()` handler accepts and processes private shares from ANY configured signer, with no validation against the expected participating set from `DkgPrivateBegin.signer_ids`: [3](#0-2) 

3. **Invalid share tracking**: When decryption fails due to corrupted data from the malicious signer, the sender is added to `invalid_private_shares`: [4](#0-3) 

4. **Final participant set determination**: The coordinator's `start_dkg_end()` sends `DkgEndBegin` with `signer_ids` derived from `dkg_private_shares.keys()`, which excludes the malicious signer if their message didn't reach the coordinator: [5](#0-4) 

5. **Inconsistent validation**: In `dkg_ended()`, the validation loops correctly check only signers in the coordinator-provided `signer_ids_set`: [6](#0-5) [7](#0-6) 

These validations pass for all honest participating signers. However, the check at line 611 uses the unfiltered `invalid_private_shares` map, causing failure even when invalid shares originate from non-participating signers: [8](#0-7) 

6. **Coordinator misidentification**: When honest signers report BadPrivateShares from non-participating signers, the coordinator incorrectly marks the honest reporters as malicious: [9](#0-8) 

This breaks the security guarantee that DKG should complete successfully when sufficient honest signers (meeting the threshold) have valid shares.

## Impact Explanation

**Severity: Low** - Maps to "Any remotely-exploitable denial of service in a node" from the severity criteria.

**Concrete Impact:**
- DKG cannot complete, preventing establishment of threshold signing keys
- All honest signers report `DkgStatus::Failure`, causing the coordinator to abort: [10](#0-9) 

- Honest signers are incorrectly marked as malicious by the coordinator
- The system cannot proceed to the signing phase without valid threshold keys
- Affects all DKG participants in the round

**Scenario**: With 10 signers (threshold=7, dkg_threshold=7):
1. Attacker controls Signer A
2. Signer A doesn't send `DkgPublicShares` (excluded from participating set)
3. Signer A sends corrupted `DkgPrivateShares` to other signers via P2P
4. All 9 honest signers add Signer A to `invalid_private_shares`
5. Coordinator sends `DkgEndBegin` with only the 9 honest signers
6. Despite having 9 valid participating signers (exceeding threshold of 7), all report failure
7. DKG aborts with `Error::DkgFailure`, must be restarted

The severity is limited to Low because:
- No cryptographic security compromise occurs
- No funds are at risk
- System can recover by retrying DKG with updated signer configuration
- Attack is eventually detectable

## Likelihood Explanation

**Likelihood: High**

**Attacker Capabilities Required:**
- Control of a single configured signer (within threshold-1, part of normal threat model)
- Ability to send network messages during DKG private share phase
- No cryptographic capabilities or key compromise needed

**Attack Complexity: Low**
- Send corrupted `DkgPrivateShares` with malformed ciphertext (random bytes)
- Optionally avoid sending `DkgPublicShares` to ensure exclusion from participating set
- No deep protocol understanding required beyond message timing

**Economic Feasibility:**
- Minimal cost: only network bandwidth for malformed messages
- No computational resources beyond normal signer operation
- Attack repeatable at negligible cost

**Success Probability:**
- 100% success rate if attacker controls any configured signer
- Honest signers cannot distinguish between participating vs non-participating signers when receiving private shares
- No existing mitigation prevents the attack

## Recommendation

Filter `invalid_private_shares` to only include signers in the final participating set before checking if it's empty:

```rust
let dkg_end = if self.invalid_private_shares
    .keys()
    .all(|id| !signer_ids_set.contains(id)) {
    // All invalid shares are from non-participating signers, safe to proceed
    match self.signer.compute_secrets(
        &self.decrypted_shares,
        &self.commitments,
        &self.dkg_id.to_be_bytes(),
    ) {
        // ... rest of the logic
    }
} else {
    // Invalid shares from participating signers - must fail
    DkgEnd {
        dkg_id: self.dkg_id,
        signer_id: self.signer_id,
        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
            self.invalid_private_shares
                .iter()
                .filter(|(id, _)| signer_ids_set.contains(id))
                .map(|(id, share)| (*id, share.clone()))
                .collect(),
        )),
    }
};
```

Additionally, add validation in `dkg_private_shares()` to reject shares from signers not in `DkgPrivateBegin.signer_ids`:

```rust
// After line 1041, add:
if let Some(ref dkg_private_begin) = self.dkg_private_begin_msg {
    if !dkg_private_begin.signer_ids.contains(&src_signer_id) {
        warn!(%src_signer_id, "Signer not in participating set");
        return Ok(vec![]);
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_non_participating_signer_dkg_abort() {
    use rand_core::OsRng;
    let mut rng = OsRng;
    
    // Setup: 3 signers, threshold=2, signer_id=0 is honest
    let private_key = Scalar::random(&mut rng);
    let mut public_keys = PublicKeys::default();
    
    // Configure 3 signers (ids: 0, 1, 2)
    for id in 0..3 {
        let pk = ecdsa::PublicKey::new(&Scalar::random(&mut rng)).unwrap();
        public_keys.signers.insert(id, pk);
        public_keys.key_ids.insert(id, pk);
        let mut key_ids = HashSet::new();
        key_ids.insert(id);
        public_keys.signer_key_ids.insert(id, key_ids);
    }
    
    let mut signer = Signer::<v2::Signer>::new(
        2, 2, 3, 3, 0, vec![0], private_key, public_keys, &mut rng
    ).unwrap();
    signer.verify_packet_sigs = false;
    
    // Start DKG
    let dkg_begin = Message::DkgBegin(DkgBegin { dkg_id: 1 });
    signer.process(&Packet { msg: dkg_begin, sig: vec![] }, &mut rng).unwrap();
    
    // Honest signer 0 and 1 send public shares, malicious signer 2 does NOT
    // Simulate receiving DkgPrivateBegin with only signers 0,1
    let dkg_private_begin = Message::DkgPrivateBegin(DkgPrivateBegin {
        dkg_id: 1,
        signer_ids: vec![0, 1], // Signer 2 excluded
        key_ids: vec![],
    });
    signer.process(&Packet { msg: dkg_private_begin, sig: vec![] }, &mut rng).unwrap();
    
    // Malicious signer 2 sends corrupted private shares
    let corrupted_shares = DkgPrivateShares {
        dkg_id: 1,
        signer_id: 2, // Non-participating signer
        shares: vec![(2, hashbrown::HashMap::from([(0, vec![0xFF; 48])]))],
    };
    
    // This adds signer 2 to invalid_private_shares due to decryption failure
    signer.dkg_private_shares(&corrupted_shares, &mut rng).unwrap();
    assert!(!signer.invalid_private_shares.is_empty());
    
    // Simulate DkgEndBegin with only participating signers 0,1
    let dkg_end_begin = Message::DkgEndBegin(DkgEndBegin {
        dkg_id: 1,
        signer_ids: vec![0, 1], // Signer 2 still excluded
        key_ids: vec![],
    });
    signer.process(&Packet { msg: dkg_end_begin, sig: vec![] }, &mut rng).unwrap();
    
    // Call dkg_ended() - should succeed but FAILS due to bug
    let result = signer.dkg_ended(&mut rng).unwrap();
    
    if let Message::DkgEnd(end) = result {
        // BUG: This fails even though signer 2 is not in participating set
        assert!(matches!(end.status, DkgStatus::Failure(DkgFailure::BadPrivateShares(_))));
        // Expected: DkgStatus::Success since only signers 0,1 are participating
    }
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L529-534)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L551-583)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L611-611)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
```

**File:** src/state_machine/signer/mod.rs (L652-659)
```rust
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
```

**File:** src/state_machine/signer/mod.rs (L1037-1041)
```rust
        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };
```

**File:** src/state_machine/signer/mod.rs (L1089-1095)
```rust
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L432-436)
```rust
        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L670-676)
```rust
                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```
