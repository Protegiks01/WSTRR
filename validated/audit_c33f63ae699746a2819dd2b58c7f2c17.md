# Audit Report

## Title
Memory Exhaustion DoS via Unbounded DkgPrivateShares Encrypted Share Size

## Summary
The `DkgPrivateShares` message structure accepts encrypted shares as arbitrary-sized `Vec<u8>` values without size validation. A malicious signer within the protocol threat model can send gigabyte-sized payloads, causing memory exhaustion on all recipients (coordinator and signers), preventing DKG completion and violating the liveness guarantee.

## Finding Description

The vulnerability exists in the `DkgPrivateShares` struct definition where encrypted shares are stored in an unbounded `Vec<u8>`: [1](#0-0) 

Legitimate encrypted shares should contain a 32-byte scalar encrypted with AES-GCM. The encryption adds a 12-byte nonce: [2](#0-1) 

And a 16-byte authentication tag (implicit in AES-GCM), yielding an expected size of approximately 60 bytes total. However, the protocol has **no validation** enforcing this size constraint.

When a `DkgPrivateShares` message is received, the following sequence occurs:

1. **Serde deserializes** the message, allocating memory for arbitrary-sized `Vec<u8>` values without any size checks.

2. **Signature verification passes** if the attacker is a legitimate signer (within the protocol threat model of up to threshold-1 malicious signers): [3](#0-2) 

3. **The entire message is cloned and stored** in memory before any content validation occurs:

**Coordinator (FROST) storage** with no size checks: [4](#0-3) 

**Coordinator (FIRE) storage** with no size checks: [5](#0-4) 

**Signer storage** with no size checks: [6](#0-5) 

4. **Only after storage** is decryption attempted, at which point memory is already exhausted: [7](#0-6) 

**Security Guarantee Broken:** The protocol's liveness guarantee assumes DKG can complete when participants are honest up to threshold-1. A single malicious signer (within the threat model) can prevent DKG completion by exhausting memory on all recipients, violating this guarantee.

**Attack Propagation:**
1. Malicious signer crafts `DkgPrivateShares` with gigabyte-sized `Vec<u8>` in the shares field
2. Signs the message with their legitimate private key
3. Sends to coordinator and all other signers
4. All recipients deserialize (allocating gigabytes), verify signature (passes), clone and store (doubling memory usage)
5. All recipients crash with OOM before meaningful validation occurs

## Impact Explanation

This vulnerability maps to **Medium severity** under the scope definition of "Any transient consensus failures."

**Concrete Impact:**
- **DKG cannot complete:** The group signing key cannot be established
- **No threshold signatures:** Without a group key, no signatures can be generated
- **Service disruption:** All participants crash and must restart
- **Transient but operational:** The failure is recoverable by excluding the malicious signer, but causes significant operational disruption

**Quantified Harm:**
- A single malicious message with 1GB encrypted shares crashes all N recipients
- Memory usage: Deserialization allocates the full vector, then `.clone()` doubles it during storage
- Affects: All signers participating in DKG + the coordinator
- In blockchain integration contexts, this prevents transaction signing and confirmation during the attack and recovery period

The severity is **Medium** rather than **Low** because it prevents consensus operations (DKG completion) rather than merely affecting a single node, and impacts the core protocol functionality.

## Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a legitimate signer with valid signing key (within protocol threat model), OR
- Must have compromised a legitimate signer's private key
- Must have network access to protocol participants

**Attack Complexity:** Low
1. Craft `DkgPrivateShares` with oversized `Vec<u8>` values (trivial serialization)
2. Sign with valid signer's private key (standard protocol operation)
3. Send to recipients (normal message flow)
4. Memory exhaustion is automatic upon receipt

**Economic Feasibility:** High
- No computational cost beyond message construction
- Single message affects all N participants
- Network bandwidth is the only constraint

**Detection:** High (easily attributable)
- Attack is immediately attributable to the specific `signer_id` in the message
- OOM crash logs clearly indicate the cause
- Malicious signer can be identified and excluded from future rounds

**Estimated Probability:** Moderate
- Requires insider threat or compromised key (not external attacker)
- But insider threats are realistic in multi-party distributed systems
- No technical barriers once attacker position is achieved

## Recommendation

Add size validation for encrypted shares before deserialization or storage. The expected size for an encrypted 32-byte scalar with AES-GCM is approximately 60 bytes (32-byte plaintext + 12-byte nonce + 16-byte auth tag).

**Recommended fix:**

1. Define a maximum encrypted share size constant (e.g., 128 bytes to allow overhead):
```rust
const MAX_ENCRYPTED_SHARE_SIZE: usize = 128;
```

2. Add validation in the message handlers before cloning:
```rust
// In gather_private_shares (both coordinators)
for (_, shares_map) in &dkg_private_shares.shares {
    for (_, encrypted_share) in shares_map {
        if encrypted_share.len() > MAX_ENCRYPTED_SHARE_SIZE {
            warn!("Oversized encrypted share from signer {}", dkg_private_shares.signer_id);
            return Ok(());
        }
    }
}
```

3. Similarly in signer's `dkg_private_shares` function before line 1064.

Alternatively, implement a custom deserializer that enforces size limits during deserialization to prevent memory allocation for oversized payloads.

## Proof of Concept

```rust
#[test]
fn test_oversized_dkg_private_shares() {
    // This test demonstrates that oversized encrypted shares
    // are accepted and stored without validation
    
    let mut coordinator = setup_frost_coordinator();
    let malicious_signer_id = 1;
    
    // Create oversized encrypted share (e.g., 1MB instead of ~60 bytes)
    let oversized_share = vec![0u8; 1_000_000];
    
    let mut shares = Vec::new();
    let mut share_map = HashMap::new();
    share_map.insert(1u32, oversized_share);
    shares.push((1u32, share_map));
    
    let dkg_private_shares = DkgPrivateShares {
        dkg_id: coordinator.current_dkg_id,
        signer_id: malicious_signer_id,
        shares,
    };
    
    // Sign with legitimate key
    let private_key = get_signer_private_key(malicious_signer_id);
    let sig = dkg_private_shares.sign(&private_key).unwrap();
    
    let packet = Packet {
        msg: Message::DkgPrivateShares(dkg_private_shares),
        sig,
    };
    
    // This should trigger memory allocation for the oversized share
    // and clone it during storage (doubling memory usage)
    let result = coordinator.gather_private_shares(&packet);
    
    // The message is accepted and stored despite being oversized
    assert!(result.is_ok());
    assert!(coordinator.dkg_private_shares.contains_key(&malicious_signer_id));
    
    // Memory exhaustion would occur with sufficiently large payloads
}
```

**Notes:**
- The vulnerability is confirmed through code inspection showing unbounded `Vec<u8>` in the shares field with no size validation before allocation or cloning
- All three message handlers (both coordinators and signer) clone the entire message before any content validation
- The attack is within the protocol threat model (malicious signer up to threshold-1)
- The fix requires adding size validation at the message handling layer before memory-intensive operations

### Citations

**File:** src/net.rs (L192-199)
```rust
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/util.rs (L14-15)
```rust
/// Size of the AES-GCM nonce
pub const AES_GCM_NONCE_SIZE: usize = 12;
```

**File:** src/state_machine/coordinator/frost.rs (L362-363)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1063-1064)
```rust
        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1072-1097)
```rust
        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
```
