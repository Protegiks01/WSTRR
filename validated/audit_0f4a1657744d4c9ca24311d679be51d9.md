# Audit Report

## Title
Nonce Mismatch Vulnerability via Duplicate NonceRequest Processing

## Summary
The signer's `nonce_request()` handler processes duplicate `NonceRequest` messages without deduplication, causing `Party::gen_nonce()` to overwrite previously generated nonces. Since the coordinator rejects duplicate `NonceResponse` messages, this creates a mismatch between the signer's stored nonce and the public nonce the coordinator uses for signature aggregation, causing signature verification to fail and resulting in a denial of service.

## Finding Description

The vulnerability exists in the signing protocol's nonce generation and coordination flow. When a signer receives a `NonceRequest`, it unconditionally generates a new nonce without checking if it has already responded to the same signing round.

**Root Cause:**

The `Party::gen_nonce()` function unconditionally overwrites the internal `self.nonce` field each time it is called: [1](#0-0) 

The signer's `nonce_request()` handler processes incoming `NonceRequest` messages without any deduplication logic based on `dkg_id`, `sign_id`, or `sign_iter_id`: [2](#0-1) 

This handler calls `self.signer.gen_nonces()` unconditionally at line 731, which results in generating a new nonce and overwriting the previously stored value.

**Attack Scenario:**

1. Coordinator sends a legitimate `NonceRequest` to the signer
2. Signer generates nonce N1, stores it in `self.nonce`, and sends `NonceResponse` with public nonce P1
3. Coordinator receives P1 and stores it
4. **Attack**: A duplicate `NonceRequest` arrives at the signer (either replayed by a network attacker if authentication is disabled, or sent by a malicious/buggy coordinator)
5. Signer processes the duplicate without checking for duplicates, generates NEW nonce N2, and overwrites `self.nonce`
6. Signer sends `NonceResponse` with public nonce P2
7. Coordinator receives the duplicate `NonceResponse` but rejects it, keeping the original P1: [3](#0-2) 

8. Coordinator sends `SignatureShareRequest` using public nonce P1
9. Signer computes its signature share using the stored nonce N2 (which was overwritten): [4](#0-3) 

10. The signature share calculation uses `self.nonce.d` and `self.nonce.e` (now containing N2 values) but the coordinator's binding computation and aggregation use P1
11. Signature verification fails due to the nonce mismatch

**Why Existing Mitigations Fail:**

The coordinator has duplicate detection for `NonceResponse` messages, but this protection works against the attacker's goal. The coordinator correctly rejects duplicate responses and keeps the first nonce, but the signer has already overwritten its internal state. 

The signer's `sign_share_request()` handler validates nonce validity but does NOT verify that its own stored nonce matches the public nonce the coordinator included for this signer: [5](#0-4) 

The handler extracts and validates the nonces from the request (lines 781-795) but never checks if the signer's own nonce in the request matches `PublicNonce::from(&self.signer.nonce)`.

## Impact Explanation

**Severity: Medium**

This vulnerability causes the signing round to fail completely. When the aggregated signature is verified, it will fail because the signer computed its signature share using a different nonce than the coordinator used in aggregation. This results in:

1. **Immediate Impact**: Complete failure of the signing round
2. **Operational Impact**: Signers must retry the entire signing process with fresh nonces
3. **Blockchain Context**: In a blockchain using WSTS for threshold signatures, this delays transaction signing and could prevent timely block production or transaction confirmations

**Scope Alignment**: This constitutes a "transient consensus failure" as defined in the Medium severity category. The signing round fails but can be retried. It does not cause:
- Permanent loss of funds
- Chain splits  
- Acceptance of invalid signatures
- Persistent network shutdown

All participants in the signing round are affected since the entire signing operation fails, not just the attacked signer's contribution.

## Likelihood Explanation

**Likelihood: High (no authentication) to Low (properly configured)**

**Attack Requirements:**

1. **With `verify_packet_sigs=false` (message authentication disabled)**: 
   - Any network-level attacker who can observe and replay `NonceRequest` packets
   - **Likelihood**: HIGH - Simple packet replay attack

2. **With `verify_packet_sigs=true` (message authentication enabled)**:
   - Requires either:
     - (a) Compromise of the coordinator's signing key, OR
     - (b) A malicious or buggy coordinator that legitimately sends duplicate `NonceRequest` messages
   - **Likelihood**: MEDIUM (compromised coordinator) to LOW (well-configured deployments)

**Attack Complexity**: Low. The attacker simply needs to:
1. Capture a `NonceRequest` packet
2. Replay it to the target signer after the signer has sent its first `NonceResponse` but before it receives the `SignatureShareRequest`
3. Network delays provide a natural window of opportunity (typically several round-trip times)

**Economic Feasibility**: Minimal cost - requires only packet capture and replay capabilities on the network path between coordinator and signers.

**Detection Risk**: Low. The attack appears as legitimate protocol messages. The only observable effect is signature verification failures, which could be misattributed to network issues or software bugs rather than an active attack.

## Recommendation

Implement duplicate request detection in the signer's `nonce_request()` handler. The signer should track which signing rounds it has already responded to and reject duplicate requests.

**Solution 1: Track processed signing rounds**

Add state tracking to the `Signer` struct to record processed `(dkg_id, sign_id, sign_iter_id)` tuples and check against this before generating new nonces:

```rust
fn nonce_request<R: RngCore + CryptoRng>(
    &mut self,
    nonce_request: &NonceRequest,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Check if we've already processed this signing round
    if self.dkg_id == nonce_request.dkg_id 
        && self.sign_id == nonce_request.sign_id 
        && self.sign_iter_id == nonce_request.sign_iter_id 
        && !self.public_nonces.is_empty() 
    {
        info!(
            %self.signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "Ignoring duplicate NonceRequest"
        );
        return Ok(vec![]);
    }
    
    // Update tracking state
    self.sign_id = nonce_request.sign_id;
    self.sign_iter_id = nonce_request.sign_iter_id;
    
    let mut msgs = vec![];
    let signer_id = self.signer_id;
    let key_ids = self.signer.get_key_ids();
    let nonces = self.signer.gen_nonces(&self.network_private_key, rng);
    
    // Store generated nonces for validation
    self.public_nonces = nonces.clone();
    
    // ... rest of function
}
```

**Solution 2: Validate nonce match in signature share computation**

Add validation in `sign_share_request()` to ensure the nonce in the coordinator's request matches the signer's stored nonce:

```rust
fn sign_share_request<R: RngCore + CryptoRng>(
    &mut self,
    sign_request: &SignatureShareRequest,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // ... existing validation ...
    
    if signer_id_set.contains(&self.signer_id) {
        // Find our nonce response in the request
        let my_nonce_response = sign_request.nonce_responses
            .iter()
            .find(|nr| nr.signer_id == self.signer_id)
            .ok_or(Error::InvalidNonceResponse)?;
        
        // Validate our stored nonce matches the coordinator's expectation
        let expected_nonce = PublicNonce::from(&self.signer.nonce);
        if my_nonce_response.nonces.len() != 1 
            || my_nonce_response.nonces[0] != expected_nonce 
        {
            warn!(
                signer_id = %self.signer_id,
                "Nonce mismatch: stored nonce doesn't match coordinator's request"
            );
            return Err(Error::InvalidNonceResponse);
        }
        
        // ... rest of function
    }
}
```

Implementing both solutions provides defense in depth.

## Proof of Concept

```rust
#[test]
fn test_duplicate_nonce_request_overwrites_nonce() {
    use crate::state_machine::signer::Signer;
    use crate::net::{NonceRequest, SignatureType};
    use crate::v2::Party as V2Party;
    use crate::traits::Signer as SignerTrait;
    use crate::util::create_rng;
    
    let mut rng = create_rng();
    let signer_id = 0;
    let key_ids = vec![1, 2];
    let num_signers = 3;
    let num_keys = 10;
    let threshold = 7;
    
    // Create signer
    let mut signer = Signer::<V2Party>::new(
        signer_id,
        &key_ids,
        num_signers,
        num_keys,
        threshold,
        &[],
        &mut rng,
    );
    
    // First NonceRequest
    let nonce_request1 = NonceRequest {
        dkg_id: 1,
        sign_id: 1,
        sign_iter_id: 1,
        message: vec![1, 2, 3],
        signature_type: SignatureType::Frost,
    };
    
    let packet1 = Packet::new(Message::NonceRequest(nonce_request1.clone()));
    let response1 = signer.process(&packet1, &mut rng).unwrap();
    
    // Extract first nonce from response
    let first_nonce = if let Message::NonceResponse(ref nr) = response1[0] {
        nr.nonces[0].clone()
    } else {
        panic!("Expected NonceResponse");
    };
    
    // Duplicate NonceRequest with same IDs
    let packet2 = Packet::new(Message::NonceRequest(nonce_request1.clone()));
    let response2 = signer.process(&packet2, &mut rng).unwrap();
    
    // Extract second nonce from response
    let second_nonce = if let Message::NonceResponse(ref nr) = response2[0] {
        nr.nonces[0].clone()
    } else {
        panic!("Expected NonceResponse");
    };
    
    // Verify nonces are different (vulnerability confirmed)
    assert_ne!(first_nonce, second_nonce, 
        "Duplicate NonceRequest generated different nonce, overwriting the first");
    
    // The signer's stored nonce is now second_nonce, but coordinator uses first_nonce
    // This will cause signature verification to fail
}
```

This test demonstrates that processing duplicate `NonceRequest` messages generates different nonces, confirming the vulnerability exists in the current codebase.

### Citations

**File:** src/v2.rs (L76-84)
```rust
    /// Generate and store a private nonce for a signing round
    pub fn gen_nonce<RNG: RngCore + CryptoRng>(
        &mut self,
        secret_key: &Scalar,
        rng: &mut RNG,
    ) -> PublicNonce {
        self.nonce = Nonce::random(secret_key, rng);
        PublicNonce::from(&self.nonce)
    }
```

**File:** src/v2.rs (L255-257)
```rust
        let (_, R) = compute::intermediate(msg, party_ids, nonces);
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
```

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L781-818)
```rust
        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/state_machine/coordinator/fire.rs (L922-929)
```rust
            let have_nonces = nonce_info
                .public_nonces
                .contains_key(&nonce_response.signer_id);

            if have_nonces {
                info!(signer_id = %nonce_response.signer_id, "Received duplicate NonceResponse");
                return Ok(());
            }
```
