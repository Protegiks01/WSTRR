Audit Report

## Title
Memory Exhaustion via Unbounded Polynomial Degree in DKG Public Shares

## Summary
A malicious authenticated signer can craft DKG public shares containing polynomial commitments with arbitrarily large vectors of elliptic curve points, causing memory exhaustion and denial of service on all receiving nodes. The vulnerability exists because serde deserializes the entire `Vec<Point>` before any size validation occurs, allowing an attacker to force allocation of gigabytes of memory per message.

## Finding Description

The `PolyCommitment` structure contains a `poly` field of type `Vec<Point>` that represents the public polynomial commitment during distributed key generation. This structure uses automatic serde serialization/deserialization with no bounds checking: [1](#0-0) 

When a `DkgPublicShares` message is received, it contains a vector of these commitments: [2](#0-1) 

The attack exploits the deserialization-before-validation pattern. When the state machine's `process()` method receives a packet, the entire message has already been deserialized by serde: [3](#0-2) 

Even when packet signature verification is enabled, it occurs after full deserialization has completed and memory has been allocated: [4](#0-3) 

The `dkg_public_share()` handler performs basic validation but does not check the polynomial size: [5](#0-4) 

Size validation only occurs much later in the `dkg_ended()` method when `check_public_shares()` is called: [6](#0-5) 

The `check_public_shares()` function validates that the polynomial length equals the threshold, but this validation happens after the memory has already been allocated during deserialization: [7](#0-6) 

**Attack Vector:**
1. Malicious signer constructs a `PolyCommitment` with a `poly` vector containing millions of curve points
2. Wraps it in a `DkgPublicShares` message and signs it with their legitimate credentials
3. Broadcasts the message to other participants
4. Serde deserializes the entire vector, allocating excessive memory on each receiving node
5. Nodes crash from memory exhaustion before validation logic can reject the oversized polynomial

The legitimate polynomial size should equal the threshold (typically 2-13 based on test configurations). An attacker can send polynomials with 100 million or more points, causing multi-gigabyte allocations per message.

## Impact Explanation

**Severity: LOW** per the defined scope: "Any remotely-exploitable denial of service in a node."

The attack causes immediate denial of service against all nodes participating in the DKG round:
- Each compressed elliptic curve point is 33 bytes
- An attacker sending 100 million points forces ~3.3 GB memory allocation per node
- Memory exhaustion triggers OOM killer or node crash
- DKG round fails, preventing threshold signature setup
- A single malicious message affects multiple victims simultaneously

The attack is remotely exploitable over the network protocol without requiring local access. While it requires the attacker to be an authenticated signer (insider threat), this is within the protocol's threat model of supporting up to threshold-1 malicious signers. The DoS impact prevents protocol availability and operation.

## Likelihood Explanation

**Likelihood: High** if a malicious authenticated signer exists in the system.

**Required Attacker Capabilities:**
- Must be a legitimate signer with valid credentials (private key)
- Must have network connectivity to participate in DKG
- Within protocol threat model (up to threshold-1 malicious signers)

**Attack Complexity: Low**
- Create `PolyCommitment` with oversized `Vec<Point>` 
- Wrap in `DkgPublicShares` message
- Sign with legitimate credentials
- Broadcast during DKG round
- No special timing or race conditions required

**Detection:**
The attacker's `signer_id` is included in the message, making attribution trivial. However, damage (node crashes) occurs before honest participants can report the failure. Post-mortem analysis would immediately identify the malicious signer.

**Economic Feasibility:**
Near-zero cost to attacker. Creating the oversized serialized message requires minimal computation, while victims must allocate substantial memory resources.

## Recommendation

Implement size validation before deserialization by adding a custom `Deserialize` implementation for `PolyCommitment` that enforces maximum polynomial degree bounds. Alternatively, add a deserialize wrapper that validates sizes before constructing the full structure.

**Option 1: Custom Deserialize with bounds checking**
```rust
// Add to src/common.rs
const MAX_POLY_DEGREE: usize = 1000; // Conservative upper bound

impl<'de> Deserialize<'de> for PolyCommitment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct PolyCommitmentHelper {
            id: ID,
            poly: Vec<Point>,
        }
        
        let helper = PolyCommitmentHelper::deserialize(deserializer)?;
        
        if helper.poly.len() > MAX_POLY_DEGREE {
            return Err(serde::de::Error::custom(
                format!("Polynomial degree {} exceeds maximum {}", helper.poly.len(), MAX_POLY_DEGREE)
            ));
        }
        
        Ok(PolyCommitment {
            id: helper.id,
            poly: helper.poly,
        })
    }
}
```

**Option 2: Early validation in message handler**
Check the polynomial size immediately in `dkg_public_share()` before storing the message, though this still allows memory allocation during deserialization.

**Recommended: Implement Option 1** to prevent memory allocation entirely for oversized messages, combined with clear error logging to identify malicious signers.

## Proof of Concept

```rust
#[cfg(test)]
mod memory_exhaustion_poc {
    use super::*;
    use wsts::common::PolyCommitment;
    use wsts::curve::point::Point;
    use wsts::curve::scalar::Scalar;
    use wsts::schnorr::ID;
    use wsts::net::DkgPublicShares;
    use wsts::util::create_rng;
    
    #[test]
    #[ignore] // Ignore by default as it allocates large memory
    fn test_oversized_polynomial_deserialization() {
        // This PoC demonstrates that deserializing an oversized polynomial
        // will allocate excessive memory before any validation occurs
        
        let mut rng = create_rng();
        let ctx = 0u64.to_be_bytes();
        
        // Create a malicious PolyCommitment with excessive points
        // Using 10 million points instead of 100 million to keep test tractable
        let oversized_poly_size = 10_000_000;
        let mut oversized_poly = Vec::with_capacity(oversized_poly_size);
        
        for _ in 0..oversized_poly_size {
            oversized_poly.push(Point::from(Scalar::random(&mut rng)));
        }
        
        let malicious_commitment = PolyCommitment {
            id: ID::new(&Scalar::random(&mut rng), &Scalar::random(&mut rng), &ctx, &mut rng),
            poly: oversized_poly,
        };
        
        // Wrap in DkgPublicShares message
        let malicious_msg = DkgPublicShares {
            dkg_id: 0,
            signer_id: 0,
            comms: vec![(1, malicious_commitment)],
            kex_public_key: Point::from(Scalar::random(&mut rng)),
        };
        
        // Serialize the malicious message
        let serialized = bincode::serialize(&malicious_msg).expect("Serialization should succeed");
        
        println!("Serialized message size: {} bytes", serialized.len());
        println!("This demonstrates that a malicious signer can create oversized messages");
        
        // Deserialization will allocate all the memory for the Vec<Point>
        // before any validation occurs
        let _deserialized: DkgPublicShares = bincode::deserialize(&serialized)
            .expect("Deserialization succeeds and allocates excessive memory");
        
        // Memory has now been allocated - validation would happen later in the protocol
        // In a real attack with 100M points, this would cause OOM before reaching here
    }
}
```

**Note:** This PoC requires adding `bincode` as a dev-dependency for testing serialization, though the actual protocol may use a different serialization format. The vulnerability exists regardless of serialization format as long as serde deserializes the full Vec before validation.

### Citations

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/net.rs (L139-149)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
```

**File:** src/state_machine/signer/mod.rs (L458-477)
```rust
    pub fn process<R: RngCore + CryptoRng>(
        &mut self,
        packet: &Packet,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
```

**File:** src/state_machine/signer/mod.rs (L551-563)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L975-1026)
```rust
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```
