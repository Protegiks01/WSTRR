Audit Report

## Title
Unbounded DKG Encrypted Share Size Enables Memory and CPU Exhaustion DoS

## Summary
The `encrypt()` and `decrypt()` functions accept arbitrarily large inputs without size validation. A malicious signer can exploit this during DKG by sending oversized encrypted shares in `DkgPrivateShares` messages, causing honest nodes to exhaust memory and CPU resources, effectively denying service to the DKG protocol.

## Finding Description

The vulnerability exists in the encryption/decryption flow used for DKG private share distribution.

The `encrypt()` function accepts an unbounded `data: &[u8]` parameter with no size validation whatsoever. [1](#0-0) 

Similarly, the `decrypt()` function accepts unbounded input, performing only minimal validation (checking for nonce presence and non-empty data). [2](#0-1) 

During DKG, the `DkgPrivateShares` message structure stores encrypted shares as unbounded `Vec<u8>` values in a nested HashMap structure. [3](#0-2) 

In legitimate usage, signers encrypt 32-byte Scalars (via `private_share.to_bytes()`), which with AES-GCM overhead (12-byte nonce + 16-byte auth tag) results in ~60-byte ciphertexts. [4](#0-3) 

However, when honest signers receive `DkgPrivateShares` messages, they immediately clone and store the entire message in memory without any size validation. [5](#0-4) 

The handler then attempts to decrypt each encrypted share, passing the unbounded bytes directly to the `decrypt()` function. [6](#0-5) 

The FireCoordinator similarly stores the entire message without size checks. [7](#0-6) 

The FrostCoordinator exhibits the same vulnerability. [8](#0-7) 

**Root Cause**: The codebase assumes encrypted shares will be ~60 bytes but enforces no validation. There are no size checks at any layer - not in the encryption functions, not in the message structure, not in serde deserialization, and not in the state machine handlers.

**Attack Propagation**: A malicious signer constructs a `DkgPrivateShares` message with oversized `Vec<u8>` values (e.g., 10 MB per share), signs it with their valid private key, and broadcasts it. The signature verification passes because the malicious signer uses their registered valid key. [9](#0-8)  All recipients deserialize, store via `.clone()`, and attempt to decrypt the oversized blobs, exhausting memory and CPU resources.

The duplicate detection only prevents the same signer from sending multiple messages, but does not prevent: (a) multiple malicious signers each sending one oversized message, or (b) oversized messages in different DKG rounds. [10](#0-9) 

## Impact Explanation

**Specific Harm**: A malicious signer can send `DkgPrivateShares` messages containing arbitrarily large encrypted blobs, causing:

1. **Memory Exhaustion**: With typical DKG parameters (10 keys, 4 parties), a single malicious message could contain 40 oversized shares. At 10 MB per share, that's 400 MB per message. The `.clone()` operation creates full copies in memory, and with threshold-1 malicious signers allowed by the threat model, multiple attackers can each send 400 MB messages.

2. **CPU Exhaustion**: AES-GCM decryption is O(n) in ciphertext size. Attempting to decrypt 10 MB blobs instead of 60 bytes causes significant CPU delays. Processing 40 such blobs per message effectively stalls the DKG process.

3. **Network Bandwidth Saturation**: Transmitting hundreds of MB per DKG message saturates network bandwidth, preventing legitimate protocol messages from being transmitted.

**Who is Affected**: All honest signers and the coordinator receiving the malicious messages. In a network with resource-constrained nodes, this impacts the majority of participants.

**Severity Justification**: This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." A malicious signer can remotely crash or severely degrade honest nodes during DKG, preventing the system from generating valid signing keys and disrupting the entire threshold signature protocol.

## Likelihood Explanation

**Required Attacker Capabilities**: 
- Position as a registered signer with valid message signing keys
- Ability to send messages during DKG private share distribution phase  
- No cryptographic breaks required

**Attack Complexity**: Low. The attacker simply:
1. Constructs a `DkgPrivateShares` message with oversized `Vec<u8>` values (standard Rust Vec operations)
2. Signs it with their valid private key (standard signing operation)
3. Broadcasts to honest signers and coordinator (normal protocol flow)

**Economic Feasibility**: Minimal cost. Creating large byte arrays and signing messages requires negligible resources compared to victim impact. The attack causes 400 MB+ memory consumption and substantial CPU time per victim, while costing the attacker virtually nothing.

**Detection Risk**: Medium. Oversized messages are detectable if monitored at the network layer, but the protocol currently has no such monitoring, and by the time the message is processed, the damage (memory allocation and CPU consumption) has already occurred.

**Estimated Probability**: High. Any malicious signer can execute this attack during any DKG round. The only prerequisite is being registered as a signer, which is assumed possible within the protocol threat model (up to threshold-1 malicious signers).

## Recommendation

Implement strict size validation at multiple layers:

1. **Add maximum encrypted share size constant**:
```rust
// In src/util.rs
const MAX_ENCRYPTED_SHARE_SIZE: usize = 128; // 32 bytes Scalar + AES-GCM overhead + safety margin
```

2. **Validate in decrypt() function**:
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    if data.len() > MAX_ENCRYPTED_SHARE_SIZE {
        return Err(EncryptionError::OversizedCiphertext);
    }
    // ... existing code
}
```

3. **Validate before processing DkgPrivateShares**:
```rust
// In src/state_machine/signer/mod.rs, at start of dkg_private_shares()
for (_, shares_map) in &dkg_private_shares.shares {
    for (_, encrypted_share) in shares_map {
        if encrypted_share.len() > MAX_ENCRYPTED_SHARE_SIZE {
            warn!("Received oversized encrypted share from signer {}", src_signer_id);
            return Ok(vec![]);
        }
    }
}
```

4. **Add similar validation in coordinator handlers** to prevent storing oversized messages.

This defense-in-depth approach ensures that oversized encrypted shares are rejected before consuming excessive memory or CPU resources.

## Proof of Concept

```rust
#[cfg(test)]
mod dos_test {
    use super::*;
    use crate::net::DkgPrivateShares;
    use crate::util::{decrypt, create_rng};
    use hashbrown::HashMap;
    
    #[test]
    fn test_oversized_encrypted_share_dos() {
        // Demonstrate that oversized encrypted shares consume excessive memory and CPU
        
        // Create a malicious DkgPrivateShares message with 10 MB encrypted share
        // instead of the expected ~60 bytes
        let oversized_encrypted_share = vec![0u8; 10_000_000]; // 10 MB
        
        let mut shares_map = HashMap::new();
        shares_map.insert(0u32, oversized_encrypted_share.clone());
        
        let malicious_msg = DkgPrivateShares {
            dkg_id: 0,
            signer_id: 0,
            shares: vec![(0, shares_map)],
        };
        
        // This clone operation (as done in line 1064 of signer/mod.rs) 
        // allocates 10 MB in memory
        let cloned_msg = malicious_msg.clone();
        assert_eq!(cloned_msg.shares[0].1[&0].len(), 10_000_000);
        
        // Attempting to decrypt this oversized blob (as done in line 1076)
        // consumes significant CPU time proportional to the size
        let shared_secret = [0u8; 32];
        let decrypt_result = decrypt(&shared_secret, &cloned_msg.shares[0].1[&0]);
        
        // The decrypt will fail, but has already consumed CPU resources
        assert!(decrypt_result.is_err());
        
        // With 40 such shares (typical DKG: 10 keys Ã— 4 parties),
        // total memory = 400 MB and substantial CPU time consumed
    }
}
```

### Citations

**File:** src/util.rs (L80-99)
```rust
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
}
```

**File:** src/util.rs (L102-116)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L934-945)
```rust
            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
```

**File:** src/state_machine/signer/mod.rs (L1058-1061)
```rust
        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }
```

**File:** src/state_machine/signer/mod.rs (L1063-1064)
```rust
        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1074-1097)
```rust
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/frost.rs (L362-363)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```
