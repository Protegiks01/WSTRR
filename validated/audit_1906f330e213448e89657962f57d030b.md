Audit Report

## Title
Permanent Malicious Signer Marking Enables Threshold Reduction via Network DoS

## Summary
The FIRE coordinator permanently marks signers as malicious based solely on network timeouts during signature share gathering, with no recovery mechanism. An attacker can exploit this by repeatedly causing network disruptions to incrementally reduce the available signer set below threshold, permanently disabling the threshold signature system without any cryptographic capability.

## Finding Description

The vulnerability exists in the FIRE coordinator's timeout handling mechanism. When a timeout occurs during the `SigShareGather` state, all signers who have not yet responded are permanently marked as malicious, regardless of the actual cause of the timeout. [1](#0-0) 

The malicious signer tracking has three critical flaws:

1. **Network-based marking without cryptographic evidence**: Signers are marked malicious due to timeout (a network issue), not due to any cryptographic proof of malicious behavior such as invalid signature shares, bad proofs, or incorrect nonces.

2. **Permanent marking with no recovery mechanism**: Once a signer is marked malicious, they remain in the `malicious_signer_ids` HashSet indefinitely. The coordinator's `reset()` function, which clears most internal state, explicitly does NOT clear this set: [2](#0-1) 

3. **Permanent exclusion from future signing rounds**: Once marked malicious, signers' nonces are rejected in all subsequent signing attempts: [3](#0-2) 

4. **Persistence across restarts**: The malicious signer tracking is preserved in saved state, making the marking survive coordinator restarts: [4](#0-3) [5](#0-4) 

The threshold check only detects when insufficient signers remain—it does not prevent the problem or provide recovery: [6](#0-5) 

**Attack Scenario:**

An attacker with network positioning capability can execute the following attack:

1. **Round 1**: Allow threshold number of signers to respond, but cause network disruption for remaining signers during `sign_timeout` window → those signers marked malicious → system retries with reduced signer set

2. **Round 2**: Previously marked signers' nonces are now rejected. Attacker repeats network disruption on different subset of signers → more signers marked malicious

3. **Result**: After sufficient iterations, the remaining non-malicious signers control fewer keys than the threshold, making the system permanently unable to generate signatures

The security invariant violated is: **Signers should only be marked malicious based on cryptographic evidence of misbehavior, not network conditions**. The protocol conflates network unavailability with malicious behavior, creating a permanent availability attack vector.

## Impact Explanation

**Severity: Critical**

This vulnerability enables permanent denial of service of the threshold signature system, mapping directly to the critical impact scope: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

**Quantified Impact:**

Consider a deployment with:
- 10 signers, each controlling 1 key
- Threshold = 7 keys
- Attacker can selectively cause network timeouts

**Attack execution:**
- Round 1: Attacker causes timeout for 3 signers → marked malicious (7 keys remain, threshold met, system retries)
- Round 2: Previous 3 signers' nonces rejected, attacker causes timeout for 3 more signers → marked malicious (4 keys remain < 7 threshold)
- **Result**: System permanently unable to generate signatures

**Consequences for blockchain consensus:**

If WSTS is used for blockchain consensus signatures (as in Stacks), inability to generate threshold signatures means:
- No new blocks can be signed and confirmed
- Network halts indefinitely
- No automatic recovery mechanism
- Manual intervention required to recreate coordinator and rerun DKG

The vulnerability affects all users of the FIRE coordinator in production deployments.

## Likelihood Explanation

**Likelihood: Medium to High**

**Required Attacker Capabilities:**
- Network positioning to cause packet loss or delays between coordinator and specific signers (e.g., ISP-level routing, DDoS capability, or position on network path)
- Timing to trigger disruption during the signature share gathering window (configured by `sign_timeout`)
- No cryptographic secrets or signing keys required
- No need to compromise coordinator or signer nodes

**Attack Complexity: Medium**

The FIRE coordinator uses a star topology where the coordinator communicates directly with each signer. This architecture makes selective network disruption feasible. The attacker must:

1. Monitor or predict when `SignatureShareRequest` messages are sent
2. Cause network disruption for duration of `sign_timeout` (typically seconds to minutes)
3. Selectively target signers (allow some responses initially to maintain threshold)
4. Repeat across 2-3 signing rounds depending on threshold parameters

**Economic Feasibility: High**

Network DoS attacks are significantly cheaper than cryptographic attacks. The attack is cumulative—each successful network disruption permanently eliminates signers from the available pool. For cloud-deployed coordinators, common DDoS techniques suffice.

**Detection Risk: Low**

The attack appears as legitimate network failures in coordinator logs. No invalid cryptographic messages are sent, making it difficult to distinguish malicious DoS from genuine network issues without external network monitoring infrastructure.

## Recommendation

Implement the following mitigations:

1. **Separate network failures from malicious behavior**: Do not mark signers as malicious based on timeouts alone. Only mark signers as malicious when they provide cryptographically invalid responses (bad signature shares, invalid proofs, etc.).

2. **Add recovery mechanism**: Implement a mechanism to clear or reset malicious signer markings after a cooldown period or through explicit operator action.

3. **Modify reset() function**: Include clearing of `malicious_signer_ids` in the `reset()` function:

```rust
fn reset(&mut self) {
    self.state = State::Idle;
    self.dkg_public_shares.clear();
    self.dkg_private_shares.clear();
    self.dkg_end_messages.clear();
    self.party_polynomials.clear();
    self.message_nonces.clear();
    self.signature_shares.clear();
    self.dkg_wait_signer_ids.clear();
    self.malicious_signer_ids.clear(); // ADD THIS LINE
    self.nonce_start = None;
    self.sign_start = None;
}
```

4. **Track timeout-based vs. cryptographic-based malicious behavior separately**: Maintain two separate sets: `timeout_signer_ids` (temporary, cleared between sign rounds) and `cryptographically_malicious_signer_ids` (permanent, only set when cryptographic validation fails).

5. **Implement exponential backoff for timeouts**: Instead of permanent marking, use temporary exclusion with exponential backoff that allows signers to rejoin after demonstrating availability.

## Proof of Concept

The existing test case demonstrates this behavior: [7](#0-6) 

This test shows:
1. First timeout during signature share gathering → coordinator retries (lines 3112-3125)
2. Second timeout with same scenario → InsufficientSigners error returned (lines 3162-3183)

The test confirms that malicious markings accumulate across retry iterations, eventually causing permanent system failure when the threshold cannot be met.

To reproduce:
1. Set up FIRE coordinator with timeout enabled
2. Start signing round with sufficient signers
3. Prevent subset of signers from responding during `sign_timeout`
4. Observe those signers marked malicious and system retry
5. Repeat with different signers until insufficient non-malicious signers remain
6. System permanently unable to generate signatures

### Citations

**File:** src/state_machine/coordinator/fire.rs (L173-186)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L191-199)
```rust
                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
```

**File:** src/state_machine/coordinator/fire.rs (L903-914)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
```

**File:** src/state_machine/coordinator/fire.rs (L1333-1334)
```rust
            malicious_signer_ids: state.malicious_signer_ids.clone(),
            malicious_dkg_signer_ids: state.malicious_dkg_signer_ids.clone(),
```

**File:** src/state_machine/coordinator/fire.rs (L1362-1362)
```rust
            malicious_signer_ids: self.malicious_signer_ids.clone(),
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```

**File:** src/state_machine/coordinator/fire.rs (L3000-3184)
```rust
        let threshold = config.threshold as f64;
        let num_signers_to_remove =
            (((num_keys - threshold) / keys_per_signer as f64).floor() + 1_f64) as usize;
        let mut insufficient_coordinators = coordinators.clone();
        let mut insufficient_signers = signers.clone();

        insufficient_signers.truncate(
            insufficient_signers
                .len()
                .saturating_sub(num_signers_to_remove),
        );

        // Start a signing round with an insufficient number of signers
        let msg = "It was many and many a year ago, in a kingdom by the sea"
            .as_bytes()
            .to_vec();
        let signature_type = SignatureType::Frost;
        let message = insufficient_coordinators
            .first_mut()
            .unwrap()
            .start_signing_round(&msg, signature_type, None)
            .unwrap();
        assert_eq!(
            insufficient_coordinators.first().unwrap().state,
            State::NonceGather(signature_type)
        );

        // Send the message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) = feedback_messages(
            &mut insufficient_coordinators,
            &mut insufficient_signers,
            &[message],
        );
        assert!(operation_results.is_empty());
        for coordinator in &insufficient_coordinators {
            assert_eq!(coordinator.state, State::NonceGather(signature_type));
        }

        assert!(outbound_messages.is_empty());

        // Sleep long enough to hit the timeout
        thread::sleep(Duration::from_millis(256));

        let (outbound_message, operation_result) = insufficient_coordinators
            .first_mut()
            .unwrap()
            .process_timeout()
            .unwrap();

        assert!(outbound_message.is_none());
        assert!(operation_result.is_some());
        for coordinator in &insufficient_coordinators {
            assert_eq!(coordinator.state, State::NonceGather(signature_type));
        }

        assert!(
            matches!(
                operation_result.unwrap(),
                OperationResult::SignError(SignError::NonceTimeout(..))
            ),
            "Expected OperationResult::SignError(SignError::NonceTimeout)"
        );

        // Start a new signing round with a sufficient number of signers for nonces but not sig shares
        let mut insufficient_coordinators = coordinators.clone();
        let mut insufficient_signers = signers.clone();

        let message = insufficient_coordinators
            .first_mut()
            .unwrap()
            .start_signing_round(&msg, signature_type, None)
            .unwrap();
        assert_eq!(
            insufficient_coordinators.first().unwrap().state,
            State::NonceGather(signature_type)
        );

        // Send the message to all signers and gather responses by sharing with all other signers and insufficient_coordinator
        let (outbound_messages, operation_results) = feedback_messages(
            &mut insufficient_coordinators,
            &mut insufficient_signers,
            &[message],
        );
        assert!(operation_results.is_empty());
        for coordinator in &insufficient_coordinators {
            assert_eq!(coordinator.state, State::SigShareGather(signature_type));
        }

        assert_eq!(outbound_messages.len(), 1);

        let mut malicious = Vec::new();

        // now remove signers so the number is insufficient
        let num_signers_to_drain = insufficient_signers
            .len()
            .saturating_sub(num_signers_to_remove);
        malicious.extend(insufficient_signers.drain(num_signers_to_drain..));

        // Send the SignatureShareRequest message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) = feedback_messages(
            &mut insufficient_coordinators,
            &mut insufficient_signers,
            &outbound_messages,
        );
        assert!(outbound_messages.is_empty());
        assert!(operation_results.is_empty());

        for coordinator in &insufficient_coordinators {
            assert_eq!(coordinator.state, State::SigShareGather(signature_type));
        }

        // Sleep long enough to hit the timeout
        thread::sleep(Duration::from_millis(256));

        let (outbound_message, operation_result) = insufficient_coordinators
            .first_mut()
            .unwrap()
            .process_timeout()
            .unwrap();

        assert!(outbound_message.is_some());
        assert!(operation_result.is_none());
        assert_eq!(
            insufficient_coordinators.first().unwrap().state,
            State::NonceGather(signature_type)
        );

        // put the malicious signers back in
        insufficient_signers.append(&mut malicious);

        // Send the NonceRequest message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) = feedback_messages(
            &mut insufficient_coordinators,
            &mut insufficient_signers,
            &[outbound_message.unwrap()],
        );
        assert_eq!(outbound_messages.len(), 1);
        assert!(operation_results.is_empty());

        for coordinator in &insufficient_coordinators {
            assert_eq!(coordinator.state, State::SigShareGather(signature_type));
        }

        // again remove signers so the number is insufficient
        let num_signers_to_drain = insufficient_signers
            .len()
            .saturating_sub(num_signers_to_remove);
        malicious.extend(insufficient_signers.drain(num_signers_to_drain..));

        // Send the SignatureShareRequest message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) = feedback_messages(
            &mut insufficient_coordinators,
            &mut insufficient_signers,
            &outbound_messages,
        );
        assert!(outbound_messages.is_empty());
        assert!(operation_results.is_empty());

        for coordinator in &insufficient_coordinators {
            assert_eq!(coordinator.state, State::SigShareGather(signature_type));
        }

        // Sleep long enough to hit the timeout
        thread::sleep(Duration::from_millis(256));

        let (outbound_message, operation_result) = insufficient_coordinators
            .first_mut()
            .unwrap()
            .process_timeout()
            .unwrap();

        assert!(outbound_message.is_none());
        assert!(operation_result.is_some());
        assert_eq!(
            insufficient_coordinators.first_mut().unwrap().state,
            State::SigShareGather(signature_type)
        );
        assert!(
            matches!(
                operation_result.unwrap(),
                OperationResult::SignError(SignError::InsufficientSigners(_))
            ),
            "Expected OperationResult::SignError(SignError::InsufficientSigners)"
        );
    }
```
