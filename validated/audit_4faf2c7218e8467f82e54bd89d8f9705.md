# Audit Report

## Title
Schnorr ID Proof Bypassed by Identity Point Allows DKG Threshold Reduction

## Summary
The `ID::verify()` function does not validate that the public key point `A` is not the identity point. An attacker can exploit this during DKG by providing a zero polynomial with `poly[0] = Point::identity()`, passing all validations while contributing nothing to the group secret. This breaks the threshold security guarantee, allowing signatures to be created with fewer honest parties than required.

## Finding Description

The vulnerability exists in the Schnorr ID proof verification used during Distributed Key Generation. The `ID::verify()` function verifies the equation `kca * G == kG + c * A` but does not check if `A` is the identity point. [1](#0-0) 

When an attacker sets `A = Point::identity()`, `kG = Point::identity()`, and `kca = Scalar::zero()`, the verification equation becomes `Point::identity() == Point::identity()`, which always passes.

During DKG, the `PolyCommitment` struct passes `poly[0]` as the `A` parameter to this verification: [2](#0-1) 

The `check_public_shares()` function validates polynomial commitments using only this Schnorr proof and the polynomial length: [3](#0-2) 

Both v1 and v2 implementations add `poly[0]` directly to the group key without checking for the identity point: [4](#0-3) [5](#0-4) 

When the attacker sends zero private shares (`Scalar::zero()`), the private share validation also passes. The validation checks that `s * G == compute::poly(key_id, poly)`: [6](#0-5) 

The `compute::poly()` function evaluates a polynomial using multi-exponentiation: [7](#0-6) 

If all points in the polynomial are `Point::identity()`, the result will be `Point::identity()` for any scalar, so `Scalar::zero() * G == Point::identity()` passes validation.

The codebase validates that `PublicNonce` points are not identity points: [8](#0-7) 

However, no similar validation exists for polynomial commitments. The coordinator computes the aggregate public key by summing `poly[0]` from all parties: [9](#0-8) 

## Impact Explanation

This vulnerability completely breaks the threshold security guarantee. In a T-of-N threshold signature scheme where K attackers exploit this vulnerability, the system requires T parties to sign, but if K of those parties are attackers with zero polynomials, only (T-K) honest parties actually contribute to the signature.

**Concrete Attack Scenario:**
- Configuration: 3-of-5 threshold (need 3 parties to sign)
- 2 attackers use zero polynomials
- Attackers + 1 honest party can create valid signatures
- **Actual threshold: 1 honest party instead of 3**

**Real-World Impact:**
In Bitcoin/Stacks multisig wallets using WSTS, this enables direct theft of funds by reducing the signing threshold below the configured security level. An attacker who compromises (T-K) honest parties can steal funds that should require T honest parties.

This maps to **Critical** severity: "Any causing the direct loss of funds" and "Any confirmation of an invalid transaction."

## Likelihood Explanation

**Attacker Requirements:**
- Must be an authorized DKG participant (realistic in any multi-party setup)
- Can send network messages during DKG (normal protocol operation)
- No cryptographic breaks, special hardware, or insider access required

**Attack Complexity:**
The attack is straightforward. The attacker constructs a `PolyCommitment` message with `poly = vec![Point::identity(); threshold]` and a matching Schnorr proof with `kG = Point::identity()` and `kca = Scalar::zero()`. The attacker sends `Scalar::zero()` as private shares to all parties. All validations pass.

**Success Rate:** 100% deterministic success if the attacker participates in DKG.

**Detection:** Low probability. The malicious commitment appears valid to all implemented checks. No monitoring exists for identity point polynomials.

## Recommendation

Add identity point validation for polynomial commitments, similar to the validation that exists for `PublicNonce`:

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    // Check that poly[0] is not the identity point
    if poly_comm.poly[0] == Point::identity() {
        return false;
    }
    
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

Additionally, consider adding validation in `ID::verify()` to reject identity points:

```rust
pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
    if *A == Point::identity() {
        return false;
    }
    let c = Self::challenge(&self.id, &self.kG, A, ctx);
    &self.kca * &G == &self.kG + c * A
}
```

## Proof of Concept

```rust
#[test]
fn test_identity_point_polynomial_bypass() {
    use crate::{schnorr::ID, common::PolyCommitment, curve::{point::Point, scalar::Scalar}};
    
    // Attacker creates malicious commitment with identity point
    let malicious_id = ID {
        id: Scalar::from(1),
        kG: Point::identity(),
        kca: Scalar::zero(),
    };
    
    let threshold = 3;
    let malicious_poly = vec![Point::identity(); threshold];
    
    let commitment = PolyCommitment {
        id: malicious_id,
        poly: malicious_poly,
    };
    
    let ctx = 0u64.to_be_bytes();
    
    // Verify that the malicious commitment passes validation
    assert!(commitment.verify(&ctx), "Malicious commitment should pass ID verification");
    assert!(check_public_shares(&commitment, threshold, &ctx), "Malicious commitment should pass check_public_shares");
    
    // Verify that zero private share passes validation
    let zero_share = Scalar::zero();
    let key_id = Scalar::from(1);
    let poly_eval = compute::poly(&key_id, &commitment.poly).unwrap();
    assert_eq!(zero_share * G, poly_eval, "Zero share should validate against identity polynomial");
}
```

### Citations

**File:** src/schnorr.rs (L62-65)
```rust
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```

**File:** src/common.rs (L37-39)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/v1.rs (L161-166)
```rust
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
```

**File:** src/v1.rs (L191-195)
```rust
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
```

**File:** src/v2.rs (L135-140)
```rust
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
```

**File:** src/compute.rs (L130-139)
```rust
pub fn poly(x: &Scalar, f: &Vec<Point>) -> Result<Point, PointError> {
    let mut s = Vec::with_capacity(f.len());
    let mut pow = Scalar::one();
    for _ in 0..f.len() {
        s.push(pow);
        pow *= x;
    }

    Point::multimult(s, f.clone())
}
```

**File:** src/state_machine/coordinator/fire.rs (L803-807)
```rust
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```
