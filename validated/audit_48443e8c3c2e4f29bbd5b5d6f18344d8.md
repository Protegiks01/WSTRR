After systematically validating this security claim against the WSTS codebase, I have completed a thorough analysis following the validation framework.

# Audit Report

## Title
Duplicate Key IDs in NonceResponse Bypass Validation and Cause Aggregation Failure

## Summary
A malicious signer can send a `NonceResponse` with duplicate key IDs and corresponding duplicate nonces that passes HashSet-based validation but causes signature aggregation to fail. The coordinator validates key_ids by converting to a HashSet (removing duplicates), but stores the NonceResponse with duplicates intact, leading to a nonces.len() != sig_shares.len() error during aggregation and causing a denial of service.

## Finding Description

The WSTS coordinator validates NonceResponse messages by converting the `key_ids` vector to a HashSet before comparing it to configured key IDs. [1](#0-0)  This validation removes duplicates, allowing a malicious signer to bypass the check by sending duplicate key IDs.

**Attack Execution Path:**

1. **Malicious NonceResponse Creation**: A malicious signer with legitimate keys {1, 2} manually crafts a NonceResponse with `key_ids = [1, 2, 1, 1]` and 4 corresponding nonces, bypassing the state machine's normal nonce generation.

2. **Validation Bypass**: The coordinator's validation converts key_ids to HashSet {1, 2}, which matches the configured keys {1, 2}, so validation passes. [1](#0-0)  Individual nonce validity is checked [2](#0-1)  but there is no check that `key_ids.len() == nonces.len()` or that key_ids contains no duplicates.

3. **Storage with Duplicates**: The NonceResponse is stored with all duplicates intact. [3](#0-2) 

4. **Flattening Preserves Duplicates**: During aggregation, the coordinator flattens nonces and key_ids from all NonceResponses, preserving all duplicates. [4](#0-3)  If the malicious signer sent 4 nonces, all 4 are included in the flattened nonces array.

5. **Signature Share Mismatch**: In v2, each party generates a single signature share regardless of how many keys it controls. [5](#0-4)  The malicious signer, when responding to SignatureShareRequest, generates only 1 signature share (as expected for a single party), not 4.

6. **Aggregation Failure**: The aggregator enforces a length check that fails when the malicious signer's 4 nonces don't match its 1 signature share. [6](#0-5)  This returns `BadNonceLen` error and prevents signature aggregation from completing.

The root cause is that v2 is designed for one nonce per party [7](#0-6)  with multiple key_ids being informational. However, the validation doesn't enforce this relationship or check for duplicates, allowing a malicious signer to inject extra nonces that break the aggregation invariant.

## Impact Explanation

This vulnerability enables any malicious signer to prevent signature aggregation from completing, causing the entire signing round to fail. This constitutes a **transient consensus failure** (Medium severity) because:

- Any signing round can be blocked by any malicious signer included in that round
- All honest participants are affected when a signing attempt includes the attacker
- Transaction confirmation is delayed until the round times out or is restarted with the malicious signer excluded
- No permanent damage, fund loss, or state corruption occurs
- Normal operations can resume by excluding the identified malicious signer

This aligns with the Medium severity definition: "Any transient consensus failures" - the signing protocol fails temporarily but can be recovered through coordinator intervention.

## Likelihood Explanation

**Required Capabilities:**
- Must be a valid signing participant with configured key IDs (within protocol threat model of up to threshold-1 malicious signers)
- Must be included in the signing set for a threshold signature round

**Attack Complexity:** Trivial. The attacker crafts a `NonceResponse` message with duplicate entries in the `key_ids` vector and corresponding duplicate nonces, bypassing the state machine's normal message construction.

**Economic Feasibility:** Zero cost. The attack requires only sending a single malformed message per signing round targeted.

**Detection:** The attack is detected only during aggregation when the `BadNonceLen` error occurs. By this point, the signing round has already consumed resources and must be restarted. The coordinator can identify which signer sent duplicate key_ids by inspecting stored NonceResponses, but the current implementation doesn't prevent the issue upfront.

**Estimated Probability:** Near 100% success rate for causing the intended DoS effect on each signing attempt where the malicious signer is included.

## Recommendation

Add validation in the coordinator's `gather_nonces()` method to check for duplicate key_ids and enforce that the relationship between key_ids and nonces is correct:

```rust
// After line 889 in fire.rs and line 521 in frost.rs, add:

// Check for duplicate key_ids within the NonceResponse
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id,
        "NonceResponse contains duplicate key_ids"
    );
    return Ok(());
}

// For v2, enforce one nonce per party (not per key)
// For v1, enforce one nonce per key
let expected_nonce_count = if is_v2_coordinator {
    1  // v2 parties generate one nonce total
} else {
    nonce_response.key_ids.len()  // v1 parties generate one nonce per key
};

if nonce_response.nonces.len() != expected_nonce_count {
    warn!(
        signer_id = %nonce_response.signer_id,
        expected = expected_nonce_count,
        actual = %nonce_response.nonces.len(),
        "NonceResponse nonce count doesn't match expected count"
    );
    return Ok(());
}
```

This prevents malicious signers from injecting duplicate key_ids or mismatched nonce counts that would cause aggregation failures.

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_cause_aggregation_failure() {
    // Setup: Create a coordinator with a signer that has keys {1, 2}
    // Malicious actor crafts NonceResponse with key_ids=[1,2,1,1] and 4 nonces
    // Expected: Validation passes (HashSet comparison removes duplicates)
    // But aggregation fails with BadNonceLen(4, 1) error
    
    let mut nonce_response = NonceResponse {
        dkg_id: 0,
        sign_id: 0,
        sign_iter_id: 0,
        signer_id: 1,
        key_ids: vec![1, 2, 1, 1],  // Duplicates!
        nonces: vec![
            PublicNonce::random(&mut rng),
            PublicNonce::random(&mut rng),
            PublicNonce::random(&mut rng),
            PublicNonce::random(&mut rng),
        ],  // 4 nonces
        message: vec![0u8; 32],
    };
    
    // Pass to coordinator - validation should pass but aggregation fails
    // Demonstrates nonces.len() (4) != sig_shares.len() (1)
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L891-901)
```rust
            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L1121-1129)
```rust
            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/v2.rs (L271-275)
```rust
        SignatureShare {
            id: self.party_id,
            z_i: z,
            key_ids: self.key_ids.clone(),
        }
```

**File:** src/v2.rs (L304-306)
```rust
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }
```

**File:** src/v2.rs (L627-633)
```rust
    fn gen_nonces<RNG: RngCore + CryptoRng>(
        &mut self,
        secret_key: &Scalar,
        rng: &mut RNG,
    ) -> Vec<PublicNonce> {
        vec![self.gen_nonce(secret_key, rng)]
    }
```
