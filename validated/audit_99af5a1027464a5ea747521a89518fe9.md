Audit Report

## Title
Unvalidated DKG Failure Reports Enable Denial of Service by Single Malicious Signer

## Summary
The FIRE and FROST coordinators accept `MissingPublicShares` and `MissingPrivateShares` failure reports without validation, allowing a single malicious signer to abort DKG by falsely claiming honest signers failed to send shares. The coordinators possess the data needed to validate these claims but fail to do so, unlike their validation of `BadPublicShares` and `BadPrivateShares` reports.

## Finding Description

The vulnerability exists in the `gather_dkg_end` methods of both coordinator implementations.

**FIRE Coordinator Behavior:**

The FIRE coordinator processes DkgEnd messages and handles different failure types. For `BadPublicShares` failures, it validates claims by checking actual share data against the coordinator's records [1](#0-0) . Similarly, for `BadPrivateShares`, extensive validation verifies the claims and marks false reporters as malicious [2](#0-1) .

However, for `MissingPublicShares` and `MissingPrivateShares` failures, no validation occurs despite developer comments indicating awareness: "this shouldn't happen, maybe mark signer malicious?" [3](#0-2) . The coordinator collects all reported failures and aborts DKG if any exist [4](#0-3) .

**FROST Coordinator Behavior:**

The FROST coordinator performs zero validation on any reported failures. It simply collects all failure reports and immediately aborts DKG if any signer reports a failure, with an empty malicious_signers set [5](#0-4) .

**Root Cause:**

The coordinators store all received shares in `dkg_public_shares` and `dkg_private_shares` maps [6](#0-5) . These are populated during the gather phases [7](#0-6) [8](#0-7) .

When a signer reports missing shares, the coordinator can verify this claim by checking if the allegedly missing signer's shares exist in these maps. However, this validation is not implemented. A malicious signer can claim that another signer (who successfully sent shares) failed to send them, and the coordinator will abort DKG without detecting the false report.

**Security Invariant Broken:**

The DKG protocol guarantees "Accountability: Invalid shares can be traced to the malicious party" per protocol documentation. However, for false `MissingPublicShares`/`MissingPrivateShares` reports, the malicious reporter is not identified, violating this guarantee.

## Impact Explanation

The direct impact is a **denial of service in DKG operations**. A single malicious signer can prevent DKG completion indefinitely by repeatedly submitting false failure reports. This prevents:
1. Initial key generation for new signer sets
2. Key rotation when membership changes
3. Recovery from compromised key scenarios

**Severity Assessment:**

Per the provided severity definitions, the baseline impact is **Low severity**: "Any remotely-exploitable denial of service in a node."

However, the severity could escalate based on integration requirements:
- If DKG failure prevents mandatory key rotation required for block signing, it could reach **Critical severity**: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks"
- If DKG failure causes different nodes to have divergent state about valid signing keys, it could reach **High severity**: "Any unintended chain split or network partition"

Without concrete evidence of the integration design requiring mandatory DKG completion for continued operation, the proven severity is Low with potential escalation based on deployment context.

## Likelihood Explanation

**Attack Requirements:**
- Attacker must be an authorized signer (within protocol threat model)
- Standard message-sending capability
- No cryptographic breaks or special privileges needed

**Attack Execution:**
The attack is trivial. The attacker sends a DkgEnd message with fabricated failure data [9](#0-8) :

```
DkgEnd {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id, 
    status: DkgStatus::Failure(DkgFailure::MissingPublicShares(fabricated_set))
}
```

**Success Rate:** 100% - The vulnerability is deterministic with no race conditions or probabilistic elements.

**Detection Difficulty:** High - The coordinator cannot distinguish legitimate from false reports without implementing the missing validation. Other signers may notice discrepancies but the coordinator makes final decisions.

## Recommendation

Implement validation for `MissingPublicShares` and `MissingPrivateShares` reports consistent with existing `BadPublicShares` and `BadPrivateShares` validation.

For FIRE coordinator, in `gather_dkg_end` method, add validation cases:

```rust
DkgFailure::MissingPublicShares(missing_shares) => {
    for missing_signer_id in missing_shares {
        if self.dkg_public_shares.contains_key(missing_signer_id) {
            warn!("Signer {signer_id} reported MissingPublicShares from {missing_signer_id} but coordinator received those shares, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        }
    }
}
DkgFailure::MissingPrivateShares(missing_shares) => {
    for missing_signer_id in missing_shares {
        if self.dkg_private_shares.contains_key(missing_signer_id) {
            warn!("Signer {signer_id} reported MissingPrivateShares from {missing_signer_id} but coordinator received those shares, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        }
    }
}
```

Apply similar validation logic to the FROST coordinator's `gather_dkg_end` method.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Initialize a coordinator and signers for DKG
2. Have all honest signers successfully send public and private shares
3. Have one malicious signer send `DkgEnd` with `Failure(MissingPublicShares([honest_signer_id]))`
4. Verify that DKG aborts despite all shares being received
5. Verify that the malicious signer is not marked as malicious

Expected behavior: DKG should complete successfully and mark the false reporter as malicious.

Actual behavior: DKG aborts with the false failure report accepted as valid.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L40-41)
```rust
    dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L525-565)
```rust
    fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
            info!(
                dkg_id = %dkg_private_shares.dkg_id,
                signer_id = %dkg_private_shares.signer_id,
                "DkgPrivateShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.private_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```

**File:** src/state_machine/coordinator/frost.rs (L400-417)
```rust
        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
```

**File:** src/net.rs (L243-260)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG end message from signers to coordinator
pub struct DkgEnd {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// DKG status for this Signer after receiving public/private shares
    pub status: DkgStatus,
}

impl Signable for DkgEnd {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_END".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
    }
}
```
