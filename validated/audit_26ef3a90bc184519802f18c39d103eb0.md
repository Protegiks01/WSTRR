# Audit Report

## Title
Unvalidated DKG Failure Reports Allow Malicious Signers to Cause Repeated DKG Denial of Service

## Summary
The FIRE coordinator's `gather_dkg_end()` function does not validate three types of DKG failure reports (`Threshold`, `MissingPublicShares`, `MissingPrivateShares`), allowing a single malicious signer to falsely report these failures and cause indefinite DKG round failures without detection. This enables denial of service on distributed key generation operations.

## Finding Description

The vulnerability exists in the FIRE coordinator's DKG end validation logic. When signers complete DKG processing, they send `DkgEnd` messages reporting either success or failure. The coordinator validates cryptographic proofs for `BadPublicShares` and `BadPrivateShares` failures but three failure types have no validation whatsoever: [1](#0-0) [2](#0-1) 

These failure reports are unconditionally added to the `reported_failures` map: [3](#0-2) 

If any failures exist after processing all DkgEnd messages, the entire DKG round fails: [4](#0-3) 

**Attack Execution:**
1. Malicious signer participates normally until DkgEndBegin phase
2. Signer returns false failure in `dkg_ended()` method instead of honest validation
3. Coordinator receives `DkgEnd` with `DkgStatus::Failure(DkgFailure::MissingPrivateShares(victim_ids))`
4. Coordinator processes the failure but performs no validation (empty match arms)
5. False failure added to `reported_failures` 
6. DKG fails with `Error::DkgFailure`, preventing aggregate key generation
7. Malicious signer NOT added to `malicious_signers` (empty match arms), enabling indefinite repetition

**Why Validation is Possible:**

The coordinator maintains authoritative information about which signers sent shares: [5](#0-4) [6](#0-5) 

The coordinator broadcasts this list to signers, who use it to detect missing shares: [7](#0-6) [8](#0-7) 

The coordinator has complete data to validate these claims by cross-referencing reported signer IDs against its `dkg_public_shares` and `dkg_private_shares` maps, and by verifying threshold calculations. This validation is not implemented.

This breaks the Byzantine fault tolerance guarantee that DKG should tolerate up to threshold-1 malicious signers, since a single malicious signer can prevent completion.

## Impact Explanation

**Severity: Low**

This vulnerability maps to "Any remotely-exploitable denial of service in a node" under the Low severity category. The impact is:

- **Prevents DKG completion**: New aggregate public keys cannot be generated, blocking initial setup and key rotation
- **Resource waste**: Computational resources spent on polynomial generation, O(nÂ²) share exchanges, and commitment verification across all participants are wasted
- **Does NOT affect existing operations**: Existing aggregate keys continue functioning for signing operations
- **Does NOT cause**: Fund loss, chain splits, network shutdown, or consensus failures

If WSTS DKG is integrated into consensus-critical operations (e.g., Stacks signer set formation), this could potentially elevate to Medium severity under "Any transient consensus failures" by preventing new signers from joining. However, without evidence of such integration, this remains Low severity.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially executable:

**Attacker Requirements:**
- Registered signer with valid keys (standard protocol participant)
- Network access to send messages to coordinator (normal protocol operation)
- No cryptographic breaks or special privileges required

**Attack Complexity:** Minimal. The attacker modifies their signer implementation to return false failure: [9](#0-8) 

Instead of honest validation, return:
```rust
DkgEnd {
    dkg_id: self.dkg_id,
    signer_id: self.signer_id,
    status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(arbitrary_signer_ids)),
}
```

**Detection & Cost:**
- Zero detection mechanism (coordinator logs but cannot verify)
- Zero economic cost (no slashing, bonds, or reputation system)
- Zero risk (malicious signer not tracked, can repeat indefinitely)
- Guaranteed success

## Recommendation

Implement validation logic for the three unvalidated failure types in `gather_dkg_end()`:

```rust
DkgFailure::Threshold => {
    // Verify threshold claim by counting keys from dkg_private_shares.keys()
    let mut num_keys = 0u32;
    for signer_id in self.dkg_private_shares.keys() {
        if let Some(key_ids) = self.config.public_keys.signer_key_ids.get(signer_id) {
            num_keys = num_keys.saturating_add(key_ids.len() as u32);
        }
    }
    if num_keys >= self.config.dkg_threshold {
        // False report - sufficient keys exist
        malicious_signers.insert(*signer_id);
    }
}
DkgFailure::MissingPublicShares(missing) => {
    // Verify each reported signer is actually missing from dkg_public_shares
    for reported_signer_id in missing {
        if self.dkg_public_shares.contains_key(reported_signer_id) {
            // False report - shares exist
            malicious_signers.insert(*signer_id);
            break;
        }
    }
}
DkgFailure::MissingPrivateShares(missing) => {
    // Verify each reported signer is actually missing from dkg_private_shares
    for reported_signer_id in missing {
        if self.dkg_private_shares.contains_key(reported_signer_id) {
            // False report - shares exist
            malicious_signers.insert(*signer_id);
            break;
        }
    }
}
```

This ensures false reporters are identified as malicious and prevents indefinite attack repetition.

## Proof of Concept

```rust
#[test]
fn test_false_missing_private_shares_dos() {
    // Setup coordinator and signers
    let (mut coordinators, mut signers) = setup::<FireCoordinator<v2::Aggregator>, v2::Signer>(3, 3);
    
    // Run DKG until DkgEndBegin
    let dkg_begin = coordinators[0].start_dkg_round(None).unwrap();
    let (msgs, _) = feedback_messages(&mut coordinators, &mut signers, &[dkg_begin]);
    let (msgs, _) = feedback_messages(&mut coordinators, &mut signers, &msgs);
    
    // Malicious signer 0 sends false MissingPrivateShares claim
    let false_failure = DkgEnd {
        dkg_id: coordinators[0].current_dkg_id,
        signer_id: 0,
        status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
            vec![1, 2].into_iter().collect() // False claim - these signers sent shares
        )),
    };
    
    let packet = Packet {
        sig: false_failure.sign(&signers[0].network_private_key).unwrap(),
        msg: Message::DkgEnd(false_failure),
    };
    
    // Process the false failure report
    let result = coordinators[0].process(&packet);
    
    // DKG should fail with reported failures
    assert!(matches!(result, Ok((None, Some(OperationResult::DkgError(_))))));
    
    // Malicious signer 0 should NOT be in malicious_signers (vulnerability)
    assert!(!coordinators[0].malicious_dkg_signer_ids.contains(&0));
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L451-455)
```rust
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L608-610)
```rust
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L617-619)
```rust
                        DkgFailure::Threshold => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L779-788)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/signer/mod.rs (L504-510)
```rust
    pub fn dkg_ended<R: RngCore + CryptoRng>(&mut self, rng: &mut R) -> Result<Message, Error> {
        if !self.can_dkg_end() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadState),
            }));
```

**File:** src/state_machine/signer/mod.rs (L529-534)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L551-582)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```
