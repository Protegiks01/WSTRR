# Audit Report

## Title
Missing DKG Round ID Validation Before Duplicate Check Enables Denial of Service

## Summary
The `dkg_private_shares()` function in the Signer state machine lacks validation that incoming `DkgPrivateShares` messages match the current DKG round ID before performing duplicate detection and storing shares. This allows an attacker to replay legitimately-signed messages from previous DKG rounds, which block legitimate current-round shares and cause DKG failure, preventing the signing group from completing key generation and signing transactions.

## Finding Description

The Signer's `dkg_private_shares()` function performs validation in this order: signer_id verification, party_id validation, duplicate detection keyed by signer_id only, immediate storage of shares, then decryption. [1](#0-0) 

Critically, the function never validates that the incoming message's `dkg_id` field matches the Signer's current `self.dkg_id`. The `DkgPrivateShares` message structure includes a `dkg_id` field that identifies which DKG round the shares belong to: [2](#0-1) 

In contrast, both coordinator implementations (FIRE and FROST) correctly validate `dkg_id` BEFORE the duplicate check: [3](#0-2) [4](#0-3) 

The Signer's packet signature verification only confirms the message was signed by the claimed signer, but does not validate round ID correctness: [5](#0-4) [6](#0-5) 

**Attack Execution Path:**

1. Attacker captures or replays a validly-signed `DkgPrivateShares` message from DKG round N-1 (from signer X)
2. During current round N, victim signer Y receives the replayed message
3. No `dkg_id` validation occurs - the function proceeds normally
4. Duplicate check passes (first message received from signer X in this round)
5. Wrong-round shares are stored immediately at line 1063-1064
6. Decryption fails because KEX keys are rotated per round: [7](#0-6) 

7. Failed decryption marks the shares as `invalid_private_shares`: [8](#0-7) 

8. When legitimate shares from signer X arrive with correct `dkg_id = N`, the duplicate check at lines 1058-1061 rejects them (already have entry for signer X)
9. During `dkg_ended()`, the presence of invalid shares causes DKG failure: [9](#0-8) [10](#0-9) 

The security guarantee broken is **DKG round isolation** - shares from different DKG rounds should not interfere with each other. Without round ID validation, the duplicate detection mechanism becomes a vector for denial of service.

## Impact Explanation

This vulnerability enables a remotely-exploitable denial of service attack against DKG participants. When an attacker successfully injects wrong-round shares to enough signers, the entire DKG round fails with `BadPrivateShares` errors. Since the signing group cannot complete DKG, they cannot derive the group public key and therefore cannot sign transactions.

The coordinator does not automatically restart failed DKG rounds - manual intervention is required from the application layer. During the failure period, the signing group is unable to participate in transaction signing operations.

This maps to **Low severity** ("Any remotely-exploitable denial of service in a node") or **Medium severity** ("Any transient consensus failures") depending on how many signers are affected and recovery time. If the attack prevents transaction confirmation across multiple blocks, impact severity increases toward the Critical threshold.

## Likelihood Explanation

**Attacker Requirements:**
- Network-level access to observe and replay messages between signers
- OR ability to forge messages if `verify_packet_sigs = false` in configuration

**Attack Complexity:**
Low - The attacker simply needs to capture and replay a `DkgPrivateShares` message from any previous DKG round. The replayed message:
- Contains a valid signature (legitimately signed by the source signer in the previous round)
- The signature includes the `dkg_id` field in its hash, so it remains cryptographically valid
- Passes all authentication checks since it was legitimately created

**Economic Feasibility:**
Minimal cost - requires only network positioning to capture and replay messages. No cryptographic breaks, no key compromises, no expensive computational resources needed.

**Detection:**
Low detection risk - the replayed message appears as a legitimate protocol message until DKG validation fails. By that point, legitimate shares have already been blocked.

**Estimated Probability:**
Moderate to High if the attacker has network access to signer-to-signer communication channels. With a single compromised or malicious signer, success is guaranteed as they can replay their own previous messages to target specific victims.

## Recommendation

Add `dkg_id` validation before the duplicate check in the `dkg_private_shares()` function, matching the pattern used by both coordinator implementations:

```rust
pub fn dkg_private_shares<R: RngCore + CryptoRng>(
    &mut self,
    dkg_private_shares: &DkgPrivateShares,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    let src_signer_id = dkg_private_shares.signer_id;
    
    // ADD THIS VALIDATION FIRST
    if dkg_private_shares.dkg_id != self.dkg_id {
        return Err(Error::BadDkgId(
            dkg_private_shares.dkg_id,
            self.dkg_id,
        ));
    }

    // check that the signer_id exists in the config
    let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
        warn!(%src_signer_id, "No public key configured");
        return Ok(vec![]);
    };
    
    // ... rest of function
}
```

This ensures round isolation is enforced at the signer level, preventing wrong-round shares from interfering with the current DKG round.

## Proof of Concept

```rust
#[test]
fn test_dkg_private_shares_wrong_round_blocks_legitimate() {
    let mut rng = OsRng;
    let config = test_config(4, 3, 3);
    
    // Create signer in round N=10
    let mut signer = Signer::<v2::Signer>::new(
        config.threshold,
        config.dkg_threshold,
        config.num_signers,
        config.num_keys,
        config.signer_ids[0],
        &config.key_ids[0],
        config.num_parties(),
        config.public_keys.clone(),
        &mut rng,
    );
    signer.dkg_id = 10; // Current round is 10
    
    // Create old shares from round N-1=9 (wrong round)
    let old_shares = DkgPrivateShares {
        dkg_id: 9,  // Wrong round!
        signer_id: config.signer_ids[1],
        shares: vec![(0, HashMap::new())],
    };
    
    // Process wrong-round shares - they get stored without validation
    let result1 = signer.dkg_private_shares(&old_shares, &mut rng);
    assert!(result1.is_ok()); // Passes without dkg_id validation
    
    // Now try to process legitimate shares from same signer but correct round
    let legitimate_shares = DkgPrivateShares {
        dkg_id: 10,  // Correct round
        signer_id: config.signer_ids[1], // Same signer
        shares: vec![(0, HashMap::new())],
    };
    
    // This should work but gets blocked by duplicate check
    let result2 = signer.dkg_private_shares(&legitimate_shares, &mut rng);
    assert!(result2.is_ok());
    
    // Verify that legitimate shares were silently discarded
    // The stored shares should be from the wrong round (dkg_id=9)
    let stored = signer.dkg_private_shares.get(&config.signer_ids[1]).unwrap();
    assert_eq!(stored.dkg_id, 9); // Wrong round shares are stored
    assert_ne!(stored.dkg_id, signer.dkg_id); // Not current round
    
    // This causes DKG to fail during dkg_ended()
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L417-431)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
```

**File:** src/state_machine/signer/mod.rs (L463-479)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
            Message::DkgPrivateShares(dkg_private_shares) => {
                self.dkg_private_shares(dkg_private_shares, rng)
```

**File:** src/state_machine/signer/mod.rs (L611-620)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
```

**File:** src/state_machine/signer/mod.rs (L643-659)
```rust
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
```

**File:** src/state_machine/signer/mod.rs (L1038-1064)
```rust
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1089-1095)
```rust
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-549)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
```

**File:** src/state_machine/coordinator/fire.rs (L527-547)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L338-357)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
```
