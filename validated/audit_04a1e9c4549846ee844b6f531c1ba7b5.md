# Audit Report

## Title
DKG Round ID Replay Attack Allows Permanent Secret Key Loss and Network Halt

## Summary
Both coordinator and signer state machines fail to validate that incoming DKG round IDs are strictly increasing, allowing replay of old `DkgBegin` messages to force state regression. This triggers polynomial regeneration that can permanently destroy secret keys when the fake DKG completes, causing network-wide signing failure.

## Finding Description

**Coordinator Vulnerability:**

The Fire and Frost coordinators only check for equality when validating DKG round IDs in their `process_message` methods. When `current_dkg_id != dkg_begin.dkg_id`, the equality check fails and execution continues: [1](#0-0) [2](#0-1) 

Both coordinators then call `start_dkg_round` which unconditionally accepts any `dkg_id` value without validating that it represents progression (i.e., `id > current_dkg_id`): [3](#0-2) [4](#0-3) 

This allows round ID regression when old messages are replayed.

**Signer Vulnerability:**

The signer's `process` method dispatches `DkgBegin` messages directly to the `dkg_begin` handler without any round ID validation: [5](#0-4) 

The `dkg_begin` handler unconditionally calls `reset` with the attacker-controlled `dkg_id`: [6](#0-5) 

The `reset` method accepts any `dkg_id` value (including older ones) and always calls `reset_polys`: [7](#0-6) 

**Root Cause - Polynomial Regeneration:**

The `reset_polys` implementations in both v1 and v2 generate completely new random polynomials, destroying the old polynomial state: [8](#0-7) [9](#0-8) 

**Secret Key Destruction:**

When the fake DKG completes, `compute_secret` is called during `dkg_ended`, which zeros out the existing private key and computes a new one from the new shares: [10](#0-9) [11](#0-10) 

Once line 156 executes, `private_key` from the legitimate DKG round N is permanently destroyed and replaced with a key derived from the fake DKG's new random polynomials.

**Why Packet Signatures Don't Prevent This:**

Packet signature verification only authenticates the sender, not message freshness: [12](#0-11) [13](#0-12) 

An attacker can capture a legitimately signed `DkgBegin` message from round N-1 and replay it after round N completes. The signature remains valid because it was genuinely created by the coordinator.

## Impact Explanation

**Severity: Critical**

This vulnerability meets the Critical impact criterion: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

**Attack Outcomes:**

1. **If fake DKG completes**: All participating signers execute `compute_secret`, which zeros their private keys (line 156) and replaces them with keys derived from incompatible random polynomials. The original keys from round N are permanently and mathematically unrecoverable.

2. **If fake DKG doesn't complete**: Signers become stuck in DKG state and cannot participate in signing operations, causing denial of service until manual intervention.

**Quantified Impact:**
- With 10 signers and threshold 7: if the coordinator and 7+ signers accept the replay, the legitimate round N keys are destroyed
- Recovery requires complete DKG restart with new key generation
- For Stacks blockchain integration, this causes indefinite block signing failure until new DKG coordination
- All previous signing infrastructure and key material becomes invalid

## Likelihood Explanation

**Attacker Prerequisites:**
- Network access to observe and replay messages (standard network capability)
- No cryptographic breaks required
- No private key access needed
- Attack uses legitimately signed protocol messages

**Attack Steps:**
1. Passively observe and capture `DkgBegin(dkg_id: N-1)` message during DKG round N-1
2. Wait for DKG round N to complete successfully
3. Replay captured message to coordinator and signers
4. Coordinator and signers accept the message due to missing monotonicity check
5. All participants regress to `dkg_id = N-1` with new random polynomials
6. If fake DKG orchestrated by coordinator completes, private keys are overwritten

**Probability: HIGH**
- Attack is deterministic given network access
- No race conditions or timing dependencies
- Works against all current WSTS deployments
- Economic cost: zero (simple packet replay)

## Recommendation

Add monotonicity validation for DKG round IDs to prevent regression:

**For Coordinators (both Fire and Frost):**
```rust
if let Message::DkgBegin(dkg_begin) = &packet.msg {
    if self.current_dkg_id >= dkg_begin.dkg_id {
        // Reject old or duplicate DKG rounds
        return Ok((None, None));
    }
    let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
    return Ok((Some(packet), None));
}
```

**For Signers:**
```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    if self.dkg_id >= dkg_begin.dkg_id {
        // Reject old or duplicate DKG rounds
        return Ok(vec![]);
    }
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

Additionally, consider implementing replay protection mechanisms such as message sequence numbers or timestamps.

## Proof of Concept

```rust
#[test]
fn test_dkg_round_id_replay_attack() {
    use crate::state_machine::coordinator::fire::FireCoordinator;
    use crate::state_machine::signer::Signer;
    use crate::net::{DkgBegin, Message, Packet};
    use crate::v2;
    use rand_core::OsRng;
    
    // Setup: Complete DKG round 10 successfully
    let mut coordinator = /* setup FireCoordinator */;
    let mut signer = /* setup Signer */;
    
    // Complete DKG round 10
    coordinator.current_dkg_id = 10;
    signer.dkg_id = 10;
    // ... complete DKG, signer now has private_key_10
    
    // Attack: Replay DkgBegin from round 9
    let replay_packet = Packet {
        sig: vec![],
        msg: Message::DkgBegin(DkgBegin { dkg_id: 9 }),
    };
    
    // Verify coordinator accepts regression
    let result = coordinator.process(&replay_packet);
    assert!(result.is_ok());
    assert_eq!(coordinator.current_dkg_id, 9); // REGRESSED!
    
    // Verify signer accepts regression and regenerates polynomials
    let old_poly = signer.signer.save().polynomial.clone();
    let result = signer.process(&replay_packet, &mut OsRng);
    assert!(result.is_ok());
    assert_eq!(signer.dkg_id, 9); // REGRESSED!
    let new_poly = signer.signer.save().polynomial.clone();
    assert_ne!(old_poly, new_poly); // Polynomial changed!
    
    // If fake DKG completes, private_key_10 will be destroyed
}
```

**Notes:**
- The test named `old_round_ids_are_ignored` (line 3293 in fire.rs) actually tests duplicate IDs, not older IDs, as `old_id = id` on line 3297.
- The vulnerability exists because the equality check `current_dkg_id == dkg_id` only prevents processing the exact same round twice, not older rounds.
- No production code calls `clear_polys` after DKG completion, leaving polynomials in memory that get overwritten by `reset_polys`.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L222-224)
```rust
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L231-236)
```rust
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
```

**File:** src/state_machine/coordinator/fire.rs (L1430-1434)
```rust
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }
```

**File:** src/state_machine/coordinator/frost.rs (L76-81)
```rust
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
```

**File:** src/state_machine/coordinator/frost.rs (L958-962)
```rust
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }
```

**File:** src/state_machine/signer/mod.rs (L418-424)
```rust
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
```

**File:** src/state_machine/signer/mod.rs (L467-469)
```rust
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/signer/mod.rs (L471-472)
```rust
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
```

**File:** src/state_machine/signer/mod.rs (L849-850)
```rust
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;
```

**File:** src/v1.rs (L126-128)
```rust
    pub fn reset_poly<RNG: RngCore + CryptoRng>(&mut self, rng: &mut RNG) {
        self.f = Some(VSS::random_poly(self.threshold - 1, rng));
    }
```

**File:** src/v1.rs (L156-157)
```rust
        self.private_key = Scalar::zero();
        self.group_key = Point::zero();
```

**File:** src/v1.rs (L205-206)
```rust
        self.private_key = private_shares.values().sum();
        self.public_key = self.private_key * G;
```

**File:** src/v2.rs (L583-585)
```rust
    fn reset_polys<RNG: RngCore + CryptoRng>(&mut self, rng: &mut RNG) {
        self.f = Some(VSS::random_poly(self.threshold - 1, rng));
    }
```
