# Audit Report

## Title
Schnorr ID Proof Bypassed by Identity Point Allows DKG Threshold Reduction

## Summary
The `ID::verify()` function does not validate that the public key point is not the identity point (point at infinity). Malicious DKG participants can exploit this to create trivial proofs that always pass verification while contributing nothing to the group key, effectively reducing the threshold security from T parties to (T-K) honest parties where K is the number of malicious participants.

## Finding Description

The vulnerability exists in the Schnorr identity proof verification during Distributed Key Generation (DKG). The `ID::verify()` function performs the verification equation `kca * G == kG + c * A` without validating that the public key point `A` is not the identity element. [1](#0-0) 

When an attacker sets `A = Point::identity()`, `kG = Point::identity()`, and `kca = Scalar::zero()`, both sides of the equation evaluate to `Point::identity()`, causing the verification to always pass and bypassing the proof-of-knowledge requirement entirely.

During DKG, polynomial commitments pass `poly[0]` (the polynomial's constant term representing the party's public key contribution) as the `A` parameter to ID verification. [2](#0-1) 

The validation function only checks the Schnorr proof validity and polynomial length, but does not verify that `poly[0]` is not the identity point. [3](#0-2) 

Both v1 and v2 implementations add the validated `poly[0]` to compute the group key. [4](#0-3) [5](#0-4) 

Since adding the identity point is a no-op in elliptic curve arithmetic, the attacker contributes nothing to the group key while being counted as a valid participant.

The codebase validates that `PublicNonce` points are not identity points, [6](#0-5)  but no similar validation exists for `poly[0]` in polynomial commitments.

The state machine's DKG validation uses the same vulnerable validation path. [7](#0-6) 

The malicious party can also send zero private shares that pass validation because `Scalar::zero() * G == compute::poly(id, [Point::identity(), ...]) == Point::identity()`. [8](#0-7) 

## Impact Explanation

This vulnerability breaks the fundamental threshold security guarantee of WSTS. In a (T, N) threshold system where K malicious parties exploit this vulnerability:

- Only (N-K) honest parties actually contribute to the group key
- The system still requires T parties to sign
- If K ≥ N-T+1, then (N-K) < T, meaning fewer than T honest parties contributed
- Signatures require at least one malicious party's participation, or are impossible if malicious parties refuse to sign

In the worst case, if K ≥ T malicious parties exploit this, the threshold assumption is completely broken. For Bitcoin/Stacks multisig custody applications, this enables:

1. **Network shutdown**: If malicious parties refuse to sign after DKG, the network cannot process transactions requiring T signatures, even though T honest parties were supposed to be sufficient.

2. **Threshold reduction attack**: An attacker who participates in DKG with this exploit and later compromises only (T-K) honest parties can forge signatures, when they should need to compromise T honest parties.

3. **Direct loss of funds**: In multisig applications, this reduces the actual signing threshold below the configured security level, enabling theft by breaking the threshold assumption.

This maps to **Critical** severity as it enables "any network to shut down or otherwise not confirm new valid transactions" and "any causing the direct loss of funds."

## Likelihood Explanation

The attack has very high likelihood of success:

**Required Attacker Capabilities:**
- Must be an authorized DKG participant (within protocol threat model)
- Can send network messages during the DKG phase
- No cryptographic breaks or special computational resources required

**Attack Complexity:**
Low. The attacker constructs a malicious `PolyCommitment` with:
- `id.kG = Point::identity()`
- `id.kca = Scalar::zero()`
- `poly = vec![Point::identity(), ...]` (all coefficients can be identity)
- Private shares sent as `Scalar::zero()`

The p256k1 crate supports serialization of the identity point, so this message can be constructed and transmitted through normal protocol channels.

**Economic Feasibility:**
Extremely feasible - no additional costs beyond normal DKG participation. The attack is deterministic and succeeds 100% of the time once the malicious commitment is accepted.

**Detection Risk:**
Low. The malicious commitment appears valid to all verification checks. No current mechanism detects identity point commitments.

**Estimated Probability:**
Near 100% success rate if the attacker is a DKG participant.

## Recommendation

Add identity point validation in two locations:

1. **In `ID::verify()`**: Validate that `A` is not the identity point before performing the verification equation.

```rust
pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
    if *A == Point::identity() {
        return false;
    }
    let c = Self::challenge(&self.id, &self.kG, A, ctx);
    &self.kca * &G == &self.kG + c * A
}
```

2. **In `check_public_shares()`**: Validate that `poly[0]` is not the identity point.

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.poly[0] != Point::identity() 
        && poly_comm.verify(ctx) 
        && poly_comm.poly.len() == threshold
}
```

Additionally, consider validating that `self.kG` in the `ID` struct is not the identity point when constructing or deserializing ID proofs.

## Proof of Concept

```rust
#[test]
fn test_identity_point_bypass() {
    use crate::curve::{point::{Point, G}, scalar::Scalar};
    use crate::schnorr::ID;
    
    // Construct a malicious ID with identity point
    let malicious_id = ID {
        id: Scalar::from(1u32),
        kG: Point::identity(),
        kca: Scalar::zero(),
    };
    
    // The public key being "proven" is the identity point
    let A = Point::identity();
    let ctx = &[0u8; 8];
    
    // This verification should fail but currently passes
    assert!(malicious_id.verify(&A, ctx));
    
    // Demonstrate that this bypasses the proof requirement
    // A legitimate proof would require knowledge of the discrete log of A
    // But with identity point, anyone can create a "proof" without any secret
}
```

### Citations

**File:** src/schnorr.rs (L62-65)
```rust
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```

**File:** src/common.rs (L36-39)
```rust
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/v1.rs (L161-167)
```rust
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
```

**File:** src/v1.rs (L191-195)
```rust
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
```

**File:** src/v2.rs (L135-144)
```rust
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }
```

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```
