# Audit Report

## Title
Malicious DKG Signers Can Participate in Subsequent Rounds Due to Incomplete Exclusion Enforcement

## Summary
The FIRE coordinator maintains two separate tracking sets for malicious signers (`malicious_signer_ids` and `malicious_dkg_signer_ids`) but fails to enforce exclusion during DKG operations and only partially enforces it during signing. This allows signers detected as malicious during DKG to repeatedly participate in subsequent DKG and signing rounds, causing transient consensus failures.

## Finding Description

The FIRE coordinator tracks malicious signers in two separate `HashSet<u32>` fields: [1](#0-0) 

The saved state structure documents their intended purpose as tracking malicious signers during signing and DKG rounds respectively: [2](#0-1) 

When malicious DKG behavior is detected (bad public or private shares), the coordinator verifies reports and adds the malicious signer to `malicious_dkg_signer_ids`: [3](#0-2) 

The code comment explicitly documents that this set contains "all DKG signers who were ever malicious," indicating persistent tracking: [4](#0-3) 

However, enforcement is critically incomplete:

**During DKG public share gathering**, no malicious signer sets are checked: [5](#0-4) 

**During DKG private share gathering**, no malicious signer sets are checked: [6](#0-5) 

**During signing nonce gathering**, only `malicious_signer_ids` is checked, not `malicious_dkg_signer_ids`: [7](#0-6) 

The `reset()` function deliberately preserves both malicious signer sets across state resets, confirming they were intended to persist: [8](#0-7) 

Both sets are persisted in the coordinator's saved state and loaded upon recovery: [9](#0-8) 

This architectural inconsistency breaks the security guarantee that malicious signers should be excluded from protocol participation after detection.

### Attack Execution Path

1. Attacker controls one signer node within threshold-1 (allowed by threat model)
2. Attacker sends malformed DKG shares in round N
3. Other signers detect and report misbehavior via DkgEnd messages
4. Coordinator verifies reports and adds attacker to `malicious_dkg_signer_ids`
5. DKG fails with `DkgError::DkgEndFailure`
6. External system retries by calling `start_dkg_round()`
7. In round N+1, `gather_public_shares()` and `gather_private_shares()` don't check `malicious_dkg_signer_ids`
8. Attacker participates again and repeats the attack indefinitely
9. If DKG succeeds, `gather_nonces()` only checks `malicious_signer_ids`, allowing the DKG-malicious signer to participate in signing

## Impact Explanation

This vulnerability enables **transient consensus failures** (Medium severity):

1. **Repeated DKG Disruption**: Malicious signers can force repeated DKG failures, preventing establishment of the aggregate public key required for signing operations.

2. **Signing Delays**: Even if DKG succeeds, the malicious DKG signer can participate in signing and cause timeouts. The timeout handler marks signers as malicious and checks if sufficient non-malicious signers remain: [10](#0-9) 

However, this check only considers `malicious_signer_ids`, not `malicious_dkg_signer_ids`, allowing DKG-malicious signers to contribute to signing delays.

3. **Resource Exhaustion**: Multiple retry iterations compound delays, preventing timely operation completion.

The system can eventually recover through external Config modification, but experiences transient consensus failures during this period.

## Likelihood Explanation

**Probability: 95%+** - This is a deterministic design flaw requiring no cryptographic assumptions.

**Required Attacker Capabilities**:
- Control of one signer node (within protocol threat model of up to threshold-1 malicious signers)
- Ability to send malformed DKG messages through normal protocol interfaces
- Persistence across multiple rounds

**Attack Complexity**: Low
- No timing attacks or race conditions required
- No cryptographic primitive compromise needed
- Simple message manipulation through standard protocol flow
- Attacker's actions are detected and logged but not prevented from recurring

**Economic Feasibility**: High - requires only standard signer node access.

## Recommendation

Add malicious signer exclusion checks in DKG and signing operations:

1. **In `gather_public_shares()`**: Check both `malicious_signer_ids` and `malicious_dkg_signer_ids` before accepting shares
2. **In `gather_private_shares()`**: Check both malicious signer sets before accepting shares
3. **In `gather_nonces()`**: Check both `malicious_signer_ids` and `malicious_dkg_signer_ids` before accepting nonces
4. **In `gather_sig_shares()`**: Check both malicious signer sets before accepting signature shares

Example fix for `gather_public_shares()`:
```rust
fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
    if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
        // Add this check
        if self.malicious_dkg_signer_ids.contains(&dkg_public_shares.signer_id) 
            || self.malicious_signer_ids.contains(&dkg_public_shares.signer_id) {
            warn!(
                signer_id = %dkg_public_shares.signer_id,
                "Rejected DkgPublicShares from known malicious signer"
            );
            return Ok(());
        }
        // ... rest of existing logic
    }
    Ok(())
}
```

Apply similar checks to `gather_private_shares()`, `gather_nonces()`, and `gather_sig_shares()`.

## Proof of Concept

```rust
#[test]
fn malicious_dkg_signer_not_excluded() {
    use crate::state_machine::coordinator::{Coordinator as CoordinatorTrait, Config};
    use crate::v2::Aggregator;
    
    // Setup coordinator
    let mut coordinator = FireCoordinator::<Aggregator>::new(config);
    
    // Simulate malicious signer detection during DKG
    let malicious_signer_id = 1u32;
    coordinator.malicious_dkg_signer_ids.insert(malicious_signer_id);
    
    // Start new DKG round
    coordinator.start_dkg_round(None).unwrap();
    
    // Create DkgPublicShares from the malicious signer
    let malicious_shares = create_dkg_public_shares(malicious_signer_id);
    let packet = create_packet(malicious_shares);
    
    // Process the packet - it should be rejected but isn't
    coordinator.gather_public_shares(&packet).unwrap();
    
    // Verify the malicious signer's shares were accepted (vulnerability)
    assert!(coordinator.dkg_public_shares.contains_key(&malicious_signer_id));
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L64-65)
```rust
    malicious_signer_ids: HashSet<u32>,
    malicious_dkg_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L177-200)
```rust
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L525-565)
```rust
    fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
            info!(
                dkg_id = %dkg_private_shares.dkg_id,
                signer_id = %dkg_private_shares.signer_id,
                "DkgPrivateShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.private_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L601-603)
```rust
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1333-1334)
```rust
            malicious_signer_ids: state.malicious_signer_ids.clone(),
            malicious_dkg_signer_ids: state.malicious_dkg_signer_ids.clone(),
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```

**File:** src/state_machine/coordinator/mod.rs (L292-295)
```rust
    /// set of malicious signers during signing round
    pub malicious_signer_ids: HashSet<u32>,
    /// set of malicious signers during dkg round
    pub malicious_dkg_signer_ids: HashSet<u32>,
```
