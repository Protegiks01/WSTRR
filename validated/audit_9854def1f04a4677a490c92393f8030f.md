# Audit Report

## Title
Signature Share ID Spoofing Enables False Blame Assignment and Denial of Service

## Summary
The `Aggregator::check_signature_shares()` function uses the unvalidated `sig_share.id` field to identify malicious parties when signature aggregation fails. A malicious signer can spoof this field to frame innocent parties, as the coordinator only validates `sig_share.key_ids` but not the `id` field used for blame assignment. This enables false accusations that can lead to denial of service through wrongful exclusion of honest signers.

## Finding Description

The vulnerability stems from a validation gap where the field used for party identification during blame assignment is never authenticated.

**The Attack Flow:**

1. **Malicious Party Creates Spoofed Share**: A malicious signer constructs a `SignatureShare` with a victim's party ID in the `id` field while using their own cryptographic material (`z_i` computed with their private keys) and their legitimate `key_ids`. [1](#0-0) 

2. **Coordinator Validates Only `key_ids`**: When the coordinator receives the `SignatureShareResponse`, it validates that the union of all `key_ids` matches the expected keys for that signer, but never validates the `id` field. [2](#0-1) 

3. **Blame Uses Unvalidated `id`**: When signature verification fails, `check_signature_shares()` iterates through shares and uses `sig_shares[i].id` to identify which party provided the bad signature. For the malicious share with spoofed ID, it will check the signature equation using the victim's public key against the attacker's `z_i`, which will fail verification. [3](#0-2) 

4. **False Accusation**: The victim's party ID (from the spoofed `sig_shares[i].id`) is added to `bad_party_sigs` and returned in the error, falsely identifying an honest party as malicious. [4](#0-3) 

**Why This Breaks Security Guarantees:**

The WSTS library provides blame assignment functionality to identify malicious signers. The `AggregatorError::BadPartySigs(Vec<u32>)` error is specifically designed to communicate which parties submitted invalid shares. However, this information is unreliable because the party IDs are not validated against the authenticated sender identity. Integrators who reasonably rely on this error information to exclude malicious parties will inadvertently exclude honest parties instead.

## Impact Explanation

This vulnerability enables **Medium severity** impact as defined by "Any transient consensus failures."

**Direct Impact:**
- Honest signers are falsely identified as malicious through spoofed party IDs
- The actual malicious signer remains undetected since their real ID is not in the blame list

**Realistic Integration Impact:**
Integrators naturally use `BadPartySigs` errors to implement security measures such as temporarily excluding misbehaving parties from future signing rounds. When honest parties are falsely accused:

1. They may be excluded from subsequent signing attempts
2. Repeated attacks across multiple rounds progressively reduce available honest signers
3. When honest signers fall below the signing threshold, no valid signatures can be produced

**Transient Consensus Failure:**
The inability to produce signatures due to insufficient honest signers below threshold constitutes a transient consensus failure. The system temporarily cannot reach consensus on signatures, though it can potentially recover by adding new signers or correcting the exclusion list. This maps precisely to the Medium severity category.

**Concrete Example:**
In a 10-signer system with threshold 7:
- One malicious signer frames 3 honest signers per failed round
- After 2 rounds, only 4 honest signers remain available (10 - 3 - 3)
- Threshold of 7 cannot be met â†’ signature production halts

## Likelihood Explanation

**Likelihood: High**

**Attacker Requirements:**
- Be a legitimate protocol participant (within threshold-1 malicious signers)
- Ability to construct `SignatureShare` objects before sending to coordinator
- No cryptographic secrets or special privileges required

**Attack Execution:**
The attack is trivial to execute:
1. During normal signing, create `SignatureShare` with legitimate `z_i` and `key_ids`
2. Before sending, modify the public `id` field to point to victim's party ID
3. Submit the modified share to coordinator
4. When aggregation fails (naturally or deliberately induced by providing invalid `z_i`), victim is blamed

**Technical Feasibility:**
- `SignatureShare` fields are public and directly modifiable
- No cryptographic signatures protect the `id` field
- The coordinator's validation only checks `key_ids`, not `id`
- Detection is nearly impossible without external audit logs

**Economic Cost:**
Minimal - only requires normal protocol participation and a single field modification.

## Recommendation

**Immediate Fix:**
Add validation in the coordinator to ensure `sig_share.id` matches authenticated sender identity. In v2 architecture where signer_id equals party_id for honest implementations:

```rust
// In coordinator's SignatureShareResponse handler (frost.rs ~line 641)
for sig_share in &sig_share_response.signature_shares {
    if sig_share.id != sig_share_response.signer_id {
        warn!(
            signer_id = %sig_share_response.signer_id,
            claimed_id = %sig_share.id,
            "SignatureShare id doesn't match authenticated signer_id"
        );
        return Ok(());
    }
}
```

**Alternative Approach:**
Modify `check_signature_shares()` to accept an additional parameter mapping signature share indices to authenticated signer IDs, so blame assignment uses authenticated identity rather than unvalidated `id` field.

## Proof of Concept

```rust
#[test]
fn test_signature_share_id_spoofing() {
    use crate::v2::{Party, Aggregator};
    use crate::traits::Signer;
    use crate::common::SignatureShare;
    
    let num_signers = 3;
    let num_keys = 3;
    let threshold = 2;
    let mut rng = crate::util::create_rng();
    
    // Setup honest parties 0, 1, 2
    let mut parties: Vec<Party> = (0..num_signers)
        .map(|i| Party::new(i, &[i], num_signers, num_keys, threshold, &mut rng))
        .collect();
    
    // DKG
    let polys = crate::traits::test_helpers::dkg(&mut parties, &mut rng).unwrap();
    
    // Generate nonces
    let network_key = crate::curve::scalar::Scalar::from(1);
    let nonces: Vec<_> = parties.iter_mut()
        .map(|p| p.gen_nonces(&network_key, &mut rng)[0].clone())
        .collect();
    
    let msg = b"test message";
    let signer_ids = vec![0, 1];
    let key_ids = vec![0, 1];
    
    // Party 0 signs honestly
    let honest_share = parties[0].sign(msg, &signer_ids, &key_ids, &nonces[..2])[0].clone();
    
    // Party 1 signs but SPOOFS party 2's ID
    let mut malicious_share = parties[1].sign(msg, &signer_ids, &key_ids, &nonces[..2])[0].clone();
    malicious_share.id = 2;  // Spoof victim's ID
    malicious_share.z_i += crate::curve::scalar::Scalar::from(1); // Make it invalid
    
    // Aggregate
    let mut aggregator = Aggregator::new(num_keys, threshold);
    aggregator.init(&polys).unwrap();
    
    let result = aggregator.sign(
        msg,
        &nonces[..2],
        &[honest_share, malicious_share],
        &key_ids,
    );
    
    // Verify victim (party 2) is falsely blamed
    if let Err(crate::errors::AggregatorError::BadPartySigs(bad_parties)) = result {
        assert!(bad_parties.contains(&2), "Victim party 2 should be falsely blamed");
        assert!(!bad_parties.contains(&1), "Actual malicious party 1 escapes blame");
    } else {
        panic!("Expected BadPartySigs error");
    }
}
```

This test demonstrates that party 1 can frame party 2 by spoofing the `id` field, causing party 2 to be incorrectly identified in the `BadPartySigs` error while party 1 escapes detection.

### Citations

**File:** src/common.rs (L213-220)
```rust
pub struct SignatureShare {
    /// The ID of the party
    pub id: u32,
    /// The party signature
    pub z_i: Scalar,
    /// The key IDs of the party
    pub key_ids: Vec<u32>,
}
```

**File:** src/state_machine/coordinator/frost.rs (L631-640)
```rust
            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
```

**File:** src/v2.rs (L389-413)
```rust
        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
```
