# Audit Report

## Title
Duplicate Key IDs in NonceResponse Bypass Validation and Cause Invalid Lagrange Interpolation

## Summary
A malicious signer can send a NonceResponse with duplicate key_ids that bypasses the coordinator's validation by exploiting HashSet conversion. The duplicates propagate to all signers, causing incorrect Lagrange interpolation coefficients and resulting in all signature shares being invalid. This creates a complete denial of service where a single malicious signer prevents any signatures from being produced.

## Finding Description

**Root Cause - Lambda Function Without Deduplication:**

The Lagrange interpolation function computes coefficients by iterating over all key_ids without deduplication: [1](#0-0) 

When key_ids contains duplicates, the lambda value is multiplied by duplicate factors. For example, computing λ₂ for key_ids=[1, 1, 2]:
- Loop iteration 1 (j=1): multiply by 1/(1-2) = -1
- Loop iteration 2 (j=1 again): multiply by 1/(1-2) = -1  
- Loop iteration 3 (j=2): skip (i==j)
- Result: (-1) × (-1) = 1 instead of the correct -1

**Validation Bypass via HashSet Conversion:**

Both FIRE and FROST coordinators validate NonceResponse key_ids by converting to HashSet: [2](#0-1) [3](#0-2) 

If a malicious signer sends key_ids=[1, 1, 2], it becomes {1, 2} for validation and passes if configured signer_key_ids={1, 2}. However, the original NonceResponse with duplicates is stored: [4](#0-3) [5](#0-4) 

**Duplicate Propagation to All Signers:**

The coordinator constructs SignatureShareRequest by collecting nonce_responses and flat_mapping their key_ids without deduplication: [6](#0-5) 

All signers receive this request and extract key_ids via flat_map: [7](#0-6) 

**Invalid Signature Share Computation:**

Signers pass the duplicate-containing key_ids to their sign functions: [8](#0-7) 

In Party::sign_with_tweak, each signer computes lambda with the duplicate key_ids: [9](#0-8) 

This causes all honest signers to compute incorrect lambda values, making all signature shares invalid.

**Detection Without Prevention:**

The aggregator detects the invalid signature and calls check_signature_shares: [10](#0-9) 

However, check_signature_shares also uses the same duplicate key_ids for lambda computation: [11](#0-10) 

Since both signature creation and verification use the same incorrect lambda values, individual signature shares may appear valid to the check, but the aggregated signature remains invalid. The check_signature_shares function returns BadGroupSig without identifying specific bad parties: [12](#0-11) 

The entire signing round is wasted with no ability to identify and exclude the malicious signer.

## Impact Explanation

This vulnerability enables a complete denial of service against the WSTS signing protocol:

- **100% Failure Rate**: Every signing round fails when the malicious signer participates
- **All Participants Affected**: Honest signers waste computational resources generating invalid signature shares
- **Persistent DoS**: The attack continues indefinitely as long as the malicious signer participates
- **System Unavailability**: The system becomes unable to produce any valid signatures
- **No Mitigation**: The coordinator cannot identify the malicious party to exclude them

This qualifies as **Low severity** per the scope definition: "Any remotely-exploitable denial of service in a node." If the WSTS deployment controls more than 10% of miners, this could escalate to **Medium severity**: "Any network denial of service impacting more than 10 percent of miners that does not shut down the network."

## Likelihood Explanation

**Attacker Capabilities**: The attacker must be a registered signer in the WSTS protocol with the ability to send NonceResponse messages. This is within the protocol's threat model (malicious signers up to threshold-1).

**Attack Complexity**: Trivial. The attacker simply modifies their NonceResponse to include duplicate key_ids (e.g., changing [1, 2] to [1, 1, 2]).

**Economic Feasibility**: Extremely low cost. Sending a single modified network message causes indefinite denial of service.

**Detection Risk**: Medium. The attack is detected when signature verification fails, but the root cause may be difficult to diagnose without detailed logging, and the system cannot identify which party is responsible.

**Probability of Success**: 100%. The validation bypass is guaranteed due to the HashSet conversion, and all signature shares will be computed with incorrect lambda values.

## Recommendation

Add validation to reject NonceResponse messages containing duplicate key_ids:

```rust
// In gather_nonces function, after line 885 (fire.rs) / line 517 (frost.rs)
let nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

// Add duplicate check BEFORE comparing to config
if nonce_response_key_ids.len() != nonce_response.key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response contains duplicate key_ids");
    return Ok(());
}

if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

Alternatively, deduplicate key_ids in the lambda function or when extracting them via flat_map, though rejecting at validation is cleaner.

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_lambda_calculation() {
    use wsts::compute::lambda;
    
    // Correct lambda calculation with no duplicates
    let key_ids_correct = vec![1, 2];
    let lambda_2_correct = lambda(2, &key_ids_correct);
    
    // Lambda calculation with duplicate key_ids
    let key_ids_duplicate = vec![1, 1, 2];
    let lambda_2_duplicate = lambda(2, &key_ids_duplicate);
    
    // The values should be different, proving the bug
    assert_ne!(lambda_2_correct, lambda_2_duplicate);
    
    // Verify the incorrect value
    // lambda(2, [1,2]) should be 1/(1-2) = -1
    // lambda(2, [1,1,2]) incorrectly becomes 1/(1-2) * 1/(1-2) = 1
    println!("Correct lambda(2, [1,2]): {:?}", lambda_2_correct);
    println!("Incorrect lambda(2, [1,1,2]): {:?}", lambda_2_duplicate);
}
```

This test demonstrates that duplicate key_ids cause the lambda function to compute incorrect Lagrange interpolation coefficients, which invalidates all signature shares.

## Notes

The vulnerability affects all three signature types (FROST, Schnorr, Taproot) as they all use the same lambda computation path. The impact is severe because the system cannot recover or identify the malicious party, leading to persistent denial of service requiring manual intervention or out-of-band coordination to exclude the malicious signer.

### Citations

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L542-543)
```rust
            self.public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L808-818)
```rust
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L403-403)
```rust
                cx += compute::lambda(*key_id, key_ids) * c * public_key;
```

**File:** src/v2.rs (L410-416)
```rust
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
        } else {
            AggregatorError::BadGroupSig
        }
```

**File:** src/v2.rs (L457-461)
```rust
        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```
