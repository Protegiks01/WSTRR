# Audit Report

## Title
Unauthenticated KEX Public Key Allows Private Share Decryption via Low-Order Point Attack

## Summary
The `kex_public_key` field in `DkgPublicShares` messages is not authenticated by the message signature, allowing a network adversary to replace it with `Point::identity()`. This causes all private shares encrypted for the victim to use a constant, publicly-computable shared secret, enabling complete decryption and reconstruction of the group secret key.

## Finding Description

The vulnerability stems from a critical authentication gap in the DKG protocol's encrypted share distribution mechanism. The attack exploits two fundamental flaws:

**1. Missing Authentication**

The `Signable` implementation for `DkgPublicShares` only includes `dkg_id`, `signer_id`, and `comms` in the signature hash, completely omitting `kex_public_key`: [1](#0-0) 

This allows an attacker to modify `kex_public_key` without invalidating the message signature. The modified packet passes signature verification during packet processing: [2](#0-1) 

**2. Missing Validation**

When `DkgPublicShares` messages are received, the `kex_public_key` is stored directly without any validation: [3](#0-2) 

Unlike `PublicNonce` which explicitly validates against `Point::identity()`: [4](#0-3) 

No such protection exists for `kex_public_key`.

**Attack Execution**

A man-in-the-middle attacker intercepts a legitimate `DkgPublicShares` message and replaces the victim's `kex_public_key` with `Point::identity()`. When other signers encrypt private shares for the victim, they retrieve the compromised key and compute the shared secret: [5](#0-4) 

The `make_shared_secret` function performs Diffie-Hellman without validation: [6](#0-5) 

When `public_key = Point::identity()`, the computation yields `shared_key = private_key * Point::identity() = Point::identity()`, and the shared secret becomes a constant value derived from `Point::identity()`, which anyone can compute. This allows the attacker to decrypt all shares sent to the victim using standard AES-GCM decryption.

On the receiving side, the victim's signer uses the same mechanism to decrypt shares: [7](#0-6) 

**Secret Reconstruction**

Each decrypted share reveals polynomial evaluations for the victim's key IDs. By compromising threshold number of parties' KEX keys via this attack, the attacker obtains threshold secrets. Using Lagrange interpolation (implemented in the compute module), the attacker reconstructs the group secret and can forge signatures without any honest participation. [8](#0-7) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability completely breaks the fundamental security guarantee of the threshold signature scheme. The impact maps directly to the Critical severity category:

1. **"Any confirmation of an invalid transaction"** - With the reconstructed group secret, the attacker can forge valid signatures on arbitrary messages without threshold participation, allowing confirmation of fraudulent transactions.

2. **"Any causing the direct loss of funds"** - In systems using WSTS for custody (e.g., Bitcoin multisig, Stacks STX pools), the compromised group key enables the attacker to create valid spending transactions and steal all protected funds.

3. **Threshold Security Violation** - The core property that at least `t` honest parties must participate in signing is completely bypassed. The attacker gains unilateral signing capability, equivalent to having compromised all threshold parties simultaneously.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities (Within Threat Model)**

The attack requires only network-level message observation and modification. No signature forgery is needed because `kex_public_key` is unauthenticated. This is within the documented threat model for network adversaries.

**Attack Complexity: LOW**

- No cryptographic breaks required (secp256k1, SHA-256, AES-GCM remain secure)
- Simple field replacement in intercepted messages
- Computing `Point::identity()` is trivial
- Deriving the constant shared secret requires only standard cryptographic operations
- Lagrange interpolation is a well-known algorithm

**Detection Risk: LOW**

The attack is difficult to detect because:
- Modified messages pass signature verification (as verified in code)
- Encryption/decryption operations complete successfully
- No error conditions are triggered
- The victim may not realize their shares are compromised until after DKG completes

**Economic Feasibility: HIGH**

- Requires only network-level access (no specialized hardware)
- Can be executed in a single DKG round
- Success probability approaches 100% given the complete lack of validation

## Recommendation

**1. Add `kex_public_key` to Signable Hash**

Modify the `Signable` implementation for `DkgPublicShares` to include `kex_public_key`:

```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        hasher.update(self.kex_public_key.compress().as_bytes()); // ADD THIS LINE
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**2. Add Point Validation**

Add validation when storing `kex_public_key` in the signer's `dkg_public_share` method:

```rust
// Validate kex_public_key is not identity or generator
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    warn!(%signer_id, "Invalid KEX public key (identity or generator)");
    return Ok(vec![]);
}
```

**3. Add Validation in make_shared_secret**

Add a validation check in the `make_shared_secret` function:

```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> Result<[u8; 32], Error> {
    if public_key == &Point::identity() || public_key == &G {
        return Err(Error::InvalidPublicKey);
    }
    let shared_key = private_key * public_key;
    Ok(make_shared_secret_from_key(&shared_key))
}
```

## Proof of Concept

```rust
#[test]
fn test_unauthenticated_kex_key_attack() {
    use crate::curve::point::Point;
    use crate::net::{DkgPublicShares, Signable};
    use crate::util::make_shared_secret;
    use crate::curve::scalar::Scalar;
    use rand_core::OsRng;
    
    // Create a legitimate DkgPublicShares message
    let mut rng = OsRng;
    let private_key = Scalar::random(&mut rng);
    let legitimate_kex_key = Point::from(Scalar::random(&mut rng));
    
    let mut msg = DkgPublicShares {
        dkg_id: 1,
        signer_id: 0,
        comms: vec![],
        kex_public_key: legitimate_kex_key,
    };
    
    // Sign the message
    let sig1 = msg.sign(&private_key).unwrap();
    
    // Attack: Replace kex_public_key with Point::identity()
    msg.kex_public_key = Point::identity();
    
    // The signature still verifies! (vulnerability)
    let public_key = crate::curve::ecdsa::PublicKey::new(&private_key).unwrap();
    assert!(msg.verify(&sig1, &public_key));
    
    // Now compute shared secret with identity point
    let sender_private = Scalar::random(&mut rng);
    let shared_secret_attacker = make_shared_secret(&sender_private, &Point::identity());
    let shared_secret_victim = make_shared_secret(&sender_private, &msg.kex_public_key);
    
    // Both produce the same constant value
    assert_eq!(shared_secret_attacker, shared_secret_victim);
    
    // This constant can be computed by anyone knowing Point::identity()
    // enabling decryption of all shares encrypted for the victim
}
```

## Notes

This vulnerability represents a fundamental breach of the DKG protocol's security model. The attack is practical, requires only network-level access, and completely bypasses the threshold signature guarantee. The lack of authentication on `kex_public_key` combined with the absence of point validation creates a critical attack vector that allows unilateral signature forgery capability.

### Citations

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/compute.rs (L69-79)
```rust
/// Compute the Lagrange interpolation value
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
```
