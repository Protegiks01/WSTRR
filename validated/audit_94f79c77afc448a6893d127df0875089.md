# Audit Report

## Title
Insufficient Validation of Reported Signer IDs in DKG Failure Reports Enables Denial of Service

## Summary
The coordinator's `gather_dkg_end` function fails to validate that signer IDs contained within `DkgFailure` reports reference legitimate participants. In FROST, no validation occurs for any failure type. In FIRE, only `BadPublicShares` and `BadPrivateShares` are validated, while `MissingPublicShares` and `MissingPrivateShares` accept arbitrary signer IDs. This allows a malicious participant to inject false failure reports, causing DKG to fail indefinitely without detection.

## Finding Description

The vulnerability exists because coordinators validate the **reporting** signer ID but not the **reported** signer IDs contained within `DkgFailure` enum values.

**FROST Coordinator:**

The `gather_dkg_end` function validates that the reporting signer is legitimate: [1](#0-0) 

However, when processing failure reports, it simply clones all failures without validating the signer IDs contained within them: [2](#0-1) 

The function returns with an empty `malicious_signers` set, providing no attribution: [3](#0-2) 

**FIRE Coordinator:**

Similarly validates the reporting signer: [4](#0-3) 

For `BadPublicShares`, validation occurs by checking if reported signers actually exist: [5](#0-4) 

For `BadPrivateShares`, extensive cryptographic validation occurs: [6](#0-5) 

However, `MissingPublicShares` and `MissingPrivateShares` have only placeholder comments with no validation: [7](#0-6) 

**Attack Scenario:**

A malicious DKG participant can craft a `DkgEnd` message with `DkgStatus::Failure(DkgFailure::MissingPublicShares([999999, 888888]))` where the reported signer IDs don't exist in the protocol. The coordinator accepts this because the reporting signer ID is valid, but never validates that 999999 or 888888 are legitimate participants. This causes DKG to fail at the error return point: [8](#0-7) 

The malicious signer is never marked in `malicious_signers`, allowing repeated attacks.

## Impact Explanation

This vulnerability enables a denial of service attack on the DKG protocol. A single malicious participant can prevent DKG completion indefinitely by reporting false failures with arbitrary signer IDs. This breaks the following security guarantees:

1. **DKG Liveness**: The protocol should complete DKG when sufficient honest participants are present
2. **Malicious Actor Detection**: The protocol should identify and exclude malicious actors

The impact severity is **Low** under the defined scope as it qualifies as "any remotely-exploitable denial of service in a node." The attack prevents aggregate public key generation, which blocks all subsequent threshold signature operations dependent on that coordinator group.

Quantified impact:
- **FROST**: 100% DKG failure rate with zero detection capability
- **FIRE**: Partial - attacker can use `MissingPublicShares`/`MissingPrivateShares` without detection

## Likelihood Explanation

The likelihood is **High** because:

**Attacker Requirements:**
- Must be an authorized DKG participant with valid signer ID (within protocol threat model)
- Must control their signer implementation to craft malicious messages
- No cryptographic operations or special network position required

**Attack Complexity:**
1. Participate normally through DKG public shares phase (validated at lines 486-491 in fire.rs, 299-304 in frost.rs)
2. Participate normally through DKG private shares phase (validated at lines 534-539 in fire.rs, 345-350 in frost.rs)
3. Upon receiving `DkgEndBegin`, send `DkgEnd` with fabricated failure containing arbitrary signer IDs
4. Coordinator accepts message since reporter ID is valid
5. DKG fails without marking the malicious reporter
6. Repeat indefinitely

The attack requires no special timing, race conditions, or cryptographic operations. Detection risk is zero in FROST and minimal in FIRE for the unvalidated failure types.

## Recommendation

Implement validation of reported signer IDs in all `DkgFailure` variants:

**For FROST coordinator**, add validation in `gather_dkg_end`:
```rust
for (signer_id, dkg_end) in &self.dkg_end_messages {
    if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
        // Validate reported signer IDs
        let reported_ids: HashSet<u32> = match dkg_failure {
            DkgFailure::MissingPublicShares(ids) => ids.clone(),
            DkgFailure::BadPublicShares(ids) => ids.clone(),
            DkgFailure::MissingPrivateShares(ids) => ids.clone(),
            DkgFailure::BadPrivateShares(map) => map.keys().cloned().collect(),
            _ => HashSet::new(),
        };
        
        for reported_id in reported_ids {
            if !self.config.public_keys.signers.contains_key(&reported_id) {
                warn!("Signer {signer_id} reported invalid signer ID {reported_id}, marking as malicious");
                malicious_signers.insert(*signer_id);
                continue;
            }
        }
        
        reported_failures.insert(*signer_id, dkg_failure.clone());
    }
}
```

**For FIRE coordinator**, complete the TODO at lines 765-770:
```rust
DkgFailure::MissingPublicShares(missing_ids) => {
    for missing_id in missing_ids {
        if !self.config.public_keys.signers.contains_key(missing_id) {
            warn!("Signer {signer_id} reported non-existent signer {missing_id} as missing, marking {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        }
    }
}
DkgFailure::MissingPrivateShares(missing_ids) => {
    for missing_id in missing_ids {
        if !self.config.public_keys.signers.contains_key(missing_id) {
            warn!("Signer {signer_id} reported non-existent signer {missing_id} as missing, marking {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_malicious_dkg_failure_report_with_invalid_signer_ids() {
    // Setup coordinator with 3 signers (IDs 0, 1, 2)
    let mut coordinator = setup_frost_coordinator(3, 2);
    coordinator.start_dkg_round(None).unwrap();
    
    // Signers 0, 1, 2 send valid DkgPublicShares and DkgPrivateShares
    // ... (normal DKG flow)
    
    // Malicious signer 0 sends DkgEnd with false failure report
    let malicious_dkg_end = DkgEnd {
        dkg_id: coordinator.current_dkg_id,
        signer_id: 0, // Valid reporter ID
        status: DkgStatus::Failure(
            DkgFailure::MissingPublicShares(
                HashSet::from([999999, 888888]) // Non-existent signer IDs
            )
        ),
    };
    
    let packet = Packet {
        sig: malicious_dkg_end.sign(&signer_keys[0]).unwrap(),
        msg: Message::DkgEnd(malicious_dkg_end),
    };
    
    // Process the malicious message
    let result = coordinator.process(&packet);
    
    // Verify DKG fails
    assert!(matches!(result, Ok((None, Some(OperationResult::DkgError(_))))));
    
    // Verify malicious signer is NOT marked (vulnerability)
    if let Ok((_, Some(OperationResult::DkgError(DkgError::DkgEndFailure { 
        malicious_signers, .. 
    })))) = result {
        assert!(malicious_signers.is_empty()); // BUG: should contain signer 0
    }
}
```

### Citations

**File:** src/state_machine/coordinator/frost.rs (L387-387)
```rust
            if self.ids_to_await.contains(&dkg_end.signer_id) {
```

**File:** src/state_machine/coordinator/frost.rs (L403-408)
```rust
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }
```

**File:** src/state_machine/coordinator/frost.rs (L413-416)
```rust
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
```

**File:** src/state_machine/coordinator/fire.rs (L581-581)
```rust
            if self.dkg_wait_signer_ids.contains(&dkg_end.signer_id) {
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L785-788)
```rust
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```
