# Audit Report

## Title
DKG Round ID Not Validated in Signer's dkg_public_share() Enabling Replay/Framing Attacks

## Summary
The signer's `dkg_public_share()` method fails to validate that incoming `DkgPublicShares` messages match the current DKG round ID (`dkg_id`), unlike both coordinator implementations. This allows network adversaries to replay legitimately-signed messages from previous DKG rounds, causing verification failures that blame innocent parties and result in DKG failure.

## Finding Description

The signer's `dkg_public_share()` method processes `DkgPublicShares` messages with only basic validation—signer ID existence, party ID ownership, and duplicate detection—but never verifies that the message's `dkg_id` matches the current round. [1](#0-0) 

In contrast, both coordinators properly validate the `dkg_id` field. The FROST coordinator rejects mismatched IDs: [2](#0-1) 

The FIRE coordinator has identical validation: [3](#0-2) 

**Attack Mechanism:**

A network adversary can capture valid `DkgPublicShares` messages from DKG round N and replay them during round M. The signer accepts and stores the replayed message using first-come-first-served semantics. When the legitimate round M message arrives, it's rejected as a duplicate. [4](#0-3) 

During `dkg_ended()`, the stored shares are verified using the current round's `dkg_id` as cryptographic context: [5](#0-4) 

The verification chain passes the context through to Schnorr ID proof verification: [6](#0-5) [7](#0-6) [8](#0-7) 

The Schnorr challenge computation includes the context parameter: [9](#0-8) 

Since the replayed share was created with context N but verified with context M, the challenge values differ and verification fails. The signer then reports `DkgFailure::BadPublicShares` identifying the innocent original sender: [10](#0-9) 

**Why Existing Protections Fail:**

Packet signature verification validates sender identity but not round ID. The `DkgPublicShares` message includes `dkg_id` in its signature hash: [11](#0-10) 

This means old messages remain validly signed. The `Packet::verify()` method only checks the signature against the sender's public key: [12](#0-11) 

The signer's message processing routes `DkgPublicShares` directly to the handler without state-based filtering: [13](#0-12) 

This breaks the security guarantee that DKG rounds are isolated and only accept messages intended for the current round.

## Impact Explanation

This vulnerability enables **Low severity denial of service** attacks:

- **DKG Failure**: Replayed shares fail cryptographic verification, causing the signer to abort DKG with `BadPublicShares` failure
- **Framing Attack**: The innocent original sender is falsely identified as malicious, potentially leading to their permanent exclusion
- **Persistent DoS**: The attack can be repeated across all subsequent DKG rounds, permanently preventing key generation
- **Node-Level Impact**: Each signer processes messages independently, so attackers can target individual nodes

This aligns with the defined Low severity scope: "Any remotely-exploitable denial of service in a node." If coordinated against multiple nodes, it could escalate to network-level impact.

## Likelihood Explanation

This attack is **highly likely** within the WSTS threat model:

**Attacker Capabilities (All Within Threat Model):**
- Network adversary position to observe protocol messages
- Ability to delay or reorder messages (standard network adversary capability)
- No signature forgery required (uses legitimate old signatures)
- No cryptographic breaks required
- No private key access required

**Attack Simplicity:**
1. Passively observe and save `DkgPublicShares` messages during any successful DKG round
2. Replay saved messages to victim signers during subsequent rounds before legitimate messages arrive
3. Minimal resources required (message storage and network position)

**Detection Difficulty:** The attack uses legitimately-signed messages, making it indistinguishable from benign network delays until verification fails.

## Recommendation

Add `dkg_id` validation in the signer's `dkg_public_share()` method to match the coordinator implementations:

```rust
pub fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Add dkg_id validation
    if dkg_public_shares.dkg_id != self.dkg_id {
        return Err(Error::BadDkgId(
            dkg_public_shares.dkg_id,
            self.dkg_id,
        ));
    }
    
    // ... existing validation logic ...
}
```

This ensures DKG round isolation by rejecting messages from previous or future rounds, preventing replay attacks and maintaining consistency with coordinator behavior.

## Proof of Concept

```rust
#[test]
fn test_dkg_round_id_replay_attack() {
    use crate::v2;
    let mut rng = create_rng();
    
    // Create signer for DKG round 1
    let mut signer = Signer::<v2::Signer>::new(
        /* threshold */ 3,
        /* num_signers */ 3,
        /* num_keys */ 4,
        /* dkg_threshold */ 4,
        /* signer_id */ 0,
        /* key_ids */ vec![1],
        /* public_keys */ Default::default(),
        /* coordinator_public_key */ Default::default(),
        &mut rng,
    ).unwrap();
    
    signer.dkg_id = 1;
    
    // Create valid DkgPublicShares for round 1
    let shares_round_1 = DkgPublicShares {
        dkg_id: 1,
        signer_id: 1,
        comms: vec![],
        kex_public_key: Point::generator().clone(),
    };
    
    // Accept message in round 1 (should succeed)
    assert!(signer.dkg_public_share(&shares_round_1).is_ok());
    
    // Move to round 2
    signer.dkg_id = 2;
    signer.dkg_public_shares.clear();
    
    // Replay old round 1 message in round 2
    // BUG: This should fail but currently succeeds
    let result = signer.dkg_public_share(&shares_round_1);
    
    // Should return Error::BadDkgId but doesn't (vulnerability!)
    assert!(result.is_ok()); // Currently passes - THIS IS THE BUG
    
    // The replayed message gets stored
    assert!(signer.dkg_public_shares.contains_key(&1));
    
    // Later verification with round 2 context will fail,
    // causing the innocent signer 1 to be blamed
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L471-477)
```rust
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
```

**File:** src/state_machine/signer/mod.rs (L557-558)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
```

**File:** src/state_machine/signer/mod.rs (L593-598)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/frost.rs (L292-297)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/state_machine/coordinator/fire.rs (L479-484)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/common.rs (L37-38)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
```

**File:** src/common.rs (L319-320)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
```

**File:** src/schnorr.rs (L55-58)
```rust
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
```

**File:** src/schnorr.rs (L62-64)
```rust
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
```

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/net.rs (L526-538)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
```
