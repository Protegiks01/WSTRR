# Audit Report

## Title
Duplicate key_ids in NonceResponse Bypass HashSet Validation, Causing Denial of Service via Incorrect Lagrange Interpolation

## Summary
A malicious signer can inject duplicate key_ids into their NonceResponse message, bypassing the coordinator's HashSet-based validation. These duplicates propagate through the signing protocol and cause all signers to compute incorrect Lagrange interpolation coefficients, resulting in guaranteed signature verification failure. This enables a single malicious signer to perform a persistent denial of service attack on the threshold signature system.

## Finding Description

The vulnerability exists in the coordinator's validation of NonceResponse messages during the nonce gathering phase. The coordinator validates that a signer's key_ids match their configured keys by converting the incoming Vec<u32> to a HashSet before comparison. [1](#0-0) 

This validation allows a malicious NonceResponse with key_ids = [1, 1, 2, 3] to pass when the configuration expects {1, 2, 3}, because the HashSet conversion silently removes duplicates during the equality check. However, the original NonceResponse with duplicates intact is stored in the coordinator's state. [2](#0-1) 

When the coordinator constructs the SignatureShareRequest after collecting sufficient nonces, it extracts all stored NonceResponse objects and includes them in the request message. [3](#0-2) 

Each signer receives this SignatureShareRequest and extracts the key_ids by flattening all nonce_responses using flat_map, which preserves any duplicate key_ids present in the original messages. [4](#0-3) 

The critical failure occurs in the Lagrange coefficient computation. When a signer computes their signature share, they call the lambda function for each of their keys, passing the full key_ids list (now containing duplicates). [5](#0-4) 

The lambda function iterates over all elements in the key_ids slice without checking for uniqueness. [6](#0-5) 

If a key_id appears multiple times (e.g., [1, 1, 2, 3]), the function multiplies by the same factor multiple times, producing incorrect Lagrange coefficients. For lambda(2, [1, 1, 2, 3]):
- j=1 (first): lambda *= 1/(1-2) = -1
- j=1 (duplicate): lambda *= 1/(1-2) = 1 (sign flips!)
- j=3: lambda *= 3/(3-2) = 3

The correct value lambda(2, [1, 2, 3]) = -3 becomes 3 with duplicates—both sign and magnitude are incorrect.

Since ALL signers receive the same SignatureShareRequest with duplicated key_ids, ALL signers compute their signature shares using these incorrect Lagrange coefficients. When the coordinator aggregates these shares, the resulting signature is mathematically invalid and will fail verification. [7](#0-6) 

The existing validate_key_id function only checks individual key_id ranges, not uniqueness within a collection. [8](#0-7) 

## Impact Explanation

This vulnerability enables a single malicious signer to execute a persistent denial of service attack against the threshold signature system with the following characteristics:

1. **Immediate Impact**: 100% signature verification failure while the malicious signer participates in any signing round
2. **No Detection**: The coordinator cannot identify which signer injected the malicious NonceResponse, as the validation passed and all signers produce shares that appear structurally valid
3. **No Automatic Exclusion**: The malicious signer remains in future signing rounds unless manually identified and removed from the configuration
4. **Resource Waste**: All honest signers expend computational resources generating signature shares that are guaranteed to produce an invalid aggregate signature

According to the provided severity scope, this maps to **Low** severity: "Any remotely-exploitable denial of service in a node." The severity could escalate depending on integration context—if WSTS signatures are required for Stacks blockchain transaction confirmation and this prevents network-wide transaction processing, it could reach **Critical** severity under "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

The threshold signature scheme is designed to tolerate up to threshold-1 malicious signers through mathematical guarantees. However, this vulnerability allows a single malicious signer (which is within the threshold-1 bound for any threshold ≥ 2) to cause complete signing failure through a validation bypass, violating the protocol's core liveness guarantee.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Control of a single signer's signing key (through compromise or Byzantine behavior within the expected threat model)
- Ability to construct and send NonceResponse messages with modified key_ids field
- No cryptographic breaks, zero-days, or social engineering required

**Attack Complexity:** Very low. The attacker modifies their NonceResponse construction to include duplicate key_ids before transmission. Example: changing `key_ids: vec![1, 2, 3]` to `key_ids: vec![1, 1, 2, 3]`. The serialization format (Serde) preserves Vec duplicates, and no subsequent validation checks for uniqueness.

**Detection Risk:** None. The HashSet-based validation explicitly allows the malicious message through, and there is no post-failure mechanism to identify which NonceResponse contained invalid data. The coordinator only sees that signature verification failed, with no attribution to any specific signer.

**Estimated Probability:** High. Any signer that becomes compromised or exhibits Byzantine behavior can execute this attack with 100% deterministic success. The attack persists across multiple signing rounds until the malicious signer is manually identified and removed from the configuration, which requires out-of-band investigation.

## Recommendation

Add explicit validation to reject NonceResponse messages containing duplicate key_ids. The fix should occur at the earliest point in the validation chain, immediately after receiving the NonceResponse and before the HashSet conversion.

**Recommended fix in src/state_machine/coordinator/fire.rs (around line 880):**

```rust
// Check for duplicate key_ids before validation
let mut key_id_dedup_check = HashSet::with_capacity(nonce_response.key_ids.len());
for key_id in &nonce_response.key_ids {
    if !key_id_dedup_check.insert(*key_id) {
        warn!(
            signer_id = %nonce_response.signer_id, 
            "Nonce response contains duplicate key_ids"
        );
        return Ok(());
    }
}

// Existing validation continues
let nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();
if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

The same fix should be applied to the FROST coordinator implementation in src/state_machine/coordinator/frost.rs with identical logic.

Additionally, consider adding a defensive check in the lambda function itself to detect and reject duplicate inputs, though the primary fix should be at the validation layer to fail fast.

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_cause_incorrect_lambda() {
    use crate::compute::lambda;
    
    // Correct Lagrange coefficient for key_id=2 with keys [1,2,3]
    let correct_lambda = lambda(2, &[1, 2, 3]);
    
    // Incorrect Lagrange coefficient with duplicate key_id=1
    let incorrect_lambda = lambda(2, &[1, 1, 2, 3]);
    
    // The duplicate causes incorrect computation
    assert_ne!(correct_lambda, incorrect_lambda);
    
    // The mathematical values differ: correct=-3, incorrect=3
    // Both magnitude and sign are wrong
    println!("Correct lambda(2, [1,2,3]): {}", correct_lambda);
    println!("Incorrect lambda(2, [1,1,2,3]): {}", incorrect_lambda);
}
```

This test demonstrates that the lambda function produces mathematically incorrect Lagrange coefficients when given duplicate key_ids, which is the root cause of signature verification failure in the attack scenario.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-977)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/common.rs (L314-316)
```rust
pub fn validate_key_id(key_id: u32, num_keys: u32) -> bool {
    key_id > 0 && key_id <= num_keys
}
```
