# Audit Report

## Title
Incorrect Threshold Check After Marking Signers Malicious Causes Persistent Denial of Service

## Summary
The FIRE coordinator's signature share timeout handler uses the configured total number of keys (`config.num_keys`) instead of the actual number of keys that completed DKG when checking if sufficient non-malicious signers remain. This causes the coordinator to incorrectly retry signature rounds that cannot succeed, leading to a persistent denial of service where no signatures can be produced until manual restart.

## Finding Description
The vulnerability exists in the `process_timeout` function when handling signature share timeouts. When a timeout occurs in the `SigShareGather` state, the coordinator marks all non-responding signers as malicious and then performs a threshold check to determine if signing can continue. [1](#0-0) 

The critical flaw is at line 191, which performs the check using `self.config.num_keys`: [2](#0-1) 

The `config.num_keys` field represents the **configured** total number of keys in the system: [3](#0-2) 

However, DKG can complete with fewer keys than configured. When `dkg_threshold < num_keys`, the coordinator proceeds with DKG if the threshold is met during timeout, even though not all configured signers participated: [4](#0-3) 

The actual participating keys are stored in `party_polynomials`, which is populated only from signers that completed DKG: [5](#0-4) 

In the v1 implementation, each key_id receives its own Party and polynomial commitment: [6](#0-5) 

**Attack Scenario:**
1. System configured with 10 keys, threshold=7, dkg_threshold=9
2. During DKG, one signer with 1 key doesn't respond
3. DKG timeout occurs but threshold is met (9 >= 9), so DKG completes
4. `party_polynomials.len()` = 9, but `config.num_keys` = 10
5. During signing, 3 signers with 1 key each timeout
6. Coordinator marks them malicious and checks: `10 - 3 = 7 >= 7` → **PASSES** (incorrect)
7. Correct check should be: `9 - 3 = 6 < 7` → **SHOULD FAIL**
8. Coordinator transitions to `NonceRequest` state to retry
9. During nonce gathering, malicious signers are rejected: [7](#0-6) 

10. Only 6 non-malicious keys remain (below threshold of 7)
11. Nonce gathering times out and returns `NonceTimeout` error: [8](#0-7) 

12. The `malicious_signer_ids` field persists across signing attempts: [9](#0-8) 

13. All subsequent signing attempts fail at the nonce gathering stage because insufficient non-malicious signers remain

This vulnerability breaks the **liveness guarantee** of the coordinator - once triggered, it cannot produce signatures until manually restarted, as the malicious signer set is never cleared and insufficient honest participants remain.

## Impact Explanation
This vulnerability causes a **persistent denial of service** in the coordinator node. Once triggered, the coordinator cannot produce any signatures for any message until manually restarted.

**Specific Harm:**
- Complete loss of signing capability for the affected coordinator node
- Wasted network bandwidth and CPU cycles on repeated failed signing attempts
- Requires manual intervention (coordinator restart) to recover functionality
- Multiple independent coordinator nodes can be simultaneously affected
- Loss of accumulated malicious signer tracking state upon restart

This aligns with **Low** severity per the defined scope: "Any remotely-exploitable denial of service in a node." While it prevents signature generation, it does not directly cause fund loss, chain splits, or confirmation of invalid transactions.

## Likelihood Explanation
**Likelihood: Medium to High**

The vulnerability can be triggered through natural network conditions without any malicious actor:

**Required Conditions:**
- System configured with `dkg_threshold < num_keys` (standard configuration as evidenced by test setup)
- DKG completes with fewer than `num_keys` participants due to network issues or signer unavailability  
- During signing, sufficient signers timeout such that: `config.num_keys - malicious_keys >= threshold` but `actual_dkg_keys - malicious_keys < threshold`

**Attack Complexity:** Low
- No cryptographic operations required
- No privileged access needed
- Can occur organically through network instability
- Attacker only needs to cause network delays/packet drops to specific signers

**Economic Feasibility:** Trivial
- No funds at risk for attacker
- Simple network disruption is sufficient
- Effect persists until manual restart with minimal attacker cost

**Detection Risk:** Low
- Appears as normal timeout behavior
- Difficult to distinguish from legitimate network issues
- No cryptographic evidence of malicious activity

In networks with unreliable connectivity or in the presence of adversarial participants capable of selective network disruption, this probability increases significantly.

## Recommendation
Replace the threshold check to use the actual number of keys that completed DKG instead of the configured number:

```rust
// Current (incorrect) code at line 191:
if self.config.num_keys - num_malicious_keys < self.config.threshold {

// Should be:
let actual_num_keys = self.party_polynomials.len() as u32;
if actual_num_keys - num_malicious_keys < self.config.threshold {
```

Additionally, consider:
1. Adding a validation after DKG completion to ensure `party_polynomials.len() >= threshold`
2. Logging a warning when DKG completes with fewer keys than configured
3. Implementing a mechanism to clear stale malicious signer state or reassess malicious status periodically

## Proof of Concept

```rust
#[test]
fn test_incorrect_threshold_check_dos() {
    // Setup: 10 keys, threshold=7, dkg_threshold=9
    let num_signers = 10u32;
    let keys_per_signer = 1u32;
    let threshold = 7u32;
    let dkg_threshold = 9u32;
    
    let (mut coordinators, mut signers) = setup_with_custom_thresholds(
        num_signers,
        keys_per_signer,
        threshold,
        dkg_threshold,
        Some(Duration::from_millis(100)),
    );
    
    // Remove 1 signer before DKG to simulate network issue
    signers.truncate(9);
    
    // Complete DKG with 9 signers (meets dkg_threshold)
    let msg = coordinators[0].start_dkg_round(None).unwrap();
    feedback_messages(&mut coordinators, &mut signers, &[msg]);
    // ... complete DKG ...
    
    // Verify party_polynomials.len() == 9, not 10
    assert_eq!(coordinators[0].party_polynomials.len(), 9);
    
    // Start signing round
    let msg = coordinators[0].start_signing_round(&[1,2,3], SignatureType::Frost, None).unwrap();
    
    // Remove 3 signers to simulate timeout (leaves 6)
    signers.truncate(6);
    
    // Gather nonces (succeeds with 6)
    feedback_messages(&mut coordinators, &mut signers, &[msg]);
    
    // Now remove signers for signature share timeout
    signers.truncate(3);
    
    // Wait for signature share timeout
    thread::sleep(Duration::from_millis(150));
    
    let (packet, result) = coordinators[0].process_timeout().unwrap();
    
    // BUG: Should return InsufficientSigners, but returns NonceRequest instead
    assert!(packet.is_some()); // Incorrectly retries
    assert!(result.is_none()); // Should have returned error
    
    // Subsequent nonce gathering will fail due to insufficient honest signers
    // This creates a persistent DoS state
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L64-64)
```rust
    malicious_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L84-98)
```rust
                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPublicTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.public_shares_gathered()?;
                                let packet = self.start_private_shares()?;
                                return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L149-172)
```rust
            State::NonceGather(_signature_type) => {
                if let Some(start) = self.nonce_start {
                    if let Some(timeout) = self.config.nonce_timeout {
                        if now.duration_since(start) > timeout {
                            error!("Timeout gathering nonces for signing round {} iteration {}, unable to continue", self.current_sign_id, self.current_sign_iter_id);
                            let recv = self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                                .iter()
                                .copied()
                                .collect();
                            let mal = self.malicious_signer_ids.iter().copied().collect();
                            return Ok((
                                None,
                                Some(OperationResult::SignError(SignError::NonceTimeout(
                                    recv, mal,
                                ))),
                            ));
                        }
                    }
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L173-210)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
                        }
                    }
                }
            }
        }
        Ok((None, None))
```

**File:** src/state_machine/coordinator/fire.rs (L794-812)
```rust
    fn dkg_end_gathered(&mut self) -> Result<(), Error> {
        // Cache the polynomials used in DKG for the aggregator
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
        }

        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
        self.move_to(State::Idle)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/mod.rs (L136-137)
```rust
    /// total number of keys
    pub num_keys: u32,
```

**File:** src/v1.rs (L537-540)
```rust
        let parties = key_ids
            .iter()
            .map(|id| Party::new(*id, num_keys, threshold, rng))
            .collect();
```
