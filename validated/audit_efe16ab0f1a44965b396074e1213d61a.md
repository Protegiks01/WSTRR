# Audit Report

## Title
Malicious Coordinator Can Frame Honest Parties via Lagrange Coefficient Mismatch in SignatureShareRequest

## Summary
A malicious coordinator can modify the `key_ids` field in `SignatureShareRequest` messages to cause honest signers to compute signature shares using incorrect Lagrange coefficients. When the coordinator validates these shares using the original `key_ids`, validation fails and honest parties are incorrectly blamed, leading to denial of service.

## Finding Description

The vulnerability exists in the signing flow where signers extract `key_ids` from the coordinator's `SignatureShareRequest` without validating they match what the signer originally sent.

**Attack Flow:**

1. Signers create and send `NonceResponse` messages with their `key_ids`: [1](#0-0) 

2. Coordinator receives, validates against config, and stores these in `self.public_nonces`: [2](#0-1) [3](#0-2) 

3. Coordinator creates `SignatureShareRequest` by cloning stored `nonce_responses`: [4](#0-3) 

4. **ATTACK**: Since these are clones, a malicious coordinator can modify the `key_ids` field before signing the request with its legitimate coordinator key.

5. Signers receive the request, verify the coordinator's signature (passes), and extract `key_ids` WITHOUT validation: [5](#0-4) 

The signer validation only checks signer IDs and nonce validity, NOT whether `key_ids` match what was sent: [6](#0-5) 

6. Signers compute signature shares using the (potentially modified) `key_ids` to calculate Lagrange coefficients: [7](#0-6) 

7. Coordinator validates shares by extracting `key_ids` from its stored (original, unmodified) `nonce_responses`: [8](#0-7) 

8. During validation, the aggregator computes Lagrange coefficients using the original `key_ids`: [9](#0-8) 

9. The Lagrange coefficient formula produces different values for different `key_ids` sets: [10](#0-9) 

10. Validation fails because different Lagrange coefficients were used, and honest parties are added to `bad_party_sigs`: [11](#0-10) 

**Root Cause:**

Signers trust the coordinator-signed `SignatureShareRequest` completely and don't verify that the embedded `key_ids` match what they originally sent. The protocol provides no cryptographic binding between the signer's original `NonceResponse` and the `key_ids` used in signature computation.

## Impact Explanation

**Denial of Service (Critical)**: A malicious coordinator can systematically frame all honest signers by modifying `key_ids` in the `SignatureShareRequest`. If the coordinator frames enough honest signers above the threshold, no valid signatures can be produced because:

1. Framed signers are identified in `BadPartySigs` errors [12](#0-11) 

2. The coordinator tracks malicious signers and may exclude them from future rounds [13](#0-12) 

3. Without sufficient honest signers, the threshold cannot be met, preventing signature generation

This directly maps to the Critical impact criterion: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

## Likelihood Explanation

**High Likelihood** - The attack is highly feasible because:

1. **Attacker Position**: Requires controlling a coordinator node, which is standard infrastructure in production deployments
2. **Technical Complexity**: Low - requires only modifying cloned data structures before signing, no cryptographic attacks needed  
3. **Resources Required**: None beyond running a legitimate coordinator with its signing key
4. **Detection Difficulty**: The coordinator legitimately signs the modified request, leaving no cryptographic evidence of tampering. Signers cannot detect the modification without comparing the received `key_ids` with what they originally sent.

## Recommendation

Add validation in the signer's `sign_share_request` method to verify that the `key_ids` in the `SignatureShareRequest` for this signer match what the signer originally sent in its `NonceResponse`:

```rust
// In sign_share_request, after line 804:
if signer_id_set.contains(&self.signer_id) {
    let my_key_ids = self.signer.get_key_ids();
    let my_nonce_response = sign_request.nonce_responses
        .iter()
        .find(|nr| nr.signer_id == self.signer_id)
        .ok_or(Error::InvalidNonceResponse)?;
    
    let received_key_ids: HashSet<u32> = my_nonce_response.key_ids.iter().copied().collect();
    let expected_key_ids: HashSet<u32> = my_key_ids.iter().copied().collect();
    
    if received_key_ids != expected_key_ids {
        warn!(signer_id = %self.signer_id, "key_ids in SignatureShareRequest don't match what we sent");
        return Err(Error::InvalidSignatureShare);
    }
    
    // Continue with existing logic...
}
```

Alternatively, signers could verify the embedded signer signatures on each `NonceResponse` within the `SignatureShareRequest` to ensure they haven't been tampered with.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability:
// 1. Honest signer sends NonceResponse with key_ids = [1, 2, 3]
// 2. Malicious coordinator clones this and modifies to key_ids = [1, 2, 4]  
// 3. Coordinator signs modified SignatureShareRequest
// 4. Signer accepts it (only checks coordinator signature, not key_ids)
// 5. Signer computes shares with lambda based on [1, 2, 4]
// 6. Coordinator validates with lambda based on [1, 2, 3]
// 7. Validation fails, honest signer blamed via BadPartySigs

// For key_id = 1:
// lambda([1,2,3], 1) = 2/(2-1) * 3/(3-1) = 2 * 1.5 = 3
// lambda([1,2,4], 1) = 2/(2-1) * 4/(4-1) = 2 * 1.333... = 2.666...
// Different lambdas â†’ validation fails even with correct signature share
```

## Notes

This vulnerability breaks the security guarantee that honest parties cannot be framed as malicious. The attack exploits the trust boundary between coordinator and signers, where signers assume the coordinator accurately relays `key_ids` without providing cryptographic proof. The defense-in-depth principle is violated as signers don't independently verify critical parameters they use for cryptographic computation.

### Citations

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L772-795)
```rust
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L808-818)
```rust
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/state_machine/coordinator/fire.rs (L184-186)
```rust
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L870-889)
```rust
            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-977)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
```

**File:** src/state_machine/coordinator/fire.rs (L1115-1129)
```rust
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/v2.rs (L389-409)
```rust
        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
```

**File:** src/v2.rs (L412-413)
```rust
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```
