# Audit Report

## Title
Nonce Timeout Handler Fails to Mark Non-Responsive Signers as Malicious

## Summary
The FIRE coordinator's nonce timeout handler does not mark non-responsive signers as malicious, unlike the signature share timeout handler. This asymmetry allows Byzantine signers to cause repeated signing failures by refusing to send nonces, as they remain eligible for subsequent retry attempts.

## Finding Description

A critical asymmetry exists in how the FIRE coordinator's `process_timeout()` method handles timeouts during different phases of the signing protocol.

**Nonce Timeout Behavior (Vulnerable):**

When the nonce gathering phase times out, the handler collects signers who successfully responded into a `recv` vector and returns them in a `NonceTimeout` error, but critically fails to mark non-responsive signers as malicious. [1](#0-0) 

During nonce gathering, when a signer responds successfully, their ID is added to `sign_wait_signer_ids`: [2](#0-1) 

The coordinator actively excludes known malicious signers by rejecting their nonce responses: [3](#0-2) 

However, this exclusion mechanism is only effective if non-responsive signers are actually marked as malicious during nonce timeout, which does not happen.

**Signature Share Timeout Behavior (Correct):**

In stark contrast, the signature share timeout handler explicitly marks ALL non-responsive signers (those remaining in `sign_wait_signer_ids` after timeout) as malicious, checks if sufficient non-malicious signers remain, and either retries or returns an error: [4](#0-3) 

**Root Cause:**

When retries occur (via application-layer intervention calling `reset()` then `start_signing_round()`), the `request_nonces()` method clears the message nonce state and broadcasts to all configured signers: [5](#0-4) 

Since non-responsive signers were never marked as malicious, they remain eligible participants and can refuse again, causing repeated failures.

**Attack Scenario:**

1. Configuration: 10 signers with 1 key each, threshold = 7
2. Byzantine attacker controls 4 signers (within protocol threat model of threshold-1)
3. Coordinator broadcasts `NonceRequest` to all signers
4. 6 honest signers respond, 4 Byzantine signers refuse
5. Only 6 keys < 7 threshold, nonce timeout fires [6](#0-5) 
6. Byzantine signers NOT marked as malicious
7. Application layer calls `reset()` (which preserves `malicious_signer_ids`) then `start_signing_round()` to retry [7](#0-6) 
8. `request_nonces()` clears state and broadcasts to all signers again (including the 4 non-responders)
9. Byzantine signers refuse again
10. Timeout fires again, cycle repeats

This breaks the protocol invariant that malicious or unresponsive signers should be systematically excluded from future signing attempts, as implemented correctly in the signature share timeout handler.

## Impact Explanation

This vulnerability enables a denial-of-service attack against the signing protocol. Byzantine signers can cause persistent signing failures by passively refusing to send nonces. Since they are never marked as malicious, every retry attempt (initiated by the application layer) includes them again, preventing progress.

The impact severity maps to **Low** under the defined scope: "Any remotely-exploitable denial of service in a node." However, if WSTS is integrated into consensus-critical signing operations (such as Stacks block signing), the impact escalates to **Medium**: "Any transient consensus failures."

The asymmetric handling of timeouts creates an exploitable weakness where nonce gathering is fundamentally less robust than signature share gathering. This violates the FIRE protocol's goal of providing robustness by systematically removing bad actors.

## Likelihood Explanation

**Likelihood: High**

The attack requires minimal capabilities:
- Control of legitimate signing parties within the protocol threat model (up to threshold-1 malicious signers)
- Passive refusal to respond to `NonceRequest` messages (no active operations required)
- No cryptographic operations or special network capabilities

**Attack Complexity:** Trivial. The attacker participates normally in DKG to establish credentials, then simply ignores nonce requests during signing rounds.

**Economic Cost:** Zero. The attacker expends no computational resourcesâ€”non-response is free.

**Detection Difficulty:** Very high. The coordinator cannot distinguish between genuine network failures, crashed signers, or malicious non-response without additional out-of-band verification. Without marking non-responders as malicious, there is no protocol-level mechanism to exclude them from subsequent attempts.

**Success Probability:** Deterministic (100%). If an attacker controls enough signers to prevent the threshold from being met (e.g., 4 signers in a 10-signer, threshold-7 configuration) and consistently refuses to send nonces, signing will fail on every retry until either:
- Manual operator intervention excludes the non-responsive signers
- Sufficient additional honest signers are added to compensate
- The threshold is lowered (which may violate security requirements)

## Recommendation

Modify the nonce timeout handler to mirror the behavior of the signature share timeout handler:

```rust
State::NonceGather(_signature_type) => {
    if let Some(start) = self.nonce_start {
        if let Some(timeout) = self.config.nonce_timeout {
            if now.duration_since(start) > timeout {
                warn!("Timeout gathering nonces for signing round {} iteration {}", 
                      self.current_sign_id, self.current_sign_iter_id);
                
                // Get the set of all signers who responded with nonces
                let responded_signers: HashSet<u32> = self
                    .message_nonces
                    .get(&self.message)
                    .ok_or(Error::MissingMessageNonceInfo)?
                    .sign_wait_signer_ids
                    .clone();
                
                // Mark all non-responsive signers as malicious
                // (all configured signers minus those who responded)
                for signer_id in 0..self.config.num_signers {
                    if !responded_signers.contains(&signer_id) {
                        warn!("Mark non-responsive signer {signer_id} as malicious");
                        self.malicious_signer_ids.insert(signer_id);
                    }
                }
                
                // Check if we have enough non-malicious signers to meet threshold
                let num_malicious_keys: u32 =
                    self.compute_num_key_ids(self.malicious_signer_ids.iter())?;
                
                if self.config.num_keys - num_malicious_keys < self.config.threshold {
                    error!("Insufficient non-malicious signers after nonce timeout");
                    let mal = self.malicious_signer_ids.iter().copied().collect();
                    return Ok((
                        None,
                        Some(OperationResult::SignError(
                            SignError::InsufficientSigners(mal),
                        )),
                    ));
                }
                
                // Retry with remaining non-malicious signers
                self.move_to(State::NonceRequest(signature_type))?;
                let packet = self.request_nonces(signature_type)?;
                return Ok((Some(packet), None));
            }
        }
    }
}
```

This ensures non-responsive signers are:
1. Marked as malicious on nonce timeout
2. Excluded from subsequent nonce requests via the existing check at lines 903-915
3. Counted when determining if sufficient signers remain to meet the threshold

## Proof of Concept

```rust
#[test]
fn test_nonce_timeout_does_not_mark_malicious() {
    use crate::state_machine::coordinator::{
        fire::Coordinator, Config, CoordinatorTrait,
    };
    use crate::v2;
    use std::time::Duration;
    use std::thread;
    
    // Setup: 10 signers, 1 key each, threshold 7
    let mut config = Config::new(10, 10, 7, 7, Duration::from_millis(128), 
                                  Duration::from_millis(128), None, None, None);
    
    let mut coordinator = Coordinator::<v2::Aggregator>::new(config);
    
    // Simulate DKG completion (set aggregate public key)
    // ... (setup code omitted for brevity)
    
    // Start signing round
    let msg = b"test message";
    let nonce_req = coordinator.start_signing_round(msg, SignatureType::Frost, None).unwrap();
    
    // Simulate only 6 out of 10 signers responding with nonces
    // (simulate responses from signers 0-5)
    // ... (response simulation omitted)
    
    // Wait for nonce timeout
    thread::sleep(Duration::from_millis(256));
    
    // Process timeout
    let (packet, result) = coordinator.process_timeout().unwrap();
    
    // Verify nonce timeout occurred
    assert!(matches!(result, Some(OperationResult::SignError(SignError::NonceTimeout(..)))));
    
    // VULNERABILITY: Check that non-responsive signers (6-9) were NOT marked as malicious
    assert!(!coordinator.malicious_signer_ids.contains(&6));
    assert!(!coordinator.malicious_signer_ids.contains(&7));
    assert!(!coordinator.malicious_signer_ids.contains(&8));
    assert!(!coordinator.malicious_signer_ids.contains(&9));
    
    // This demonstrates that on retry, these signers will be included again,
    // allowing them to cause repeated failures
}
```

This test demonstrates that after a nonce timeout, non-responsive signers remain unmarked in `malicious_signer_ids`, confirming the vulnerability.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L149-172)
```rust
            State::NonceGather(_signature_type) => {
                if let Some(start) = self.nonce_start {
                    if let Some(timeout) = self.config.nonce_timeout {
                        if now.duration_since(start) > timeout {
                            error!("Timeout gathering nonces for signing round {} iteration {}, unable to continue", self.current_sign_id, self.current_sign_iter_id);
                            let recv = self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                                .iter()
                                .copied()
                                .collect();
                            let mal = self.malicious_signer_ids.iter().copied().collect();
                            return Ok((
                                None,
                                Some(OperationResult::SignError(SignError::NonceTimeout(
                                    recv, mal,
                                ))),
                            ));
                        }
                    }
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L173-208)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
                        }
                    }
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L814-838)
```rust
    fn request_nonces(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.message_nonces.clear();
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
        info!(
            sign_id = %self.current_sign_id,
            sign_iter_id = %self.current_sign_iter_id,
            "Requesting Nonces"
        );
        let nonce_request = NonceRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            message: self.message.clone(),
            signature_type,
        };
        let nonce_request_msg = Packet {
            sig: nonce_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign NonceRequest"),
            msg: Message::NonceRequest(nonce_request),
        };
        self.move_to(State::NonceGather(signature_type))?;
        self.nonce_start = Some(Instant::now());

        Ok(nonce_request_msg)
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L940-942)
```rust
            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L952-959)
```rust
            if nonce_info.nonce_recv_key_ids.len() >= self.config.threshold as usize {
                // We have a winning message!
                self.message.clone_from(&nonce_response.message);
                let aggregate_nonce = self.compute_aggregate_nonce();
                info!("Aggregate nonce: {aggregate_nonce}");

                self.move_to(State::SigShareRequest(signature_type))?;
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1478-1490)
```rust
    // Reset internal state
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```
