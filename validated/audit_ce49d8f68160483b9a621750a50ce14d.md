Audit Report

## Title
Duplicate Key IDs in NonceResponse Bypass Validation and Corrupt Lagrange Coefficient Computation

## Summary
A malicious signer can send NonceResponse messages with duplicate key_ids that pass coordinator validation but cause incorrect Lagrange coefficient computation during signature aggregation. The validation logic converts the key_ids vector to a HashSet before comparison, masking duplicates, while the original vector with duplicates is stored and later used for cryptographic operations. This results in signature verification failure and prevents successful signing rounds.

## Finding Description

The vulnerability exists in both FROST and FIRE coordinator implementations where NonceResponse validation converts the `key_ids` vector to a HashSet before comparing against the configured signer_key_ids. [1](#0-0) [2](#0-1) 

The NonceResponse struct stores key_ids as a Vec<u32>, not a HashSet: [3](#0-2) 

**Root Cause**: When a malicious signer sends key_ids `[1, 1, 2]` and the configuration expects `{1, 2}`, the validation passes because `HashSet::from([1, 1, 2])` equals `{1, 2}`. However, the original NonceResponse with duplicate key_ids is stored unchanged: [4](#0-3) 

**Propagation**: When collecting key_ids for signature aggregation, the coordinator uses flat_map on the stored NonceResponses, preserving all duplicates from the original vectors: [5](#0-4) [6](#0-5) 

These collected key_ids are then passed to aggregator signing methods and to all signers via SignatureShareRequest: [7](#0-6) 

**Cryptographic Impact**: All signers extract key_ids using flat_map, preserving duplicates: [8](#0-7) 

These duplicate key_ids are passed to the Lagrange coefficient computation function. The lambda function iterates over all elements in key_ids: [9](#0-8) 

While the `if i != *j` check prevents division by zero, duplicate values cause the coefficient to be computed incorrectly. For example, `lambda(2, [1, 1, 2])` multiplies by `(1/(1-2))` twice, yielding 1, whereas the correct `lambda(2, [1, 2])` yields -1.

Signers compute shares with these incorrect Lagrange coefficients: [10](#0-9) 

The aggregator's check_signature_shares function uses these corrupted key_ids for verification: [11](#0-10) 

The final signature verification checks against the correct group public key (derived from DKG without duplicates), causing verification to fail: [12](#0-11) 

**Complete Attack Flow**:
1. Malicious signer sends NonceResponse with duplicate key_ids [1, 1, 2]
2. Coordinator validates: {1, 1, 2} → {1, 2} matches config ✓
3. Original NonceResponse with [1, 1, 2] is stored
4. Coordinator sends SignatureShareRequest containing all NonceResponses
5. All signers extract key_ids using flat_map, getting duplicates [... 1, 1, 2, ...]
6. Each signer computes shares with incorrect Lagrange coefficients (lambda(key_id, [... 1, 1, 2, ...]))
7. Coordinator aggregates shares computed with incorrect lambdas
8. Final signature verification fails because z*G ≠ R + c*Y, where Y is the correct group public key

**Why No Existing Validation Catches This**: The coordinator validates that key_ids match the configuration but performs this check after HashSet conversion. There is no validation for uniqueness within the key_ids vector, nor any check that the number of key_ids matches the number of nonces.

## Impact Explanation

This vulnerability enables a single malicious signer to execute a denial-of-service attack against the WSTS signing protocol. When duplicate key_ids corrupt the Lagrange coefficient computation, the mathematical foundation of threshold signature reconstruction breaks. The Lagrange interpolation formula requires correct lambda values to reconstruct the group secret. Incorrect lambda values violate this mathematical invariant, causing signature verification to fail consistently.

**Quantified Impact**: Any signing round where a single signer includes duplicate key_ids will fail to produce a valid signature. In a system with threshold T out of N signers, one malicious signer can block all signing operations indefinitely.

**Severity Justification**: This maps to **Low** severity under the scope definition: "Any remotely-exploitable denial of service in a node." The attack prevents signing operations from succeeding but does not cause fund loss, chain splits, or acceptance of invalid transactions. The DoS is remotely exploitable by any protocol participant.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be a legitimate signer in the WSTS protocol with the ability to send network messages to the coordinator. They must modify their client code to construct NonceResponse messages with duplicate key_ids.

**Attack Complexity**: Low. The attacker only needs to craft a NonceResponse with duplicate key_ids that, when deduplicated, match their configured key set. No cryptographic operations, timing attacks, or complex state manipulation is required.

**Economic Feasibility**: Trivial. The attack requires no special resources beyond being a protocol participant.

**Detection**: The attack manifests as signature verification failure, but the coordinator's check_signature_shares diagnostic function uses the same corrupted key_ids list, potentially misidentifying which parties provided bad signatures.

**Probability**: High if any signer is malicious or misconfigured. The vulnerability is deterministic and requires no special conditions beyond a single malformed NonceResponse.

## Recommendation

Add validation to ensure key_ids contains no duplicates and matches the expected length before accepting a NonceResponse:

```rust
// In gather_nonces, after line 889 (fire.rs) / 521 (frost.rs), add:
if nonce_response.key_ids.len() != signer_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids length mismatch");
    return Ok(());
}

let mut key_ids_set = HashSet::new();
for key_id in &nonce_response.key_ids {
    if !key_ids_set.insert(key_id) {
        warn!(signer_id = %nonce_response.signer_id, "Duplicate key_id in NonceResponse");
        return Ok(());
    }
}
```

Alternatively, convert key_ids to HashSet immediately upon receiving NonceResponse and store it as a HashSet throughout the protocol to prevent duplicates from propagating.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_duplicate_key_ids_corrupt_lambda() {
        // Demonstrate that lambda gives incorrect results with duplicates
        let correct_key_ids = vec![1u32, 2u32];
        let duplicate_key_ids = vec![1u32, 1u32, 2u32];
        
        let lambda_correct = compute::lambda(2, &correct_key_ids);
        let lambda_duplicate = compute::lambda(2, &duplicate_key_ids);
        
        // lambda(2, [1, 2]) = 1/(1-2) = -1
        // lambda(2, [1, 1, 2]) = (1/(1-2)) * (1/(1-2)) = 1
        assert_ne!(lambda_correct, lambda_duplicate);
        
        // This proves duplicates produce mathematically incorrect Lagrange coefficients
        // which will cause signature verification to fail
    }
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L675-678)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/frost.rs (L695-700)
```rust
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    shares,
                    &key_ids,
                    merkle_root,
```

**File:** src/net.rs (L321-321)
```rust
    pub key_ids: Vec<u32>,
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L69-79)
```rust
/// Compute the Lagrange interpolation value
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L403-403)
```rust
                cx += compute::lambda(*key_id, key_ids) * c * public_key;
```

**File:** src/common.rs (L245-250)
```rust
    pub fn verify(&self, public_key: &Point, msg: &[u8]) -> bool {
        let c = challenge(public_key, &self.R, msg);
        let R = &self.z * G + (-c) * public_key;

        R == self.R
    }
```
