# Audit Report

## Title
Incomplete Malicious Signer Ban Allows Repeated DKG Disruption

## Summary
The FIRE coordinator tracks malicious DKG signers in `malicious_dkg_signer_ids` but fails to enforce this ban when gathering public and private shares in subsequent DKG rounds. This allows previously-identified malicious signers to repeatedly disrupt DKG, preventing the establishment of an aggregate public key required for all signing operations.

## Finding Description

The FIRE coordinator maintains two separate tracking sets: `malicious_signer_ids` for signing rounds and `malicious_dkg_signer_ids` for DKG rounds. [1](#0-0) 

When DKG failures occur, malicious signers are correctly identified and added to `malicious_dkg_signer_ids` after validating reported failures for bad public or private shares. [2](#0-1) 

However, the `gather_public_shares` function accepts shares from any signer in the configuration without checking if they are banned in `malicious_dkg_signer_ids`. The function only validates that the signer_id exists in the config and checks for duplicates. [3](#0-2) 

Similarly, `gather_private_shares` also fails to enforce the ban, performing the same limited checks without verifying against `malicious_dkg_signer_ids`. [4](#0-3) 

In contrast, the signing flow correctly implements ban enforcement. The `gather_nonces` function explicitly checks `malicious_signer_ids` and rejects nonce responses from banned signers. [5](#0-4) 

The malicious signer sets are intentionally persistent across rounds - they are not cleared in the `reset()` function. [6](#0-5) 

This asymmetry creates a critical vulnerability where malicious signers are permanently banned from signing rounds but can indefinitely participate in DKG rounds. A malicious signer can:

1. Participate in DKG round N and send invalid shares
2. Get detected and added to `malicious_dkg_signer_ids`
3. Participate in DKG round N+1 (not blocked by gather functions)
4. Send invalid shares again, causing repeated DKG failures
5. Repeat indefinitely

Since signing operations require a valid aggregate public key, which is only set upon successful DKG completion, [7](#0-6)  a single persistent malicious signer can prevent the system from ever establishing an aggregate public key, blocking all transaction signing indefinitely.

A comprehensive grep search of the codebase confirms that no checks for `malicious_dkg_signer_ids.contains()` exist anywhere, guaranteeing this bypass is exploitable.

## Impact Explanation

**Critical** severity is justified because this vulnerability directly maps to: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

Without successful DKG completion, no aggregate public key is established. Without an aggregate public key, the coordinator cannot start any signing rounds. This results in:

**Initial Deployment Scenario (Critical):**
- A single malicious signer can prevent the system from ever becoming operational
- No blocks can be signed during initial system setup
- Requires manual intervention to remove the malicious signer from network configuration
- Complete denial of service until configuration changes are deployed

**Key Rotation Scenario (High):**
- Prevents security-critical key rotation operations from completing
- System may continue with old keys if already operational, but cannot rotate to new keys
- Forces continued use of potentially compromised keys

The impact is most severe during initial deployment where a single malicious signer (within the allowed threshold-1 threat model) can prevent the entire network from ever establishing the cryptographic foundation required for operation.

## Likelihood Explanation

**High** likelihood is justified by:

**Attacker Prerequisites:**
- Must be an authorized signer (within the protocol threat model of up to threshold-1 malicious signers)
- No special privileges beyond normal signer participation
- No cryptographic breaks or key compromises required

**Attack Complexity:**
- Low - attacker simply sends malformed DKG shares through normal protocol messages
- Detection occurs and the signer is added to `malicious_dkg_signer_ids`
- However, detection has no preventive effect due to missing enforcement
- Attack is deterministic with 100% success probability

**Technical Feasibility:**
- The missing validation check is confirmed by code inspection and grep search
- The attack is reliable and repeatable through normal protocol message flow
- No race conditions or timing dependencies

The attack requires no special resources and exploits a clear logic flaw in the coordinator's validation logic.

## Recommendation

Add malicious signer checks to both `gather_public_shares` and `gather_private_shares` functions, mirroring the pattern already implemented in `gather_nonces`:

```rust
// In gather_public_shares (around line 491):
if self.malicious_dkg_signer_ids.contains(&dkg_public_shares.signer_id) {
    warn!(
        signer_id = %dkg_public_shares.signer_id,
        "Received DkgPublicShares from malicious signer"
    );
    return Ok(());
}

// In gather_private_shares (around line 539):
if self.malicious_dkg_signer_ids.contains(&dkg_private_shares.signer_id) {
    warn!(
        signer_id = %dkg_private_shares.signer_id,
        "Received DkgPrivateShares from malicious signer"
    );
    return Ok(());
}
```

Additionally, consider implementing a check at DKG initiation to verify that sufficient non-malicious signers remain to meet the threshold before starting a new DKG round.

## Proof of Concept

```rust
#[test]
fn malicious_dkg_signer_not_banned_in_subsequent_rounds() {
    // Setup coordinator with 3 signers, threshold 2
    let (mut coordinator, signers, key_ids) = setup::<FireCoordinator<v2::Aggregator>, v2::Signer>(3, 3, 2, 2);
    
    // Round 1: Start DKG
    let dkg_begin_packet = coordinator.start_dkg_round(None).unwrap();
    
    // Signer 0 sends VALID public shares
    let (dkg_public_packet_0, _) = feedback_messages(&mut [&mut signers[0]], &[dkg_begin_packet.clone()]);
    coordinator.process_message(&dkg_public_packet_0[0]).unwrap();
    
    // Signer 1 sends INVALID public shares (mutated)
    let (dkg_public_packet_1, _) = feedback_mutated_messages(&mut [&mut signers[1]], &[dkg_begin_packet.clone()]);
    coordinator.process_message(&dkg_public_packet_1[0]).unwrap();
    
    // Complete DKG round 1 with failure, marking signer 1 as malicious
    // ... (continue DKG protocol until failure is detected)
    
    // Verify signer 1 is in malicious_dkg_signer_ids
    assert!(coordinator.malicious_dkg_signer_ids.contains(&1));
    
    // Round 2: Start new DKG (retry)
    coordinator.current_dkg_id += 1;
    let dkg_begin_packet_2 = coordinator.start_public_shares().unwrap();
    
    // Signer 1 (malicious) sends public shares again
    let (dkg_public_packet_1_round2, _) = feedback_messages(&mut [&mut signers[1]], &[dkg_begin_packet_2]);
    
    // BUG: This should be rejected but is accepted
    let result = coordinator.process_message(&dkg_public_packet_1_round2[0]);
    
    // Vulnerability: Malicious signer 1 can participate in round 2
    assert!(result.is_ok()); // This passes, proving the vulnerability
    assert!(coordinator.dkg_public_shares.contains_key(&1)); // Malicious signer's shares are accepted
}
```

This test demonstrates that a signer marked as malicious in `malicious_dkg_signer_ids` during round 1 can still participate and send shares in round 2, allowing repeated DKG disruption.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L64-65)
```rust
    malicious_signer_ids: HashSet<u32>,
    malicious_dkg_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L525-565)
```rust
    fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
            info!(
                dkg_id = %dkg_private_shares.dkg_id,
                signer_id = %dkg_private_shares.signer_id,
                "DkgPrivateShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.private_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1464-1465)
```rust
        if self.aggregate_public_key.is_none() {
            return Err(Error::MissingAggregatePublicKey);
```

**File:** src/state_machine/coordinator/fire.rs (L1478-1490)
```rust
    // Reset internal state
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```
