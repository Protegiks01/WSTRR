# Audit Report

## Title
Missing Validation of DH Public Keys Allows Predictable Encryption Keys in DKG Private Share Distribution

## Summary
The DKG protocol fails to validate ephemeral Diffie-Hellman public keys (`kex_public_key`) in `DkgPublicShares` messages. Combined with the fact that `kex_public_key` is not included in message authentication, this allows network attackers to force predictable encryption keys by substituting `Point::identity()`, enabling decryption of private shares and reconstruction of the distributed group key.

## Finding Description

The vulnerability exists in the DKG private share encryption mechanism where three critical flaws combine to enable complete key compromise:

**Flaw 1: kex_public_key is not authenticated**

The `DkgPublicShares::hash()` implementation only includes `dkg_id`, `signer_id`, and polynomial commitments in the authentication hash, deliberately excluding `kex_public_key`: [1](#0-0) 

This allows a network attacker to modify the `kex_public_key` field without invalidating the ECDSA signature, as the signature verification only checks the hash that doesn't include this field.

**Flaw 2: No validation when storing kex_public_key**

When `DkgPublicShares` messages are received, the `kex_public_key` is stored directly without any validation: [2](#0-1) 

Unlike other cryptographic values in the codebase, there is no check to ensure `kex_public_key` is not the identity point or other degenerate values.

**Flaw 3: make_shared_secret performs no validation**

The shared secret derivation blindly multiplies the private key by the received public key: [3](#0-2) 

When `public_key = Point::identity()`, this results in `shared_key = private_key * identity = identity`, producing a constant, predictable shared secret that any observer can compute.

**Attack Vector - Network Man-in-the-Middle:**

1. Attacker intercepts `DkgPublicShares` messages from t honest signers
2. Modifies each victim's `kex_public_key` to `Point::identity()`
3. Forwards modified messages (signatures remain valid since `kex_public_key` is not in hash)
4. Other honest signers receive the modified messages and store the identity point
5. When encrypting private shares, they compute: `shared_secret = make_shared_secret(kex_private_key, Point::identity())` which equals a predictable constant
6. This predictable shared secret is used as the encryption key: [4](#0-3) 

7. Attacker intercepts encrypted `DkgPrivateShares` messages and decrypts them using the predictable key
8. With t decrypted shares, attacker reconstructs the group private key via Lagrange interpolation

**Evidence of Awareness:**

The codebase explicitly validates `PublicNonce` points against the identity point, demonstrating that developers are aware of this attack class: [5](#0-4) 

However, no equivalent validation exists for `kex_public_key`.

**Why TupleProof Cannot Prevent This:**

The `TupleProof` verification checks two equations: [6](#0-5) 

When `B = Point::identity()`, the second equation becomes `z * identity == r * identity + s * identity`, which simplifies to `identity == identity`, always passing regardless of the scalar values. The proof cannot detect the malicious identity point.

## Impact Explanation

This vulnerability enables **complete compromise of the distributed group key**, mapping to **Critical** severity:

**Scope Alignment:**
- "Any causing the direct loss of funds other than through any form of freezing"
- "Any confirmation of an invalid transaction, such as with an incorrect nonce"

**Attack Outcome:**
With the reconstructed private key, an attacker can:
1. Create valid signatures for arbitrary transactions
2. Steal funds from addresses controlled by the compromised threshold key
3. Execute unauthorized operations in blockchain systems relying on this signature scheme

The FROST DKG protocol's fundamental security guarantee—that private polynomial shares remain confidential during distribution—is completely broken. An external network attacker (not even a protocol participant) can reconstruct the distributed key without requiring threshold-1 compromised signers.

## Likelihood Explanation

**Attack Complexity: Low**
- Single unprotected field modification in network messages
- No cryptographic breaks required
- Predictable encryption key is computable by anyone

**Attacker Capabilities: Realistic**
- Network position to intercept/modify messages (standard for P2P blockchain networks)
- No insider access needed
- No special cryptographic capabilities required

**Detection Difficulty: Very Low**
- Message ECDSA signatures remain valid (since `kex_public_key` not in hash)
- `TupleProof` verifications pass (identity point satisfies proof equations)
- Only detectable through DKG failure for victims (who can't decrypt with mismatched keys)
- By the time failure is detected, shares are already leaked

**Success Probability: High**
If attacker can position themselves on the network path during DKG (feasible in decentralized P2P networks), the attack succeeds with 100% probability.

## Recommendation

**Fix 1: Include kex_public_key in message authentication**

Modify `DkgPublicShares::hash()` to include the `kex_public_key` field:

```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        hasher.update(self.kex_public_key.compress().as_bytes()); // ADD THIS
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**Fix 2: Validate kex_public_key when storing**

Add validation in `dkg_public_share()`:

```rust
// After line 1016 in src/state_machine/signer/mod.rs
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    warn!("Invalid kex_public_key from signer {}", signer_id);
    return Ok(vec![]);
}
```

**Fix 3: Add validation in make_shared_secret**

```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> Result<[u8; 32], Error> {
    if *public_key == Point::identity() || *public_key == G {
        return Err(Error::InvalidPublicKey);
    }
    let shared_key = private_key * public_key;
    Ok(make_shared_secret_from_key(&shared_key))
}
```

All three fixes should be implemented for defense-in-depth.

## Proof of Concept

```rust
#[test]
fn test_identity_point_produces_predictable_encryption_key() {
    use crate::util::{make_shared_secret, make_shared_secret_from_key, create_rng};
    use crate::curve::{scalar::Scalar, point::Point};
    
    let mut rng = create_rng();
    
    // Two different signers with different private keys
    let private_key_1 = Scalar::random(&mut rng);
    let private_key_2 = Scalar::random(&mut rng);
    
    // Attacker substitutes identity point as the kex_public_key
    let identity = Point::identity();
    
    // Both signers compute the "shared" secret with identity
    let shared_secret_1 = make_shared_secret(&private_key_1, &identity);
    let shared_secret_2 = make_shared_secret(&private_key_2, &identity);
    
    // VULNERABILITY: Both produce the SAME predictable value
    assert_eq!(shared_secret_1, shared_secret_2);
    
    // Attacker can compute this without knowing any private keys
    let attacker_computed = make_shared_secret_from_key(&identity);
    assert_eq!(shared_secret_1, attacker_computed);
    
    // This predictable key is then used to encrypt private shares,
    // allowing the attacker to decrypt them
}
```

## Notes

The vulnerability is exacerbated by the fact that `kex_public_key` is transmitted in `DkgPublicShares` but not authenticated. This creates a false sense of security where message signatures are verified, but the critical key exchange parameter can be tampered with. The codebase's explicit validation of `PublicNonce` against identity points proves that developers understand this attack class, making the absence of validation for `kex_public_key` a significant oversight rather than an intentional design decision.

### Citations

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L941-942)
```rust
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/common.rs (L159-163)
```rust
impl PublicNonce {
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L288-292)
```rust
    pub fn verify(&self, A: &Point, B: &Point, K: &Point) -> bool {
        let s = Self::challenge(A, B, K, &self.R);

        (self.z * G == self.R + s * A) && (self.z * B == self.rB + s * K)
    }
```
