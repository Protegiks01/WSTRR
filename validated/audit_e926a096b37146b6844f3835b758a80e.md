# Audit Report

## Title
Memory and CPU Exhaustion via Unbounded PolyCommitment Vector During DKG

## Summary
A malicious signer can cause denial-of-service attacks against the DKG protocol by sending `DkgPublicShares` messages containing `PolyCommitment` structures with arbitrarily large polynomial vectors. The expensive signature verification operations (including elliptic curve point compression) occur before polynomial size validation, enabling resource exhaustion that prevents DKG completion across the entire signing group.

## Finding Description

The vulnerability exists because WSTS performs expensive cryptographic operations on unvalidated input data, violating secure coding practices around input validation and fail-fast principles.

**Core Vulnerability**: The `PolyCommitment` structure contains an unbounded `Vec<Point>` field with no size constraints during deserialization. [1](#0-0) 

When a `DkgPublicShares` message is received, packet signature verification executes before any polynomial size validation. Both coordinators and signers follow this pattern:

**Coordinator Path**: The coordinator verifies packet signatures first if `verify_packet_sigs` is enabled, which defaults to `true`. [2](#0-1)  The default configuration enables this verification. [3](#0-2) 

**Signer Path**: Signers follow the identical vulnerable pattern, checking `verify_packet_sigs` before processing. [4](#0-3)  The signer's default configuration also enables verification. [5](#0-4) 

**Why Verification is Expensive**: During packet verification, the `DkgPublicShares.hash()` method iterates over ALL polynomial points and compresses each one - an expensive elliptic curve operation. [6](#0-5) 

**Late Validation**: The polynomial size validation only checks `poly.len() == threshold`. [7](#0-6)  However, this validation is only called much later during `dkg_ended()` processing. [8](#0-7) 

The coordinator's `gather_public_shares` method performs no polynomial size validation. [9](#0-8)  Similarly, the signer's `dkg_public_share` handler has no size checks. [10](#0-9) 

By this time, the expensive verification operations have already completed, and memory has already been allocated for the oversized vector.

## Impact Explanation

This vulnerability enables a malicious insider signer to prevent DKG completion across the entire signing group, constituting a **transient consensus failure**.

**Specific Impacts**:
- **Memory Exhaustion**: A single `PolyCommitment` with 10 million points consumes ~640 MB (33 bytes per compressed point Ã— 10M). With multiple commitments per message (one per party), total memory consumption can reach multiple gigabytes.

- **CPU Exhaustion**: Hashing 10 million points with elliptic curve compression operations can take several minutes per message, completely blocking message processing threads.

- **Group-Wide Failure**: The attack affects not just individual nodes but the entire signing group:
  - Coordinators become unresponsive and cannot complete DKG
  - All honest signers processing the malicious message also become unresponsive  
  - The entire DKG round fails, preventing threshold signature generation

This maps to **Medium severity** ("Any transient consensus failures") because WSTS signers perform critical threshold signing operations for blockchain consensus. Failed DKG prevents signature generation, causing consensus delays. While transient (DKG can be retried without the malicious signer), it disrupts operations and exceeds Low severity by affecting group coordination rather than just individual node availability.

## Likelihood Explanation

**Attack Requirements**:
- Attacker must be a registered signer with a valid `signer_id` in the configuration
- Attacker must possess the private key for their `signer_id`
- Attacker must have network access to send messages during DKG

These requirements fall within the WSTS threat model, which explicitly allows for malicious signers up to `threshold-1`.

**Attack Complexity**: Low - Create a `PolyCommitment` with `Vec::with_capacity(10_000_000)`, sign the `DkgPublicShares` message with the attacker's valid private key, and send to coordinator and/or other signers during the DKG phase.

**Economic Feasibility**: High - Single malicious message causes damage with no computational cost to the attacker (victims bear the CPU/memory cost), and can be repeated in every DKG round.

**Success Probability**: ~100% if the attacker is a registered signer and no external message size limits exist at the application layer.

## Recommendation

Implement early input validation before performing expensive cryptographic operations:

1. **Add size limit constant**: Define a maximum polynomial size based on the configured threshold (e.g., `MAX_POLY_SIZE = threshold + safety_margin`)

2. **Validate before verification**: Check polynomial sizes immediately after deserialization and before calling `packet.verify()`:
```rust
// In gather_public_shares and dkg_public_share handlers
for (_, comm) in &dkg_public_shares.comms {
    if comm.poly.len() > MAX_POLY_SIZE || comm.poly.is_empty() {
        warn!("Invalid polynomial size: {}", comm.poly.len());
        return Err(Error::InvalidPolyCommitment);
    }
}
```

3. **Implement bounded deserialization**: Consider using serde's deserialize_with attribute to enforce size limits during deserialization itself.

## Proof of Concept

```rust
#[test]
fn test_oversized_poly_dos() {
    use std::time::Instant;
    
    // Create a DkgPublicShares message with oversized polynomial
    let mut poly_points = Vec::with_capacity(1_000_000);
    for _ in 0..1_000_000 {
        poly_points.push(Point::generator()); // Arbitrary points
    }
    
    let poly_comm = PolyCommitment {
        id: ID::new(&Scalar::random(&mut rng), &poly_points[0], b"context"),
        poly: poly_points,
    };
    
    let msg = DkgPublicShares {
        dkg_id: 1,
        signer_id: 0,
        comms: vec![(0, poly_comm)],
        kex_public_key: Point::generator(),
    };
    
    // Measure hash time (happens during packet.verify())
    let start = Instant::now();
    let mut hasher = Sha256::new();
    msg.hash(&mut hasher);
    let elapsed = start.elapsed();
    
    // Verify it takes excessive time
    assert!(elapsed.as_secs() > 10, "Hashing took {} seconds - DoS successful", elapsed.as_secs());
}
```

### Citations

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L319-320)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
```

**File:** src/state_machine/coordinator/frost.rs (L63-69)
```rust
        if self.config.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/coordinator/frost.rs (L290-334)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.ids_to_await.remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            for (party_id, comm) in &dkg_public_shares.comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }

            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.ids_to_await.is_empty() {
            self.move_to(State::DkgPrivateDistribute)?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/mod.rs (L198-198)
```rust
            verify_packet_sigs: true,
```

**File:** src/state_machine/signer/mod.rs (L347-347)
```rust
            verify_packet_sigs: true,
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L557-557)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
```

**File:** src/state_machine/signer/mod.rs (L984-1026)
```rust

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```
