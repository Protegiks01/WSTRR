# Audit Report

## Title
Missing DKG Round ID Validation Enables Denial of Service via Message Replay

## Summary
The signer's DKG message handlers do not validate the `dkg_id` field before storing messages, while the coordinator properly validates this field. This allows an attacker with network access to replay messages from previous DKG rounds, causing honest signers to store mismatched shares that fail validation and abort the DKG round.

## Finding Description

The signer's message handlers in the WSTS state machine accept and store DKG messages without validating that the incoming message's `dkg_id` field matches the signer's current round ID (`self.dkg_id`).

The `dkg_public_share()` handler stores public shares without any `dkg_id` validation. [1](#0-0)  It performs signer_id validation, party_id validation, and duplicate checks, but never verifies that `dkg_public_shares.dkg_id` matches `self.dkg_id`.

The `dkg_private_shares()` handler similarly accepts and stores private shares without checking the round ID. [2](#0-1)  It validates the sender and performs decryption, but the `dkg_id` field is never compared to the signer's current round.

The `dkg_end_begin()` handler also lacks this validation. [3](#0-2)  It simply caches the message without any `dkg_id` verification.

In contrast, the coordinator properly validates `dkg_id` in its message handlers. For public shares, it checks the round ID and returns a `BadDkgId` error when mismatches occur. [4](#0-3)  The same validation occurs for private shares. [5](#0-4) 

**Attack Mechanism:**

When a new DKG round begins, the signer's `reset()` method updates `self.dkg_id` to the new round value and clears all DKG-related state. [6](#0-5) 

An attacker who has captured legitimate DKG messages from round N can replay them to signers during round N+1. Since the signer doesn't validate `dkg_id`, these replayed messages are stored. When legitimate round N+1 messages arrive from the same signer_id, they are rejected as duplicates by the checks in the handlers. [7](#0-6) 

Eventually, when `dkg_ended()` is called, the stored commitments are validated against the current `self.dkg_id`. [8](#0-7)  The validation fails because the Schnorr proofs in the replayed messages were created with context `dkg_id=N` but are being verified against context `dkg_id=N+1`.

The Schnorr proof creation includes the context parameter in the challenge computation. [9](#0-8)  The verification recomputes the challenge with the provided context. [10](#0-9)  When contexts differ, verification fails.

The signer then returns a `DkgEnd` message with failure status. [11](#0-10) 

DKG messages include `dkg_id` in their signature hash via the Signable trait implementation. [12](#0-11)  This prevents an attacker from modifying the `dkg_id` field, but allows replay of the original signed messages which will pass signature verification but fail the deferred commitment validation.

## Impact Explanation

**Severity: Low**

This vulnerability enables a remotely-exploitable denial of service attack that prevents DKG completion. The impact aligns with the Low severity scope: "Any remotely-exploitable denial of service in a node" and "Any network denial of service impacting more than 10 percent of miners that does not shut down the network."

When a signer reports `BadPublicShares` due to storing replayed messages, the coordinator re-verifies the public shares using its own stored messages (which are legitimate because the coordinator validates `dkg_id` before storing). [13](#0-12)  Finding them valid, the coordinator marks the reporting signer as malicious and returns a DKG failure error. [14](#0-13) 

Specific impacts:
- Individual signers can be forced to abort DKG participation
- If the attacker targets sufficient signers such that remaining valid keys fall below `dkg_threshold`, the entire DKG round fails network-wide
- DKG must be restarted, delaying key generation and preventing signing operations until completion
- No compromise of cryptographic material, fund loss, or invalid signature acceptance occurs
- The attack is limited to a single DKG round as it requires messages from a completed round to replay

## Likelihood Explanation

**Likelihood: High**

The attack has a high likelihood of success due to:

**Low Attacker Requirements:**
- Network position to inject/replay messages to signers (man-in-the-middle or similar)
- Ability to capture previously broadcast DKG messages (observable on the network)
- No cryptographic secrets, private keys, or computational resources required

**Simple Attack Execution:**
- Capture messages during a legitimate DKG round N
- Wait for round N+1 to begin
- Replay captured messages to target signers before legitimate messages arrive
- Success depends on message timing, which an attacker with network position can influence

**High Success Probability:**
- No race conditions or cryptographic challenges to overcome
- The duplicate check mechanism ensures that the first message received (replayed) prevents the legitimate message from being stored
- No economic cost or stake required to execute the attack

**Detection Difficulty:**
- DKG failures appear as legitimate validation failures in logs
- Distinguishing between network issues and deliberate attacks is difficult
- The attack leaves no cryptographic evidence since all signatures are valid for the original messages

## Recommendation

Add `dkg_id` validation to the signer's message handlers before storing any messages. The validation should match the pattern used by the coordinator.

For `dkg_public_share()`:
```rust
pub fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Add validation before any processing
    if dkg_public_shares.dkg_id != self.dkg_id {
        warn!("Received DkgPublicShares with mismatched dkg_id: got {}, expected {}", 
              dkg_public_shares.dkg_id, self.dkg_id);
        return Ok(vec![]);
    }
    // ... existing validation logic
}
```

Apply the same pattern to `dkg_private_shares()` and `dkg_end_begin()` handlers. This ensures that messages from previous rounds are rejected before being stored, preventing the replay attack.

## Proof of Concept

```rust
#[test]
fn test_dkg_replay_attack() {
    let mut rng = OsRng;
    
    // Setup signer with initial DKG round
    let mut signer = Signer::new(/* ... config ... */);
    
    // Simulate DKG round N=1
    let dkg_begin_1 = DkgBegin { dkg_id: 1, /* ... */ };
    signer.dkg_begin(&dkg_begin_1, &mut rng).unwrap();
    
    // Create legitimate DkgPublicShares for round 1
    let public_shares_1 = DkgPublicShares {
        dkg_id: 1,
        signer_id: 0,
        comms: vec![/* ... */],
        kex_public_key: Point::random(&mut rng),
    };
    
    // Signer accepts and stores round 1 message
    signer.dkg_public_share(&public_shares_1).unwrap();
    assert!(signer.dkg_public_shares.contains_key(&0));
    
    // Start new DKG round N=2 (resets state and updates dkg_id)
    let dkg_begin_2 = DkgBegin { dkg_id: 2, /* ... */ };
    signer.dkg_begin(&dkg_begin_2, &mut rng).unwrap();
    assert_eq!(signer.dkg_id, 2);
    assert!(signer.dkg_public_shares.is_empty());
    
    // Attacker replays message from round 1
    signer.dkg_public_share(&public_shares_1).unwrap();
    
    // Replayed message is stored (vulnerability)
    assert!(signer.dkg_public_shares.contains_key(&0));
    
    // Create legitimate round 2 message
    let public_shares_2 = DkgPublicShares {
        dkg_id: 2,
        signer_id: 0,
        comms: vec![/* ... */],
        kex_public_key: Point::random(&mut rng),
    };
    
    // Legitimate message is rejected as duplicate
    signer.dkg_public_share(&public_shares_2).unwrap();
    
    // Verification will fail in dkg_ended() because stored shares
    // have Schnorr proofs with context dkg_id=1, but verification
    // uses context dkg_id=2
    let dkg_end = signer.dkg_ended(&mut rng).unwrap();
    
    // Assert that DKG fails due to bad public shares
    match dkg_end {
        Message::DkgEnd(end) => {
            assert!(matches!(end.status, 
                DkgStatus::Failure(DkgFailure::BadPublicShares(_))));
        },
        _ => panic!("Expected DkgEnd message"),
    }
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L557-557)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
```

**File:** src/state_machine/signer/mod.rs (L593-599)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L959-971)
```rust
    pub fn dkg_end_begin(&mut self, dkg_end_begin: &DkgEndBegin) -> Result<Vec<Message>, Error> {
        let msgs = vec![];

        self.dkg_end_begin_msg = Some(dkg_end_begin.clone());

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            "received DkgEndBegin"
        );

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/signer/mod.rs (L1029-1110)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/fire.rs (L479-483)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L527-531)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L632-648)
```rust
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L785-788)
```rust
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/schnorr.rs (L48-58)
```rust
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
```

**File:** src/schnorr.rs (L62-65)
```rust
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```
