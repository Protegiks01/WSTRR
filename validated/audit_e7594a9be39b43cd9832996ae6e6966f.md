Based on my thorough validation of the codebase, I confirm this is a **VALID CRITICAL VULNERABILITY**. All evidence supports the claims made in the report.

---

# Audit Report

## Title
Missing Validation of KEX Public Keys in DKG Allows Predictable Shared Secrets Leading to Group Private Key Compromise

## Summary
The DKG protocol fails to validate KEX (Key Exchange) public keys received in `DkgPublicShares` messages. A malicious signer can broadcast `Point::identity()` as their KEX public key, forcing all honest signers to compute identical predictable shared secrets when encrypting private polynomial shares. This breaks confidentiality of the shares, enabling complete reconstruction of the group private key and signature forgery.

## Finding Description

The WSTS DKG protocol uses ephemeral KEX keypairs for Diffie-Hellman key exchange to encrypt private polynomial shares during distribution.

**The Vulnerability:**

When signers receive `DkgPublicShares` messages, they store the `kex_public_key` without any validation: [1](#0-0) 

This unvalidated key is then used in Diffie-Hellman exchange to encrypt private shares: [2](#0-1) 

The `make_shared_secret` function performs scalar multiplication without validating the point: [3](#0-2) 

**Why This Breaks Security:**

Due to the fundamental elliptic curve property that `scalar * Point::identity() = Point::identity()`, when a malicious signer broadcasts `kex_public_key = Point::identity()`:

1. Every honest signer computing `shared_secret = their_kex_private * Point::identity()` gets `Point::identity()`
2. The shared secret bytes become predictable via `ansi_x963_derive_key(Point::identity().compress().as_bytes(), "DH_SHARED_SECRET_KEY/")`
3. All honest signers use the SAME shared secret when encrypting shares for the malicious signer's key_ids
4. Anyone (including network eavesdroppers) can compute this shared secret and decrypt the encrypted shares

**Contrast with Existing Protections:**

The codebase correctly validates signing nonces to prevent identity point attacks: [4](#0-3) 

This validation is enforced during signature share requests: [5](#0-4) 

However, no equivalent validation exists for KEX public keys in the signer state machine or coordinator: [6](#0-5) 

**Attack Execution:**

1. Malicious signer controls threshold `T` key_ids (realistic in weighted schemes where one signer can control multiple key_ids)
2. Broadcasts `DkgPublicShares` with `kex_public_key = Point::identity()`
3. All honest parties encrypt their polynomial evaluations for those key_ids using the predictable shared secret
4. Attacker (or eavesdropper) decrypts all shares: `f_1(k), f_2(k), ..., f_N(k)` for k in malicious_key_ids
5. With `T` evaluation points, reconstructs each honest party's polynomial via Lagrange interpolation
6. Extracts constant terms `f_i(0)` from each polynomial
7. Sums all constant terms (including attacker's own) to compute the group private key

The group private key is computed as the sum of all polynomial constant terms: [7](#0-6) 

## Impact Explanation

**Severity: CRITICAL**

This vulnerability results in complete compromise of the group private key, which directly maps to the critical impact defined in scope: **"Any confirmation of an invalid transaction"**.

A compromised group private key allows the attacker to:
1. Forge valid-looking signatures for arbitrary transactions
2. The signature verification will pass cryptographically
3. However, the transactions are unauthorized and represent invalid state transitions

**Downstream Impact:**
- All signatures produced by the compromised group can be forged indefinitely
- Transaction authenticity is completely invalidated
- No recovery possible without complete DKG restart with new participants
- Affects all parties in the DKG round and all future users of the group key
- In blockchain systems using WSTS for threshold signatures (e.g., multi-signature wallets, custody solutions), this enables unauthorized fund transfers

**Quantified Example:**
In a 5-of-7 threshold setup where a malicious signer controls 5 key_ids:
- Attacker receives encrypted shares from all honest parties (up to 7 parties)
- With 5 decrypted evaluation points per party, reconstructs each party's degree-4 polynomial
- Extracts constant terms from each polynomial and sums them to obtain the group private key
- Can now forge signatures for any message, enabling unauthorized transactions

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Capabilities Required:**
- Must be a legitimate signer participating in DKG (explicitly within threat model)
- Ability to modify outgoing `DkgPublicShares` message (standard signer capability)
- Control of threshold number of key_ids (common in weighted threshold schemes where one entity controls multiple keys)

**Attack Complexity: LOW**
- Modify single field: set `kex_public_key` to `Point::identity()` 
- `Point::identity()` is a valid serializable Point value (evidenced by its use in validation checks)
- No cryptographic breaks required
- No timing requirements or race conditions
- Attack is deterministic and repeatable
- Works passively (eavesdropper can also exploit without being the malicious signer)

**Economic Feasibility: HIGH**
- Zero additional cost if attacker already participates as a signer
- In weighted schemes, single signer commonly controls threshold or more key_ids
- Passive network eavesdropping suffices (no active MITM needed)

**Detection Risk: LOW**
- No validation exists that would reject `Point::identity()` as a KEX key
- Appears as normal DKG participation in all protocol messages
- Only detected when forged signatures are used, by which point the group key is already compromised
- DKG completes successfully without any errors or warnings

**Realistic Scenarios:**
- Insider threat: Malicious signer in custody setup
- Compromised signer node injecting malicious DkgPublicShares messages  
- Economic incentive: Stealing funds from threshold wallet implementations

## Recommendation

Add validation for KEX public keys to reject the identity element, similar to the existing nonce validation. Implement checks in both the signer and coordinator state machines:

**For Signer (src/state_machine/signer/mod.rs):**

Add validation before storing KEX public keys (around line 1018):
```rust
// Validate KEX public key is not identity or generator
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    warn!(%signer_id, "Invalid KEX public key (identity or generator)");
    return Ok(vec![]);
}

for key_id in signer_key_ids {
    self.kex_public_keys
        .insert(*key_id, dkg_public_shares.kex_public_key);
}
```

**For Coordinator (src/state_machine/coordinator/fire.rs):**

Add validation in `gather_public_shares` (around line 492):
```rust
// Validate KEX public key
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    warn!(signer_id = %dkg_public_shares.signer_id, 
          "Invalid KEX public key (identity or generator)");
    return Ok(());
}
```

This ensures KEX keys have the same level of protection as nonces, preventing predictable shared secret attacks.

## Proof of Concept

```rust
#[test]
fn test_kex_identity_attack() {
    use crate::curve::point::{Point, G};
    use crate::curve::scalar::Scalar;
    use crate::util::make_shared_secret;
    
    // Simulate honest signer's ephemeral private key
    let honest_kex_private = Scalar::random(&mut create_rng());
    
    // Attacker broadcasts Point::identity() as KEX public key
    let malicious_kex_public = Point::identity();
    
    // Honest signer computes shared secret with malicious key
    let shared_secret = make_shared_secret(&honest_kex_private, &malicious_kex_public);
    
    // Attacker (or eavesdropper) can compute the SAME shared secret
    // because scalar * Point::identity() = Point::identity() for ANY scalar
    let attacker_computed_secret = make_shared_secret(&Scalar::random(&mut create_rng()), &malicious_kex_public);
    
    // All shared secrets are identical and predictable
    assert_eq!(shared_secret, attacker_computed_secret);
    
    // This breaks confidentiality: attacker can decrypt all encrypted shares
    // sent to their key_ids using this predictable shared secret
}
```

This test demonstrates that when `Point::identity()` is used as a KEX public key, all Diffie-Hellman exchanges produce the same predictable result, breaking the confidentiality guarantee of the encrypted private shares.

## Notes

The vulnerability is particularly severe because:

1. **Stealthy**: The attack leaves no trace in protocol execution - DKG completes successfully
2. **Universal decryption**: Anyone observing the network can decrypt the shares, not just the malicious signer
3. **Permanent compromise**: Once the group key is compromised, all future signatures are compromised
4. **Realistic threat model**: Single malicious signer controlling threshold key_ids is common in weighted schemes

The fix is straightforward and follows the existing pattern used for nonce validation, making it a high-priority security patch.

### Citations

**File:** src/state_machine/signer/mod.rs (L787-795)
```rust
        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/v1.rs (L205-206)
```rust
        self.private_key = private_shares.values().sum();
        self.public_key = self.private_key * G;
```
