After performing a thorough validation of this security claim against the WSTS codebase, I have verified this is a **VALID VULNERABILITY**. Here is my analysis:

## Audit Report

### Title
Duplicate Key IDs in NonceResponse Bypass Validation and Corrupt Lagrange Coefficient Computation

### Summary
A malicious signer can send NonceResponse messages with duplicate key_ids that pass coordinator validation but cause incorrect Lagrange coefficient computation during signature aggregation. The validation logic converts the key_ids vector to a HashSet before comparison, masking duplicates, while the original vector with duplicates is stored and later used for cryptographic operations, resulting in signature verification failure and denial of service.

### Finding Description

The vulnerability exists in both FROST and FIRE coordinator implementations. The NonceResponse struct stores key_ids as Vec<u32>: [1](#0-0) 

The coordinator validation converts this vector to a HashSet before comparison in FIRE: [2](#0-1) 

And in FROST: [3](#0-2) 

**Root Cause**: When a malicious signer sends key_ids `[1, 1, 2]` and the configuration expects `{1, 2}`, the validation passes because `HashSet::from([1, 1, 2])` equals `{1, 2}`. However, the original NonceResponse with duplicate key_ids is stored unchanged: [4](#0-3) 

**Propagation**: When collecting key_ids for signature aggregation, the FIRE coordinator uses flat_map on stored NonceResponses, preserving all duplicates: [5](#0-4) 

The FROST coordinator does the same: [6](#0-5) 

Signers also extract key_ids using flat_map: [7](#0-6) 

**Cryptographic Impact**: These duplicate key_ids are passed to the Lagrange coefficient computation function: [8](#0-7) 

When computing `lambda(2, [1, 1, 2])`, the loop multiplies by `1/(1-2)` twice (once for each occurrence of 1), yielding `(-1) * (-1) = 1`, whereas the correct `lambda(2, [1, 2])` yields `-1`. This mathematical error breaks the Lagrange interpolation formula.

Signers compute their shares using these corrupted coefficients: [9](#0-8) 

The aggregator's check_signature_shares function uses the same corrupted key_ids for verification: [10](#0-9) 

### Impact Explanation

This vulnerability enables a single malicious signer to execute a denial-of-service attack against the WSTS signing protocol. The corrupted Lagrange coefficient computation breaks the mathematical foundation of threshold signature reconstruction. The Lagrange interpolation formula requires `sum(lambda_i * x_i) = x`, but incorrect lambda values violate this equation, causing signature verification to consistently fail.

**Severity Justification**: This maps to **Low** severity under the scope definition: "Any remotely-exploitable denial of service in a node." The attack prevents signing operations from succeeding but does not cause fund loss, chain splits, or acceptance of invalid transactions. One malicious signer can block all signing operations indefinitely.

### Likelihood Explanation

**Attacker Requirements**: The attacker must be a legitimate signer in the WSTS protocol with the ability to send network messages to the coordinator.

**Attack Complexity**: Low. The attacker only needs to craft a NonceResponse with duplicate key_ids that, when deduplicated, match their configured key set. No cryptographic operations, timing attacks, or complex state manipulation is required.

**Economic Feasibility**: Trivial. The attack requires no special resources beyond being a protocol participant.

**Detection**: The attack manifests as signature verification failure, but the coordinator's check_signature_shares diagnostic function uses the same corrupted key_ids list, potentially misidentifying which parties provided bad signatures.

**Probability**: High if any signer is malicious or misconfigured. The vulnerability is deterministic and requires no special conditions.

### Recommendation

Add validation to ensure key_ids contains no duplicates before storing the NonceResponse. This can be implemented by checking that the length of the Vec equals the length of the HashSet:

```rust
let nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

// Add this check
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response contains duplicate key_ids");
    return Ok(());
}

if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

This validation should be added to both FIRE and FROST coordinator implementations.

### Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a test signer configured with key_ids `{1, 2}`
2. Constructing a NonceResponse with duplicate key_ids `[1, 1, 2]`
3. Sending this to the coordinator
4. Observing that validation passes (HashSet comparison)
5. Extracting key_ids during signature aggregation (flat_map preserves duplicates)
6. Computing `lambda(2, [1, 1, 2])` returns `1` instead of correct `-1`
7. Signature verification fails due to incorrect Lagrange interpolation

The mathematical proof: `lambda(2, [1, 1, 2])` iterates over j=[1, 1, 2], computing `lambda *= 1/(1-2)` twice for the duplicate 1s, yielding `1 * (-1) * (-1) = 1`, while `lambda(2, [1, 2])` correctly yields `-1`.

### Citations

**File:** src/net.rs (L310-326)
```rust
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L675-678)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L403-404)
```rust
                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }
```
