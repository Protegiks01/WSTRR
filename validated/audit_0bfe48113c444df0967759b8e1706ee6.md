Audit Report

## Title
Coordinator Fails to Attribute Blame for Missing Private Shares Enabling Persistent DKG Denial of Service

## Summary
The FIRE and FROST coordinators fail to validate `DkgFailure::MissingPrivateShares` reports during the DKG end phase, leaving only a TODO comment where extensive validation logic should exist. A malicious signer can exploit this by selectively omitting encrypted shares for certain key_ids, causing honest signers to report failures that the coordinator cannot attribute to any party. This enables persistent DKG denial of service as the unidentified malicious signer can participate in retry attempts and repeat the attack indefinitely.

## Finding Description

The vulnerability exists in the `gather_dkg_end` function where the FIRE coordinator processes DKG failure reports from signers. When signers report `DkgFailure::MissingPrivateShares`, the coordinator performs no validation and does not add any signer to the `malicious_signers` set: [1](#0-0) 

This contrasts sharply with the extensive validation performed for `DkgFailure::BadPrivateShares`, which includes cryptographic verification, shared secret validation, and polynomial commitment checks: [2](#0-1) 

The FROST coordinator exhibits the same vulnerability, returning empty `malicious_signers` for all failure types: [3](#0-2) 

**Attack Mechanism:**

During `dkg_private_begin`, an honest signer constructs a `DkgPrivateShares` message by iterating through active key_ids and encrypting shares for each destination: [4](#0-3) 

A malicious signer can modify this logic to selectively omit certain `dst_key_id` values from the `encrypted_shares` HashMap (line 944), effectively withholding shares from targeted participants.

Honest signers detect this during `dkg_ended` by checking if all their key_ids have corresponding encrypted shares: [5](#0-4) 

When honest signers report this failure, they construct a `DkgFailure::MissingPrivateShares` containing the accused signer IDs: [6](#0-5) 

The coordinator collects these reports but performs no validation to distinguish between a malicious dealer who actually withheld shares and a malicious reporter making false claims: [7](#0-6) 

Since no signer is added to `malicious_signers` for this failure type, the coordinator returns an error without attribution: [8](#0-7) 

**Why Validation is Possible:**

The coordinator has all data necessary to validate these claims. It stores all `DkgPrivateShares` messages in a BTreeMap: [9](#0-8) 

The coordinator uses this stored data extensively when validating `BadPrivateShares` reports: [10](#0-9) 

The coordinator could validate `MissingPrivateShares` claims by checking whether the accused signer's `DkgPrivateShares.shares` HashMap contains encrypted shares for all expected key_ids of the reporting signer. The `DkgPrivateShares` structure is defined as: [11](#0-10) 

When the coordinator receives and stores these messages, no content validation occurs: [12](#0-11) 

## Impact Explanation

The vulnerability enables a **persistent denial of service** on DKG operations:

1. **DKG Operation Failure**: Any DKG round with the malicious signer fails, as honest signers correctly detect and report missing shares.

2. **No Blame Attribution**: The malicious signer is not identified or added to `malicious_dkg_signer_ids`: [13](#0-12) 

3. **Persistent Attack**: Without identifying the malicious signer, retry attempts include the same attacker, leading to repeated failures.

This maps to **LOW to MEDIUM** severity:
- **LOW**: "Any network denial of service impacting more than 10 percent of miners" - A single malicious signer can prevent all N signers from completing DKG, clearly exceeding the 10% threshold.
- **MEDIUM**: "Any transient consensus failures" - If DKG cannot complete, threshold signature operations cannot proceed, potentially causing transient consensus failures in systems depending on WSTS for distributed signing.

The attack causes DKG to fail uniformly for all participants rather than creating incompatible signing groups, as there is a single coordinator architecture where all signers see the same failure state.

## Likelihood Explanation

The attack is **highly likely** to succeed if an attacker controls a signer identity:

1. **Trivial Execution**: The attacker simply modifies the `encrypted_shares` HashMap construction to skip certain `dst_key_id` values or manually constructs a `DkgPrivateShares` message with incomplete mappings.

2. **No Special Capabilities Required**: Requires only control of a participating signer identity and ability to send protocol messages - no cryptographic breaks, key theft, or timing attacks needed.

3. **Deterministic Success**: Every execution succeeds as long as at least one honest signer is missing shares and reports the failure.

4. **Zero Detection Risk**: The coordinator explicitly does not attribute blame for this failure type, making the attacker unidentifiable through the protocol.

5. **Sustainable Attack**: Since `malicious_dkg_signer_ids` is never updated for this failure type, the same attacker can participate in unlimited retry attempts.

## Recommendation

Implement validation logic for `DkgFailure::MissingPrivateShares` in the `gather_dkg_end` function, analogous to the existing `BadPrivateShares` validation. The coordinator should:

1. Extract the reporter's key_ids from `self.config.public_keys.signer_key_ids.get(signer_id)`
2. Retrieve the accused signer's stored `DkgPrivateShares` from `self.dkg_private_shares.get(bad_signer_id)`
3. For each (party_id, shares_map) in the accused signer's shares, verify that all of the reporter's key_ids exist in the shares_map
4. If any key_id is missing, add the accused signer to `malicious_signers`
5. If all key_ids are present, add the reporter to `malicious_signers` for making a false accusation

Replace lines 768-770 in `src/state_machine/coordinator/fire.rs` with comprehensive validation that mirrors the structure used for `BadPrivateShares` validation.

## Proof of Concept

The existing test case demonstrates the unvalidated behavior: [14](#0-13) 

This test confirms that when `MissingPrivateShares` is reported, the coordinator returns a `DkgError::DkgEndFailure` without identifying any malicious signers. A malicious signer can construct a `DkgPrivateShares` message with an incomplete shares HashMap, send it through the protocol, and trigger this code path. Since the coordinator stores messages without validation and performs no blame attribution, the attack succeeds deterministically and can be repeated indefinitely.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L41-41)
```rust
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L549-558)
```rust
            self.dkg_wait_signer_ids
                .remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
            info!(
                dkg_id = %dkg_private_shares.dkg_id,
                signer_id = %dkg_private_shares.signer_id,
                "DkgPrivateShares received"
            );
```

**File:** src/state_machine/coordinator/fire.rs (L607-611)
```rust
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());

```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L768-770)
```rust
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-788)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }

            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/coordinator/frost.rs (L413-416)
```rust
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
```

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L601-609)
```rust
        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L926-949)
```rust
        for (party_id, shares) in &self.signer.get_shares() {
            debug!(
                "Signer {} addding dkg private share for party_id {party_id}",
                self.signer_id
            );
            // encrypt each share for the recipient
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
        }
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/state_machine/coordinator/mod.rs (L1854-1878)
```rust
        let OperationResult::DkgError(DkgError::DkgEndFailure {
            reported_failures, ..
        }) = &operation_results[0]
        else {
            panic!(
                "Expected OperationResult::DkgError(DkgError::DkgEndFailure) got {:?}",
                operation_results[0]
            );
        };
        assert_eq!(
            reported_failures.len(),
            num_signers as usize,
            "Expected {num_signers} DkgFailures got {}",
            reported_failures.len()
        );
        let expected_signer_ids = (0..1).collect::<HashSet<u32>>();
        for dkg_failure in reported_failures {
            let (_, DkgFailure::MissingPrivateShares(signer_ids)) = dkg_failure else {
                panic!("Expected DkgFailure::MissingPublicShares got {dkg_failure:?}");
            };
            assert_eq!(
                expected_signer_ids, *signer_ids,
                "Expected signer_ids {expected_signer_ids:?} got {signer_ids:?}"
            );
        }
```
