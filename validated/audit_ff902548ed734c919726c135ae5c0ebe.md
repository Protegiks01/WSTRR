# Audit Report

## Title
Duplicate key_ids in NonceResponse Bypass HashSet Validation, Causing Denial of Service via Incorrect Lagrange Interpolation

## Summary
A malicious signer can inject duplicate `key_ids` into their `NonceResponse` message, bypassing coordinator validation that uses HashSet comparison. These duplicates propagate through the signing protocol and cause incorrect Lagrange coefficient computation, resulting in guaranteed signature verification failure. A single compromised signer can prevent all threshold signatures from succeeding indefinitely.

## Finding Description

**Root Cause:**
The coordinator validates `NonceResponse.key_ids` by converting the Vec to a HashSet before comparing with the configured signer's key_ids. [1](#0-0)  This HashSet conversion silently removes duplicates, allowing a malicious `NonceResponse` with `key_ids = [1, 1, 2, 3]` to pass validation when the config expects `{1, 2, 3}`.

**Attack Path:**

1. **Validation Bypass**: The coordinator's `gather_nonces` method accepts the malicious NonceResponse because HashSet comparison removes duplicates during validation. [2](#0-1) 

2. **Duplicate Preservation**: The validated NonceResponse (with duplicates intact in the Vec field) is stored in coordinator state. [3](#0-2) 

3. **Propagation to Signers**: When building the `SignatureShareRequest`, the coordinator collects all stored NonceResponse objects, preserving the duplicate key_ids. [4](#0-3) 

4. **Signer Extraction**: Signers extract key_ids by flat-mapping over all nonce_responses, which preserves all duplicates. [5](#0-4) 

5. **Incorrect Lagrange Computation**: The `lambda()` function iterates over ALL elements in the key_ids slice. [6](#0-5)  When a key_id appears multiple times, it multiplies by the same factor repeatedly, producing incorrect coefficients.

   For example, `lambda(2, [1, 1, 2, 3])`:
   - j=1 (first): multiply by 1/(1-2) = -1 → lambda = -1
   - j=1 (duplicate): multiply by 1/(1-2) = -1 → lambda = 1 (sign flips!)
   - j=2: skip (i==j)
   - j=3: multiply by 3/(3-2) = 3 → lambda = 3
   
   The correct value is `lambda(2, [1, 2, 3]) = -3`, but with duplicates it becomes `3`.

6. **Wrong Signature Shares**: Each signer computes their signature share using the incorrect lambda values. [7](#0-6) 

7. **Coordinator Aggregation with Same Duplicates**: The coordinator extracts key_ids from nonce_responses using the same flat_map pattern, resulting in the same duplicate key_ids. [8](#0-7) 

8. **Verification Failure**: The aggregated signature fails final Schnorr verification [9](#0-8)  because the Lagrange interpolation property is violated. While `check_signature_shares` also uses the same duplicate key_ids [10](#0-9)  (making individual shares appear valid), the final aggregate fails because the mathematical relationship `z*G = R + c*GroupPublicKey` does not hold when lambda coefficients are incorrect.

**Why Existing Mitigations Fail:**
- The `validate_key_id()` function only validates individual key_id ranges, not duplicate detection. [11](#0-10) 
- The SignatureShareResponse validation also uses HashSet comparison, failing to detect duplicates. [12](#0-11) 
- The error returned is `AggregatorError::BadGroupSig` [13](#0-12) , which does not identify the malicious signer, and the coordinator does not mark signers as malicious based on signature verification failures.

## Impact Explanation

**Severity Assessment:**

This vulnerability enables a **complete denial of service** with a single compromised signer. The impact severity depends on integration context:

- **Low Severity** (minimum): "Any remotely-exploitable denial of service in a node" - A single malicious signer can prevent any threshold signature from succeeding, causing 100% signature failure rate.

- **Critical Severity** (if integrated with Stacks): "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks" - If WSTS signatures are required for transaction confirmation, this prevents the network from confirming any transactions.

**Quantified Impact:**
- **Immediate**: 100% signature failure rate while malicious signer participates
- **Persistent**: The malicious signer is not detected or excluded from the signing set, causing repeated failures
- **Threshold Violation**: In threshold signature schemes, the system should tolerate up to (threshold-1) Byzantine participants. A single malicious signer causing complete system failure violates this security guarantee.

## Likelihood Explanation

**Required Attacker Capabilities:**
- Control of a single signer's private key (within the protocol threat model of up to threshold-1 malicious signers)
- Ability to send network messages (normal protocol participation)
- No cryptographic breaks required

**Attack Complexity:**
Very low. The attacker simply modifies their `NonceResponse.key_ids` field to include a duplicate before signing and sending the message. No sophisticated techniques required.

**Detection and Exclusion:**
None. The malicious message passes all validation checks. The coordinator logs signature failures but does not identify the root cause or exclude the malicious signer from future rounds.

**Probability:**
High. Any compromised signer (whether through key theft, Byzantine behavior, or software bugs) can trivially execute this attack with 100% success rate until manual intervention.

## Recommendation

Add explicit duplicate detection after HashSet validation:

```rust
// In src/state_machine/coordinator/fire.rs, after line 885
let nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}

// Add duplicate check
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Duplicate key_ids detected in NonceResponse");
    return Ok(());
}
```

Apply the same check in:
- `SignatureShareResponse` validation (around line 1066 in fire.rs)
- `gather_nonces` in frost.rs for consistency

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_cause_lambda_error() {
    use wsts::compute::lambda;
    
    // Correct lambda computation with unique key_ids
    let correct_lambda = lambda(2, &[1, 2, 3]);
    println!("Correct lambda(2, [1,2,3]) = {:?}", correct_lambda);
    
    // Incorrect lambda computation with duplicate key_ids
    let incorrect_lambda = lambda(2, &[1, 1, 2, 3]);
    println!("Incorrect lambda(2, [1,1,2,3]) = {:?}", incorrect_lambda);
    
    // They should be different, proving the vulnerability
    assert_ne!(correct_lambda, incorrect_lambda, 
        "Lambda values differ with duplicate key_ids, violating Lagrange interpolation");
}
```

This test demonstrates that duplicate key_ids produce different (incorrect) Lagrange coefficients, breaking the mathematical foundation of threshold signatures and causing signature verification to fail.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-977)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L403-403)
```rust
                cx += compute::lambda(*key_id, key_ids) * c * public_key;
```

**File:** src/v2.rs (L415-415)
```rust
            AggregatorError::BadGroupSig
```

**File:** src/v2.rs (L476-476)
```rust
        if proof.verify(&key.x(), msg) {
```

**File:** src/common.rs (L314-316)
```rust
pub fn validate_key_id(key_id: u32, num_keys: u32) -> bool {
    key_id > 0 && key_id <= num_keys
}
```
