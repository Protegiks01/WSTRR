# Audit Report

## Title
Missing DKG Round ID Validation Before Duplicate Check Enables Denial of Service

## Summary
The `dkg_private_shares()` function in the Signer state machine lacks validation that incoming `DkgPrivateShares` messages match the current DKG round ID before performing duplicate detection and storing shares. This allows an attacker to replay legitimately-signed messages from previous DKG rounds, blocking legitimate current-round shares and causing DKG failure.

## Finding Description

The Signer's `dkg_private_shares()` function performs validation in this order: signer_id verification, party_id validation, duplicate detection keyed by signer_id only, immediate storage of shares, then decryption. [1](#0-0) 

Critically, the function never validates that the incoming message's `dkg_id` field matches the Signer's current `self.dkg_id`. The `DkgPrivateShares` message structure includes a `dkg_id` field (u64) that identifies which DKG round the shares belong to. [2](#0-1) 

In contrast, both coordinator implementations correctly validate `dkg_id` BEFORE the duplicate check. The FireCoordinator checks if `dkg_private_shares.dkg_id != self.current_dkg_id` and returns `Error::BadDkgId` if they don't match. [3](#0-2)  The FrostCoordinator implements identical validation. [4](#0-3) 

The Signer's packet signature verification only confirms the message was cryptographically signed by the claimed signer, but does not validate round ID correctness. [5](#0-4)  This signature check occurs before message processing. [6](#0-5) 

**Attack Execution Path:**

1. Attacker captures or replays a validly-signed `DkgPrivateShares` message from DKG round N-1 (from signer X)
2. During current round N, victim signer Y receives the replayed message
3. No `dkg_id` validation occurs - the function proceeds with signer_id and party_id checks only
4. Duplicate check passes (first message received from signer X in this round)
5. Wrong-round shares are stored immediately in `self.dkg_private_shares`
6. Decryption fails because KEX keys are rotated per round via `self.kex_private_key = Scalar::random(rng)` during reset. [7](#0-6) 
7. Failed decryption marks the shares as `invalid_private_shares`. [8](#0-7) 
8. When legitimate shares from signer X arrive with correct `dkg_id = N`, the duplicate check rejects them (already have entry for signer X)
9. During `dkg_ended()`, the presence of invalid shares causes DKG to return `DkgStatus::Failure(DkgFailure::BadPrivateShares(...))`. [9](#0-8) 

The security guarantee broken is **DKG round isolation** - shares from different DKG rounds should not interfere with each other. Without round ID validation, the duplicate detection mechanism becomes a denial-of-service vector.

## Impact Explanation

This vulnerability enables a remotely-exploitable denial of service attack against DKG participants. When an attacker successfully injects wrong-round shares to signers, the entire DKG round fails with `BadPrivateShares` errors. Since the signing group cannot complete DKG, they cannot derive the group public key and therefore cannot sign transactions.

Manual intervention is required from the application layer to restart failed DKG rounds. During the failure period, the signing group is unable to participate in transaction signing operations.

This maps to **Low severity** per the provided scope: "Any remotely-exploitable denial of service in a node". If the attack prevents transaction confirmation across multiple blocks by affecting enough signers, impact severity could increase toward **Medium** ("Any transient consensus failures") or **Critical** thresholds.

## Likelihood Explanation

**Attacker Requirements:**
- Network-level access to observe and replay messages between signers, OR
- A malicious signer within threshold who can replay their own previous messages

**Attack Complexity:**
Low - The attacker simply captures and replays a `DkgPrivateShares` message from any previous DKG round. The replayed message contains a valid cryptographic signature (legitimately signed in the previous round), includes the `dkg_id` field in its hash, and passes all authentication checks since it was legitimately created.

**Economic Feasibility:**
Minimal cost - requires only network positioning to capture and replay messages. No cryptographic breaks, no key compromises, no expensive computational resources needed.

**Detection:**
Low detection risk - the replayed message appears as a legitimate protocol message until DKG validation fails, by which point legitimate shares have already been blocked.

**Estimated Probability:**
Moderate to High if the attacker has network access to signer-to-signer communication channels. With a single malicious signer within threshold, success is guaranteed as they can replay their own previous messages to target specific victims.

## Recommendation

Add `dkg_id` validation at the beginning of the `dkg_private_shares()` function, immediately after retrieving the signer_id and before any other validation:

```rust
pub fn dkg_private_shares<R: RngCore + CryptoRng>(
    &mut self,
    dkg_private_shares: &DkgPrivateShares,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Validate dkg_id matches current round
    if dkg_private_shares.dkg_id != self.dkg_id {
        warn!(
            "Received DkgPrivateShares with mismatched dkg_id: {} != {}",
            dkg_private_shares.dkg_id, self.dkg_id
        );
        return Ok(vec![]);
    }
    
    let src_signer_id = dkg_private_shares.signer_id;
    // ... rest of function continues normally
}
```

This matches the validation pattern used by both coordinator implementations and ensures DKG round isolation is properly enforced.

## Proof of Concept

```rust
#[test]
fn test_dkg_private_shares_wrong_round_blocked() {
    use crate::{
        curve::{ecdsa, scalar::Scalar},
        net::{DkgPrivateShares, DkgPublicShares},
        state_machine::{signer::Signer, PublicKeys},
        util::create_rng,
        v2,
    };
    use hashbrown::HashSet;
    use std::collections::HashMap;

    let mut rng = create_rng();
    let private_key = Scalar::random(&mut rng);
    let public_key = ecdsa::PublicKey::new(&private_key).unwrap();
    let private_key2 = Scalar::random(&mut rng);
    let public_key2 = ecdsa::PublicKey::new(&private_key2).unwrap();
    
    let mut public_keys: PublicKeys = Default::default();
    public_keys.signers.insert(0, public_key);
    public_keys.signers.insert(1, public_key2);
    public_keys.key_ids.insert(1, public_key);
    public_keys.key_ids.insert(2, public_key2);
    
    let mut key_ids = HashSet::new();
    key_ids.insert(1);
    public_keys.signer_key_ids.insert(0, key_ids);
    
    let mut key_ids2 = HashSet::new();
    key_ids2.insert(2);
    public_keys.signer_key_ids.insert(1, key_ids2);

    let mut signer = Signer::<v2::Signer>::new(
        1, 1, 2, 2, 0, vec![1], private_key, public_keys, &mut rng
    ).unwrap();

    // Setup: process public shares to establish KEX keys
    let kex_public_key = signer.kex_private_key * crate::curve::point::G;
    let public_share = DkgPublicShares {
        dkg_id: 0,
        signer_id: 1,
        comms: vec![],
        kex_public_key,
    };
    signer.dkg_public_share(&public_share).unwrap();

    // Attack: Send private shares from WRONG round (dkg_id = 99)
    let wrong_round_shares = DkgPrivateShares {
        dkg_id: 99,  // Wrong round!
        signer_id: 1,
        shares: vec![(1, HashMap::new())],
    };
    signer.dkg_private_shares(&wrong_round_shares, &mut rng).unwrap();

    // Vulnerability: Wrong-round shares were accepted and stored
    assert_eq!(1, signer.dkg_private_shares.len());
    
    // Attack succeeds: Legitimate shares with correct dkg_id=0 are now blocked
    let legitimate_shares = DkgPrivateShares {
        dkg_id: 0,  // Correct round
        signer_id: 1,
        shares: vec![(1, HashMap::new())],
    };
    signer.dkg_private_shares(&legitimate_shares, &mut rng).unwrap();
    
    // Still only 1 entry - legitimate shares were rejected as duplicate
    assert_eq!(1, signer.dkg_private_shares.len());
    
    // The stored shares are from wrong round (dkg_id=99), not legitimate (dkg_id=0)
    let stored = signer.dkg_private_shares.get(&1).unwrap();
    assert_eq!(stored.dkg_id, 99);  // VULNERABILITY: Wrong round stored!
}
```

This test demonstrates that wrong-round shares are accepted and block legitimate shares, violating DKG round isolation and enabling denial of service.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L652-660)
```rust
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };
```

**File:** src/state_machine/signer/mod.rs (L1029-1110)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L525-565)
```rust
    fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
            info!(
                dkg_id = %dkg_private_shares.dkg_id,
                signer_id = %dkg_private_shares.signer_id,
                "DkgPrivateShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.private_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/frost.rs (L336-375)
```rust
    fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }

            self.ids_to_await.remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
            info!(
                dkg_id = %dkg_private_shares.dkg_id,
                signer_id = %dkg_private_shares.signer_id,
                "DkgPrivateShares received"
            );
        }

        if self.ids_to_await.is_empty() {
            self.move_to(State::DkgEndDistribute)?;
        }
        Ok(())
    }
```
