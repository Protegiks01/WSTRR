# Audit Report

## Title
Unbounded Message Serialization Sizes Enable Memory Exhaustion DoS

## Summary
The WSTS library processes DKG messages without validating vector sizes before hashing and storage, allowing malicious signers to cause denial of service through memory and CPU exhaustion. Messages with excessive polynomial commitments are accepted, hashed for signature verification, and stored in coordinator state before size validation occurs in later protocol phases.

## Finding Description

The `DkgPublicShares` message structure contains unbounded vectors that are processed without size validation before storage. The `comms` field is defined as `Vec<(u32, PolyCommitment)>` with no maximum size constraint [1](#0-0) , and each `PolyCommitment` contains an unbounded `poly: Vec<Point>` field [2](#0-1) .

During signature verification (if enabled), the `DkgPublicShares::hash` method iterates through all entries in `comms` and all Points in each polynomial, compressing each Point (33 bytes) [3](#0-2) . This occurs before any size validation, as the signature verification happens at the entry point of message processing [4](#0-3)  via the `packet.verify()` method [5](#0-4) .

In the coordinator's `gather_public_shares` function, messages are cloned and stored immediately in state without checking vector bounds or polynomial sizes. The FROST coordinator implementation stores the entire message via clone [6](#0-5) , and the FIRE coordinator exhibits the same pattern [7](#0-6) .

The `check_public_shares` validation function only verifies that the polynomial length equals the configured threshold, not that it's within reasonable absolute bounds [8](#0-7) . This validation occurs much later during the DkgEnd phase in both signer [9](#0-8)  and coordinator implementations [10](#0-9) , after resources have already been consumed.

A malicious signer can construct messages with arbitrary vector sizes (e.g., 10,000 comms entries with excessive Points each) and sign them with their valid private key. These messages will be accepted, signature-verified (consuming CPU), and stored (consuming memory) before eventual rejection during DkgEnd validation.

## Impact Explanation

This vulnerability enables remotely-exploitable denial of service against coordinator and signer nodes. A malicious signer can craft `DkgPublicShares` messages with excessive polynomial commitments. When received, the node must:

1. Hash the entire message during signature verification, iterating through all Points and performing point compression operations (CPU exhaustion)
2. Clone and store the entire message structure in state (memory exhaustion)

Since DKG completion is required before any threshold signatures can be generated, preventing DKG through DoS prevents the entire signing functionality. This maps to **"Low: Any remotely-exploitable denial of service in a node"** in the protocol scope, as it renders nodes unresponsive and prevents signature generation without completely shutting down the network.

Multiple concurrent malicious messages from different registered signers could compound the impact, especially in resource-constrained environments.

## Likelihood Explanation

**High Likelihood** - The attack is trivially exploitable:

**Required Attacker Capabilities:**
- Must be a registered signer with valid credentials (within protocol threat model)
- Ability to send network messages to coordinators

**Attack Complexity:** Very Low
- Simply construct oversized message by populating vectors with excessive elements
- Sign with valid private key (no cryptographic bypasses needed)
- Executable with basic script modifications

**Economic Feasibility:** High
- Minimal computational cost (just memory allocation)
- Single message impacts multiple nodes simultaneously
- No ongoing costs or resource requirements

**Detection Risk:** Low
- No size limits exist to reject messages before processing
- Messages pass initial validation checks (signature verification succeeds)
- Only fail validation after resource consumption

**Success Probability:** High
- Works immediately upon message receipt
- No race conditions or timing dependencies
- Affects all coordinator/signer implementations
- Repeatable across DKG rounds

## Recommendation

Implement early size validation before hashing and storage:

1. Add maximum bounds constants for message vector sizes (e.g., `MAX_COMMS_ENTRIES`, `MAX_POLY_SIZE`)
2. Validate bounds immediately upon message reception, before signature verification
3. Reject oversized messages with appropriate error responses
4. Consider adding these checks in the message deserialization layer

Example validation to add before signature verification:
```rust
const MAX_COMMS_ENTRIES: usize = 100;
const MAX_POLY_SIZE: usize = 100;

if dkg_public_shares.comms.len() > MAX_COMMS_ENTRIES {
    return Err(Error::MessageTooLarge);
}
for (_, comm) in &dkg_public_shares.comms {
    if comm.poly.len() > MAX_POLY_SIZE {
        return Err(Error::MessageTooLarge);
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_oversized_dkg_public_shares_dos() {
    let mut rng = create_rng();
    let ctx = 0u64.to_be_bytes();
    
    // Create legitimate signer
    let signer_private_key = Scalar::random(&mut rng);
    let signer_public_key = ecdsa::PublicKey::new(&signer_private_key).unwrap();
    
    // Construct malicious DkgPublicShares with excessive comms entries
    let mut malicious_comms = Vec::new();
    for i in 0..10000 {  // 10,000 comms entries
        let mut poly = Vec::new();
        for _ in 0..1000 {  // 1,000 Points each
            poly.push(Point::from(Scalar::random(&mut rng)));
        }
        malicious_comms.push((
            i,
            PolyCommitment {
                id: ID::new(&Scalar::random(&mut rng), &Scalar::random(&mut rng), &ctx, &mut rng),
                poly,
            },
        ));
    }
    
    let malicious_msg = DkgPublicShares {
        dkg_id: 0,
        signer_id: 0,
        comms: malicious_comms,
        kex_public_key: Point::from(Scalar::random(&mut rng)),
    };
    
    // Demonstrate that hashing (which occurs during signature verification) 
    // consumes excessive CPU
    let start = std::time::Instant::now();
    let _sig = malicious_msg.sign(&signer_private_key).unwrap();
    let hash_time = start.elapsed();
    
    // Demonstrate that cloning/storage consumes excessive memory
    let start = std::time::Instant::now();
    let _stored = malicious_msg.clone();
    let clone_time = start.elapsed();
    
    // Both operations complete (attack succeeds), but consume excessive resources
    assert!(hash_time.as_millis() > 100);  // Significant CPU time
    assert!(clone_time.as_millis() > 10);   // Significant memory allocation time
}
```

### Citations

**File:** src/net.rs (L147-147)
```rust
    pub comms: Vec<(u32, PolyCommitment)>,
```

**File:** src/net.rs (L157-162)
```rust
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
```

**File:** src/net.rs (L526-531)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
```

**File:** src/common.rs (L32-32)
```rust
    pub poly: Vec<Point>,
```

**File:** src/common.rs (L319-320)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
```

**File:** src/state_machine/coordinator/fire.rs (L218-224)
```rust
        if self.config.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L633-637)
```rust
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
```

**File:** src/state_machine/coordinator/frost.rs (L317-318)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L557-557)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
```
