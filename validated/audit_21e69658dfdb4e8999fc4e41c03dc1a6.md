# Audit Report

## Title
Unauthenticated KEX Public Key Enables Man-in-the-Middle Decryption of DKG Private Shares via Point-at-Infinity Substitution

## Summary
The `kex_public_key` field in `DkgPublicShares` messages is neither authenticated by the message signature nor validated against point-at-infinity, allowing a man-in-the-middle attacker to replace any participant's `kex_public_key` with `Point::identity()`. This causes all encrypted private shares for that participant to use a predictable shared secret, enabling the attacker to decrypt private polynomial shares and reconstruct the group private key with threshold shares.

## Finding Description

**Security Guarantee Broken:** Confidentiality of private polynomial shares during DKG, ultimately compromising the security of the group private key.

### Root Cause 1: Missing Authentication

The `DkgPublicShares` message signature computation explicitly excludes the `kex_public_key` field. [1](#0-0) 

The signature only authenticates `dkg_id`, `signer_id`, and polynomial commitments (`comms`). An attacker can modify `kex_public_key` without invalidating the signature, and the modified message passes verification. [2](#0-1) 

### Root Cause 2: Missing Validation

When processing incoming `DkgPublicShares` messages, the signer stores the `kex_public_key` directly without any validation against `Point::identity()`. [3](#0-2) 

In contrast, the codebase properly validates public nonces to prevent this exact attack class by checking against `Point::identity()`. [4](#0-3) 

However, no equivalent validation exists for `kex_public_key` in the DKG flow.

### Root Cause 3: Predictable Shared Secret from Point-at-Infinity

The `make_shared_secret()` function performs scalar multiplication without validating the public key. [5](#0-4) 

When `public_key` is `Point::identity()`, the scalar multiplication `private_key * public_key` yields `Point::identity()` regardless of `private_key`, producing a constant, predictable shared secret through the key derivation function.

### Attack Flow

1. During DKG, victim V generates a legitimate `kex_public_key` and broadcasts it. [6](#0-5) 

2. Attacker intercepts V's `DkgPublicShares` message and replaces `kex_public_key` with `Point::identity()`

3. Signature verification passes because `kex_public_key` is not authenticated in the hash

4. All signers store `Point::identity()` as V's key without validation

5. During private share distribution, each sender encrypts shares for V using the compromised key. [7](#0-6) 

6. Because V's stored key is `Point::identity()`, all senders compute the same predictable `shared_secret`

7. The attacker computes this same predictable `shared_secret` and decrypts all private shares intended for V. [8](#0-7) 

8. V's decryption fails because V uses the correct `kex_private_key`, but the attacker has already obtained the shares

9. Repeating this attack for threshold `t` participants gives the attacker `t` private key shares

10. The attacker uses Lagrange interpolation to reconstruct the group private key, enabling arbitrary transaction signing

## Impact Explanation

This vulnerability achieves **Critical** severity as defined in the scope:

**Direct Loss of Funds:** With threshold `t` compromised private shares, the attacker reconstructs the group private key and can sign arbitrary transactions to steal all funds controlled by that key. This directly maps to: "Any causing the direct loss of funds other than through any form of freezing."

**Invalid Transaction Confirmation:** The attacker can sign and broadcast unauthorized transactions. This maps to: "Any confirmation of an invalid transaction, such as with an incorrect nonce."

**Quantified Impact:**
- All assets controlled by compromised WSTS-generated keys are at risk
- Attacker needs MITM capability on threshold participants (e.g., 28 out of 40)
- Attack window is during DKG private share distribution phase
- Affects all downstream systems relying on these threshold signatures

## Likelihood Explanation

**Required Attacker Capabilities:**
1. Man-in-the-middle network position to intercept and modify DKG traffic between threshold participants
2. Ability to deserialize/reserialize `DkgPublicShares` messages
3. No cryptographic breaks or compromised private keys required

**Attack Complexity:**
The attack requires modifying a single field in DKG messages. The modified messages pass all existing validation checks. However, the attacker must successfully MITM threshold participants (e.g., 28 out of 40), which is a significant requirement.

**Threat Model Alignment:**
MITM attacks are explicitly in-scope per the High severity definition: "attacks restricted to the Stacks blockchain RPC/P2P ports."

**Detection Risk:**
The modified `kex_public_key` passes signature verification. Decryption failures at victims may be attributed to network errors. No cryptographic alarms trigger since the attack exploits protocol logic rather than breaking cryptographic primitives.

**Realistic Assessment:**
While requiring MITM on threshold participants is a high bar, it's achievable for well-resourced attackers targeting high-value deployments through compromised network infrastructure (ISPs, data centers, cloud providers).

## Recommendation

Implement three complementary fixes:

**Fix 1: Authenticate kex_public_key in signature**
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // ADD THIS LINE:
        hasher.update(self.kex_public_key.compress().as_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**Fix 2: Validate kex_public_key on receipt**
```rust
// In dkg_public_shares processing:
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!("Received DkgPublicShares with identity kex_public_key");
    return Ok(vec![]);
}
```

**Fix 3: Validate public keys in make_shared_secret**
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> Result<[u8; 32], Error> {
    if *public_key == Point::identity() {
        return Err(Error::InvalidPublicKey);
    }
    let shared_key = private_key * public_key;
    Ok(make_shared_secret_from_key(&shared_key))
}
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a test where a signer broadcasts `DkgPublicShares` with legitimate `kex_public_key`
2. Simulating MITM by replacing `kex_public_key` with `Point::identity()` (or `Point::new()`)
3. Verifying signature still passes despite modification
4. Observing that all senders compute identical `shared_secret` when encrypting shares
5. Demonstrating attacker can decrypt shares using the predictable `shared_secret`

The test would validate that `make_shared_secret(&any_private_key, &Point::identity())` produces a deterministic output independent of `any_private_key`, allowing share decryption without knowledge of legitimate keys.

### Citations

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L872-877)
```rust
        let mut public_share = DkgPublicShares {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            comms: Vec::new(),
            kex_public_key: self.kex_private_key * G,
        };
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```
