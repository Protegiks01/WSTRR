# Audit Report

## Title
Memory and CPU Exhaustion via Unbounded PolyCommitment Vector During DKG

## Summary
A malicious signer can cause denial-of-service attacks by sending `DkgPublicShares` messages with oversized `PolyCommitment` structures containing arbitrarily large polynomial vectors. Expensive signature verification operations (including elliptic curve point compression) execute before polynomial size validation, enabling resource exhaustion that prevents DKG completion.

## Finding Description

The vulnerability violates the security principle of "validate early, fail fast" by performing expensive cryptographic operations on unvalidated input data.

**Core Vulnerability**: The `PolyCommitment` structure contains an unbounded `Vec<Point>` field with no size constraints. [1](#0-0) 

**Execution Flow - Coordinator Path**: When a `DkgPublicShares` message arrives, the coordinator verifies packet signatures first if `verify_packet_sigs` is enabled (which defaults to `true`). [2](#0-1) 

The coordinator's default configuration enables signature verification: [3](#0-2) 

**Execution Flow - Signer Path**: Signers follow the identical pattern, verifying signatures before validation: [4](#0-3) 

Signers default to enabling verification: [5](#0-4) 

**Why Verification is Expensive**: During packet verification via `Packet::verify()`, the `DkgPublicShares.hash()` method iterates over ALL polynomial points and compresses each one - an expensive elliptic curve operation: [6](#0-5) 

**Late Validation**: The polynomial size validation exists but executes too late: [7](#0-6) 

For signers, `check_public_shares()` is only called during `dkg_ended()` processing, well after packet verification: [8](#0-7) 

For coordinators, validation occurs in `gather_dkg_end()` when processing failure reports: [9](#0-8) 

**No Early Validation**: The coordinator's `gather_public_shares()` method stores messages without polynomial size validation: [10](#0-9) 

The signer's `dkg_public_share()` method similarly lacks early validation: [11](#0-10) 

**Attack Execution**:
1. Malicious signer creates `DkgPublicShares` with `PolyCommitment` containing millions of points
2. Signs the message with their valid private key
3. Recipients verify the signature, hashing and compressing all millions of points
4. This causes severe CPU exhaustion (minutes of processing) and memory exhaustion (gigabytes)
5. Victim nodes become unresponsive, preventing DKG completion
6. Eventually detected, but damage is done

## Impact Explanation

This vulnerability enables a malicious insider signer to prevent DKG completion across the entire signing group.

**Resource Exhaustion**: A single `PolyCommitment` with 10 million points requires ~640 MB memory and several minutes of CPU time for point compression operations. With multiple commitments per message (one per party), total resource consumption scales significantly.

**Group-Wide Impact**: The attack affects all participants processing the malicious message:
- Coordinators become unresponsive and cannot complete DKG
- All honest signers processing the message also become unresponsive
- The entire DKG round fails

**Severity Justification - Medium**: This maps to "Any transient consensus failures" because:
- WSTS is designed for blockchain threshold signature operations
- Failed DKG prevents signature generation required for consensus
- Affects entire signing group, not just individual nodes
- While transient (DKG can be retried after excluding malicious signer), it disrupts critical operations
- Exceeds Low severity (single node DoS) as it impacts group coordination

## Likelihood Explanation

**Attack Requirements** (all within threat model):
- Attacker must be a registered signer with valid `signer_id`
- Must possess the corresponding private key
- Must have network access during DKG

The WSTS threat model explicitly allows for malicious signers up to `threshold-1`.

**Attack Complexity**: Low - Simply create oversized `PolyCommitment` and sign with valid key

**Economic Feasibility**: High - Single message causes significant damage with no cost to attacker

**Detection Difficulty**: Low - Appears as legitimate signed DKG message until resource exhaustion occurs

**Success Probability**: ~100% for registered signers (absent external message size limits)

## Recommendation

Implement early validation before expensive operations:

1. **Add size limits during deserialization**: Validate `poly.len() <= threshold` when deserializing `PolyCommitment` structures

2. **Validate before signature verification**: Move `check_public_shares()` call to occur before `packet.verify()` in both coordinator and signer message processing paths

3. **Add maximum size constant**: Define `MAX_POLYNOMIAL_SIZE` constant and enforce during deserialization

4. **Fast-fail on oversized messages**: Reject packets with oversized polynomial commitments before performing any expensive operations

## Proof of Concept

```rust
#[test]
fn test_oversized_poly_commitment_dos() {
    // Create malicious DkgPublicShares with oversized PolyCommitment
    let malicious_poly = PolyCommitment {
        id: ID::new(...),
        poly: vec![Point::generator(); 10_000_000], // 10M points
    };
    
    let malicious_shares = DkgPublicShares {
        dkg_id: 0,
        signer_id: 0,
        comms: vec![(0, malicious_poly)],
        kex_public_key: Point::generator(),
    };
    
    // Sign with valid key
    let packet = Packet {
        msg: Message::DkgPublicShares(malicious_shares),
        sig: msg.sign(&valid_private_key).unwrap(),
    };
    
    // Verify causes resource exhaustion before size validation
    let start = Instant::now();
    let _ = packet.verify(&public_keys, &coordinator_key);
    let duration = start.elapsed();
    
    assert!(duration > Duration::from_secs(10)); // Demonstrates delay
}
```

### Citations

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/coordinator/fire.rs (L218-225)
```rust
        if self.config.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L633-640)
```rust
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }
```

**File:** src/state_machine/coordinator/mod.rs (L178-199)
```rust
impl Config {
    /// Create a new config object with no timeouts
    pub fn new(
        num_signers: u32,
        num_keys: u32,
        threshold: u32,
        message_private_key: Scalar,
    ) -> Self {
        Config {
            num_signers,
            num_keys,
            threshold,
            dkg_threshold: num_keys,
            message_private_key,
            dkg_public_timeout: None,
            dkg_private_timeout: None,
            dkg_end_timeout: None,
            nonce_timeout: None,
            sign_timeout: None,
            public_keys: Default::default(),
            verify_packet_sigs: true,
        }
```

**File:** src/state_machine/signer/mod.rs (L347-347)
```rust
            verify_packet_sigs: true,
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L557-562)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```
