# Audit Report

## Title
Fire Coordinator Timeout Logic Incorrectly Marks Honest Signers as Malicious on Network Delays

## Summary
The FIRE coordinator's signature share timeout handler permanently excludes honest signers experiencing network delays without cryptographic validation, violating the FIRE protocol specification and progressively degrading system capacity until permanent denial of service occurs.

## Finding Description

The vulnerability exists in the `process_timeout()` function when handling signature share timeouts. When `sign_timeout` expires during `State::SigShareGather`, the coordinator marks all signers in `sign_wait_signer_ids` as malicious without any cryptographic validation of malicious behavior. [1](#0-0) 

The `sign_wait_signer_ids` set contains signers who successfully sent valid nonce responses but have not yet sent signature shares. Signers are added to this set when they send valid nonce responses [2](#0-1)  and removed only when signature shares arrive. [3](#0-2) 

Once marked malicious, signers are permanently excluded. The coordinator silently rejects nonce responses from any signer in `malicious_signer_ids`. [4](#0-3) 

**Critical Specification Violation**: The FIRE protocol specification states "When a signing round begins, A will contain all parties who successfully completed DKG" (wsts.tex line 450), indicating the active set should reset at the start of each signing round. However, the implementation never clears `malicious_signer_ids`:

- The `reset()` function does not clear this set [5](#0-4) 
- The `start_signing_round()` function does not clear this set [6](#0-5) 
- No `.clear()` or `.remove()` operations exist on `malicious_signer_ids` anywhere in the codebase (verified via grep)

This causes signers experiencing transient network delays to be permanently excluded across ALL future signing rounds, not just within a single round as the FIRE specification intends. This breaks the protocol's liveness guarantee by conflating honest-but-slow behavior with cryptographically-proven malicious behavior.

## Impact Explanation

Honest signers experiencing network delays are permanently excluded from signing, progressively reducing total signing capacity. When the system falls below threshold, it returns `SignError::InsufficientSigners` and can no longer produce valid signatures. [7](#0-6) 

In blockchain contexts (e.g., Stacks), this results in:
- Inability to confirm new blocks
- Network unable to process transactions for multiple blocks  
- Complete network shutdown until coordinator is manually restarted with cleared state

This maps to **High severity** ("Any remotely-exploitable denial of service") and can escalate to **Critical severity** ("Any network to shut down or otherwise not confirm new valid transactions for multiple blocks").

## Likelihood Explanation

This vulnerability triggers naturally through:
- Normal network congestion or packet loss
- System load spikes causing processing delays
- Transient connectivity issues

Each timeout event permanently reduces capacity. After cumulative timeouts (whether natural or attacker-induced), the system loses the ability to produce signatures. An attacker need only introduce network delays via traffic shapingâ€”no cryptographic capabilities or privileged access required.

The probability increases with network latency, system load, number of signers, and tight timeout configurations.

## Recommendation

Modify the coordinator to reset `malicious_signer_ids` at the start of each signing round, consistent with the FIRE specification:

```rust
pub fn start_signing_round(
    &mut self,
    message: &[u8],
    signature_type: SignatureType,
    sign_id: Option<u64>,
) -> Result<Packet, Error> {
    // ... existing checks ...
    
    // Clear malicious signers for new round per FIRE spec
    self.malicious_signer_ids.clear();
    
    self.message = message.to_vec();
    if let Some(id) = sign_id {
        self.current_sign_id = id;
    } else {
        self.current_sign_id = self.current_sign_id.wrapping_add(1);
    }
    // ... rest of function ...
}
```

Alternatively, maintain separate per-round and persistent malicious signer tracking if certain behaviors should result in permanent exclusion (e.g., cryptographically invalid signatures), while allowing recovery from timeout-based marking.

## Proof of Concept

The vulnerability is demonstrated by the existing test behavior at lines 3063-3184 which shows timeouts marking signers as malicious, combined with the verified absence of any clearing mechanism between signing rounds. A complete PoC would:

1. Initialize coordinator with sufficient signers
2. Start signing round i, induce timeout on subset of signers
3. Verify signers marked malicious
4. Start new signing round i+1  
5. Verify marked signers remain excluded (violating FIRE spec)
6. Repeat until `InsufficientSigners` error occurs

The technical validation confirms all claims through code inspection: [8](#0-7)  (malicious_signer_ids field definition).

## Notes

The coordinator implementation violates the FIRE protocol specification by maintaining permanent exclusion across signing rounds rather than resetting the active set per-round as specified. This specification mismatch transforms transient network issues into permanent denial of service.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L64-64)
```rust
    malicious_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L173-186)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L188-199)
```rust
                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
```

**File:** src/state_machine/coordinator/fire.rs (L903-914)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
```

**File:** src/state_machine/coordinator/fire.rs (L940-942)
```rust
            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1468-1475)
```rust
        if let Some(id) = sign_id {
            self.current_sign_id = id;
        } else {
            self.current_sign_id = self.current_sign_id.wrapping_add(1);
        }
        info!("Starting signing round {}", self.current_sign_id);
        self.move_to(State::NonceRequest(signature_type))?;
        self.request_nonces(signature_type)
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```
