After rigorous validation according to the WSTS Security Judge framework, I have completed my analysis.

## PHASE 1: IMMEDIATE DISQUALIFICATION CHECKS - PASSED
✓ In-scope files (src/v1.rs, src/v2.rs, src/state_machine/signer/mod.rs)
✓ Threat model compliant (malicious signer within protocol bounds)
✓ Security issue with concrete exploit

## PHASE 2: CODE VALIDATION - **CRITICAL FLAW IDENTIFIED**

I traced the complete execution path and found that the validation at lines 1047-1056 in the state machine **BLOCKS** the original attack scenario: [1](#0-0) 

This validation ensures a signer can ONLY send private shares for party_ids they control. The attack scenario described (sending shares for party P3 not owned by the attacker) is **impossible** through this check.

**However, I discovered a DIFFERENT but VALID attack path:**

A signer controlling parties [P1, P2] can:
1. Send `DkgPublicShares` with commitments for [P1] ONLY (omitting P2)
2. Send `DkgPrivateShares` with shares from [P1, P2] (all their parties)

The validation at line 553 only checks if `shares.comms.is_empty()`, NOT that it contains ALL expected parties: [2](#0-1) 

This allows partial commitment submission while still sending full private shares.

## PHASE 3: VULNERABILITY CONFIRMATION

The core vulnerability is VALID in `compute_secret`:

**Forward validation exists** (checks every public share has corresponding private share): [3](#0-2) 

**Reverse validation is MISSING** (warns but doesn't error when private share lacks public commitment): [4](#0-3) 

**All shares are summed unconditionally**, including unvalidated ones: [5](#0-4) 

Same issue exists in v2: [6](#0-5) [7](#0-6) 

## PHASE 4: IMPACT & LIKELIHOOD

**Impact:** Medium to High
- DKG succeeds but produces cryptographically inconsistent keys
- Signatures fail verification (Medium: transient consensus failures)
- If different shares sent to different nodes → chain split (High)

**Likelihood:** High
- Any configured signer can omit commitments for their own parties
- No cryptographic breaks required
- Attack is undetectable until signatures fail

---

# Audit Report

## Title
Missing Reverse Validation Allows Private Share Injection Without Corresponding Public Commitments in DKG

## Summary
The `compute_secret()` function validates that every public commitment has a corresponding private share (forward direction) but fails to validate the reverse. A malicious signer can omit public commitments for some of their own parties while still sending private shares for those parties, causing victims to compute corrupted private keys that produce invalid signatures.

## Finding Description

**Root Cause:**

In both v1 and v2 implementations, `compute_secret()` performs forward validation ensuring every public commitment has a corresponding private share: [3](#0-2) 

However, the reverse validation is incomplete. When iterating through private shares, if no public commitment exists, the function only logs a warning without adding to `bad_shares`: [4](#0-3) 

Critically, ALL private shares are summed regardless of validation status: [5](#0-4) 

The same vulnerability exists in v2: [6](#0-5) 

**State Machine Enablement:**

The state machine builds `commitments` only from provided public shares, without verifying completeness: [2](#0-1) 

The check at line 553 only validates that `shares.comms` is not empty, not that it contains all expected party_ids for that signer.

Meanwhile, `decrypted_shares` is populated from ALL party_ids in the received message: [8](#0-7) 

**Attack Execution:**

1. Malicious Signer X is configured with parties [P1, P2]
2. X sends `DkgPublicShares` with commitments for [P1] only (omitting P2)
3. X sends `DkgPrivateShares` with shares from [P1, P2]  
4. Validation at line 1048 passes (both P1 and P2 belong to X)
5. `commitments` contains only [P1]
6. `decrypted_shares` contains [P1, P2]
7. `compute_secrets` is called with mismatched data
8. In `compute_secret`, P2's shares bypass validation (line 197 warning only)
9. Victim's private key = f_P1(victim_id) + f_P2(victim_id), but group public key = C_P1[0]
10. Cryptographic invariant broken: private key doesn't correspond to expected public key

## Impact Explanation

**Security Guarantee Violated:** DKG must ensure every private key share is validated against its public polynomial commitment, guaranteeing the sum of private keys equals the discrete log of the group public key.

**Concrete Harm:**
- Victims' private keys include unvalidated scalar values not reflected in group public key
- Relationship `sk_i * G = expected_public_share_i` is broken
- ALL signatures produced with corrupted keys fail verification
- DKG returns `Ok(())` despite producing cryptographically inconsistent keys
- If attacker sends different omitted commitments to different nodes, they compute incompatible keys causing signature divergence

**Severity Mapping:**
- **Medium**: "Any transient consensus failures" - DKG produces unusable keys, blocking signing operations
- **High**: "Any chain split caused by different nodes processing the same block or transaction and yielding different results" - if different nodes receive different malicious omissions, they produce incompatible signatures for identical messages

## Likelihood Explanation

**Attacker Requirements:**
- Valid signer configuration (standard protocol participant)
- Control of multiple party_ids (common in WSTS deployment)
- Network access to send DKG messages (inherent to participation)

**Attack Complexity:** LOW
- Omit commitments for some owned parties in `DkgPublicShares`
- Send full private shares in `DkgPrivateShares`
- No cryptographic operations or special timing required

**Detection:** Only produces warnings, not errors. DKG completes successfully and corruption discovered only when signatures fail.

**Probability:** HIGH - Any signer controlling multiple parties can execute this attack trivially.

## Recommendation

Add reverse validation in `compute_secret()` to ensure every party_id in `private_shares` has a corresponding entry in `public_shares`:

```rust
// After line 180 in v1.rs, add:
let mut extra_shares = Vec::new();
for i in private_shares.keys() {
    if public_shares.get(i).is_none() {
        extra_shares.push(*i);
    }
}
if !extra_shares.is_empty() {
    return Err(DkgError::BadPrivateShares(extra_shares));
}
```

Additionally, in the state machine, validate that signers send commitments for ALL their configured party_ids:

```rust
// After line 562 in state_machine/signer/mod.rs:
if let Some(expected_key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
    let provided_ids: HashSet<u32> = shares.comms.keys().copied().collect();
    if provided_ids != *expected_key_ids {
        missing_public_shares.insert(*signer_id);
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_unvalidated_private_share_injection() {
    use crate::v1::Party;
    use crate::common::PolyCommitment;
    use crate::curve::scalar::Scalar;
    use hashbrown::HashMap;
    use rand_core::OsRng;

    let mut rng = OsRng;
    let n = 10;
    let t = 7;
    
    // Create victim party
    let mut victim = Party::new(1, n, t, &mut rng);
    
    // Create attacker's parties P1 and P2
    let p1 = Party::new(10, n, t, &mut rng);
    let p2 = Party::new(20, n, t, &mut rng);
    
    let ctx = 0u64.to_be_bytes();
    
    // Attacker sends commitment for P1 only (omits P2)
    let mut public_shares = HashMap::new();
    public_shares.insert(10, p1.get_poly_commitment(&ctx, &mut rng).unwrap());
    
    // But sends private shares from BOTH P1 and P2
    let mut private_shares = HashMap::new();
    let p1_shares = p1.get_shares();
    let p2_shares = p2.get_shares();
    private_shares.insert(10, *p1_shares.get(&1).unwrap());
    private_shares.insert(20, *p2_shares.get(&1).unwrap()); // P2 has no commitment!
    
    // This should fail but succeeds - P2's share is summed without validation
    let result = victim.compute_secret(private_shares, &public_shares, &ctx);
    
    // Vulnerability: returns Ok despite P2 having no commitment
    assert!(result.is_ok(), "compute_secret should fail but succeeds");
    
    // The private key now includes unvalidated P2 contribution
    // victim.private_key = f_P1(1) + f_P2(1)
    // But group_key only includes C_P1[0], not C_P2[0]
    // This breaks the cryptographic invariant
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L551-563)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L1047-1056)
```rust
        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L1072-1102)
```rust
        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
```

**File:** src/v1.rs (L172-180)
```rust
        let mut missing_shares = Vec::new();
        for i in public_shares.keys() {
            if private_shares.get(i).is_none() {
                missing_shares.push((self.id, *i));
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }
```

**File:** src/v1.rs (L190-199)
```rust
        let mut bad_shares = Vec::new();
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
            } else {
                warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", i);
            }
        }
```

**File:** src/v1.rs (L205-208)
```rust
        self.private_key = private_shares.values().sum();
        self.public_key = self.private_key * G;

        Ok(())
```

**File:** src/v2.rs (L165-186)
```rust
        let mut bad_shares = Vec::new();
        for key_id in &self.key_ids {
            if let Some(shares) = private_shares.get(key_id) {
                for (sender, s) in shares {
                    if let Some(comm) = public_shares.get(sender) {
                        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
                            bad_shares.push(*sender);
                        }
                    } else {
                        warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", sender);
                    }
                }
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }
        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }
```

**File:** src/v2.rs (L191-191)
```rust
                let secret = shares.values().sum();
```
