# Audit Report

## Title
FROST Coordinator Fails to Validate Bad Private Share Claims, Enabling Persistent DKG Denial of Service

## Summary
The FROST coordinator implementation does not validate `BadPrivateShares` claims reported by signers during DKG. A malicious signer can send false accusations against honest participants, causing DKG to fail without identification of the malicious actor. This enables a repeatable denial-of-service attack that prevents the network from establishing an aggregate public key required for threshold signatures.

## Finding Description

The FROST coordinator's `gather_dkg_end` function collects failure reports from signers but performs no cryptographic validation of the claims. When a signer reports `DkgStatus::Failure(DkgFailure::BadPrivateShares(...))`, the coordinator simply aggregates these reports and returns an error with an empty `malicious_signers` set. [1](#0-0) 

The coordinator lacks the cryptographic validation logic present in the FIRE coordinator implementation. Specifically, the FROST coordinator does not import the required validation functions (`decrypt`, `make_shared_secret_from_key`, `check_public_shares`): [2](#0-1) 

In contrast, the FIRE coordinator includes these imports: [3](#0-2) 

The FIRE coordinator performs comprehensive validation of `BadPrivateShares` claims by: (1) verifying the DH tuple proof to ensure the shared key is correct, (2) decrypting the allegedly bad private shares using the shared secret, (3) validating each decrypted share against the polynomial commitments by checking `private_eval * G == poly_eval`, and (4) identifying which party is malicious (the false accuser or the actual sender of bad shares): [4](#0-3) 

The `BadPrivateShare` structure includes cryptographic proofs specifically designed for coordinator verification - a shared DH key and a Chaum-Pedersen tuple proof: [5](#0-4) 

However, the FROST coordinator never uses these proofs. The coordinator's error handling simply returns the empty `malicious_signers` set: [6](#0-5) 

**Attack Flow:**
1. Malicious signer M participates in DKG with honest signers
2. All parties successfully exchange valid public and private shares
3. During the DkgEnd phase, M sends a `DkgEnd` message containing `DkgStatus::Failure(DkgFailure::BadPrivateShares(...))` with false claims
4. The FROST coordinator accepts this claim without validation and transitions to error state
5. DKG fails with empty `malicious_signers` set - M is not identified
6. When DKG is retried, M repeats the attack indefinitely

## Impact Explanation

This vulnerability enables persistent network shutdown. Without a completed DKG, the network cannot establish an aggregate public key. Without an aggregate public key, threshold signatures cannot be generated. Without threshold signatures, the blockchain cannot confirm transactions or produce new blocks.

The attack is persistent because the malicious signer is never identified in the `malicious_signers` set returned to the calling code. When the caller retries DKG (as would be standard practice after a failure), the malicious signer can immediately repeat the false accusation, creating an indefinite denial of service.

This maps to **Critical** severity under the scope definition: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

The FIRE coordinator implementation is not vulnerable as it performs proper validation and correctly identifies malicious signers.

## Likelihood Explanation

**Attacker Capabilities:** The attacker needs control of only one signer in the DKG participant set. This is within the protocol's threat model, which allows up to threshold-1 malicious signers. No cryptographic breaks, insider access, or special privileges are required.

**Attack Complexity:** Trivial. The attacker participates normally in the public and private share exchange phases, then sends a `DkgEnd` message with a false `BadPrivateShares` claim. The message format is standard and uses the existing protocol structures.

**Economic Feasibility:** Extremely low cost. The attack requires no computational resources beyond normal DKG participation, has no gas costs, and cannot be economically disincentivized since the malicious party is never identified.

**Detection Risk:** Zero. The FROST coordinator does not log which signers are making accusations, returns an empty `malicious_signers` set, and cannot distinguish between legitimate failures and false claims.

**Probability of Success:** 100%. The vulnerability is deterministic - the FROST coordinator will always fail to validate claims and always return an empty `malicious_signers` set.

## Recommendation

The FROST coordinator should implement the same validation logic as the FIRE coordinator:

1. Import the required validation functions: `decrypt`, `make_shared_secret_from_key`, `check_public_shares`, and `G`
2. When processing `BadPrivateShares` claims in `gather_dkg_end`, verify the DH tuple proof
3. Decrypt the allegedly bad private shares using the shared secret
4. Validate each decrypted share against the polynomial commitments
5. Populate the `malicious_signers` set with the ID of whichever party is actually malicious (the false accuser or the sender of bad shares)

The implementation should mirror the validation logic shown in the FIRE coordinator: [7](#0-6) 

## Proof of Concept

A proof of concept can be constructed by modifying existing FIRE coordinator tests to use the FROST coordinator instead. The `malicious_signers_dkg` test in the FIRE coordinator demonstrates the expected behavior: [8](#0-7) 

To demonstrate the vulnerability:

```rust
#[test]
fn frost_coordinator_fails_to_identify_malicious_signer() {
    // Use setup from coordinator test utilities
    let (mut coordinators, mut signers) = 
        setup::<FrostCoordinator<v2::Aggregator>, v2::Signer>(5, 2);
    
    // Start DKG
    let message = coordinators[0].start_dkg_round(None).unwrap();
    
    // Complete public and private share phases
    let (messages, _) = feedback_messages(&mut coordinators, &mut signers, &[message]);
    let (messages, _) = feedback_messages(&mut coordinators, &mut signers, &messages);
    
    // Mutate one signer's private shares to create BadPrivateShares
    let (_, results) = feedback_mutated_messages(
        &mut coordinators, &mut signers, &messages,
        |signer, msgs| {
            if signer.signer_id == 0 {
                // Mutate private shares to be invalid
                corrupt_private_shares(msgs)
            } else {
                msgs
            }
        }
    );
    
    // Verify that DkgEndFailure is returned with EMPTY malicious_signers
    let OperationResult::DkgError(DkgError::DkgEndFailure {
        malicious_signers, ..
    }) = &results[0] else {
        panic!("Expected DkgEndFailure");
    };
    
    // BUG: malicious_signers should contain signer 0, but is empty
    assert!(malicious_signers.is_empty()); // This passes, demonstrating the bug
    
    // This means the attack can be repeated - DKG will never complete
}
```

### Citations

**File:** src/state_machine/coordinator/frost.rs (L1-22)
```rust
use hashbrown::{HashMap, HashSet};
use std::collections::BTreeMap;
use tracing::{debug, info, warn};

use crate::{
    common::{PolyCommitment, PublicNonce, Signature, SignatureShare},
    compute,
    curve::{ecdsa, point::Point},
    net::{
        DkgBegin, DkgEnd, DkgEndBegin, DkgPrivateBegin, DkgPrivateShares, DkgPublicShares,
        DkgStatus, Message, NonceRequest, NonceResponse, Packet, Signable, SignatureShareRequest,
        SignatureType,
    },
    state_machine::{
        coordinator::{
            Config, Coordinator as CoordinatorTrait, Error, SavedState, SignRoundInfo, State,
        },
        DkgError, OperationResult, SignError, StateMachine,
    },
    taproot::SchnorrProof,
    traits::Aggregator as AggregatorTrait,
};
```

**File:** src/state_machine/coordinator/frost.rs (L377-420)
```rust
    fn gather_dkg_end(&mut self, packet: &Packet) -> Result<(), Error> {
        debug!(
            dkg_id = %self.current_dkg_id,
            waiting = ?self.ids_to_await,
            "Waiting for Dkg End from signers"
        );
        if let Message::DkgEnd(dkg_end) = &packet.msg {
            if dkg_end.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(dkg_end.dkg_id, self.current_dkg_id));
            }
            if self.ids_to_await.contains(&dkg_end.signer_id) {
                self.ids_to_await.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.ids_to_await,
                    "DkgEnd received"
                );
            }
        }

        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1-27)
```rust
use hashbrown::{HashMap, HashSet};
use std::{collections::BTreeMap, time::Instant};
use tracing::{debug, error, info, warn};

use crate::{
    common::{check_public_shares, PolyCommitment, PublicNonce, Signature, SignatureShare},
    compute,
    curve::{
        ecdsa,
        point::{Point, G},
        scalar::Scalar,
    },
    net::{
        DkgBegin, DkgEnd, DkgEndBegin, DkgFailure, DkgPrivateBegin, DkgPrivateShares,
        DkgPublicShares, DkgStatus, Message, NonceRequest, NonceResponse, Packet, Signable,
        SignatureShareRequest, SignatureType,
    },
    state_machine::{
        coordinator::{
            Config, Coordinator as CoordinatorTrait, Error, SavedState, SignRoundInfo, State,
        },
        DkgError, OperationResult, SignError, StateMachine,
    },
    taproot::SchnorrProof,
    traits::Aggregator as AggregatorTrait,
    util::{decrypt, make_shared_secret_from_key},
};
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L2482-2585)
```rust
    fn malicious_signers_dkg<Aggregator: AggregatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
    ) -> (Vec<FireCoordinator<Aggregator>>, Vec<Signer<SignerType>>) {
        let (mut coordinators, mut signers) =
            setup::<FireCoordinator<Aggregator>, SignerType>(num_signers, keys_per_signer);

        // We have started a dkg round
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_dkg_round(None)
            .unwrap();
        assert!(coordinators.first().unwrap().aggregate_public_key.is_none());
        assert_eq!(coordinators.first().unwrap().state, State::DkgPublicGather);

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinators
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        for coordinator in &coordinators {
            assert_eq!(coordinator.state, State::DkgPrivateGather);
        }

        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::DkgPrivateBegin(_)),
            "Expected DkgPrivateBegin message"
        );

        // Send the DKG Private Begin message to all signers and share their responses with the coordinators and signers, but mutate one signer's DkgPrivateShares so it is marked malicious
        let (outbound_messages, operation_results) = feedback_mutated_messages(
            &mut coordinators,
            &mut signers,
            &outbound_messages,
            |signer, msgs| {
                if signer.signer_id != 0 {
                    return msgs;
                }
                msgs.iter()
                    .map(|packet| {
                        let Message::DkgPrivateShares(shares) = &packet.msg else {
                            return packet.clone();
                        };
                        // mutate one of the shares
                        let sshares: Vec<(u32, HashMap<u32, Vec<u8>>)> = shares
                            .shares
                            .iter()
                            .map(|(src_party_id, share_map)| {
                                (
                                    *src_party_id,
                                    share_map
                                        .iter()
                                        .map(|(dst_key_id, bytes)| {
                                            let mut bytes = bytes.clone();
                                            bytes.insert(0, 234);
                                            (*dst_key_id, bytes)
                                        })
                                        .collect(),
                                )
                            })
                            .collect();

                        Packet {
                            msg: Message::DkgPrivateShares(DkgPrivateShares {
                                dkg_id: shares.dkg_id,
                                signer_id: shares.signer_id,
                                shares: sshares.clone(),
                            }),
                            sig: vec![],
                        }
                    })
                    .collect()
            },
        );
        assert!(operation_results.is_empty());
        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::DkgEndBegin(_)),
            "Expected DkgEndBegin message"
        );

        // Send the DkgEndBegin message to all signers and share their responses with the coordinators and signers
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &outbound_messages);
        assert!(outbound_messages.is_empty());
        assert_eq!(operation_results.len(), 1);
        let OperationResult::DkgError(DkgError::DkgEndFailure {
            reported_failures, ..
        }) = &operation_results[0]
        else {
            panic!("Expected OperationResult::DkgError(DkgError::DkgEndFailure");
        };

        for (_signer_id, dkg_failure) in reported_failures {
            let DkgFailure::BadPrivateShares(bad_share_map) = dkg_failure else {
                panic!("Expected DkgFailure::BadPrivateShares");
            };
            for (bad_signer_id, _bad_private_share) in bad_share_map {
                assert_eq!(*bad_signer_id, 0u32);
            }
        }
        (coordinators, signers)
    }
```

**File:** src/net.rs (L48-55)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// A bad private share
pub struct BadPrivateShare {
    /// the DH shared key between these participants
    pub shared_key: Point,
    /// prooof that the shared key is a valid DH tuple as per chaum-pedersen
    pub tuple_proof: TupleProof,
}
```
