# Audit Report

## Title
Out-of-Order DKG Message Processing Causes Silent Share Loss and DKG Denial of Service

## Summary
The signer's message processing logic lacks state validation before dispatching messages to handlers, allowing `DkgPrivateShares` to be processed before `DkgPublicShares`. This causes silent message loss because the required key exchange (KEX) public keys are unavailable, resulting in DKG failure for all participants.

## Finding Description

The vulnerability exists in the signer's message processing architecture. Unlike the coordinator which validates state before processing messages, the signer dispatches messages based solely on type without checking if the current state is appropriate.

The signer's `process()` method dispatches messages directly based on their type without any state validation: [1](#0-0) 

In contrast, the coordinator is protected by a loop-based state machine that matches on the current state before processing messages: [2](#0-1) 

When `DkgPrivateShares` arrives out of order, the `dkg_private_shares` handler attempts to retrieve the sender's KEX public key to decrypt the shares: [3](#0-2) 

The `get_kex_public_key` method looks up keys from `self.kex_public_keys`, which is only populated during `DkgPublicShares` processing. If the key is missing, it returns an error: [4](#0-3) 

The KEX public keys are stored when processing `DkgPublicShares`: [5](#0-4) 

If the KEX key is missing when `DkgPrivateShares` arrives first, the handler returns early without storing the shares. The shares would have been stored here, but this code becomes unreachable after the early return: [6](#0-5) 

Later, when DKG completion is checked, the missing shares are detected: [7](#0-6) 

This causes DKG to fail with `MissingPrivateShares`: [8](#0-7) 

The protocol breaks the availability guarantee because network packet reordering (a normal network condition) causes deterministic DKG failure. Messages are broadcast to all signers, and there is no mechanism to ensure ordering between separate `DkgPublicShares` and `DkgPrivateShares` messages: [9](#0-8) 

## Impact Explanation

This vulnerability causes complete DKG denial of service affecting all participants in the round. The impact severity is **Low** per the provided scope: "Any remotely-exploitable denial of service in a node."

Specific impacts:
- DKG round fails for all signers when shares are missing
- Threshold signature group cannot be formed
- No signatures can be produced until a successful DKG completes
- System initialization or key rotation is blocked

While DKG can be retried, persistent network conditions or deliberate packet reordering can prevent DKG completion indefinitely. However, this does not cause invalid signatures, fund loss, or chain splits, justifying the Low severity classification.

## Likelihood Explanation

The likelihood is **High** because:

1. **Trigger conditions are common**: Network packets naturally arrive out of order due to routing, buffering, and congestion. This can trigger the vulnerability without any attacker.

2. **No defensive mechanisms**: The codebase has no message buffering, retry logic, or state validation before message processing in the signer.

3. **Deterministic behavior**: Once triggered, the failure is guaranteed - there are no race conditions or probabilistic factors.

4. **Low attack complexity**: If deliberate, an attacker only needs network-level access to delay or reorder packets between signers on the P2P network. No cryptographic secrets or special privileges are required.

5. **Natural occurrence**: This can happen accidentally during normal operation, making it a protocol robustness issue as much as a security vulnerability.

## Recommendation

Implement one of the following solutions:

**Option 1: State-based message validation (Recommended)**
Add state validation before processing messages in the signer's `process()` method, similar to the coordinator's approach. Buffer out-of-order messages and process them when the correct state is reached.

**Option 2: Message buffering**
Buffer `DkgPrivateShares` messages that arrive before the corresponding `DkgPublicShares`, and process them after the KEX public keys are available.

**Option 3: Re-attempt processing**
When `DkgPublicShares` is received, check if there are any previously failed `DkgPrivateShares` messages from that signer and re-process them.

Example fix for Option 1:
```rust
pub fn process<R: RngCore + CryptoRng>(
    &mut self,
    packet: &Packet,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // ... signature verification ...
    
    // Validate state before processing
    match (&self.state, &packet.msg) {
        (State::DkgPublicGather, Message::DkgPrivateShares(_)) => {
            // Buffer for later or return error
            return Ok(vec![]);
        }
        _ => {}
    }
    
    let out_msgs = match &packet.msg {
        // ... existing dispatch logic ...
    };
    // ... rest of method ...
}
```

## Proof of Concept

```rust
#[test]
fn test_out_of_order_dkg_messages() {
    let mut rng = create_rng();
    
    // Setup two signers
    let mut signer1 = create_signer(1, &mut rng);
    let mut signer2 = create_signer(2, &mut rng);
    
    // Start DKG
    let dkg_begin = create_dkg_begin_packet();
    signer1.process(&dkg_begin, &mut rng).unwrap();
    signer2.process(&dkg_begin, &mut rng).unwrap();
    
    // Signer1 sends public shares
    let public_shares1 = signer1.create_public_shares();
    
    // Signer1 sends private shares
    let private_shares1 = signer1.create_private_shares();
    
    // CRITICAL: Signer2 receives private shares BEFORE public shares (out of order)
    let result_private = signer2.process(&private_shares1, &mut rng);
    assert!(result_private.is_ok()); // Silent failure - returns Ok(vec![])
    
    // Now signer2 receives public shares
    signer2.process(&public_shares1, &mut rng).unwrap();
    
    // Trigger DKG end
    let dkg_end_begin = create_dkg_end_begin_packet();
    let result = signer2.process(&dkg_end_begin, &mut rng).unwrap();
    
    // Verify that DKG fails with MissingPrivateShares
    if let Message::DkgEnd(dkg_end) = &result[0] {
        assert!(matches!(
            dkg_end.status,
            DkgStatus::Failure(DkgFailure::MissingPrivateShares(_))
        ));
    } else {
        panic!("Expected DkgEnd message");
    }
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L471-487)
```rust
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
            Message::DkgPrivateShares(dkg_private_shares) => {
                self.dkg_private_shares(dkg_private_shares, rng)
            }
            Message::SignatureShareRequest(sign_share_request) => {
                self.sign_share_request(sign_share_request, rng)
            }
            Message::NonceRequest(nonce_request) => self.nonce_request(nonce_request, rng),
            Message::DkgEnd(_) | Message::NonceResponse(_) | Message::SignatureShareResponse(_) => {
                Ok(vec![])
            } // TODO
```

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L601-609)
```rust
        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L1019-1024)
```rust
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1043-1045)
```rust
        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };
```

**File:** src/state_machine/signer/mod.rs (L1063-1064)
```rust
        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1112-1128)
```rust
    fn get_kex_public_key(&self, signer_id: u32) -> Result<Point, Error> {
        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(signer_key_id) = signer_key_ids.iter().next() else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(kex_public_key) = self.kex_public_keys.get(signer_key_id) else {
            warn!(%signer_id, %signer_key_id, "No KEX public key configured");
            return Err(Error::MissingKexPublicKey(*signer_key_id));
        };

        Ok(*kex_public_key)
```

**File:** src/state_machine/coordinator/fire.rs (L226-275)
```rust
        loop {
            match self.state.clone() {
                State::Idle => {
                    // Did we receive a coordinator message?
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
                    } else if let Message::NonceRequest(nonce_request) = &packet.msg {
                        if self.current_sign_id == nonce_request.sign_id {
                            // We have already processed this sign round
                            return Ok((None, None));
                        }
                        self.current_sign_iter_id = nonce_request.sign_iter_id.wrapping_sub(1);
                        // use sign_id from NonceRequest
                        let packet = self.start_signing_round(
                            nonce_request.message.as_slice(),
                            nonce_request.signature_type,
                            Some(nonce_request.sign_id),
                        )?;
                        return Ok((Some(packet), None));
                    }
                    return Ok((None, None));
                }
                State::DkgPublicDistribute => {
                    let packet = self.start_public_shares()?;
                    return Ok((Some(packet), None));
                }
                State::DkgPublicGather => {
                    self.gather_public_shares(packet)?;
                    if self.state == State::DkgPublicGather {
                        // We need more data
                        return Ok((None, None));
                    }
                }
                State::DkgPrivateDistribute => {
                    let packet = self.start_private_shares()?;
                    return Ok((Some(packet), None));
                }
                State::DkgPrivateGather => {
                    self.gather_private_shares(packet)?;
                    if self.state == State::DkgPrivateGather {
                        // We need more data
                        return Ok((None, None));
                    }
                }
```

**File:** src/net.rs (L140-150)
```rust
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```
