After performing strict validation according to the WSTS validation framework, I have determined this is a **VALID VULNERABILITY**. Here is my full audit report:

---

# Audit Report

## Title
Missing sign_iter_id Validation in Signature Share Collection Allows Cross-Iteration Replay Attacks

## Summary
Both FROST and FIRE coordinators fail to validate the `sign_iter_id` field when receiving `SignatureShareResponse` messages, despite validating it for `NonceResponse` messages. This inconsistency allows a malicious signer to replay signature shares from previous signing iterations, causing signing rounds to fail and requiring retries, resulting in denial of service.

## Finding Description

The WSTS protocol uses three identifiers to track signing rounds: `dkg_id`, `sign_id`, and `sign_iter_id`. When timeout-based retries occur, the coordinator increments `sign_iter_id` and requests new nonces for a fresh iteration. This security guarantee—that signature shares must match nonces from the same iteration—is broken by inconsistent validation.

**Missing Validation in FROST Coordinator:**

The FROST coordinator's `gather_sig_shares` function validates only `dkg_id` and `sign_id`, omitting the `sign_iter_id` check: [1](#0-0) 

In contrast, the FROST coordinator's `gather_nonces` function correctly validates all three identifiers including `sign_iter_id`: [2](#0-1) 

**Missing Validation in FIRE Coordinator:**

The same inconsistency exists in the FIRE coordinator's `gather_sig_shares` function: [3](#0-2) 

While the FIRE coordinator's `gather_nonces` function correctly validates `sign_iter_id`: [4](#0-3) 

**Root Cause Analysis:**

The `SignatureShareResponse` struct contains a `sign_iter_id` field: [5](#0-4) 

However, the `SignatureShareResponse.hash()` implementation does not include `sign_iter_id` in the cryptographic hash used for packet signatures: [6](#0-5) 

This means even with packet signature verification enabled, the `sign_iter_id` field is not cryptographically authenticated.

**Attack Mechanism:**

When a timeout occurs during signature share gathering, the FIRE coordinator transitions back to the nonce request state: [7](#0-6) 

The `request_nonces` function increments the iteration counter: [8](#0-7) 

Subsequently, `request_sig_shares` clears old signature shares: [9](#0-8) 

However, because `gather_sig_shares` doesn't validate `sign_iter_id`, a malicious signer can replay a signature share from the previous iteration (computed with old nonces) during the new iteration (which uses new nonces).

**Why Aggregation Fails:**

When the coordinator aggregates signatures, it uses the current iteration's nonces: [10](#0-9) 

The aggregator's verification checks that each signature share was computed correctly. When verification fails, it calls `check_signature_shares`: [11](#0-10) 

The verification equation checks `z_i * G == r_sign * Rs[i] + cx_sign * cx`: [12](#0-11) 

When a signature share from iteration N (computed with nonces_N) is verified against nonces from iteration N+1 (nonces_N+1), this equation fails because Rs[i] is derived from the wrong nonce set. This causes aggregation to fail and identifies the malicious party.

## Impact Explanation

**Severity: Low** - This vulnerability maps to "Any remotely-exploitable denial of service in a node" per the defined scope.

**Specific Harm:**
- Signing rounds fail to produce valid signatures when replayed shares are mixed with current shares
- The coordinator must retry the signing process, causing delays
- Network throughput is reduced as signing operations are disrupted
- Malicious signers can repeatedly trigger this by deliberately timing out and replaying old responses

**Quantified Impact:**
- No fund loss occurs (invalid signatures are rejected before transaction confirmation)
- No invalid transactions are confirmed (cryptographic validation catches bad shares)
- No consensus failures result (only signing delays)
- The malicious signer is eventually detected through the `check_signature_shares` validation

**Affected Deployments:**
- FIRE coordinator deployments are most vulnerable due to built-in timeout-based retry logic
- FROST coordinator deployments are affected if external coordination triggers `sign_iter_id` changes
- All protocol participants experience signing delays during attacks

## Likelihood Explanation

**Attacker Requirements:**
- Must be a participating signer in the threshold signature scheme (within protocol threat model)
- Requires standard network access to send messages to the coordinator
- No cryptographic primitives need to be broken
- No privileged access or key compromise required

**Attack Complexity:**
The attack is straightforward to execute:
1. Participate normally in signing iteration N
2. Receive `SignatureShareRequest` and compute valid signature shares
3. Save the `SignatureShareResponse` without sending it (or delay transmission)
4. Wait for or deliberately cause a timeout
5. Coordinator increments to iteration N+1 and requests new nonces
6. Replay the saved `SignatureShareResponse` from iteration N
7. Coordinator accepts it due to missing validation
8. Aggregation fails, causing retry

**Triggering Conditions:**
- In FIRE: Timeouts occur naturally in distributed systems due to network delays, node issues, or deliberate delays by the attacker
- In FROST: Less common but possible if external systems modify `sign_iter_id`
- The attacker can reliably trigger timeouts by simply not responding promptly

**Probability Assessment:**
- **High** for FIRE coordinators with timeout configurations (timeouts are expected in production distributed systems)
- **Medium** for FROST coordinators (depends on external orchestration)
- Easily reproducible by any malicious signer within the threshold

## Recommendation

Add `sign_iter_id` validation in both `gather_sig_shares` functions, consistent with the validation in `gather_nonces`:

```rust
if sig_share_response.sign_iter_id != self.current_sign_iter_id {
    return Err(Error::BadSignIterId(
        sig_share_response.sign_iter_id,
        self.current_sign_iter_id,
    ));
}
```

This validation should be added immediately after the existing `dkg_id` and `sign_id` checks in both FIRE and FROST coordinators.

## Proof of Concept

A complete PoC would require an integration test that:
1. Initializes a FIRE coordinator with multiple signers and timeout configuration
2. Starts a signing round (iteration N)
3. Has one signer compute but not send its `SignatureShareResponse`
4. Triggers a timeout to force transition to iteration N+1
5. Replays the saved `SignatureShareResponse` from iteration N
6. Verifies the coordinator accepts it (due to missing validation)
7. Confirms aggregation fails with bad signature share detection

The vulnerability is conclusively proven through the code evidence showing the validation inconsistency between `gather_nonces` (which checks `sign_iter_id`) and `gather_sig_shares` (which does not).

---

**Notes:**
This vulnerability represents a clear protocol-level inconsistency where the same type of iteration-based replay protection applied to nonce responses is missing from signature share responses. The attack requires only standard signer capabilities within the protocol threat model and results in verifiable denial of service through failed signing rounds.

### Citations

**File:** src/state_machine/coordinator/frost.rs (L488-492)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/frost.rs (L600-611)
```rust
            if sig_share_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    sig_share_response.dkg_id,
                    self.current_dkg_id,
                ));
            }
            if sig_share_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    sig_share_response.sign_id,
                    self.current_sign_id,
                ));
            }
```

**File:** src/state_machine/coordinator/fire.rs (L173-207)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L814-839)
```rust
    fn request_nonces(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.message_nonces.clear();
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
        info!(
            sign_id = %self.current_sign_id,
            sign_iter_id = %self.current_sign_iter_id,
            "Requesting Nonces"
        );
        let nonce_request = NonceRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            message: self.message.clone(),
            signature_type,
        };
        let nonce_request_msg = Packet {
            sig: nonce_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign NonceRequest"),
            msg: Message::NonceRequest(nonce_request),
        };
        self.move_to(State::NonceGather(signature_type))?;
        self.nonce_start = Some(Instant::now());

        Ok(nonce_request_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L856-860)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L964-996)
```rust
    fn request_sig_shares(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.signature_shares.clear();
        info!(
            sign_id = %self.current_sign_id,
            "Requesting Signature Shares"
        );
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
            message: self.message.clone(),
            signature_type,
        };
        let sig_share_request_msg = Packet {
            sig: sig_share_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign SignatureShareRequest"),
            msg: Message::SignatureShareRequest(sig_share_request),
        };
        self.move_to(State::SigShareGather(signature_type))?;
        self.sign_start = Some(Instant::now());

        Ok(sig_share_request_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1027-1038)
```rust
        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1115-1169)
```rust
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();

            debug!(
                "aggregator.sign({}, {:?}, {:?}, {})",
                bs58::encode(&self.message).into_string(),
                nonces.len(),
                shares.len(),
                self.party_polynomials.len(),
            );

            self.aggregator.init(&self.party_polynomials)?;

            if let SignatureType::Taproot(merkle_root) = signature_type {
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    &shares,
                    &key_ids,
                    merkle_root,
                )?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else if let SignatureType::Schnorr = signature_type {
                let schnorr_proof =
                    self.aggregator
                        .sign_schnorr(&self.message, &nonces, &shares, &key_ids)?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else {
                let signature = self
                    .aggregator
                    .sign(&self.message, &nonces, &shares, &key_ids)?;
                debug!("Signature ({}, {})", signature.R, signature.z);
                self.signature = Some(signature);
            }
```

**File:** src/net.rs (L437-448)
```rust
pub struct SignatureShareResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Signature shares from this Signer
    pub signature_shares: Vec<SignatureShare>,
}
```

**File:** src/net.rs (L450-464)
```rust
impl Signable for SignatureShareResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("SIGNATURE_SHARE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for signature_share in &self.signature_shares {
            hasher.update(signature_share.id.to_be_bytes());
            hasher.update(signature_share.z_i.to_bytes());
            for key_id in &signature_share.key_ids {
                hasher.update(key_id.to_be_bytes());
            }
        }
    }
```

**File:** src/v2.rs (L389-408)
```rust
        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/v2.rs (L448-461)
```rust
    fn sign(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
    ) -> Result<Signature, AggregatorError> {
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, key_ids, None)?;

        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```
