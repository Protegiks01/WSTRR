# Audit Report

## Title
Unvalidated DKG Failure Reports Enable Denial of Service by Single Malicious Signer

## Summary
Both FIRE and FROST coordinators accept `MissingPublicShares` and `MissingPrivateShares` failure reports without validation, allowing a single malicious signer to abort DKG by falsely claiming honest signers failed to send shares. The coordinators possess all data necessary to validate these claims but fail to do so, enabling persistent denial of service attacks against DKG completion.

## Finding Description

The vulnerability exists in both coordinator implementations' DKG end phase handling:

**FIRE Coordinator Vulnerability:**

The FIRE coordinator collects all public and private shares from signers during DKG: [1](#0-0) 

These shares are populated during the gather phases: [2](#0-1) [3](#0-2) 

However, when processing DkgEnd failure reports, the coordinator performs NO validation for `MissingPublicShares` and `MissingPrivateShares` claims: [4](#0-3) 

The comments acknowledge this should be addressed ("maybe mark signer malicious?") but no implementation exists. This contrasts sharply with the extensive validation performed for `BadPublicShares` and `BadPrivateShares`: [5](#0-4) [6](#0-5) 

Any reported failure causes immediate DKG abort: [7](#0-6) 

**FROST Coordinator Vulnerability:**

The FROST coordinator is even more vulnerable, performing ZERO validation on ANY reported failures: [8](#0-7) 

**Attack Vector:**

A malicious signer constructs a DkgEnd message with fabricated missing share claims: [9](#0-8) 

The signer can claim any set of signers failed to send shares, regardless of whether the coordinator actually received those shares. Since the coordinator tells signers which participants sent shares: [10](#0-9) [11](#0-10) 

The coordinator can validate these claims by checking if shares exist in `self.dkg_public_shares` and `self.dkg_private_shares`. A claim about a signer the coordinator has shares from is provably false. However, this validation is not performed.

**Security Guarantee Broken:**

The protocol assumes DKG can complete when threshold honest signers participate. This vulnerability breaks that guarantee by allowing a single malicious signer to prevent completion, violating the threshold security model where up to (threshold-1) malicious signers should be tolerable.

## Impact Explanation

This vulnerability enables a persistent denial of service attack with the following characteristics:

**Direct Impact:**
- DKG fails to complete, returning `DkgError::DkgEndFailure`
- No aggregate public key is generated
- All network participants waiting for DKG completion are blocked

**Repeatability:**
The malicious signer is not added to `malicious_dkg_signer_ids` for these failure types, allowing indefinite repetition of the attack across DKG retries.

**Operational Impact:**
DKG is required for:
1. Generating initial signing keys for new signer sets
2. Rotating keys when signers join or leave  
3. Recovering from compromised key scenarios

Blocking DKG prevents all these operations.

**Severity Assessment:**
This maps to **Low severity** under the defined scope: "Any remotely-exploitable denial of service in a node." While the original claim suggests High severity with escalation to chain split, the direct impact is denial of service—DKG cannot complete. This does not cause different nodes to produce different results (chain split), but rather prevents key generation operations from succeeding.

## Likelihood Explanation

**Exploit Complexity: Trivial**

An attacker needs only to:
1. Be an authorized signer in the DKG round (normal protocol role)
2. Send a single `DkgEnd` message with `DkgStatus::Failure(DkgFailure::MissingPublicShares(fabricated_set))`

**Required Capabilities:**
- Standard signer credentials (within threat model)
- Ability to send network messages (normal protocol operation)
- No cryptographic breaks or secrets required

**Success Rate: 100%**
The attack is deterministic—the coordinator will always abort DKG when any failure is reported without validation.

**Economic Cost: Minimal**
Single message per DKG round, negligible bandwidth.

**Detection Difficulty: High**
The coordinator cannot distinguish false reports from legitimate network issues without implementing validation. Other signers might detect discrepancies through cross-checking, but the coordinator makes the final decision and lacks this validation.

## Recommendation

Implement validation for `MissingPublicShares` and `MissingPrivateShares` claims in both coordinators:

```rust
DkgFailure::MissingPublicShares(missing_shares) => {
    for missing_signer_id in missing_shares {
        // Check if coordinator actually received shares from this signer
        if self.dkg_public_shares.contains_key(missing_signer_id) {
            // Coordinator has shares, reporter is lying
            warn!("Signer {signer_id} falsely reported MissingPublicShares from {missing_signer_id}, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        }
        // If coordinator doesn't have shares, claim might be legitimate
    }
}
DkgFailure::MissingPrivateShares(missing_shares) => {
    for missing_signer_id in missing_shares {
        if self.dkg_private_shares.contains_key(missing_signer_id) {
            warn!("Signer {signer_id} falsely reported MissingPrivateShares from {missing_signer_id}, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        }
    }
}
```

This validation logic should mirror the existing validation for `BadPublicShares` and `BadPrivateShares`, marking false reporters as malicious and continuing DKG with remaining honest signers if threshold is still met.

## Proof of Concept

```rust
#[test]
fn test_false_missing_shares_dos() {
    // Setup: 5 signers, threshold 3
    let (mut coordinators, mut signers) = setup::<Coordinator<v2::Aggregator>, v2::Signer>(5, 1);
    
    // Start DKG - all signers send valid public and private shares
    let dkg_begin = coordinators[0].start_dkg_round(None).unwrap();
    let (messages, _) = helpers::feedback_messages(&mut coordinators, &mut signers, &[dkg_begin]);
    let (messages, _) = helpers::feedback_messages(&mut coordinators, &mut signers, &messages);
    let (mut messages, _) = helpers::feedback_messages(&mut coordinators, &mut signers, &messages);
    
    // Malicious signer 0 sends false claim that signer 1 didn't send public shares
    // even though coordinator has signer 1's shares
    let malicious_dkg_end = DkgEnd {
        dkg_id: 1,
        signer_id: 0,
        status: DkgStatus::Failure(DkgFailure::MissingPublicShares(
            vec![1].into_iter().collect()
        )),
    };
    messages.push(Packet {
        sig: malicious_dkg_end.sign(&signers[0].get_config().message_private_key).unwrap(),
        msg: Message::DkgEnd(malicious_dkg_end),
    });
    
    // Process messages - DKG should abort despite false claim
    let (_, results) = helpers::feedback_messages(&mut coordinators, &mut signers, &messages);
    
    // Verify DKG was aborted by false claim
    assert!(matches!(results[0], OperationResult::DkgError(DkgError::DkgEndFailure { .. })));
    
    // Verify coordinator actually has shares from signer 1 (proving claim was false)
    assert!(coordinators[0].dkg_public_shares.contains_key(&1));
}
```

This test demonstrates that a single malicious signer can abort DKG by falsely claiming missing shares, even though the coordinator possesses those shares and could validate the claim as false.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L40-41)
```rust
    dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L432-436)
```rust
        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```

**File:** src/state_machine/coordinator/frost.rs (L400-417)
```rust
        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
```

**File:** src/net.rs (L59-72)
```rust
pub enum DkgFailure {
    /// DKG threshold not met
    Threshold,
    /// Signer was in the wrong internal state to complete DKG
    BadState,
    /// DKG public shares were missing from these signer_ids
    MissingPublicShares(HashSet<u32>),
    /// DKG public shares were bad from these signer_ids
    BadPublicShares(HashSet<u32>),
    /// DKG private shares were missing from these signer_ids
    MissingPrivateShares(HashSet<u32>),
    /// DKG private shares were bad from these signer_ids
    BadPrivateShares(HashMap<u32, BadPrivateShare>),
}
```
