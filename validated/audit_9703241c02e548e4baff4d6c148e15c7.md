# Audit Report

## Title
Malicious Signers Evade Detection by Sending Invalid Nonces Instead of Timing Out

## Summary
The FIRE coordinator only marks signers as malicious during signature share timeouts, not when they send cryptographically invalid nonces. Attackers can send invalid nonces (with mismatched key IDs or invalid elliptic curve points) to persistently disrupt signing while avoiding permanent exclusion from the `malicious_signer_ids` set, enabling denial of service attacks that violate protocol liveness.

## Finding Description

The FIRE coordinator implements asymmetric handling of misbehaving signers, creating an exploitable detection gap that breaks the security invariant: "Signers who send cryptographically invalid protocol messages should be permanently excluded from future signing attempts."

When a signer sends a `NonceResponse` with key IDs that don't match the configuration, the coordinator logs a warning and returns `Ok()` without adding the signer to `sign_wait_signer_ids` [1](#0-0) . Similarly, when nonces fail the `is_valid()` check (D or E equals identity point or generator G), the response is rejected with `Ok()` return [2](#0-1) .

Valid signers who pass all checks are added to `sign_wait_signer_ids` [3](#0-2) . The critical issue is that malicious marking occurs exclusively during signature share timeouts, where ALL signers remaining in `sign_wait_signer_ids` are marked malicious [4](#0-3) . This is the only location where signers are added to `malicious_signer_ids`. Since attackers who sent invalid nonces were never added to `sign_wait_signer_ids`, they escape being marked.

The `Error::MaliciousSigner` variant exists in the error enum [5](#0-4)  but is commented out at the only location where it could mark invalid nonce senders [6](#0-5) .

The coordinator's threshold feasibility check during signature share timeouts relies on accurate `malicious_signer_ids` tracking [7](#0-6) . If unmarked malicious signers aren't counted, the coordinator incorrectly believes threshold is achievable when it's not. The `reset()` function preserves `malicious_signer_ids` across rounds [8](#0-7)  but never populates it for invalid nonce senders.

The `PublicNonce::is_valid()` method correctly validates that nonce points are not identity or generator [9](#0-8) , but the coordinator doesn't mark signers who fail this validation as malicious.

**Attack Flow:**
1. Attacker joins as legitimate signer with N keys where (total_keys - N) < threshold
2. During signing, sends `NonceResponse` with wrong key_ids OR nonces with D/E set to Point::identity() or G
3. Coordinator rejects response, doesn't add to `sign_wait_signer_ids`
4. Honest signers can't meet threshold without attacker's keys
5. Signing fails (nonce timeout or threshold not met)
6. Attacker repeats attack in retry, never marked malicious
7. Protocol cannot make progress = liveness violation

## Impact Explanation

**Severity: Medium** - Maps to "transient consensus failures" per the defined scope.

The vulnerability enables:

1. **Incorrect Threshold Accounting**: The feasibility check at timeout excludes unmarked malicious signers from the count, causing false beliefs about signing viability.

2. **Persistent Denial of Service**: Attackers can repeatedly disrupt signing across multiple rounds without permanent exclusion, as the retry mechanism continues requesting nonces from them.

3. **Resource Exhaustion**: Legitimate signers waste computational resources (nonce generation, signature computations, network overhead) in signing attempts that cannot succeed.

4. **Consensus Delays**: In blockchain integration scenarios (e.g., Stacks), repeated signing failures delay block production and transaction confirmation.

While cryptographic validation prevents acceptance of invalid signatures (maintaining safety), the liveness guarantee is violated. The system cannot make progress despite having honest participants theoretically capable of meeting threshold, because malicious keys are incorrectly counted as available.

## Likelihood Explanation

**Probability: High**

**Attacker Requirements:**
- Control of signers within the WSTS network (within threat model for up to threshold-1 malicious parties)
- Ability to send protocol messages (normal participant capability)
- No cryptographic breaks, key theft, or social engineering required

**Attack Complexity: Trivial**
- Modify `NonceResponse.key_ids` to wrong values (single field manipulation)
- OR set `PublicNonce.D` and `PublicNonce.E` to Point::identity() or generator G (both fail `is_valid()`)
- Send modified message to coordinator via normal message channel

**Detection Difficulty: High**
- Coordinator only logs warnings indistinguishable from implementation bugs
- No mechanism to attribute repeated failures to specific signers sending invalid data
- External observers see generic signing failures without visibility into root cause

**Economic Feasibility: Very High**
- Zero cost beyond normal participation
- Can join with minimal keys and still disrupt if threshold margins are tight
- Repeatable indefinitely with deterministic success

## Recommendation

Uncomment and utilize the `Error::MaliciousSigner` variant when invalid nonces or key_ids are detected:

```rust
// In gather_nonces() after key_ids validation failure (line 888):
return Err(Error::MaliciousSigner(nonce_response.signer_id));

// After nonce.is_valid() failure (line 899):
return Err(Error::MaliciousSigner(nonce_response.signer_id));
```

Add error handling in the caller to insert these signers into `malicious_signer_ids`:

```rust
match self.gather_nonces(packet, signature_type) {
    Err(Error::MaliciousSigner(signer_id)) => {
        warn!("Marking signer {signer_id} as malicious for invalid nonce data");
        self.malicious_signer_ids.insert(signer_id);
        return Ok((None, None));
    }
    other => other?,
}
```

This ensures signers who send cryptographically invalid data are permanently excluded from future signing rounds, closing the detection gap.

## Proof of Concept

```rust
#[test]
fn malicious_signer_evades_detection_with_invalid_nonces() {
    use crate::curve::point::{Point, G};
    
    let (mut coordinators, mut signers) = setup::<FireCoordinator<v2::Aggregator>, v2::Signer>(3, 10);
    let (mut coordinators, mut signers) = run_dkg::<FireCoordinator<v2::Aggregator>, v2::Signer>(3, 10);
    
    let msg = b"test message";
    let nonce_request = coordinators[0].start_signing_round(msg, SignatureType::Schnorr, None).unwrap();
    
    // Honest signers respond normally
    let (mut messages, _) = feedback_messages(&mut coordinators, &mut signers[0..2], &[nonce_request.clone()]);
    
    // Malicious signer sends invalid nonces (D and E = identity)
    let mut malicious_response = signers[2].process_inbound_messages(&[nonce_request], &mut create_rng()).unwrap()[0].clone();
    if let Message::NonceResponse(ref mut nr) = malicious_response.msg {
        nr.nonces[0].D = Point::identity();
        nr.nonces[0].E = Point::identity();
    }
    
    // Coordinator processes malicious response - should be rejected but signer not marked malicious
    coordinators[0].process(&malicious_response).unwrap();
    
    // Verify malicious signer NOT in malicious_signer_ids
    let saved = coordinators[0].save();
    assert!(!saved.malicious_signer_ids.contains(&2), "Malicious signer should not be marked but it is!");
    
    // Signing will fail due to insufficient keys, but attacker can repeat indefinitely
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L178-186)
```rust
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L188-200)
```rust
                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L871-889)
```rust
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L891-900)
```rust
            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
```

**File:** src/state_machine/coordinator/fire.rs (L913-914)
```rust
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
```

**File:** src/state_machine/coordinator/fire.rs (L940-942)
```rust
            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```

**File:** src/state_machine/coordinator/mod.rs (L65-67)
```rust
    /// A malicious signer sent the received message
    #[error("Malicious signer {0}")]
    MaliciousSigner(u32),
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```
