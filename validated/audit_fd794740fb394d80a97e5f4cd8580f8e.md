# Audit Report

## Title
Memory Exhaustion via Unbounded Polynomial Degree in DKG Public Shares

## Summary
A malicious authenticated signer can craft DKG public shares containing polynomial commitments with arbitrarily large vectors of elliptic curve points, causing memory exhaustion and denial of service on all receiving nodes. The vulnerability exists because serde deserializes the entire `Vec<Point>` before any size validation occurs.

## Finding Description

The `PolyCommitment` structure contains an unbounded `poly` field of type `Vec<Point>` with automatic serde deserialization and no size constraints. [1](#0-0) 

During DKG, signers broadcast `DkgPublicShares` messages containing these commitments. [2](#0-1) 

The attack exploits a deserialization-before-validation pattern. When the state machine's `process()` method is invoked, it receives an already-deserialized `&Packet` parameter, meaning serde has already allocated memory for all nested vectors including the `Vec<Point>` in each `PolyCommitment`. [3](#0-2) 

Even when signature verification is enabled, it occurs after complete deserialization and memory allocation. [4](#0-3) 

The `dkg_public_share()` handler validates signer identity and party IDs but performs no polynomial size validation. [5](#0-4) 

Size validation only occurs later in `dkg_ended()` when `check_public_shares()` is called. [6](#0-5) 

The `check_public_shares()` function validates that polynomial length equals the threshold, but this validation happens after memory has been allocated during deserialization. [7](#0-6) 

**Attack Vector:**
1. Malicious signer constructs `PolyCommitment` with `poly` containing millions of curve points
2. Wraps it in `DkgPublicShares` and signs with legitimate credentials  
3. Broadcasts to other participants
4. Receiving nodes deserialize the message, allocating gigabytes of memory
5. Nodes crash from OOM before validation logic executes

The legitimate polynomial size should equal the threshold (typically 2-13). An attacker can send polynomials with 100 million points, causing ~3.3 GB allocations per message (33 bytes per compressed point).

## Impact Explanation

**Severity: LOW** - "Any remotely-exploitable denial of service in a node"

The attack causes immediate denial of service:
- Memory exhaustion triggers OOM killer or node crashes
- DKG round fails completely, preventing threshold signature setup
- All nodes receiving the message crash simultaneously
- Protocol availability is compromised

The attack is remotely exploitable over the network without local access. While requiring authenticated signer credentials, this is within the protocol's threat model of supporting up to threshold-1 malicious signers.

## Likelihood Explanation

**Likelihood: High** if a malicious authenticated signer exists.

**Attacker Requirements:**
- Valid signer credentials (within threat model)
- Network connectivity to participate in DKG
- No special timing or race conditions needed

**Attack Complexity: Low**
- Create oversized `Vec<Point>` in `PolyCommitment`
- Sign and broadcast during DKG
- Attacker identity traceable but damage occurs before detection

**Economic Feasibility:**
Near-zero cost to attacker, high cost to victims through forced memory allocation.

## Recommendation

Implement size validation during deserialization using custom serde deserializer:

```rust
#[derive(Clone, Debug, PartialEq)]
pub struct PolyCommitment {
    pub id: ID,
    #[serde(deserialize_with = "deserialize_bounded_poly")]
    pub poly: Vec<Point>,
}

fn deserialize_bounded_poly<'de, D>(deserializer: D) -> Result<Vec<Point>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    const MAX_POLY_SIZE: usize = 100; // Adjust based on max threshold
    let vec = Vec::<Point>::deserialize(deserializer)?;
    if vec.len() > MAX_POLY_SIZE {
        return Err(serde::de::Error::custom(
            format!("polynomial too large: {} > {}", vec.len(), MAX_POLY_SIZE)
        ));
    }
    Ok(vec)
}
```

Alternatively, validate size immediately upon packet receipt before further processing.

## Proof of Concept

```rust
#[test]
fn test_oversized_polynomial_memory_exhaustion() {
    use crate::curve::point::{Point, G};
    use crate::curve::scalar::Scalar;
    use crate::common::PolyCommitment;
    use crate::net::DkgPublicShares;
    use crate::schnorr::ID;
    use crate::util::create_rng;
    
    let mut rng = create_rng();
    let ctx = 0u64.to_be_bytes();
    
    // Create oversized polynomial (10,000 points for PoC - in real attack: millions)
    let oversized_poly: Vec<Point> = (0..10_000)
        .map(|_| Scalar::random(&mut rng) * G)
        .collect();
    
    let malicious_comm = PolyCommitment {
        id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
        poly: oversized_poly, // Should be threshold size (~2-13), not 10,000
    };
    
    let malicious_shares = DkgPublicShares {
        dkg_id: 0,
        signer_id: 0,
        comms: vec![(1, malicious_comm)],
        kex_public_key: Scalar::random(&mut rng) * G,
    };
    
    // Serialize and deserialize to demonstrate memory allocation
    let serialized = bincode::serialize(&malicious_shares).unwrap();
    println!("Serialized size: {} bytes", serialized.len());
    
    // This deserialization allocates memory for all 10,000 points
    // before any validation can occur
    let deserialized: DkgPublicShares = bincode::deserialize(&serialized).unwrap();
    assert_eq!(deserialized.comms[0].1.poly.len(), 10_000);
    
    // Validation only happens later in dkg_ended(), after memory is allocated
    // With millions of points, this causes OOM before validation runs
}
```

### Citations

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/state_machine/signer/mod.rs (L458-462)
```rust
    pub fn process<R: RngCore + CryptoRng>(
        &mut self,
        packet: &Packet,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L556-558)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```
