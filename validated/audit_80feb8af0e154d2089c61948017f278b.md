# Audit Report

## Title
Memory Exhaustion via Unbounded PolyCommitment Vectors in DKG Public Shares

## Summary
A malicious DKG participant can exploit the lack of size validation on the `comms` vector in `DkgPublicShares` messages to cause memory and CPU exhaustion on all participating nodes (coordinator and signers), preventing DKG completion.

## Finding Description

During the DKG protocol, signers broadcast `DkgPublicShares` messages containing a vector of polynomial commitments in the `comms: Vec<(u32, PolyCommitment)>` field. [1](#0-0) 

Each `PolyCommitment` contains an `ID` struct (with `id: Scalar`, `kG: Point`, `kca: Scalar`) and a `poly: Vec<Point>` vector. [2](#0-1) [3](#0-2) 

**Vulnerability on Coordinator:**

When the coordinator receives `DkgPublicShares`, it performs minimal validation and directly clones and stores the entire message without any size check on the `comms` vector. [4](#0-3) 

**Vulnerability on Signers:**

Signers iterate through ALL entries in the `comms` vector to validate each `party_id`, then store the entire message without size limits. [5](#0-4) [6](#0-5) 

**Why Existing Validations Fail:**

For v2, the `validate_party_id` check only verifies `signer_id == party_id`, allowing a malicious signer to send millions of duplicate entries all with their own valid `signer_id`. [7](#0-6) 

The duplicate detection logic only prevents duplicate `DkgPublicShares` messages from the same `signer_id`, not duplicate entries within a single message. [8](#0-7) [9](#0-8) 

**Attack Execution:**

A malicious authorized participant modifies their client to populate the `comms` vector with millions of duplicate `(party_id, PolyCommitment)` tuples using valid party IDs they control. The message passes signature verification and all existing validations, but causes resource exhaustion on all receiving nodes.

## Impact Explanation

**Severity: Low** - This is a remotely-exploitable denial of service in nodes participating in DKG.

**Specific Impacts:**
- **Memory Exhaustion:** With 1 million duplicate entries and threshold=3, each malicious signer causes ~200 MB memory consumption per receiving node (ID struct ~97 bytes + polynomial ~99 bytes + overhead)
- **CPU Exhaustion:** Validation loops iterate through all entries, causing millions of unnecessary operations
- **DKG Failure:** The DKG process cannot complete, preventing new distributed key generation
- **Service Disruption:** Nodes may need to be restarted and the malicious participant excluded

**Why Not Higher Severity:**
- Does not affect existing signing operations (DKG only)
- Does not cause fund loss or produce invalid signatures
- Requires being an authorized DKG participant (limited attack surface)
- Recoverable by restarting nodes and excluding the attacker
- Does not permanently shut down the network

## Likelihood Explanation

**Required Attacker Capabilities:**
- Must be an authorized DKG participant with valid `signer_id` and configured public keys
- Ability to construct and send network messages (trivial for any participant)

**Attack Complexity: Low**
1. Modify client to create `DkgPublicShares` message
2. Populate `comms` with millions of duplicate tuples using valid `party_id` values
3. Sign and send via normal protocol flow

**Probability: High** - Any authorized participant who turns malicious can reliably execute this attack with minimal effort. The attack is easily detectable through network monitoring and memory/CPU metrics, allowing operators to identify and exclude the malicious party.

## Recommendation

Implement size validation on the `comms` vector before processing:

```rust
// In gather_public_shares (coordinator)
const MAX_COMMS_ENTRIES: usize = 100; // Adjust based on expected max parties per signer

if dkg_public_shares.comms.len() > MAX_COMMS_ENTRIES {
    warn!(signer_id = %dkg_public_shares.signer_id, 
          comms_len = dkg_public_shares.comms.len(),
          "Rejecting DkgPublicShares with excessive comms entries");
    return Ok(());
}
```

Apply the same check in the signer's `dkg_public_shares` method before the validation loop.

Additionally, consider validating uniqueness of `party_id` values within the `comms` vector to prevent duplicate entries:

```rust
let mut seen_party_ids = HashSet::new();
for (party_id, _) in &dkg_public_shares.comms {
    if !seen_party_ids.insert(*party_id) {
        warn!(%signer_id, %party_id, "Duplicate party_id in comms");
        return Ok(vec![]);
    }
    // ... existing validation
}
```

## Proof of Concept

```rust
#[test]
fn test_memory_exhaustion_via_large_comms_vector() {
    use crate::net::DkgPublicShares;
    use crate::common::PolyCommitment;
    use crate::schnorr::ID;
    use crate::curve::scalar::Scalar;
    use crate::curve::point::Point;
    
    let mut rng = create_rng();
    let ctx = 0u64.to_be_bytes();
    
    // Create a single valid PolyCommitment
    let poly_comm = PolyCommitment {
        id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
        poly: vec![Point::from(Scalar::random(&mut rng)); 3],
    };
    
    // Malicious signer creates message with 100,000 duplicate entries
    let mut comms = Vec::new();
    for _ in 0..100_000 {
        comms.push((0u32, poly_comm.clone()));
    }
    
    let malicious_shares = DkgPublicShares {
        dkg_id: 0,
        signer_id: 0,
        comms,
        kex_public_key: Point::from(Scalar::random(&mut rng)),
    };
    
    // Verify message size is excessive
    let serialized = bincode::serialize(&malicious_shares).unwrap();
    assert!(serialized.len() > 10_000_000); // Over 10 MB
    
    // This message would be processed without size validation,
    // causing memory exhaustion on all receiving nodes
}
```

### Citations

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/schnorr.rs (L14-23)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// ID type which encapsulates the ID and a schnorr proof of ownership of the polynomial
pub struct ID {
    /// The ID
    pub id: Scalar,
    /// The public schnorr response
    pub kG: Point,
    /// The aggregate of the schnorr committed values
    pub kca: Scalar,
}
```

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/state_machine/coordinator/fire.rs (L493-500)
```rust
            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L993-1002)
```rust
        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L1004-1011)
```rust
        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }
```

**File:** src/state_machine/signer/mod.rs (L1023-1024)
```rust
        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/v2.rs (L644-650)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        _signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        signer_id == party_id
    }
```
