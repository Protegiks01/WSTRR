# Audit Report

## Title
Malicious DKG Signers Can Rejoin Despite Persistent Ban Tracking

## Summary
The FIRE coordinator tracks malicious DKG signers in `malicious_dkg_signer_ids` and persists this set across restarts, but fails to enforce the ban when accepting DKG messages in subsequent rounds. This allows previously-banned malicious signers to repeatedly participate in DKG, causing persistent denial-of-service by preventing establishment of the aggregate public key required for threshold signing.

## Finding Description

The FIRE coordinator implements a tracking mechanism for malicious DKG signers but critically fails to enforce the ban, breaking the security guarantee that detected malicious signers should be excluded from future DKG rounds.

**Tracking Implementation (Present):**

The `SavedState` structure defines a field for tracking malicious DKG signers: [1](#0-0) 

The FIRE coordinator maintains this field in its internal state: [2](#0-1) 

The coordinator properly persists this state across restarts: [3](#0-2) 

And correctly loads it: [4](#0-3) 

When malicious behavior is detected during DKG (e.g., sending invalid shares), signers are added to this set: [5](#0-4) 

**Enforcement Implementation (Absent):**

When starting a new DKG round, ALL signers are unconditionally included in the wait set without filtering: [6](#0-5) 

The `gather_public_shares` method accepts messages from any signer without checking the ban list: [7](#0-6) 

Similarly, `gather_private_shares` has no enforcement check: [8](#0-7) 

And `gather_dkg_end` lacks any check at entry: [9](#0-8) 

**Proof of Missing Enforcement:**

A codebase-wide search confirms there are ZERO checks of `malicious_dkg_signer_ids.contains()` anywhere in the code, proving the ban is never enforced.

**Contrast with Signing Path (Correct Implementation):**

For signing rounds, the coordinator DOES properly enforce the ban on malicious signers by rejecting nonces: [10](#0-9) 

This demonstrates that the pattern for enforcing bans exists in the codebase but was not applied to DKG paths.

**Additional Evidence of Incomplete Implementation:**

A TODO comment suggests this enforcement was intended but never completed: [11](#0-10) 

**Attack Path:**

1. DKG Round N: Malicious signer A sends invalid shares
2. Coordinator detects malicious behavior and adds signer A to `malicious_dkg_signer_ids`
3. DKG Round N+1: `start_public_shares()` includes ALL signers (including A) in wait set
4. Signer A participates again, sending invalid shares
5. DKG fails again with signer A re-added to `malicious_dkg_signer_ids` (no-op)
6. Process repeats indefinitely

## Impact Explanation

This vulnerability enables a persistent denial-of-service attack with the following consequences:

**Direct Impact:**
- Malicious signer can repeatedly cause DKG failures
- Each DKG failure prevents establishment of the aggregate public key
- Without an aggregate public key, threshold signing cannot proceed (enforced at coordinator startup) [12](#0-11) 

**System-Level Impact:**
- Systems using WSTS for threshold signatures become unable to produce signatures
- In blockchain contexts, this prevents:
  - Block production if threshold signatures are required for consensus
  - Transaction confirmation if signatures gate finality
  - Network operation if DKG must complete for continued function

**Severity Mapping:**
- **Minimum: Low** - "Any remotely-exploitable denial of service in a node" (always applies)
- **Potential: Critical** - "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks" (if DKG is critical to network operation)

The actual severity depends on how the integrating system uses WSTS, but the vulnerability enables persistent DoS in all cases.

## Likelihood Explanation

**Prerequisites (All Easily Met):**
- Attacker must be a registered signer in `config.public_keys` ✓ (normal protocol participant)
- Attacker must be detected as malicious once ✓ (intentional for attack)
- System uses FIRE coordinator ✓ (production variant in scope)

**Attack Characteristics:**
- **Complexity:** Trivial - once marked malicious, attacker simply continues participating in DKG using normal protocol messages
- **Cost:** Negligible - reuses existing signer credentials, sends standard DKG messages
- **Detection:** High (attacker is detected each round) but has zero consequence due to lack of enforcement
- **Success Rate:** 100% - no enforcement checks exist to prevent the attack

**Exploit Algorithm:**
```
1. Participate in DKG Round N as registered signer
2. Send invalid shares to trigger detection
3. Get marked in malicious_dkg_signer_ids (persisted)
4. Wait for DKG Round N+1
5. Participate again (no checks prevent this)
6. Send invalid shares again
7. Repeat steps 4-6 indefinitely
```

The vulnerability is deterministic and requires no sophisticated techniques or rare conditions.

## Recommendation

Add enforcement checks for `malicious_dkg_signer_ids` in all DKG gathering methods, mirroring the enforcement pattern used for `malicious_signer_ids` in the signing path.

**Recommended Fix:**

Add check at the start of `gather_public_shares`:
```rust
fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
    if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
        // Add this check
        if self.malicious_dkg_signer_ids.contains(&dkg_public_shares.signer_id) {
            warn!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "Rejected DkgPublicShares from banned malicious signer"
            );
            return Ok(());
        }
        // ... rest of existing logic
```

Add similar checks in `gather_private_shares` and `gather_dkg_end`.

Alternatively, filter the wait set at initialization:
```rust
pub fn start_public_shares(&mut self) -> Result<Packet, Error> {
    self.dkg_public_shares.clear();
    self.party_polynomials.clear();
    // Filter out malicious signers
    self.dkg_wait_signer_ids = (0..self.config.num_signers)
        .filter(|id| !self.malicious_dkg_signer_ids.contains(id))
        .collect();
    // ... rest of existing logic
```

**Additional Consideration:**

Implement the TODO at line 783 to check if sufficient non-malicious signers remain to meet the DKG threshold before continuing.

## Proof of Concept

```rust
#[test]
fn malicious_dkg_signer_can_rejoin() {
    use crate::state_machine::coordinator::{
        fire::Coordinator as FireCoordinator,
        Config, Coordinator as CoordinatorTrait,
    };
    use crate::v2::Aggregator;
    use crate::curve::scalar::Scalar;
    use rand_core::OsRng;

    // Setup coordinator with FIRE
    let mut rng = OsRng;
    let config = Config::new(5, 10, 7, Scalar::random(&mut rng));
    let mut coordinator = FireCoordinator::<Aggregator>::new(config);
    
    // Simulate signer 0 being marked malicious in DKG
    coordinator.malicious_dkg_signer_ids.insert(0);
    
    // Start a new DKG round
    coordinator.start_dkg_round(None).unwrap();
    
    // Verify signer 0 is in the wait set despite being marked malicious
    assert!(
        coordinator.dkg_wait_signer_ids.contains(&0),
        "Malicious DKG signer should be excluded but is in wait set"
    );
    
    // This proves the ban is not enforced - a malicious signer can rejoin
}
```

This test demonstrates that once a signer is added to `malicious_dkg_signer_ids`, they are still included in `dkg_wait_signer_ids` when starting a new DKG round, proving the ban is tracked but not enforced.

### Citations

**File:** src/state_machine/coordinator/mod.rs (L295-295)
```rust
    pub malicious_dkg_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L65-65)
```rust
    malicious_dkg_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L399-399)
```rust
        self.dkg_wait_signer_ids = (0..self.config.num_signers).collect();
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L525-565)
```rust
    fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
            info!(
                dkg_id = %dkg_private_shares.dkg_id,
                signer_id = %dkg_private_shares.signer_id,
                "DkgPrivateShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.private_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L572-792)
```rust
    fn gather_dkg_end(&mut self, packet: &Packet) -> Result<(), Error> {
        debug!(
            "DKG Round {}: waiting for Dkg End from signers {:?}",
            self.current_dkg_id, self.dkg_wait_signer_ids
        );
        if let Message::DkgEnd(dkg_end) = &packet.msg {
            if dkg_end.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(dkg_end.dkg_id, self.current_dkg_id));
            }
            if self.dkg_wait_signer_ids.contains(&dkg_end.signer_id) {
                self.dkg_wait_signer_ids.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.dkg_wait_signer_ids,
                    "DkgEnd received"
                );
            } else {
                warn!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    "Got DkgEnd from signer who we weren't waiting on"
                );
            }
        }

        let mut reported_failures = HashMap::new();
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
        let threshold: usize = self.config.threshold.try_into().unwrap();
        if self.dkg_wait_signer_ids.is_empty() {
            // if there are any errors, mark signers malicious and retry
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());

                    match dkg_failure {
                        DkgFailure::BadState => {
                            // signer should not be in a bad state so treat as malicious
                            malicious_signers.insert(*signer_id);
                        }
                        DkgFailure::Threshold => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
                        }
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
                        }
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                    }
                }
            }

            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }

            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1334-1334)
```rust
            malicious_dkg_signer_ids: state.malicious_dkg_signer_ids.clone(),
```

**File:** src/state_machine/coordinator/fire.rs (L1363-1363)
```rust
            malicious_dkg_signer_ids: self.malicious_dkg_signer_ids.clone(),
```

**File:** src/state_machine/coordinator/fire.rs (L1464-1466)
```rust
        if self.aggregate_public_key.is_none() {
            return Err(Error::MissingAggregatePublicKey);
        }
```
