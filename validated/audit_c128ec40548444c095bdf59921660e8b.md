# Audit Report

## Title
Race Condition in DKG Failure Verification Allows Malicious Exclusion of Honest Signers

## Summary
The FIRE coordinator's `gather_dkg_end` function contains a logic flaw in its `BadPublicShares` verification that allows a malicious signer to cause honest signers to be incorrectly marked as malicious. The vulnerability arises from the coordinator accepting private shares from signers who never sent public shares, combined with timeout-based progression that doesn't require all public shares before proceeding.

## Finding Description

The vulnerability exists in the interaction between the coordinator's timeout handling and its verification logic for `BadPublicShares` reports.

**Attack Mechanism:**

A malicious signer M can exploit this by:
1. Generating invalid `DkgPublicShares` with bad Schnorr proofs
2. Sending these invalid shares to honest signers via P2P network
3. Deliberately not sending these shares to the coordinator

The coordinator's timeout handling allows it to proceed without receiving all public shares if `dkg_threshold` is met: [1](#0-0) 

Critically, the coordinator accepts private shares from **any** signer in the configuration, not just those who sent public shares: [2](#0-1) 

This allows M to send private shares even though M never sent public shares to the coordinator.

The coordinator then includes M in the `DkgEndBegin` message based on who sent private shares: [3](#0-2) 

Honest signers who received M's invalid public shares via P2P store them: [4](#0-3) 

When validating during `dkg_ended`, honest signers correctly detect the invalid shares and report `BadPublicShares(M)`: [5](#0-4) [6](#0-5) 

The validation uses `check_public_shares` which verifies Schnorr proofs: [7](#0-6) 

When the coordinator processes these reports, it attempts to verify them by checking if it has M's public shares. If the coordinator doesn't have public shares from the accused signer (returns `None`), it **incorrectly** concludes the reporting signer is lying and marks them as malicious: [8](#0-7) 

This is the core vulnerability - the coordinator assumes absence of public shares means false accusation, but the honest signer's report is correct.

The malicious signers are tracked and returned in the error: [9](#0-8) [10](#0-9) 

## Impact Explanation

**Critical Severity:** This vulnerability enables a single malicious signer to cause multiple honest signers to be incorrectly marked as malicious and excluded from the DKG protocol.

In a threshold signature system:
- If (n - threshold) honest signers are excluded, the system cannot meet the threshold requirement
- In a 7-of-10 configuration, excluding just 4 honest signers prevents any valid signatures
- This directly prevents transaction confirmation and blocks network operation

This aligns with the **Critical** impact category: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

The malicious signers list is propagated in `Error::DkgFailure` results and would affect application-layer decisions about signer trust and participation in future rounds.

## Likelihood Explanation

**High Likelihood (~80%+):**

The attack is highly feasible because:

1. **Attacker Requirements:** Only requires control of one malicious signer node (within the protocol's threat model of up to threshold-1 malicious signers)

2. **Network Control:** Standard P2P network capability - any node controls its own message sending and can selectively deliver messages to different participants

3. **Timing Window:** The timeout mechanism creates a natural window for the attack. The malicious signer simply needs to ensure the coordinator times out before receiving the malicious public shares

4. **Detection Difficulty:** Legitimate network delays are indistinguishable from malicious delays, making the attack appear as normal network behavior

5. **Prerequisites:** Only requires timeout configuration (standard in production) and threshold being meetable without the malicious signer's contribution

The attack requires no cryptographic key material, no breaking of primitives, and exploits standard protocol flow with realistic network conditions.

## Recommendation

Fix the logic flaw in `gather_dkg_end` by ensuring consistency between which signers sent public shares and which are included in the DKG process. Recommended fixes:

**Option 1:** Only accept private shares from signers who sent public shares:
```rust
fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
    if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
        // ... existing checks ...
        
        // NEW CHECK: Verify this signer sent public shares
        if !self.dkg_public_shares.contains_key(&dkg_private_shares.signer_id) {
            warn!(signer_id = %dkg_private_shares.signer_id, "received private shares without public shares");
            return Ok(());
        }
        
        // ... rest of function ...
    }
}
```

**Option 2:** Change the verification logic in `gather_dkg_end` to handle missing public shares correctly:
```rust
let Some(dkg_public_shares) = self.dkg_public_shares.get(bad_signer_id)
else {
    // If coordinator doesn't have public shares but the signer is in DkgEndBegin,
    // this indicates a protocol inconsistency - mark the accused signer as malicious
    // since they shouldn't have been included without public shares
    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} who never sent public shares to coordinator, mark {bad_signer_id} as malicious");
    malicious_signers.insert(*bad_signer_id);
    continue;
};
```

**Option 3:** Only include signers who sent public shares in `DkgEndBegin`:
```rust
pub fn start_dkg_end(&mut self) -> Result<Packet, Error> {
    // Only include signers who sent both public AND private shares
    let eligible_signers: HashSet<u32> = self
        .dkg_private_shares
        .keys()
        .filter(|id| self.dkg_public_shares.contains_key(id))
        .cloned()
        .collect();
        
    self.dkg_wait_signer_ids = eligible_signers.clone();
    
    let dkg_end_begin = DkgEndBegin {
        dkg_id: self.current_dkg_id,
        signer_ids: eligible_signers.into_iter().collect(),
        key_ids: vec![],
    };
    // ... rest of function ...
}
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Configure a DKG with threshold that can be met by subset of signers
2. Set up one malicious signer M
3. Have M generate invalid `DkgPublicShares` (bad Schnorr proof)
4. Have M send these to honest signers via P2P but NOT to coordinator
5. Trigger timeout so coordinator proceeds with threshold met
6. Have M send valid `DkgPrivateShares` to coordinator
7. Verify coordinator includes M in `DkgEndBegin`
8. Verify honest signers report `BadPublicShares(M)`
9. Verify coordinator incorrectly marks honest signers as malicious instead of M

The test would assert that honest signers appear in the `malicious_signers` set of the returned `Error::DkgFailure`, demonstrating the vulnerability.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L93-98)
```rust
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.public_shares_gathered()?;
                                let packet = self.start_private_shares()?;
                                return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L463-463)
```rust
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L624-629)
```rust
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
```

**File:** src/state_machine/coordinator/fire.rs (L775-788)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }

            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/signer/mod.rs (L556-558)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
```

**File:** src/state_machine/signer/mod.rs (L593-598)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
```

**File:** src/state_machine/signer/mod.rs (L1023-1024)
```rust
        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/coordinator/mod.rs (L97-101)
```rust
    DkgFailure {
        /// failures reported by signers during DkgEnd
        reported_failures: HashMap<u32, DkgFailure>,
        /// signers who were discovered to be malicious during this DKG round
        malicious_signers: HashSet<u32>,
```
