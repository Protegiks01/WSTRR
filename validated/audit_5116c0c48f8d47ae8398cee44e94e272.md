# Audit Report

## Title
Missing Monotonicity Validation Allows DKG Round Regression via Replay Attacks

## Summary
The WSTS protocol state machines lack monotonicity validation for DKG round IDs. Both coordinators and signers accept `DkgBegin` messages with `dkg_id` values less than their current round, allowing protocol participants to regress to previous DKG rounds when old legitimately-signed messages are replayed. This violates the intended state machine invariant that round IDs should progress monotonically.

## Finding Description

The vulnerability exists in three interconnected components:

**Signer State Machine**: The `dkg_begin()` function unconditionally accepts any `dkg_id` value and immediately resets to that round without validation. [1](#0-0) 

The `reset()` function directly overwrites `self.dkg_id` with any provided value, including values lower than the current round. [2](#0-1) 

**FROST Coordinator**: The coordinator only checks for equality (`self.current_dkg_id == dkg_begin.dkg_id`) to detect duplicate messages, but does NOT reject messages where `dkg_begin.dkg_id < self.current_dkg_id`. When such a message is received, it proceeds to call `start_dkg_round()` with the old ID. [3](#0-2) 

The `start_dkg_round()` function unconditionally sets `self.current_dkg_id` to whatever value is provided, enabling regression. [4](#0-3) 

**FIRE Coordinator**: The FIRE coordinator implementation exhibits the identical vulnerability pattern. [5](#0-4) [6](#0-5) 

**Why Existing Protections Are Insufficient**:

While `DkgBegin` messages are signed by the coordinator and verified, this only prevents forgery—not replay. A network attacker can capture legitimately signed messages and replay them later. [7](#0-6) [8](#0-7) 

The signature verification in both coordinators and signers confirms authenticity but provides no temporal or replay protection. [9](#0-8) [10](#0-9) 

**Critical Test Gap**: The test named `old_round_ids_are_ignored` is misleading—it only validates that duplicate round IDs (where `old_id == current_id`) are ignored, but does NOT test the critical case where `old_id < current_id`. [11](#0-10) 

The test sets `old_id = id` (line 1513), making them equal, not testing actual regression to older rounds.

## Impact Explanation

This vulnerability allows an attacker with network access to force protocol participants to regress to previous DKG rounds by replaying old legitimately-signed `DkgBegin` messages.

**Concrete Attack Scenario**:
1. Network is at DKG round 15
2. Attacker replays a captured `DkgBegin{dkg_id: 10}` packet
3. All recipients regress to round 10, abandoning current DKG progress
4. If replay reaches only some nodes, the network becomes desynchronized with different nodes operating in different DKG rounds
5. DKG cannot complete when participants are in different rounds
6. Failed DKG prevents generation of threshold signing keys

**Severity Assessment**: This maps to **MEDIUM severity** under "Any transient consensus failures" because:
- Failed DKG rounds prevent threshold signature generation required for consensus operations
- The attack causes temporary disruption to protocol operations
- Recovery requires coordination to restart DKG from a synchronized state

The impact could escalate to **HIGH severity** ("Any unintended chain split or network partition") if different sets of nodes become persistently desynchronized in different DKG rounds, though this depends on the specific deployment and recovery mechanisms.

## Likelihood Explanation

**Attacker Requirements**:
- Network position to observe P2P traffic (standard for distributed systems)
- Ability to inject packets (realistic for network adversaries)
- No cryptographic breaks or key compromise needed

**Attack Complexity**: LOW
1. Passively capture any `DkgBegin` message during normal operation
2. Wait for protocol to advance to a later round
3. Replay the captured packet to reachable nodes
4. Nodes will regress due to missing monotonicity checks

**Mitigating Factors**:
- Transport-layer protections (TCP sequence numbers) may prevent some replay scenarios
- Depends on network architecture and deployment environment
- Requires active network adversary, not just passive observer

**Overall Likelihood**: MEDIUM to HIGH in adversarial network environments where packet injection is possible, though specific likelihood depends on transport layer and deployment architecture.

## Recommendation

Add monotonicity validation to reject DKG messages with round IDs less than or equal to the current round:

**For Coordinators** (both FROST and FIRE):
```rust
if let Message::DkgBegin(dkg_begin) = &packet.msg {
    if self.current_dkg_id >= dkg_begin.dkg_id {
        // Reject duplicate or old DKG rounds
        warn!("Ignoring DkgBegin with non-increasing dkg_id: {} (current: {})", 
              dkg_begin.dkg_id, self.current_dkg_id);
        return Ok((None, None));
    }
    let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
    return Ok((Some(packet), None));
}
```

**For Signers**:
```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    if self.dkg_id >= dkg_begin.dkg_id {
        warn!("Ignoring DkgBegin with non-increasing dkg_id: {} (current: {})", 
              dkg_begin.dkg_id, self.dkg_id);
        return Ok(vec![]);
    }
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Fix the Test**: Rename and enhance the test to actually validate old round rejection:
```rust
fn old_round_ids_are_rejected() {
    // Test both equality (duplicate) and less-than (old) cases
    let old_id = id - 5; // Actually test old rounds
    // ... test that old_id is rejected
}
```

## Proof of Concept

```rust
#[test]
fn test_dkg_round_regression_vulnerability() {
    use crate::state_machine::coordinator::frost::Coordinator as FrostCoordinator;
    use crate::state_machine::{Config, OperationResult};
    use crate::net::{DkgBegin, Message, Packet};
    use crate::curve::scalar::Scalar;
    use rand_core::OsRng;
    
    let mut rng = OsRng;
    let config = Config::new(3, 10, 7, Scalar::random(&mut rng));
    let mut coordinator = FrostCoordinator::new(config);
    
    // Advance to round 10
    coordinator.current_dkg_id = 10;
    
    // Attempt to replay old DkgBegin with dkg_id = 5
    let old_packet = Packet {
        sig: vec![],
        msg: Message::DkgBegin(DkgBegin { dkg_id: 5 }),
    };
    
    let (response, _) = coordinator.process_message(&old_packet).unwrap();
    
    // VULNERABILITY: Coordinator accepts old round and regresses
    assert_eq!(coordinator.current_dkg_id, 5); // Regressed from 10 to 5!
    assert!(response.is_some()); // Coordinator initiated DKG for old round
    
    // Expected behavior: Should remain at round 10 and reject old message
    // assert_eq!(coordinator.current_dkg_id, 10);
    // assert!(response.is_none());
}
```

This test demonstrates that a coordinator at round 10 will regress to round 5 when receiving a replayed `DkgBegin{dkg_id: 5}` message, confirming the vulnerability.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/coordinator/frost.rs (L63-70)
```rust
        if self.config.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/coordinator/frost.rs (L73-82)
```rust
                State::Idle => {
                    // Did we receive a coordinator message?
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/frost.rs (L956-966)
```rust
    /// Start a DKG round
    fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }
        info!("Starting DKG round {}", self.current_dkg_id);
        self.move_to(State::DkgPublicDistribute)?;
        self.start_public_shares()
    }
```

**File:** src/state_machine/coordinator/frost.rs (L1512-1526)
```rust
        let id: u64 = 10;
        let old_id = id;
        coordinator.current_dkg_id = id;
        coordinator.current_sign_id = id;
        // Attempt to start an old DKG round
        let (packet, result) = coordinator
            .process(&Packet {
                sig: vec![],
                msg: Message::DkgBegin(DkgBegin { dkg_id: old_id }),
            })
            .unwrap();
        assert!(packet.is_none());
        assert!(result.is_none());
        assert_eq!(coordinator.state, State::Idle);
        assert_eq!(coordinator.current_dkg_id, id);
```

**File:** src/state_machine/coordinator/fire.rs (L228-237)
```rust
                State::Idle => {
                    // Did we receive a coordinator message?
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L1428-1439)
```rust
    /// Start a DKG round, with an optional `dkg_id`
    fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }

        info!("Starting DKG round {}", self.current_dkg_id);
        self.move_to(State::DkgPublicDistribute)?;
        self.start_public_shares()
    }
```

**File:** src/net.rs (L125-137)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG begin message from coordinator to signers
pub struct DkgBegin {
    /// DKG round ID
    pub dkg_id: u64,
}

impl Signable for DkgBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
    }
}
```

**File:** src/net.rs (L488-499)
```rust
    pub fn verify(
        &self,
        signers_public_keys: &PublicKeys,
        coordinator_public_key: &ecdsa::PublicKey,
    ) -> bool {
        match &self.msg {
            Message::DkgBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgBegin message with an invalid signature.");
                    return false;
                }
            }
```
