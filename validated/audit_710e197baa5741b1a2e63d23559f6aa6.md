# Audit Report

## Title
Coordinator Fails to Validate MissingPrivateShares Claims Enabling Persistent DKG Denial of Service

## Summary
A malicious signer can selectively withhold encrypted private shares during DKG, causing honest signers to report `MissingPrivateShares` failures. The coordinator performs no validation despite having all necessary data, resulting in DKG failure without identifying the malicious party. This enables persistent denial of service as the attacker is never marked malicious and can participate in unlimited retry attempts.

## Finding Description

The vulnerability exists in the coordinator's Byzantine fault detection mechanism for DKG private share distribution. When honest signers report `DkgFailure::MissingPrivateShares`, the coordinator performs zero validation and does not identify the malicious party. [1](#0-0) 

This contrasts sharply with `BadPrivateShares` handling, where the coordinator performs extensive validation (over 100 lines) including tuple proof verification, share decryption, and polynomial commitment checking to determine who is malicious: [2](#0-1) 

**Attack Mechanism:**

1. During DKG private share distribution, signers create `DkgPrivateShares` messages with encrypted shares stored in a HashMap mapping `dst_key_id` to encrypted bytes: [3](#0-2) 

A malicious signer can trivially omit specific `dst_key_id` entries from the `encrypted_shares` HashMap (line 932), controlling which parties receive shares.

2. Honest signers detect missing shares by checking if all their key_ids are present in received messages: [4](#0-3) 

3. Honest signers report the failure with the accused signer's ID: [5](#0-4) 

4. The coordinator collects failures but when `MissingPrivateShares` is reported, returns `Error::DkgFailure` without blame attribution: [6](#0-5) 

**Why Validation is Possible but Missing:**

The coordinator stores all `DkgPrivateShares` messages: [7](#0-6) 

The coordinator knows which key_ids each signer controls: [8](#0-7) 

The coordinator could check if the accused signer's `DkgPrivateShares.shares` HashMap contains encrypted values for all of the reporting signer's key_ids. This would deterministically identify whether the reporter or the accused is lying. However, this validation is not implemented.

## Impact Explanation

**Severity: LOW**

This vulnerability breaks the Byzantine fault tolerance security guarantee that "malicious participants can be identified and reported through the DkgFailure mechanism" as documented in the Security Model.

The impact enables persistent denial of service against DKG operations:

1. **DKG Operation Failure**: Any `MissingPrivateShares` report causes DKG to fail with `reported_failures` populated but `malicious_signers` empty: [6](#0-5) 

2. **No Blame Attribution**: Malicious signers are only added to `malicious_dkg_signer_ids` if identified in the `malicious_signers` set: [9](#0-8) 

Since `MissingPrivateShares` never populates this set, the attacker is never marked malicious and can participate in all retry attempts.

3. **Persistent DoS**: A single malicious signer can prevent DKG completion indefinitely, blocking all threshold signature operations that depend on successful DKG.

This maps to **LOW** severity under the provided scope: "Any remotely-exploitable denial of service in a node" - as the vulnerability enables DoS against the DKG protocol component. The actual system-level impact depends on integration context and retry policies.

## Likelihood Explanation

**Probability: HIGH**

- **Attacker Requirements**: Control of one signer identity participating in DKG (within the protocol's t-1 Byzantine threat model)
- **Attack Complexity**: Trivial - simply omit certain `dst_key_id` entries when building the `encrypted_shares` HashMap during `dkg_private_begin()`
- **Cryptographic Requirements**: None - no need to break encryption, forge signatures, or compromise keys
- **Detection Risk**: Zero - coordinator explicitly does not validate or attribute blame for `MissingPrivateShares`
- **Success Rate**: 100% deterministic if attacker controls any participating signer
- **Repeatability**: Unlimited - works on every DKG retry attempt since no attribution mechanism exists

The coordinator's gather_private_shares method performs no content validation: [10](#0-9) 

It only checks message format, not whether all required key_ids are present.

## Recommendation

Implement validation logic in the coordinator's `gather_dkg_end` function for `MissingPrivateShares` claims, similar to the existing `BadPrivateShares` validation:

```rust
DkgFailure::MissingPrivateShares(missing_from_signers) => {
    for accused_signer_id in missing_from_signers {
        // Get the reporting signer's key_ids
        let Some(reporter_key_ids) = 
            self.config.public_keys.signer_key_ids.get(signer_id)
        else {
            warn!("No key IDs for reporter {signer_id}");
            malicious_signers.insert(*signer_id);
            continue;
        };
        
        // Get the accused signer's DkgPrivateShares message
        let Some(accused_private_shares) = 
            self.dkg_private_shares.get(accused_signer_id)
        else {
            // Accused signer didn't send any private shares - they are malicious
            warn!("Signer {accused_signer_id} didn't send private shares");
            malicious_signers.insert(*accused_signer_id);
            continue;
        };
        
        // Check if the accused signer included shares for all reporter's key_ids
        let mut is_actually_missing = false;
        for (_src_party_id, key_shares) in &accused_private_shares.shares {
            for reporter_key_id in reporter_key_ids {
                if !key_shares.contains_key(reporter_key_id) {
                    is_actually_missing = true;
                    break;
                }
            }
        }
        
        if is_actually_missing {
            // Reporter was honest - accused signer is malicious
            warn!("Signer {accused_signer_id} actually missing shares for {signer_id}");
            malicious_signers.insert(*accused_signer_id);
        } else {
            // Reporter was lying - reporter is malicious
            warn!("Signer {signer_id} falsely reported missing shares from {accused_signer_id}");
            malicious_signers.insert(*signer_id);
        }
    }
}
```

This validation leverages data the coordinator already possesses to definitively identify the malicious party.

## Proof of Concept

```rust
#[test]
fn test_missing_private_shares_no_attribution() {
    // Setup coordinator and signers for DKG
    let mut rng = rand::thread_rng();
    let num_signers = 10;
    let threshold = 7;
    
    // Create coordinator and signers (setup code omitted for brevity)
    let mut coordinator = create_coordinator(num_signers, threshold);
    let mut signers = create_signers(num_signers, threshold);
    
    // Execute DKG public phase
    coordinator.start_dkg_round();
    for signer in &mut signers {
        let public_shares = signer.dkg_public_begin(&mut rng);
        coordinator.process_message(&public_shares);
    }
    
    // Execute DKG private phase with malicious signer
    coordinator.start_private_shares();
    for (i, signer) in signers.iter_mut().enumerate() {
        let mut private_shares = signer.dkg_private_begin(&mut rng);
        
        // Signer 0 is malicious - selectively omit shares for signer 1's key_ids
        if i == 0 {
            for (_party_id, key_shares) in &mut private_shares.shares {
                // Remove all shares destined for signer 1's key_ids
                let signer_1_key_ids = coordinator.config.public_keys
                    .signer_key_ids.get(&1).unwrap();
                for key_id in signer_1_key_ids {
                    key_shares.remove(key_id);
                }
            }
        }
        
        coordinator.process_message(&private_shares);
    }
    
    // Execute DKG end phase
    let result = coordinator.start_dkg_end();
    for signer in &mut signers {
        let dkg_end = signer.dkg_ended();
        coordinator.process_message(&dkg_end);
    }
    
    // Verify the vulnerability: DKG fails but malicious_signers is empty
    match result {
        Err(Error::DkgFailure { reported_failures, malicious_signers }) => {
            assert!(!reported_failures.is_empty(), "Should have reported failures");
            assert!(malicious_signers.is_empty(), "VULNERABILITY: No malicious signers identified");
            assert!(!coordinator.malicious_dkg_signer_ids.contains(&0), 
                "VULNERABILITY: Attacker not marked malicious for future rounds");
        }
        _ => panic!("Expected DkgFailure"),
    }
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L33-33)
```rust
    config: Config,
```

**File:** src/state_machine/coordinator/fire.rs (L41-41)
```rust
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L534-553)
```rust
            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_private_shares.signer_id) {
                warn!(signer_id = %dkg_private_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let has_received_shares = self
                .dkg_private_shares
                .contains_key(&dkg_private_shares.signer_id);
            if has_received_shares {
                info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_private_shares.signer_id);

            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L768-770)
```rust
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L785-788)
```rust
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L601-608)
```rust
        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
```

**File:** src/state_machine/signer/mod.rs (L926-948)
```rust
        for (party_id, shares) in &self.signer.get_shares() {
            debug!(
                "Signer {} addding dkg private share for party_id {party_id}",
                self.signer_id
            );
            // encrypt each share for the recipient
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
```
