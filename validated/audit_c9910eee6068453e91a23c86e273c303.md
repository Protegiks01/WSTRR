# Audit Report

## Title
DKG Failure Prioritization Masks Malicious Signer Detection

## Summary
The `dkg_ended()` function in the signer state machine uses early returns to report DKG failures in strict priority order, checking `bad_public_shares` before `missing_private_shares`. When both failure conditions exist simultaneously, only the first is reported, allowing malicious signers who withhold private shares to evade detection if coordinated with another malicious signer sending invalid public shares. The coordinator lacks implementation for handling `MissingPrivateShares` failures, preventing identification and exclusion of these malicious participants across DKG rounds.

## Finding Description

The vulnerability exists in the DKG end phase validation logic where multiple independent failure conditions can be detected but only one is reported.

The `dkg_ended()` function collects three types of failures into separate HashSets during validation: [1](#0-0) 

The function then checks for failures in this specific order using early returns: [2](#0-1) 

These failure conditions are populated by independent checks on different signers' messages within the same validation loop: [3](#0-2) 

**Attack Mechanism:**

1. Malicious Signer A sends `DkgPrivateShares` to the coordinator but withholds from honest signers (selective Byzantine delivery)
2. The coordinator receives A's shares and includes A in the `DkgEndBegin.signer_ids` list: [4](#0-3) 

3. Malicious Signer B sends invalid `DkgPublicShares` that fail cryptographic validation
4. Honest signers populate both `missing_private_shares` (with A) and `bad_public_shares` (with B)
5. Due to the early return at line 597, only `BadPublicShares(B)` is reported
6. The coordinator validates and marks B as malicious: [5](#0-4) 

7. However, `MissingPrivateShares` failures have no implementation: [6](#0-5) 

8. Signer A is never marked malicious and remains in the participant set for subsequent DKG rounds

This breaks the security guarantee that malicious signers will be detected and excluded from future protocol rounds. The coordinator loses critical information about which signers failed to provide private shares, allowing persistent disruption through coordinated attacks.

## Impact Explanation

This constitutes a **Medium** severity vulnerability mapping to "transient consensus failures" in the defined scope.

**Specific Harms:**
- Malicious signers withholding private shares can persistently avoid detection across multiple DKG rounds
- Each masked malicious signer extends DKG completion by at least one additional round
- With coordinated adversaries controlling 3 malicious signers in a 10-signer system, DKG could fail 3+ times before all malicious parties are identified
- Causes repeated failed DKG attempts, preventing establishment of a valid group signing key
- All honest participants are blocked from completing DKG and performing threshold signatures

**Who is Affected:**
- All honest signers waiting for DKG completion
- Systems dependent on WSTS for threshold signing operations (e.g., Stacks blockchain signer network)
- End users relying on timely transaction signing

The system eventually recovers when the malicious signer sending bad public shares exhausts their accomplices or gives up, fitting the "transient" classification. However, the delayed convergence prevents normal operation and enables denial-of-service attacks on DKG completion.

## Likelihood Explanation

**High** likelihood in adversarial scenarios.

**Required Attacker Capabilities:**
- Control of at least 2 malicious signer identities within the DKG participant set (within threat model of up to threshold-1 malicious signers)
- Ability to selectively deliver messages (standard Byzantine behavior - a malicious signer implementation can choose message recipients)
- No cryptographic breaks, compromised keys, or social engineering required

**Attack Feasibility:**
The attack is straightforward to execute through normal protocol message flow. WSTS is a library where the application layer handles message routing. A malicious signer implementation can trivially implement selective message delivery by choosing which peers receive each message. This is standard Byzantine adversarial behavior explicitly contemplated in distributed protocols.

**Economic Feasibility:**
Highly feasible - requires only control of multiple signer identities, which is realistic in many deployment scenarios. The attack cost is minimal (just selective message routing) while the disruption impact is significant (blocking DKG completion).

**Detection Difficulty:**
Low detection risk for the attacker. Honest signers report exactly what the code dictates (`BadPublicShares` failure), making the attack indistinguishable from legitimate protocol operation. The coordinator has no visibility into the masked `MissingPrivateShares` condition.

The vulnerability can also trigger non-maliciously through network partitions combined with transmission errors, though malicious exploitation is the primary concern.

## Recommendation

Implement proper handling for `MissingPrivateShares` failures in the coordinator's failure processing logic. The coordinator should:

1. Validate `MissingPrivateShares` claims similar to how `BadPublicShares` is validated
2. Mark signers who failed to provide complete private shares as malicious
3. Exclude them from subsequent DKG rounds

Additionally, modify the signer's `dkg_ended()` function to report ALL detected failures rather than using early returns, or implement a composite failure type that captures multiple simultaneous failure conditions. This ensures the coordinator receives complete information about all misbehaving signers in a single DKG round.

The coordinator should verify that signers in the `MissingPrivateShares` set were expected to provide shares (i.e., they're in `dkg_end_begin.signer_ids`) and that other honest signers confirm the same signers are missing. False accusations should result in marking the accuser as malicious.

Replace lines 768-770 in `src/state_machine/coordinator/fire.rs` with:

```rust
DkgFailure::MissingPrivateShares(missing_signers) => {
    // Verify that the reported signers were expected to provide shares
    for missing_signer_id in missing_signers {
        // Validate the claim by checking our records
        if self.dkg_private_shares.contains_key(missing_signer_id) {
            // We received shares from this signer, reporter is lying
            warn!("Signer {signer_id} reported MissingPrivateShares from {missing_signer_id} but we received shares");
            malicious_signers.insert(*signer_id);
        } else {
            // Confirm this signer was expected to provide shares
            if self.dkg_wait_signer_ids.contains(missing_signer_id) {
                warn!("Multiple signers confirm missing private shares from {missing_signer_id}");
                malicious_signers.insert(*missing_signer_id);
            }
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_dkg_failure_prioritization_masks_detection() {
    use rand_core::OsRng;
    
    // Setup: 4 signers, threshold 3, 2 are malicious
    let mut signers = create_signers(4, 3);
    let mut coordinator = create_coordinator(4, 3);
    
    // Phase 1: Public shares - all signers send valid public shares
    for signer in &mut signers {
        let public_shares = signer.dkg_begin(&mut OsRng).unwrap();
        coordinator.process(&public_shares).unwrap();
        // Broadcast to all signers
        for other in &mut signers {
            other.process(&public_shares, &mut OsRng).unwrap();
        }
    }
    
    // Phase 2: Private shares
    let private_begin = coordinator.start_private_shares().unwrap();
    
    // Malicious Signer 0: Sends private shares ONLY to coordinator, not to other signers
    let signer0_private = signers[0].dkg_private_begin(&private_begin, &mut OsRng).unwrap();
    coordinator.process(&signer0_private).unwrap();
    // DO NOT send to other signers (selective withholding)
    
    // Malicious Signer 1: Sends INVALID public shares to everyone
    signers[1].inject_bad_public_shares(); // Test helper to corrupt public shares
    let signer1_private = signers[1].dkg_private_begin(&private_begin, &mut OsRng).unwrap();
    coordinator.process(&signer1_private).unwrap();
    for other in &mut signers {
        other.process(&signer1_private, &mut OsRng).unwrap();
    }
    
    // Honest signers 2 and 3: Send valid shares to everyone
    for i in 2..4 {
        let private_shares = signers[i].dkg_private_begin(&private_begin, &mut OsRng).unwrap();
        coordinator.process(&private_shares).unwrap();
        for other in &mut signers {
            other.process(&private_shares, &mut OsRng).unwrap();
        }
    }
    
    // Phase 3: DKG End
    let dkg_end_begin = coordinator.start_dkg_end().unwrap();
    
    // Honest signer 2 runs dkg_ended()
    let dkg_end_msg = signers[2].process(&dkg_end_begin, &mut OsRng).unwrap();
    
    // Verify: Honest signer detected BOTH failures but only reports BadPublicShares
    match &dkg_end_msg.msg {
        Message::DkgEnd(dkg_end) => {
            match &dkg_end.status {
                DkgStatus::Failure(DkgFailure::BadPublicShares(bad_signers)) => {
                    assert!(bad_signers.contains(&1)); // Signer 1 reported
                    // Signer 0's missing private shares are NOT reported!
                }
                _ => panic!("Expected BadPublicShares failure"),
            }
        }
        _ => panic!("Expected DkgEnd message"),
    }
    
    // Verify: Coordinator only marks Signer 1 as malicious
    coordinator.process(&dkg_end_msg).unwrap_err(); // DKG fails
    assert!(coordinator.is_malicious(1)); // Signer 1 marked malicious
    assert!(!coordinator.is_malicious(0)); // Signer 0 NOT marked - VULNERABILITY
    
    // Next round: Signer 0 can repeat the attack with a new accomplice
}
```

This test demonstrates that when both `bad_public_shares` and `missing_private_shares` failures exist, only the `bad_public_shares` failure is reported, allowing Signer 0 to evade detection while Signer 1 is correctly identified and marked as malicious.

### Citations

**File:** src/state_machine/signer/mod.rs (L514-516)
```rust
        let mut missing_public_shares = HashSet::new();
        let mut missing_private_shares = HashSet::new();
        let mut bad_public_shares = HashSet::new();
```

**File:** src/state_machine/signer/mod.rs (L551-583)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L585-609)
```rust
        if !missing_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPublicShares(missing_public_shares)),
            }));
        }

        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }

        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L768-770)
```rust
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```
