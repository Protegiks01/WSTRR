[
  "[File: src/net.rs] [Struct: DkgPrivateShares] [Shares Invariant - High] Must shares vector have one entry per src_party_id, matching the comms structure?",
  "[File: src/net.rs] [Struct: NonceResponse] [Invariant - Critical] Must key_ids.len() == nonces.len() always hold, and is this validated?",
  "[File: src/net.rs] [Struct: SignatureShareResponse] [Invariant - Critical] Must signature_shares.len() match the signer's key count, and is this checked?",
  "[File: src/net.rs] [Function: Signable::sign()] [Error Handling - Medium] Is the Err(e) from ecdsa::Signature::new() properly propagated and handled by callers?",
  "[File: src/net.rs] [Function: Signable::verify()] [Error vs False - Medium] Does returning false on ecdsa::Signature::try_from() error (line 41) properly distinguish between invalid signature and parsing error?",
  "[File: src/net.rs] [Function: Packet::verify()] [Warn vs Reject - Medium] Do warn!() calls indicate the function will return false, or could some paths continue after warning?",
  "[File: src/net.rs] [All Structs] [Stack Overflow - Low] Can deeply nested structures cause stack overflow during deserialization?",
  "[File: src/net.rs] [All Vec Fields] [Heap Exhaustion - Medium] Can unbounded Vec growth cause heap exhaustion attacks?",
  "[File: src/net.rs] [Function: Packet::verify()] [Timing Leak - Medium] Does early return on signer ID lookup leak timing information about valid vs invalid IDs?",
  "[File: src/net.rs] [Function: Signable::verify()] [Timing Leak - Medium] Does signature verification have constant-time properties or can timing distinguish valid/invalid signatures?",
  "[File: src/net.rs] [Function: DkgPrivateShares::hash()] [Sort Attack - High] Could a malicious party craft dst_ids that, when sorted (line 210), produce a collision with another party's message?",
  "[File: src/net.rs] [Function: NonceResponse::hash()] [Point Order - Medium] Are points D and E hashed in consistent order (line 362-363), or could swapping them produce same hash?",
  "[File: src/net.rs] [Function: SignatureShareResponse::hash()] [Share Order -\n\n### Citations\n\n**File:** src/net.rs (L1-973)\n```rust\nuse std::fmt::Debug;\n\nuse hashbrown::{HashMap, HashSet};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse tracing::warn;\n\nuse crate::{\n    common::{MerkleRoot, PolyCommitment, PublicNonce, SignatureShare, TupleProof},\n    curve::{ecdsa, point::Point, scalar::Scalar},\n    state_machine::PublicKeys,\n};\n\n/// Trait to encapsulate sign/verify, users only need to impl hash\npub trait Signable {\n    /// Hash this object in a consistent way so it can be signed/verified\n    fn hash(&self, hasher: &mut Sha256);\n\n    /// Sign a hash of this object using the passed private key\n    fn sign(&self, private_key: &Scalar) -> Result<Vec<u8>, ecdsa::Error> {\n        let mut hasher = Sha256::new();\n\n        self.hash(&mut hasher);\n\n        let hash = hasher.finalize();\n        match ecdsa::Signature::new(hash.as_slice(), private_key) {\n            Ok(sig) => Ok(sig.to_bytes().to_vec()),\n            Err(e) => Err(e),\n        }\n    }\n\n    /// Verify a hash of this object using the passed public key\n    fn verify(&self, signature: &[u8], public_key: &ecdsa::PublicKey) -> bool {\n        let mut hasher = Sha256::new();\n\n        self.hash(&mut hasher);\n\n        let hash = hasher.finalize();\n        let sig = match ecdsa::Signature::try_from(signature) {\n            Ok(sig) => sig,\n            Err(_) => return false,\n        };\n\n        sig.verify(hash.as_slice(), public_key)\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// A bad private share\npub struct BadPrivateShare {\n    /// the DH shared key between these participants\n    pub shared_key: Point,\n    /// prooof that the shared key is a valid DH tuple as per chaum-pedersen\n    pub tuple_proof: TupleProof,\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// Final DKG status after receiving public and private shares\npub enum DkgFailure {\n    /// DKG threshold not met\n    Threshold,\n    /// Signer was in the wrong internal state to complete DKG\n    BadState,\n    /// DKG public shares were missing from these signer_ids\n    MissingPublicShares(HashSet<u32>),\n    /// DKG public shares were bad from these signer_ids\n    BadPublicShares(HashSet<u32>),\n    /// DKG private shares were missing from these signer_ids\n    MissingPrivateShares(HashSet<u32>),\n    /// DKG private shares were bad from these signer_ids\n    BadPrivateShares(HashMap<u32, BadPrivateShare>),\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// Final DKG status after receiving public and private shares\npub enum DkgStatus {\n    /// DKG completed successfully\n    Success,\n    /// DKG failed\n    Failure(DkgFailure),\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// Encapsulation of all possible network message types\npub enum Message {\n    /// Tell signers to begin DKG by sending DKG public shares\n    DkgBegin(DkgBegin),\n    /// Send DKG public shares\n    DkgPublicShares(DkgPublicShares),\n    /// Tell signers to send DKG private shares\n    DkgPrivateBegin(DkgPrivateBegin),\n    /// Send DKG private shares\n    DkgPrivateShares(DkgPrivateShares),\n    /// Tell signers to compute shares and send DKG end\n    DkgEndBegin(DkgEndBegin),\n    /// Tell coordinator that DKG is complete\n    DkgEnd(DkgEnd),\n    /// Tell signers to send signing nonces\n    NonceRequest(NonceRequest),\n    /// Tell coordinator signing nonces\n    NonceResponse(NonceResponse),\n    /// Tell signers to construct signature shares\n    SignatureShareRequest(SignatureShareRequest),\n    /// Tell coordinator signature shares\n    SignatureShareResponse(SignatureShareResponse),\n}\n\nimpl Signable for Message {\n    fn hash(&self, hasher: &mut Sha256) {\n        match self {\n            Message::DkgBegin(msg) => msg.hash(hasher),\n            Message::DkgPublicShares(msg) => msg.hash(hasher),\n            Message::DkgPrivateBegin(msg) => msg.hash(hasher),\n            Message::DkgPrivateShares(msg) => msg.hash(hasher),\n            Message::DkgEndBegin(msg) => msg.hash(hasher),\n            Message::DkgEnd(msg) => msg.hash(hasher),\n            Message::NonceRequest(msg) => msg.hash(hasher),\n            Message::NonceResponse(msg) => msg.hash(hasher),\n            Message::SignatureShareRequest(msg) => msg.hash(hasher),\n            Message::SignatureShareResponse(msg) => msg.hash(hasher),\n        }\n    }\n}\n\n#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]\n/// DKG begin message from coordinator to signers\npub struct DkgBegin {\n    /// DKG round ID\n    pub dkg_id: u64,\n}\n\nimpl Signable for DkgBegin {\n    fn hash(&self, hasher: &mut Sha256) {\n        hasher.update("
]