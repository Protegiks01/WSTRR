[
  "[File: src/util.rs] [Function: expand_to_scalar()] [Critical - Domain Separation Bypass] Can an attacker cause domain separation collisions by crafting msg/dst combinations where the concatenation of [msg]+[dst] produces identical input to ExpandMsgXmd, allowing cross-protocol attacks between DKG and signing operations?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [Critical - Zero Scalar Generation] Does expand_to_scalar() check if the resulting Scalar::from(buf) produces a zero scalar, which if used as a private key or nonce in DKG/signing would compromise the entire protocol?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [High - DST Length Validation] Can an attacker bypass the 255-byte DST length limit by exploiting the error handling in line 32, potentially causing the function to accept oversized DST values that violate hash-to-curve specifications?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [Critical - Modular Reduction Bypass] Does Scalar::from(buf) at line 33 correctly perform modular reduction of the 32-byte buffer modulo the curve order, or could certain 256-bit values produce invalid scalars outside the field?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [High - Empty Message Handling] What happens if msg is empty (&[])? Does this produce a deterministic scalar that could be predicted and exploited in nonce generation or DKG share derivation?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [Medium - DST Reuse Across Contexts] Are there checks preventing the same DST from being reused across different protocol contexts (DKG vs signing vs key tweaking), which could enable replay attacks or cross-context forgeries?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [High - Buffer Size Assumption] The 32-byte buffer size in line 30 assumes this is sufficient for Scalar::from() - what if the underlying curve requires different field element sizes, could this truncate or pad incorrectly?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [Critical - Nonce Derivation] If this function is used for nonce generation in signing, does it ensure that msg contains sufficient entropy and context binding to prevent nonce reuse across different signing rounds?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [Medium - Error Propagation] Does the Result type properly propagate EllipticCurveError, or could callers silently unwrap() this and cause panics on attacker-controlled DST lengths?",
  "[File: src/util.rs] [Function: expand_to_scalar()] [High - Deterministic Expansion] Since ExpandMsgXmd is deterministic, if an attacker learns the msg/dst pair used for private share encryption keys, can they derive the same key and decrypt DKG shares?",
  "[File: src/util.rs] [Function: hash_to_scalar()] [Critical - Zero Hash Collision] Does hash_to_scalar() check if the SHA256 digest produces all zeros (though astronomically unlikely), which when converted to a scalar could compromise cryptographic operations?",
  "[File: src/util.rs] [Function: hash_to_scalar()] [High - Hasher Clone Side Effects] Line 39 clones the hasher before finalization - does this preserve all internal state correctly, or could incremental hashing with update() calls before hash_to_scalar() lead to inconsistent results?",
  "[File: src/util.rs] [Function: hash_to_scalar()] [Medium - Modular Reduction] Does Scalar::from(hash_bytes) at line 44 perform correct modular reduction mod curve order, and what happens if the 256-bit hash value equals or exceeds the curve order?",
  "[File: src/util.rs] [Function: hash_to_scalar()] [High - Binding Value Computation] If this function is used to compute binding values in FROST signing, does it ensure the hasher contains all required nonces and the message before being called?",
  "[File: src/util.rs] [Function: hash_to_scalar()] [Low - Dead Code] The function is marked #[allow(dead_code)] at line 36 - if it's unused, why does it exist, and could its presence indicate incomplete protocol implementations that might be exploitable?",
  "[File: src/util.rs] [Function: hash_to_scalar()] [Medium - Incremental Hashing State] Can an attacker manipulate the order of hasher.update() calls before hash_to_scalar() to produce predictable scalars that enable signature forgery?",
  "[File: src/util.rs] [Function: hash_to_scalar()] [High - No Domain Separation] Unlike expand_to_scalar(), this function has no explicit domain separation tag - can this cause hash collisions between different protocol operations using the same input data?",
  "[File: src/util.rs] [Function: hash_to_scalar()] [Medium - Clone Performance] Does cloning the hasher at line 39 have timing implications that could leak information about the hash state in a side-channel attack?",
  "[File: src/util.rs] [Critical - Point at Infinity] Does make_shared_secret() check if public_key is the point at infinity (identity element)? If not, the resulting shared_key would also be infinity, producing a predictable shared secret that breaks encryption security.",
  "[File: src/util.rs] [Critical - Low Order Points] Can an attacker supply a low-order public_key that generates a small subgroup element, allowing them to brute-force the shared secret from a limited set of possibilities (small subgroup attack)?",
  "[File: src/util.rs] [Critical - Invalid Point Validation] Before the scalar multiplication at line 49, is there validation that public_key is a valid curve point? Invalid points could cause undefined behavior or leak the private_key through fault attacks.",
  "[File: src/util.rs] [High - Private Key Zero] What happens if private_key is the zero scalar? The multiplication would produce the point at infinity regardless of public_key, creating a predictable shared secret of all zeros after KDF.",
  "[File: src/util.rs] [Critical - Key Compromise via DH Oracle] If an attacker can repeatedly call make_shared_secret() with chosen public keys and observe shared secret outcomes, can they gradually leak bits of private_key through timing or error analysis?",
  "[File: src/util.rs] [High - DH Key Reuse] Does the protocol ensure private_key is ephemeral and never reused across multiple DH operations? Key reuse could enable correlation attacks linking multiple encrypted DKG shares.",
  "[File: src/util.rs] [Medium - Timing Side Channel] Does the scalar multiplication at line 49 use constant-time operations, or could the execution time vary based on private_key bit patterns, leaking the key through timing attacks?"
]