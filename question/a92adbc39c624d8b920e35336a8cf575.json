[
  "[File: src/v1.rs] [Function: Party::get_poly_commitment()] [Commitment Length] The poly vector length should equal threshold - if it doesn't match, could this cause aggregation to fail or produce wrong group key? (High)",
  "[File: src/v1.rs] [Function: Party::get_poly_commitment()] [Constant Term] The constant term poly.data()[0] is used for ID proof - if this is zero, does it create any security issues? (Medium)",
  "[File: src/v1.rs] [Function: Party::get_poly_commitment()] [ID Uniqueness] Multiple parties with the same ID but different polynomials would produce different ID proofs - is this checked during DKG? (High)",
  "[File: src/v1.rs] [Function: Party::reset_poly()] [Nonce Invalidation] When the polynomial is reset, should the nonce also be cleared since it was tied to the old polynomial? (Medium)",
  "[File: src/v1.rs] [Function: Party::get_shares()] [Polynomial Evaluation] Does poly.eval() handle the scalar input correctly for all key IDs, or could specific IDs cause evaluation errors? (Medium)",
  "[File: src/v1.rs] [Function: Party::get_poly_commitment()] [RNG in Commitment] The Schnorr ID proof generation uses rng - if this RNG is not cryptographically secure, can the proof be forged or replayed? (Critical)",
  "[File: src/v1.rs] [Function: Party::get_shares()] [Share Overwrite] If get_shares() is called multiple times, are fresh shares computed each time, or could cached shares be reused inappropriately? (Medium)",
  "[File: src/v1.rs] [Function: Party::get_poly_commitment()] [Map Collection] The commitment is created by mapping over poly coefficients - if map() produces duplicates or wrong ordering, will this be detected? (Medium)",
  "[File: src/v1.rs] [Function: Party::clear_poly()] [Partial State] After clear_poly(), the party retains private_key and group_key but has no polynomial - is this a valid state for any operations? (Low)",
  "[File: src/v1.rs] [Function: Party::get_shares()] [Scalar Zero] If a computed share evaluates to Scalar::zero(), is this a security issue or just an extremely unlikely event that should be rejected? (Medium)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Share Validation Order] Public shares are checked before private shares - could an attacker exploit this ordering to cause honest parties to accept bad private shares from good public commitments? (High)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Bad Public Shares] If check_public_shares() fails, the party is added to bad_ids but group_key doesn't include that party's poly[0] - could partial group key computation lead to inconsistent keys? (Critical)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Threshold Conversion] threshold is converted to usize with try_into() - what happens if threshold > usize::MAX on 32-bit systems? (Low)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Missing Shares Error] If private shares are missing, the error lists (self.id, missing_party_id) - but does this check happen before or after bad public shares are detected? (Medium)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Share Verification Bypass] The comment mentions batch verification bypass attacks requiring random scalars - is the current per-share verification secure, or is it vulnerable? (Critical)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Private Share Check] Each private share s is checked against poly with s*G == compute::poly() - if compute::poly() has a bug, could bad shares be accepted? (Critical)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Bad Share Handling] If a private share fails verification, it's added to bad_shares but processing continues - could this allow partial secret computation with some bad shares? (High)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Group Key Aggregation] group_key is computed as sum of all valid poly[0] values - if a single party is excluded due to bad shares, will all parties compute the same group key? (Critical)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Private Key Summation] private_key is the sum of all private share values - if any share is from a malicious party with a malformed polynomial, can this compromise the key? (Critical)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Public Key Computation] public_key is computed as private_key * G after summation - is there any verification that this matches the expected value from commitments? (High)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Zero Reset] The function starts by setting private_key and group_key to zero - could calling compute_secret() multiple times overwrite valid keys with invalid ones? (High)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Context Validation] The ctx parameter is passed to check_public_shares() - if different parties use different contexts, will they detect inconsistency? (High)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Error Early Return] If bad public shares are found, the function returns early - but group_key has already been partially computed. Could this leave inconsistent state? (Medium)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Share Correspondence] The function checks that each public_shares key has a corresponding private_shares entry - but what if private_shares contains extra entries not in public_shares? (Medium)",
  "[File: src/v1.rs] [Function: Party::compute_secret()] [Warn on Missing Share] Line 197 has a warn!() if a share can't be checked - but this should have been caught earlier. Could this indicate a race condition or logic bug? (Medium)"
]