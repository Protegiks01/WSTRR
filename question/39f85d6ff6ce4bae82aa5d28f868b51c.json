[
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign()] [High: Nonce Validation] Does sign() verify that nonces array length matches key_ids length and all nonces are non-zero?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign()] [High: Share Count] Does sign() validate that sig_shares length is at least threshold and at most num_keys?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign()] [Medium: Message Binding] Does sign() ensure the message is bound into challenge computation, preventing signature reuse across messages?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign()] [Medium: Nonce Aggregation] Does sign() aggregate nonces using binding values correctly before challenge computation?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_schnorr()] [Critical: BIP-340 Verification] Does sign_schnorr() verify the aggregated signature using BIP-340 verification rules with even-Y R?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_schnorr()] [Critical: Parity Handling] Does sign_schnorr() handle R parity correctly when verifying signature shares, negating shares if needed?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_schnorr()] [Critical: Public Key Parity] Does sign_schnorr() use the even-Y version of the group public key for BIP-340 challenge computation?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_schnorr()] [Critical: X-Only Public Key] Does sign_schnorr() use only the x-coordinate of the public key in challenge computation per BIP-340?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_schnorr()] [High: Tagged Hash] Does sign_schnorr() use BIP-340 tagged hash for challenge computation with the correct tag?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_schnorr()] [High: Proof Format] Does sign_schnorr() return a SchnorrProof with correct r (x-coordinate) and s values per BIP-340?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_schnorr()] [Medium: Share Validation] Does sign_schnorr() perform the same signature share validation as sign() before aggregation?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_taproot()] [Critical: Tweak Computation] Does sign_taproot() compute the taproot tweak correctly using the group public key and merkle_root?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_taproot()] [Critical: Tweaked Key Verification] Does sign_taproot() verify signature shares against the tweaked public key, not the original group key?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_taproot()] [Critical: Parity Consistency] Does sign_taproot() apply parity adjustments consistently between tweak computation and signature verification?",
  "[File: src/traits.rs] [Trait: Aggregator] [Function: sign_taproot()] [Critical: Merkle Root None] When merkle_root is None, does sign_taproot() still apply the correct BIP-341 key-only spend tweak?",
  "[File: src/traits\n\n### Citations\n\n**File:** src/traits.rs (L1-404)\n```rust\nuse core::{cmp::PartialEq, fmt::Debug};\nuse hashbrown::{HashMap, HashSet};\nuse polynomial::Polynomial;\nuse rand_core::{CryptoRng, RngCore};\nuse serde::{Deserialize, Serialize};\nuse std::fmt;\n\nuse crate::{\n    common::{MerkleRoot, Nonce, PolyCommitment, PublicNonce, Signature, SignatureShare},\n    curve::{point::Point, scalar::Scalar},\n    errors::{AggregatorError, DkgError},\n    taproot::SchnorrProof,\n};\n\n#[derive(Clone, Deserialize, Serialize, PartialEq)]\n/// The saved state required to reconstruct a party\npub struct PartyState {\n    /// The party's private polynomial\n    pub polynomial: Option<Polynomial<Scalar>>,\n    /// The key IDS and associate private keys for this party\n    pub private_keys: Vec<(u32, Scalar)>,\n    /// The nonce being used by this party\n    pub nonce: Nonce,\n}\n\nimpl fmt::Debug for PartyState {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        f.debug_struct("
]