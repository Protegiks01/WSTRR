[
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [State Machine Bypass - Critical] Can an attacker exploit race conditions between timeout processing and message processing to cause state machine desynchronization, allowing invalid state transitions or bypassing DKG/signing validation checks?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [Threshold Bypass - Critical] In DkgPublicGather timeout handling (lines 78-102), when dkg_threshold is met but not all signers responded, could an attacker manipulate the timeout to exclude honest signers and include only compromised ones, effectively controlling which subset participates in DKG?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [DoS - Medium] Can an attacker cause repeated timeout cycles by carefully timing message delivery to trigger the timeout path at lines 80-99, forcing continuous DKG restarts and preventing protocol progress?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [Integer Overflow - Medium] In compute_dkg_public_size() call at line 82, could a malicious signer provide key_ids that cause integer overflow when summing key counts, bypassing the dkg_threshold check?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [State Confusion - High] When timeout occurs in DkgPrivateGather (lines 106-130) and threshold is met, the coordinator continues without all expected signers - can this cause inconsistent party_polynomials state between coordinator and signers?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [Malicious Signer Tracking - High] In SigShareGather timeout (lines 174-207), all waiting signers are marked malicious (lines 178-186) - can an attacker DoS honest signers to get them marked malicious, then control the remaining signer set below threshold?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [Threshold Calculation - Critical] At lines 188-200, num_malicious_keys is computed and checked against threshold - could precision loss in key ID counting allow a malicious coordinator to incorrectly calculate remaining capacity?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [State Transition - High] When sign timeout occurs (line 202), the state moves back to NonceRequest - can this create an infinite loop where malicious signers repeatedly timeout to prevent signature completion?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [DKG End Timeout - High] DkgEndGather timeout (lines 134-145) has no threshold check - can an attacker exploit this to force DKG abortion even when threshold participants are available?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_timeout()] [Nonce Timeout - High] NonceGather timeout (lines 149-171) collects malicious_signer_ids but doesn't verify if remaining signers meet threshold before reporting timeout - can this cause false negatives?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [Signature Verification Bypass - Critical] Packet signature verification (lines 218-225) only occurs if config.verify_packet_sigs is true - can attackers forge packets if this configuration is disabled, compromising all protocol security?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [State Machine Loop - Medium] The function uses an infinite loop (line 226) - can malicious state transitions cause infinite looping, consuming resources or creating DoS conditions?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [Round ID Replay - High] In Idle state (lines 228-252), DkgBegin and NonceRequest with matching current IDs are ignored - but could an attacker replay old valid packets with future round IDs to prematurely advance the coordinator state?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [Sign Iteration Wraparound - High] At line 243, sign_iter_id uses wrapping_sub(1) - can this wraparound behavior be exploited when sign_iter_id is 0, creating inconsistent iteration tracking?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [DKG Failure Handling - High] At lines 281-296, DkgFailure errors are extracted and returned, but the coordinator state may be corrupted - can this leave the coordinator in an inconsistent state requiring reset?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [Missing Aggregate Key - Critical] Lines 302-309 return DKG result only if aggregate_public_key exists - but what if gather_dkg_end succeeded without properly setting this key, allowing signing without valid DKG?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [Signature Type Confusion - High] In SigShareGather state (lines 327-389), signature vs schnorr_proof handling depends on signature_type - can type confusion cause wrong proof type to be returned, breaking verification?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [Taproot/Schnorr Proof Missing - Medium] Lines 339-355 and 356-372 check for missing schnorr_proof - but gather_sig_shares may succeed without setting it, can this cause silent failures?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [Error Wrapping - Medium] At lines 328-332, gather_sig_shares errors are wrapped in SignError::Coordinator - does this mask critical errors that should abort the protocol?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: process_message()] [State Loop Logic - Medium] Multiple states check 'if self.state == State::X' after gather functions - can race conditions between state changes and these checks cause incorrect flow control?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_public_shares()] [Data Clearing - High] Lines 397-398 clear dkg_public_shares and party_polynomials unconditionally - can an attacker trigger this mid-DKG to erase valid state and force restart with different participants?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_public_shares()] [Signer Set Initialization - Critical] Line 399 initializes dkg_wait_signer_ids with range 0..num_signers - can this be exploited if num_signers is manipulated or doesn't match actual available signers?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_public_shares()] [Message Signing Panic - High] Line 409 uses expect() on signing failure - can an attacker trigger conditions that cause signing to fail, panicking the coordinator and causing DoS?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_public_shares()] [State Transition - Medium] Line 414 moves to DkgPublicGather before sending packet - can failure to send the packet leave coordinator in waiting state with no incoming messages?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_public_shares()] [Timestamp Recording - Low] Line 415 records start time - is this timestamp trusted? Can clock skew or manipulation affect timeout calculations?"
]