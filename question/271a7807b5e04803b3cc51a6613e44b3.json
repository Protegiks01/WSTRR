[
  "[File: src/v1.rs] [Function: Party::new()] [Threshold Bypass] Can an attacker create a Party with threshold t=0 or t>n, bypassing the minimum threshold requirement and allowing signature generation with no keys? (Critical)",
  "[File: src/v1.rs] [Function: Party::new()] [Integer Overflow] Does VSS::random_poly(t-1) panic or produce incorrect polynomial degree when t=0, causing underflow in the degree calculation? (High)",
  "[File: src/v1.rs] [Function: Party::new()] [Key Compromise] Are private_key and public_key initialized to zero, meaning a freshly created Party has no secret before DKG - could this be exploited if sign() is called prematurely? (Medium)",
  "[File: src/v1.rs] [Function: Party::new()] [State Inconsistency] Can multiple Parties be created with the same ID but different parameters (n, t), leading to incompatible DKG or signature shares? (High)",
  "[File: src/v1.rs] [Function: Party::new()] [Nonce Reuse] Is the nonce initialized to Nonce::zero() - could a sign operation occur before gen_nonce() is called, leading to nonce reuse across multiple signatures? (Critical)",
  "[File: src/v1.rs] [Function: Party::load()] [Assertion Failure] The function asserts state.private_keys.len()==1 and state.private_keys[0].0==id - can an attacker craft a state with wrong length or ID to panic the application? (Medium)",
  "[File: src/v1.rs] [Function: Party::load()] [Key ID Mismatch] If state.private_keys[0].0 != id, the assertion panics - should this be a Result instead to avoid DoS on deserialization of untrusted state? (Medium)",
  "[File: src/v1.rs] [Function: Party::load()] [State Poisoning] Can an attacker provide a state with inconsistent group_key and private_key, where private_key * G != public_key component in the group key? (High)",
  "[File: src/v1.rs] [Function: Party::load()] [Polynomial Validation] The polynomial is loaded directly from state without validation - could an attacker supply a polynomial of incorrect degree (not t-1)? (High)",
  "[File: src/v1.rs] [Function: Party::load()] [Nonce State] The nonce is restored from saved state - if this is from a previous signing round, could this lead to catastrophic nonce reuse when signing a different message? (Critical)",
  "[File: src/v1.rs] [Function: Party::save()] [State Exposure] Does save() expose sensitive data (private_key, polynomial, nonce) - what happens if this state is logged, transmitted insecurely, or stored without encryption? (High)",
  "[File: src/v1.rs] [Function: Party::save()] [Missing Validation] The save() function returns state without validating consistency - could this allow saving and later loading an invalid party state? (Medium)",
  "[File: src/v1.rs] [Struct: Party] [Field Visibility] The private_key field is private but group_key is public - can an attacker infer information about private_key from observing group_key changes during DKG? (Low)",
  "[File: src/v1.rs] [Struct: Party] [Optional Polynomial] The polynomial f is Option<Polynomial<Scalar>> - are all code paths correctly handling the None case, or can unwrap() be triggered on untrusted inputs? (Medium)",
  "[File: src/v1.rs] [Function: Party::new()] [RNG Bias] If the RNG provided has low entropy or is predictable, can an attacker predict the polynomial coefficients and therefore the private key shares? (Critical)",
  "[File: src/v1.rs] [Function: Party::load()] [Integer Conversion] Parameters n and t are u32 - are there any conversions to usize or other types that could truncate on 16-bit platforms? (Low)",
  "[File: src/v1.rs] [Function: Party::new()] [Threshold Edge Case] What happens if t=1 (1-of-n threshold) - does the polynomial become constant, and does this create any security issues with share distribution? (Medium)",
  "[File: src/v1.rs] [Function: Party::new()] [Maximum Keys] Is there a maximum limit on num_keys? Can setting n to u32::MAX cause memory exhaustion when computing shares for all key IDs? (Medium)",
  "[File: src/v1.rs] [Function: Party::new()] [ID Validation] Is party ID validated to be in range 1..=n? Can ID=0 or ID>n cause issues with Lagrange interpolation or polynomial evaluation? (High)",
  "[File: src/v1.rs] [Struct: Party] [Zero Key] If private_key remains zero (never computed), can the party still generate valid-looking signature shares that will cause aggregation to fail? (Medium)",
  "[File: src/v1.rs] [Function: Party::gen_nonce()] [Nonce Reuse] Can gen_nonce() be called multiple times with the same secret_key before signing, and if so, does this create any correlation between nonces across different messages? (Critical)",
  "[File: src/v1.rs] [Function: Party::gen_nonce()] [Secret Key Parameter] The function takes a secret_key parameter separate from self.private_key - what is this secret_key, and could using the wrong key compromise the nonce? (High)",
  "[File: src/v1.rs] [Function: Party::gen_nonce()] [RNG State] If the RNG state is reused across multiple gen_nonce() calls without proper reseeding, can nonces become predictable? (Critical)",
  "[File: src/v1.rs] [Function: Party::gen_nonce()] [Nonce Storage] The generated nonce is stored in self.nonce and overwrites any previous value - could this lead to race conditions in concurrent signing? (High)",
  "[File: src/v1.rs] [Function: Party::gen_nonce()] [Return vs Storage] The function both stores the nonce internally AND returns a public version - could this lead to using mismatched nonces if the public nonce is used elsewhere? (Medium)"
]