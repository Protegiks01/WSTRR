[
  "[File: src/util.rs] [High - Shared Key Point Validation] After computing shared_key = private_key * public_key, is there validation that shared_key is not the identity before passing to make_shared_secret_from_key()?",
  "[File: src/util.rs] [Critical - Cross-Protocol DH] Can an attacker reuse the same public_key from DKG share encryption in a signing round to correlate encrypted data across protocol phases, compromising key isolation?",
  "[File: src/util.rs] [Medium - Point Compression in KDF] The shared_key is compressed at line 57 before KDF - does compression preserve all necessary entropy, or could two different shared_key points compress to the same bytes due to Y-coordinate loss?",
  "[File: src/util.rs] [Function: make_shared_secret_from_key()] [High - Point Compression Collisions] At line 57, shared_key.compress() produces x-coordinate only - can an attacker find two different shared keys (differing only in Y-coordinate parity) that produce identical shared secrets?",
  "[File: src/util.rs] [Function: make_shared_secret_from_key()] [Medium - Domain String Hardcoded] The domain string 'DH_SHARED_SECRET_KEY/' at line 58 is hardcoded - is this string unique across all WSTS operations, or could it collide with domain strings in other components causing key reuse?",
  "[File: src/util.rs] [Function: make_shared_secret_from_key()] [High - KDF Context Binding] Does the domain string 'DH_SHARED_SECRET_KEY/' include any context about DKG round ID, party ID, or other binding information to prevent key confusion attacks?",
  "[File: src/util.rs] [Function: make_shared_secret_from_key()] [Low - Trailing Slash Significance] Why does the domain string end with '/' at line 58? Could removing or modifying this character enable collision with other domain strings elsewhere in the codebase?",
  "[File: src/util.rs] [Function: make_shared_secret_from_key()] [Medium - Compressed Bytes Validation] Does compress().as_bytes() guarantee a fixed 32-byte output, or could certain invalid points produce shorter outputs that truncate the KDF input?",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [Critical - Counter Fixed to One] The counter is hardcoded to 1 at line 66 - ANSI X9.63 KDF is designed to derive multiple keys by incrementing the counter, but this implementation only derives one key block. Can this limit enable key exhaustion or related-key attacks?",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [High - Single Block Output] Line 66 sets counter=1 and never increments it - this limits output to 32 bytes (one SHA256 block). What if WSTS needs longer derived keys in the future? Could this cause truncation vulnerabilities?",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [Medium - Endianness Dependency] The counter is converted to big-endian at line 69 - is this consistent with the ANSI X9.63 specification? Endianness mismatches could cause key derivation incompatibilities.",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [High - Empty shared_key] What happens if shared_key is an empty slice? The KDF would derive a key from only the counter and shared_info, making it independent of the DH secret and predictable.",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [High - Empty shared_info] Can shared_info be empty, and if so, does this reduce the domain separation between different derived keys, enabling cross-context attacks?",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [Medium - Hash Input Ordering] The hash input order is shared_key, counter, shared_info (lines 68-70) - is this the exact order specified by ANSI X9.63, or could misordering cause incompatibility or security issues?",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [Low - No Output Length Parameter] Unlike standard X9.63 KDF which takes a requested output length, this function hardcodes 32 bytes - does this match all WSTS key length requirements?",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [High - shared_info Not Context-Bound] Is shared_info always unique per encryption context? If multiple DKG shares use the same shared_info, they'd derive identical encryption keys from different DH secrets, breaking confidentiality.",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [Medium - Integer Overflow] If counter were ever incremented beyond u32::MAX, would it wrap to zero? Though unlikely with counter=1, this could cause key repetition in multi-block scenarios.",
  "[File: src/util.rs] [Function: ansi_x963_derive_key()] [Low - Clone vs Finalize] Line 72 calls finalize() directly without cloning - is there any scenario where the hasher needs to be reused, or is this always the terminal operation?",
  "[File: src/util.rs] [Function: encrypt()] [Critical - Nonce Randomness] Line 87 uses rng.fill_bytes() to generate the nonce - if the RNG is weak, predictable, or seeded incorrectly, can an attacker predict nonces and break AES-GCM security through nonce reuse?",
  "[File: src/util.rs] [Function: encrypt()] [Critical - Nonce Reuse Vulnerability] AES-GCM security catastrophically fails if the same key+nonce pair is ever reused. Does WSTS ensure each encryption operation uses a unique nonce, even across multiple DKG rounds or signing sessions?",
  "[File: src/util.rs] [Function: encrypt()] [High - RNG Failure Handling] What happens if rng.fill_bytes() fails or produces low-entropy output at line 87? There's no error checking before using nonce_bytes for encryption.",
  "[File: src/util.rs] [Function: encrypt()] [Critical - Key Derivation Security] The key parameter is passed directly from make_shared_secret() - if the DH shared secret is weak or predictable, the encryption is completely broken. Is there validation that key has sufficient entropy?",
  "[File: src/util.rs] [Function: encrypt()] [High - Empty Plaintext] Can data be empty at line 92? AES-GCM can encrypt empty plaintexts, but this might leak that a DKG share is zero or missing, providing oracle information to attackers.",
  "[File: src/util.rs] [Function: encrypt()] [Medium - Large Plaintext DoS] Is there a size limit on data? Extremely large plaintexts could cause DoS through memory exhaustion or slow encryption times when processing DKG shares.",
  "[File: src/util.rs] [Function: encrypt()] [High - Nonce Exposure] The nonce is prepended to the ciphertext at lines 95-96 - while this is standard, does WSTS documentation make clear that anyone intercepting encrypted DKG shares can see all nonces, enabling pattern analysis?"
]