[
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_private_shares()] [Signer Set Reduction - Critical] Lines 422-426 restrict dkg_wait_signer_ids to only those who sent DkgPublicShares - can an attacker who compromised some signers intentionally skip public shares to be excluded from private share phase?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_private_shares()] [Empty Key IDs - High] Line 435 sends empty key_ids vec - is this intentional? Could signers misinterpret this as no keys needed, skipping private share generation?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_private_shares()] [Signer ID Collection - Medium] Line 434 collects signer_ids from dkg_public_shares keys - can duplicate handling or ordering issues cause problems if map iteration order is non-deterministic?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_private_shares()] [Message Signing Panic - High] Line 439 uses expect() on DkgPrivateBegin signing - same panic risk as start_public_shares()?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_dkg_end()] [Signer Set Reduction - Critical] Lines 451-455 restrict wait set to dkg_private_shares senders only - can a malicious signer participate in public shares but skip private shares to avoid DkgEnd validation?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_dkg_end()] [Empty Key IDs - High] Line 464 sends empty key_ids - if this is a bug, could it cause signers to fail DKG validation or produce inconsistent shares?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: start_dkg_end()] [Message Signing Panic - High] Line 468 expects DkgEndBegin signing to succeed - can controlled failure cause coordinator panic?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_public_shares()] [DKG ID Validation - High] Lines 479-483 check dkg_id match - but what if attacker sends shares for future dkg_id, can coordinator cache them and use them out of order?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_public_shares()] [Missing Public Key Handling - Medium] Lines 487-491 silently return Ok(()) if signer_id not in config - should this be an error? Can attacker spam with invalid signer_ids?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_public_shares()] [Duplicate Detection - Low] Lines 493-500 detect and log duplicate shares - but is this exploitable for DoS by sending many duplicates?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_public_shares()] [Automatic State Transition - High] Lines 514-516 auto-transition when wait set empty - can an attacker race to send minimal shares and trigger premature transition?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_public_shares()] [No Validation - Critical] This function stores DkgPublicShares without validating polynomial commitments, Schnorr ID proofs, or polynomial degree - can attacker inject malicious commitments?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_private_shares()] [DKG ID Check - High] Similar to public shares, lines 527-532 check dkg_id but don't prevent caching future shares?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_private_shares()] [No Validation - Critical] Private shares are stored without decryption or validation - can attacker provide invalid encrypted shares that will fail later during DKG end phase?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_private_shares()] [Duplicate Handling - Low] Lines 541-547 handle duplicates - same DoS risk as public shares?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_private_shares()] [State Transition Timing - Medium] Lines 561-563 auto-transition when empty - can timing attacks exploit the moment between last share and transition?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Threshold Conversion - High] Line 604 converts threshold to usize with unwrap - can overflow or precision loss occur with large threshold values?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Malicious Signer Handling - Critical] Lines 613-651 validate BadPublicShares claims - but verification uses check_public_shares() without verifying Schnorr ID proofs, can attacker forge accusations?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [False Accusation - Critical] Lines 642-649 mark accuser as malicious if shares are valid - but what if the shares became invalid due to race conditions? Is this too harsh?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [BadPrivateShares Validation - Critical] Lines 652-763 validate private share claims with complex tuple proof verification and decryption - are there timing attacks or error handling issues that could be exploited?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Tuple Proof Validation - High] Lines 681-685 verify tuple proof - if verification fails, is_bad is set to false at line 752, marking accuser as malicious - can proof verification be tricked?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Shared Secret Derivation - High] Line 688 derives shared_secret from shared_key - can weak keys or predictable secrets compromise private share confidentiality?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Decryption Failure Handling - Medium] Lines 713-746 handle decryption and parsing errors by marking shares as bad - can attacker cause false positives by corrupting shares in transit?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Private Share Validation - Critical] Lines 728-733 check if private_eval * G == poly_eval - is this comparison constant-time? Can timing attacks leak information?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Polynomial Evaluation - High] Lines 716-726 evaluate polynomial at key_id - can malicious polynomial coefficients cause computation errors or overflow?"
]