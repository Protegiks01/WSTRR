[
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Loop Early Break - Medium] Lines 731-747 break on first invalid share - does this leak information about which specific key_id failed?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Malicious Signer Persistence - High] Lines 775-777 mark malicious signers in persistent set - can this set grow unbounded? Is there cleanup logic?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [Threshold Sufficiency - Critical] Lines 779-788 check if reported_failures is empty but don't verify if remaining non-malicious signers meet threshold - can DKG succeed with insufficient participants?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_dkg_end()] [DkgFailure Unhandled Cases - Medium] Lines 617-619, 765-770 have TODO comments about marking signers malicious for Threshold and MissingShares failures - are these exploitable attack vectors?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: dkg_end_gathered()] [Party Polynomial Caching - Critical] Lines 796-800 cache polynomials from public shares - but no validation is done here, can malicious polynomials be cached?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: dkg_end_gathered()] [Aggregate Key Computation - Critical] Lines 803-807 compute aggregate key by summing poly[0] values - can this be manipulated if malicious polynomials were accepted?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: dkg_end_gathered()] [Flat Map Security - High] Line 806 uses flat_map on dkg_public_shares.comms - can duplicate party_ids cause the same commitment to be summed multiple times?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: dkg_end_gathered()] [Point Addition Order - Low] The fold at lines 806-807 sums points - is point addition commutative and associative? Can ordering affect the result?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: dkg_end_gathered()] [Missing Validation - Critical] No check that aggregate_public_key is non-identity point - can DKG produce unusable zero key?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: request_nonces()] [Message Nonce Clearing - High] Line 815 clears message_nonces - can this erase valid nonce data if called incorrectly or at wrong time?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: request_nonces()] [Iteration ID Wraparound - Medium] Line 816 uses wrapping_add for sign_iter_id - can wraparound after many iterations cause ID collision with old signing rounds?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: request_nonces()] [Message Cloning - Low] Line 826 clones message - unnecessary allocation, but could this enable side channel attacks if message contains sensitive data?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: request_nonces()] [Message Signing Panic - High] Line 831 expects NonceRequest signing to succeed - can controlled failure panic the coordinator?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: request_nonces()] [Nonce Request Broadcast - Medium] No restriction on message size at line 826 - can attacker trigger nonce request with huge message causing network DoS?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [ID Validation - High] Lines 847-860 validate dkg_id, sign_id, sign_iter_id - but are these checks sufficient to prevent replay attacks across different rounds?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Key ID Set Validation - Critical] Lines 871-889 check that nonce_response key_ids match config - but uses HashSet comparison, can ordering or duplicates within key_ids bypass this check?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Nonce Validation - Critical] Lines 891-901 validate nonces with is_valid() - what does this check? Can invalid nonces be detected before they corrupt the protocol?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Malicious Signer Bypass - Medium] Lines 903-915 check malicious_signer_ids and return Ok(()) - but nonce is not recorded, can this cause inconsistent state?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Message Entry Creation - High] Lines 917-920 use entry().or_default() - can attacker create entries for arbitrary messages, exhausting memory?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Duplicate Nonce Handling - Low] Lines 922-929 detect duplicate nonces - but should this be an error rather than just logged?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Key ID Recording - Critical] Lines 936-938 record key_ids from signer_key_ids (config), not from nonce_response.key_ids - can mismatch cause incorrect threshold calculation?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Threshold Check - Critical] Line 952 checks if nonce_recv_key_ids.len() >= threshold - but this counts key IDs not signer IDs, correct for weighted threshold?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Message Overwrite - High] Line 954 overwrites self.message with nonce_response.message - can attacker with threshold control force signing of malicious message?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [Aggregate Nonce Computation - High] Line 955 computes aggregate nonce without validation - can invalid nonces corrupt the aggregate?",
  "[File: src/state_machine/coordinator/fire.rs] [Function: gather_nonces()] [State Transition Threshold - Critical] Lines 952-959 transition to SigShareRequest when threshold met - but doesn't verify all required nonces are present, can this cause partial signature?"
]