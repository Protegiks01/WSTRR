### Title
Predictable Encryption Key Due to Missing Validation of KEX Public Key Allows Private Share Exposure

### Summary
The `ansi_x963_derive_key()` function does not validate that the `shared_key` parameter is non-empty or non-predictable. A malicious signer can send `Point::identity()` as their `kex_public_key` in DkgPublicShares messages, causing all honest signers to derive a deterministic, publicly-computable encryption key when encrypting private shares for that malicious party. This breaks the confidentiality of DKG private shares and can lead to threshold bypass or aggregate key compromise.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `ansi_x963_derive_key()` function accepts any `shared_key` byte slice without validation. When `shared_key` is a predictable value (such as the compressed bytes of `Point::identity()`), the KDF output becomes deterministic since both the counter (always 1) and `shared_info` (always "DH_SHARED_SECRET_KEY/") are constants. [2](#0-1) 

The function is called exclusively through `make_shared_secret_from_key()` which passes `shared_key.compress().as_bytes()` where `shared_key` is a Point resulting from Diffie-Hellman key exchange.

**Missing Validation in DkgPublicShares Handling:** [3](#0-2) 

When a signer receives DkgPublicShares, it stores the `kex_public_key` without any validation that it's not `Point::identity()` or another invalid point. [4](#0-3) 

The coordinator similarly stores DkgPublicShares without validating `kex_public_key`.

**Vulnerable Encryption Flow:** [5](#0-4) 

When creating encrypted private shares for recipients, signers use the unvalidated `kex_public_key` to derive the shared secret. If a malicious party sent `Point::identity()` as their `kex_public_key`, the computation `self.kex_private_key * Point::identity()` always yields `Point::identity()`, regardless of the honest party's private key.

**Existing but Insufficient Precedent:** [6](#0-5) 

The codebase demonstrates awareness that `Point::identity()` leads to attacks by validating that public nonces are not the identity point. However, this same validation is missing for `kex_public_key`.

**Root Cause:**
The vulnerability exists because:
1. No validation prevents a malicious party from sending `Point::identity()` as `kex_public_key`
2. DH key exchange with `Point::identity()` produces a predictable result (`Point::identity()`)
3. `ansi_x963_derive_key()` doesn't check if `shared_key` is a predictable value
4. The KDF counter and `shared_info` are constants, making the output deterministic when `shared_key` is predictable

### Impact Explanation

**Specific Harm:**
When a malicious signer sends `Point::identity()` as their `kex_public_key`:
1. All honest signers encrypting private shares for that malicious party use a predictable AES-256-GCM key
2. The key equals `SHA256(Point::identity().compress().as_bytes() || 0x00000001 || "DH_SHARED_SECRET_KEY/")`
3. Anyone (not just the intended recipient) can compute this key and decrypt the "encrypted" shares
4. Private shares in WSTS contain secret polynomial evaluations at specific key IDs

**Quantified Impact:**
- In a DKG with threshold `t`, if an attacker learns `t` shares, they can reconstruct the aggregate private key
- Even learning fewer than `t` shares breaks the threshold assumption and enables:
  - Creating invalid signature shares that appear valid
  - Manipulating the signing process
  - Partial key knowledge that could be combined with other attacks

**Who is Affected:**
- All honest signers in a DKG where a malicious party participates
- The entire WSTS deployment if the aggregate key is compromised
- Downstream systems depending on WSTS signatures (Stacks blockchain)

**Severity Justification:**
This maps to **High** severity per the protocol scope:
- Remotely exploitable via network messages (DkgPublicShares)
- Breaks cryptographic guarantees (encryption confidentiality)
- Can lead to consensus failures if shares are manipulated to create invalid signatures
- Could escalate to **Critical** if enough shares are compromised to reconstruct the private key, leading to unauthorized transaction confirmation or fund loss

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of at least one signer ID in the DKG
- Ability to send network messages (DkgPublicShares)
- Basic knowledge of elliptic curve cryptography

**Attack Complexity:**
LOW - The attack requires only:
1. Create a DkgPublicShares message with `kex_public_key: Point::identity()`
2. Send this message during DKG public shares phase
3. Compute the predictable encryption key: `SHA256(Point::identity().compress().as_bytes() || 0x00000001 || "DH_SHARED_SECRET_KEY/")`
4. Decrypt intercepted encrypted private shares intended for the malicious key

**Economic Feasibility:**
Extremely feasible - requires no computational resources beyond normal protocol participation. No cryptographic breaks needed.

**Detection Risk:**
LOW - The attack is indistinguishable from normal protocol operation:
- `Point::identity()` is a valid Point that deserializes successfully
- No validation checks would raise alerts
- Encrypted shares appear normal (valid AES-GCM ciphertexts)

**Estimated Probability of Success:**
~100% given the prerequisites. The attack will succeed deterministically as long as:
- The attacker controls one signer/key_id
- Other signers process the malicious DkgPublicShares message
- The protocol reaches the private shares encryption phase

### Recommendation

**Primary Fix:**
Add validation in both signer and coordinator to reject `Point::identity()` as `kex_public_key`:

```rust
// In src/state_machine/signer/mod.rs, after line 1017:
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!(%signer_id, "Invalid kex_public_key (identity point)");
    return Ok(vec![]);
}

// In src/state_machine/coordinator/fire.rs, after line 491:
if dkg_public_shares.kex_public_key == Point::identity() 
   || dkg_public_shares.kex_public_key == G {
    warn!(signer_id = %dkg_public_shares.signer_id, "Invalid kex_public_key");
    return Ok(());
}
```

**Defense in Depth:**
Add validation in `ansi_x963_derive_key()` to reject empty or suspiciously small inputs:

```rust
// In src/util.rs, at the start of ansi_x963_derive_key:
pub fn ansi_x963_derive_key(shared_key: &[u8], shared_info: &[u8]) -> Result<[u8; 32], EncryptionError> {
    if shared_key.is_empty() || shared_key.len() < 32 {
        return Err(EncryptionError::InvalidSharedKey);
    }
    // ... rest of function
}
```

**Testing Recommendations:**
1. Unit test: Verify that `Point::identity()` is rejected as `kex_public_key`
2. Integration test: Simulate malicious signer sending identity point during DKG
3. Fuzz test: Test various invalid point values (low-order points, generator)
4. Regression test: Ensure valid DKG flows still work correctly

**Deployment Considerations:**
- This is a breaking change that will reject previously "valid" (but insecure) messages
- Coordinate deployment across all signers to prevent incompatibility
- Consider adding similar validation for other public key fields in the protocol

### Proof of Concept

**Exploitation Algorithm:**

1. **Malicious Signer Setup (during DKG begin):**
   - Generate normal polynomial commitments (to pass validation)
   - Create DkgPublicShares message with `kex_public_key: Point::identity()`
   - Broadcast this message to all participants

2. **Honest Signers Process Malicious Message:**
   - Store `Point::identity()` as the kex_public_key for malicious signer's key_ids
   - No validation prevents this

3. **Honest Signers Encrypt Private Shares:**
   - For each key_id controlled by malicious signer:
     - Compute: `shared_secret = make_shared_secret(&self.kex_private_key, &Point::identity())`
     - This equals: `self.kex_private_key * Point::identity() = Point::identity()`
     - Derive key: `ansi_x963_derive_key(Point::identity().compress().as_bytes(), "DH_SHARED_SECRET_KEY/".as_bytes())`
     - Encrypt share with this predictable key

4. **Attacker Decrypts All Shares:**
   - Compute same predictable key (no secrets needed)
   - Decrypt all shares intended for malicious key_ids
   - Gain knowledge of polynomial evaluations

**Expected Behavior:**
Private shares should be confidential, decryptable only by the intended recipient.

**Actual Behavior:**
Private shares encrypted for the malicious key are decryptable by anyone who:
- Observes the encrypted DkgPrivateShares messages
- Computes the predictable encryption key from public constants

**Reproduction Steps:**
1. Set up a WSTS DKG with â‰¥3 signers
2. Have one malicious signer modify their code to send `kex_public_key: Point::identity()` in DkgPublicShares
3. Observe DkgPrivateShares messages sent by honest signers
4. As an external observer, compute `SHA256(Point::identity().compress().as_bytes() || 0x00000001 || "DH_SHARED_SECRET_KEY/")`
5. Use this key to decrypt AES-GCM ciphertexts from DkgPrivateShares (extracting nonce from first 12 bytes)
6. Successfully recover private shares without possessing any secret keys

### Citations

**File:** src/util.rs (L48-60)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}

/// Create a shared secret from the passed Diffie-Hellman shared key
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/util.rs (L64-77)
```rust
pub fn ansi_x963_derive_key(shared_key: &[u8], shared_info: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    let counter = 1u32;

    hasher.update(shared_key);
    hasher.update(counter.to_be_bytes());
    hasher.update(shared_info);

    let hash = hasher.finalize();
    let mut bytes = [0u8; 32];

    bytes.clone_from_slice(hash.as_slice());
    bytes
}
```

**File:** src/state_machine/signer/mod.rs (L934-944)
```rust
            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```
