### Title
Permanent Malicious Signer Marking Enables Threshold Reduction via Network DoS

### Summary
The FIRE coordinator's timeout handling permanently marks honest signers as malicious based solely on network timeouts, with no recovery mechanism. An attacker can repeatedly DoS honest signers during signature share gathering to incrementally reduce the available signer set below threshold, permanently disabling the threshold signature system without any cryptographic capability.

### Finding Description

**Exact Code Location:** [1](#0-0) 

In the `process_timeout()` function's `SigShareGather` timeout handler, all signers remaining in `sign_wait_signer_ids` are permanently marked as malicious: [2](#0-1) 

**Root Cause:**

The malicious signer tracking mechanism has three critical flaws:

1. **Permanent marking with no recovery:** The `malicious_signer_ids` HashSet persists across all signing rounds: [3](#0-2) 

2. **Network-based, not cryptographic:** Signers are marked malicious due to timeout (network issue), not due to cryptographic proof of malicious behavior (invalid shares, proofs, etc.).

3. **Permanent exclusion from future rounds:** Once marked, signers' nonces are rejected in all subsequent signing attempts: [4](#0-3) 

**Why Existing Mitigations Fail:**

The threshold check at lines 191-199 only detects when insufficient signers remain—it does not prevent the problem or provide recovery: [5](#0-4) 

The automatic retry mechanism actually makes the problem worse by giving attackers multiple opportunities to DoS different subsets of signers across iterations. The coordinator's `reset()` function does not clear `malicious_signer_ids`: [6](#0-5) 

The malicious tracking is also persisted in saved state, making the marking survive coordinator restarts: [7](#0-6) 

### Impact Explanation

**Specific Harm:**

This vulnerability enables permanent denial of service of the threshold signature system. Once enough honest signers are marked malicious through repeated network DoS attacks, the system cannot generate valid signatures because the remaining non-malicious signers control fewer than threshold keys.

**Quantified Impact:**

Consider a deployment with:
- 10 signers, each controlling 1 key
- Threshold = 7 keys
- Attacker can DoS network connections to coordinator

**Attack execution:**
- Round 1: Attacker DoS's 3 signers during signature share gathering → marked malicious (7 keys remain, threshold met, retry)
- Round 2: Previous 3 signers' nonces rejected, attacker DoS's 3 more signers → marked malicious (4 keys remain < 7 threshold)
- Result: System permanently unable to generate signatures

**Severity: Critical**

Maps directly to protocol scope: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks"

If WSTS is used for blockchain consensus signatures (as indicated by Stacks context), inability to generate threshold signatures means:
- No new blocks can be signed and confirmed
- Network halts indefinitely
- No recovery without recreating the entire coordinator and DKG

**Who Is Affected:**

All users of the FIRE coordinator for production threshold signatures. The FROST coordinator does not have this vulnerability but also lacks timeout handling entirely.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Network positioning to DoS connections between coordinator and specific signers (e.g., ISP-level routing, DDoS capability, or position on network path)
- Timing capability to trigger DoS during the specific signature share gathering window (configured by `sign_timeout`)
- No cryptographic secrets or signing keys required
- No need to compromise coordinator or signer nodes themselves

**Attack Complexity: Medium**

The coordinator uses star topology architecture, making selective DoS feasible: [8](#0-7) 

Attack requires:
1. Monitoring to identify when `SignatureShareRequest` is sent
2. Network disruption for duration of `sign_timeout`
3. Selective targeting (allow some signers through initially to maintain threshold)
4. Repetition across 2-3 signing rounds (depending on threshold parameters)

**Economic Feasibility: High**

Network DoS is significantly cheaper than cryptographic attacks. For cloud-deployed coordinators, common DDoS techniques suffice. The attack is cumulative—each successful DoS permanently eliminates signers.

**Detection Risk: Low**

The attack appears as legitimate network failures. No invalid cryptographic messages are sent, so coordinator logs would show normal timeout behavior. Distinguishing malicious DoS from genuine network issues is difficult without external monitoring.

**Estimated Probability: High**

For adversaries with network positioning (state-level actors, ISPs, or sophisticated DDoS operators), success probability is high given the permanent nature of the vulnerability and lack of recovery mechanisms.

### Recommendation

**Primary Fix: Implement Transient Malicious Tracking**

Replace permanent malicious marking with per-signing-round tracking:

1. Add a new field to track temporarily unavailable signers within a signing round
2. Clear this tracking when starting a new signing round (`start_signing_round`)
3. Only permanently mark signers as malicious when there is cryptographic evidence (invalid signature shares, not timeouts)

**Specific Code Changes:**

In the `Coordinator` struct, add:
- `signing_round_unavailable_signers: HashSet<u32>` - cleared per signing round
- Use this instead of `malicious_signer_ids` for timeout-based marking

Modify timeout handling to use the transient set: [2](#0-1) 

Clear the transient set in `start_signing_round`: [9](#0-8) 

Reserve `malicious_signer_ids` for cryptographically-proven malicious behavior verified in `gather_sig_shares` when signature shares fail validation.

**Alternative Mitigation: Exponential Backoff with Recovery**

If transient tracking is too complex, implement:
1. Exponential backoff before permanently marking signers
2. Manual API to clear malicious signer lists
3. Automatic clearing after configurable time period (e.g., 1 hour)
4. Require multiple consecutive timeouts before permanent marking

**Testing Recommendations:**

1. Add unit test simulating network timeouts with subsequent recovery
2. Integration test with selective signer DoS across multiple rounds
3. Verify malicious tracking only triggers for cryptographic failures
4. Test that legitimate network issues don't cause permanent exclusion

**Deployment Considerations:**

This is a breaking change requiring coordinator restart. Existing saved states with malicious signer lists may need manual clearing or migration.

### Proof of Concept

**Setup:**
- 10 signers (S0-S9), each controlling 1 key
- `num_keys = 10`, `threshold = 7`
- `sign_timeout = 5 seconds`
- Attacker can selectively DoS coordinator connections

**Exploitation Algorithm:**

```
Round 1 - Initial Reduction:
1. Coordinator sends NonceRequest
2. All signers S0-S9 send NonceResponse
3. All added to sign_wait_signer_ids (line 941-942)
4. Coordinator sends SignatureShareRequest
5. ATTACKER DoS's S0, S1, S2 for 5+ seconds
6. Only S3-S9 respond with SignatureShareResponse
7. Timeout triggers (line 176)
8. S0, S1, S2 permanently marked malicious (line 185)
9. Check: 10 - 3 = 7 keys >= 7 threshold ✓
10. Coordinator retries with new NonceRequest (line 202-204)

Round 2 - Threshold Breach:
11. S0, S1, S2 attempt NonceResponse
12. Rejected due to malicious_signer_ids (line 903-915)
13. Only S3-S9 send valid nonces
14. Coordinator sends SignatureShareRequest
15. ATTACKER DoS's S3, S4, S5 for 5+ seconds
16. Only S6-S9 respond
17. Timeout triggers
18. S3, S4, S5 marked malicious
19. Check: 10 - 6 = 4 keys < 7 threshold ✗
20. Returns SignError::InsufficientSigners (line 196-199)
21. System PERMANENTLY unable to generate signatures
```

**Expected Behavior:**
Timeouts should not permanently exclude honest signers. The system should recover when network conditions improve.

**Actual Behavior:**
Honest signers are permanently excluded from all future signing rounds after a single network timeout, with no recovery mechanism. Repeated network DoS can permanently disable the threshold signature system.

**Reproduction Steps:**
1. Deploy FIRE coordinator with 10 signers, threshold 7, sign_timeout 5s
2. Start normal signing round
3. During SigShareGather, block network for signers 0-2 for 6 seconds
4. Observe timeout and malicious marking
5. Start new signing round
6. Observe signers 0-2 nonces are rejected
7. During SigShareGather, block network for signers 3-5 for 6 seconds
8. Observe InsufficientSigners error
9. Attempt any future signing - permanently fails

**Notes**

This vulnerability violates the stated security invariant: "Malicious signer detection and timeouts must not be bypassable." While the detection mechanism exists, it incorrectly marks honest signers as permanently malicious based solely on network conditions rather than cryptographic proof of malicious behavior. The wiki documentation claims this enables "automatic recovery from transient failures," but the permanent nature of the malicious marking makes this claim false—it actually prevents recovery from transient failures.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L64-64)
```rust
    malicious_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L173-207)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L964-996)
```rust
    fn request_sig_shares(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.signature_shares.clear();
        info!(
            sign_id = %self.current_sign_id,
            "Requesting Signature Shares"
        );
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
            message: self.message.clone(),
            signature_type,
        };
        let sig_share_request_msg = Packet {
            sig: sig_share_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign SignatureShareRequest"),
            msg: Message::SignatureShareRequest(sig_share_request),
        };
        self.move_to(State::SigShareGather(signature_type))?;
        self.sign_start = Some(Instant::now());

        Ok(sig_share_request_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1457-1476)
```rust
    fn start_signing_round(
        &mut self,
        message: &[u8],
        signature_type: SignatureType,
        sign_id: Option<u64>,
    ) -> Result<Packet, Error> {
        // We cannot sign if we haven't first set DKG (either manually or via DKG round).
        if self.aggregate_public_key.is_none() {
            return Err(Error::MissingAggregatePublicKey);
        }
        self.message = message.to_vec();
        if let Some(id) = sign_id {
            self.current_sign_id = id;
        } else {
            self.current_sign_id = self.current_sign_id.wrapping_add(1);
        }
        info!("Starting signing round {}", self.current_sign_id);
        self.move_to(State::NonceRequest(signature_type))?;
        self.request_nonces(signature_type)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```

**File:** src/state_machine/coordinator/mod.rs (L293-293)
```rust
    pub malicious_signer_ids: HashSet<u32>,
```
