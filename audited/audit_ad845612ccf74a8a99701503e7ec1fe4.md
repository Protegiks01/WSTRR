### Title
Missing DKG Round ID Monotonicity Validation Allows Replay of Old DKG Rounds

### Summary
The `dkg_begin()` function in the signer state machine unconditionally accepts any `dkg_id` value from the coordinator without validating that it is greater than or equal to the current `dkg_id`. This allows a compromised or misconfigured coordinator to force signers to replay old DKG rounds, causing denial of service and transient consensus failures.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `dkg_begin()` function unconditionally calls `self.reset(dkg_begin.dkg_id, rng)` without any validation that the incoming `dkg_id` is greater than or equal to `self.dkg_id`. [2](#0-1) 

The `reset()` function then unconditionally sets `self.dkg_id = dkg_id` and clears all state (commitments, shares, keys).

**Root Cause:**
The signer state machine lacks validation to ensure DKG round IDs are monotonically increasing. While the coordinator validates incoming message `dkg_id` values against its `current_dkg_id`: [3](#0-2) 

The signer has no corresponding check when receiving `DkgBegin` messages. Additionally, the coordinator's `start_dkg_round()` method accepts an optional `dkg_id` parameter without validation: [4](#0-3) 

This creates an asymmetry where coordinators validate incoming message IDs but signers do not, and coordinators can be instructed to start rounds with arbitrary IDs.

**Why Existing Mitigations Fail:**
Packet signature verification is enforced: [5](#0-4) 

However, this only ensures the `DkgBegin` message comes from the coordinator - it does not validate the semantic correctness of the `dkg_id` value. A compromised or buggy coordinator can legitimately sign a `DkgBegin` message with an old `dkg_id`.

### Impact Explanation

**Specific Harm:**
1. **Denial of Service**: An attacker who controls the coordinator can force all signers to reset their state and restart an old DKG round, disrupting any in-progress DKG operation.

2. **Transient Consensus Failures**: If the replay message reaches only a subset of signers, different signers will be operating on different `dkg_id` values, causing protocol misalignment until the issue is detected and manually resolved.

3. **State Machine Invariant Violation**: The protocol explicitly requires "Round IDs (dkg_id, sign_id, sign_iter_id) must match expected values" as a critical security invariant. This vulnerability directly violates that requirement.

**Quantified Impact:**
- All signers receiving the malicious `DkgBegin` message will reset to the old round
- All current DKG progress is lost
- Recovery requires manual intervention to restart with correct `dkg_id`
- Network is unable to complete DKG until issue is resolved

**Who Is Affected:**
All signer nodes in the WSTS network are affected, potentially impacting any dependent systems (e.g., Stacks blockchain nodes) that rely on threshold signatures for transaction validation.

**Severity Justification:**
- **Medium Severity**: Causes transient consensus failures as signers become desynchronized
- **Low Severity**: Causes denial of service in signer nodes, preventing DKG completion
- Severity depends on whether attack causes full network disruption (Medium) or impacts subset of nodes (Low)

### Likelihood Explanation

**Required Attacker Capabilities:**
1. **Coordinator Compromise**: Attacker must compromise the coordinator node or its API to call `start_dkg_round(Some(old_dkg_id))`
2. **API Exploitation**: If coordinator exposes an unvalidated API endpoint accepting `dkg_id` as input, attacker exploits this interface
3. **Insider Access**: Malicious coordinator operator or compromised administrator credentials

**Attack Complexity:**
- **Low to Medium**: Once coordinator access is obtained, exploitation is trivial - simply call `start_dkg_round(Some(0))` or any old ID
- No cryptographic operations required
- No race conditions or timing dependencies
- Attack succeeds deterministically

**Economic Feasibility:**
Highly feasible if coordinator can be accessed. The coordinator is a single point of trust, making it a valuable target for compromise.

**Detection Risk:**
- **High Detection Probability**: Signers will log warnings about unexpected DKG rounds
- Network monitoring will detect DKG disruptions immediately
- However, damage is done before detection can prevent it

**Estimated Probability:**
Moderate likelihood given:
- Requires coordinator-level access (significant barrier)
- But coordinator is single point of failure
- No validation exists to prevent the attack once access is obtained
- Realistic in scenarios where coordinator API is exposed without proper input validation

### Recommendation

**Primary Fix:**
Add monotonicity validation in the signer's `dkg_begin()` function:

```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Validate that dkg_id is monotonically increasing
    if dkg_begin.dkg_id < self.dkg_id {
        warn!(
            signer_id = %self.signer_id,
            current_dkg_id = %self.dkg_id,
            received_dkg_id = %dkg_begin.dkg_id,
            "Rejecting DkgBegin with non-monotonic dkg_id"
        );
        return Err(Error::BadDkgId(dkg_begin.dkg_id, self.dkg_id));
    }
    
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Secondary Fix:**
Add validation in coordinator's `start_dkg_round()`:

```rust
fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
    if let Some(id) = dkg_id {
        // Validate that explicitly provided ID is not decreasing
        if id < self.current_dkg_id {
            return Err(Error::BadDkgId(id, self.current_dkg_id));
        }
        self.current_dkg_id = id;
    } else {
        self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
    }
    // ... rest of implementation
}
```

**Error Type Addition:**
Add `BadDkgId` error to signer's `Error` enum to match coordinator's error handling pattern.

**Testing Recommendations:**
1. Add unit test attempting to start DKG with `dkg_id` less than current value
2. Add integration test verifying signers reject non-monotonic DKG rounds
3. Test that valid monotonic increases are still accepted
4. Verify error is logged and reported appropriately

**Deployment Considerations:**
- This is a protocol-level fix requiring coordinated upgrade
- Backward compatibility: new signers will reject old coordinator behavior
- Consider grace period or configuration flag during rollout
- Document that `start_dkg_round(Some(id))` should only use increasing IDs

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup**: Normal WSTS network with coordinator and N signers, currently at `dkg_id = 5`

2. **Attack Execution**:
   ```rust
   // Attacker with coordinator access calls:
   coordinator.start_dkg_round(Some(2))
   ```

3. **Expected Behavior**: Coordinator should reject or validate the backwards ID

4. **Actual Behavior**: 
   - Coordinator sets `current_dkg_id = 2`
   - Sends `DkgBegin { dkg_id: 2 }` to all signers
   - Each signer calls `reset(2, rng)`, setting `self.dkg_id = 2`
   - All signers clear their state and restart at DKG round 2
   - Any in-progress DKG round 5 is lost

5. **Reproduction Steps**:
   ```rust
   // In test environment
   let mut coordinator = Coordinator::new(config);
   let mut signers = create_signers(num_signers);
   
   // Complete DKG round 1
   run_dkg(&mut coordinator, &mut signers);
   assert_eq!(signers[0].dkg_id, 1);
   
   // Start DKG round 2
   coordinator.start_dkg_round(Some(2));
   // ... partial completion ...
   
   // ATTACK: Force replay of round 0
   let malicious_packet = coordinator.start_dkg_round(Some(0)).unwrap();
   
   // Send to signers
   for signer in &mut signers {
       signer.process(&malicious_packet, &mut rng).unwrap();
       // Verify signers reset to dkg_id = 0
       assert_eq!(signer.dkg_id, 0); // VULNERABILITY CONFIRMED
   }
   ```

**Observable Evidence:**
- Signer logs show unexpected DKG round number decrease
- Coordinator and signers become desynchronized if attack is partial
- DKG completion is prevented until manual reset

**Notes**

The vulnerability exists in both the signer's acceptance of non-monotonic IDs and the coordinator's lack of validation on API inputs. The fix requires adding validation at both layers for defense in depth. While exploitation requires coordinator-level access, this is a realistic threat model for production systems where APIs may be exposed or coordinators may be compromised. The stated security invariant explicitly requires monotonic round IDs, making this a clear violation of protocol requirements.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L463-469)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/coordinator/frost.rs (L292-296)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
```

**File:** src/state_machine/coordinator/frost.rs (L957-962)
```rust
    fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }
```
