### Title
Key Exchange Public Key Not Authenticated in DKG Allows Man-in-the-Middle Attack

### Summary
The WSTS protocol's DKG flow does not authenticate or bind the ephemeral `kex_public_key` to the signer's long-term identity during DkgPublicShares. This allows a network-level attacker to substitute their own key, resulting in decryption of blinded shares meant for a target signer. This can escalate to forging group signatures or key extraction, meeting the "High" impact threshold.

### Finding Description
- **Exact code location:**  
  - [src/state_machine/signer/mod.rs]  
    - kex_public_keys insertion: 1018-1021  
    - get_kex_public_key: 1112-1129  
    - DkgPublicShares construction: 872-877  
  - [src/net.rs]  
    - DkgPublicShares struct and Signable implementation: 138-164  
- **Root cause:**  
  - The `kex_public_key` field in `DkgPublicShares` is not covered by the message signature hash (`Signable::hash`), so it is not authenticated and may be replaced in transit. [1](#0-0)   
  - The state machine accepts and stores any received `kex_public_key` for each key ID without binding it to the signer's identity. [2](#0-1) 
- **Why mitigations fail:**  
  - While packets are ECDSA authenticated (Packet::verify), the signature covers only the other fields in `DkgPublicShares` and not `kex_public_key`. As a result, man-in-the-middle tampering is undetected. [3](#0-2)   
- **Relevant context:**  
  - The unvalidated `kex_public_key` is subsequently used for Diffie-Hellman encryption of secret shares. [4](#0-3) 

### Impact Explanation
- **Harm:**  
  - An attacker who can intercept (or inject) packets can substitute their own DH key as a target's `kex_public_key`, and later decrypt shares encrypted for that key ID.
  - With shares for enough key IDs (â‰¥ threshold), attacker can reconstruct the group private key, break group signature security, and sign arbitrary transactions as the group.
- **Scope/Severity:**  
  - This meets "High" severity: enables attacker to cause signature forgery (confirming invalid transactions, potential consensus split).
  - A fully compromised DKG means funds can be spent without legitimate authorization, or chain splits may occur if nodes disagree on keys. [5](#0-4) 

### Likelihood Explanation
- **Attack requirements:**  
  - Network-level attacker with man-in-the-middle (MITM) capability (as on a hostile LAN or compromised router).
  - No cryptographic breaks required. 
- **Complexity:**  
  - Simply modify `DkgPublicShares` in transit for the targeted key IDs during DKG.
- **Feasibility:**  
  - Straightforward packet rewrite attack, undetectable due to lack of field authentication.
- **Detection risk/probability:**  
  - No evidence left unless secondary integrity checks (not present here) are deployed.
  - High probability of success for attackers who can intercept traffic.

### Recommendation
- **Code changes:**  
  - Include `kex_public_key` in the `Signable::hash` for `DkgPublicShares` so it is always authenticated by the signer's ECDSA signature.
- **Alternative/Additional mitigations:**  
  - Include Schnorr or DH proof of possession for the DH key in the message, or bind ephemeral keys to the signer's long-term public key cryptographically.
- **Testing:**  
  - Add tests that simulate MITM substitution and ensure altered `DkgPublicShares` are rejected.
- **Deployment:**  
  - Patch must be rolled out to all protocol participants before trusting new DKG runs.

### Proof of Concept
1. Attacker intercepts `DkgPublicShares` from signer X, replaces `kex_public_key` with their own value, forwards to other signers.
2. Honest signers store the attacker's DH key for X's key IDs.
3. Private shares are then DH-encrypted to the attacker's key, not X's.
4. Attacker collects enough shares, reconstructs the group secret, and forges group signatures.

Expected: Only X can decrypt shares intended for X due to authenticated `kex_public_key`.  
Actual: Attacker can decrypt if they substitute theirs undetected. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3)

### Citations

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/net.rs (L485-539)
```rust
impl Packet {
    /// This function verifies the packet's signature, returning true if the signature is valid,
    /// i.e. is appropriately signed by either the provided coordinator or one of the provided signer public keys
    pub fn verify(
        &self,
        signers_public_keys: &PublicKeys,
        coordinator_public_key: &ecdsa::PublicKey,
    ) -> bool {
        match &self.msg {
            Message::DkgBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgBegin message with an invalid signature.");
                    return false;
                }
            }
            Message::DkgPrivateBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgPrivateBegin message with an invalid signature.");
                    return false;
                }
            }
            Message::DkgEndBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgEndBegin message with an invalid signature.");
                    return false;
                }
            }
            Message::DkgEnd(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicEnd message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicEnd message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```
