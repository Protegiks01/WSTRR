### Title
Unvalidated Private Shares Included in DKG Secret Derivation Due to Mismatched Signer Lists

### Summary
The `can_dkg_end()` function allows DKG completion when `dkg_private_begin_msg.signer_ids` and `dkg_end_begin_msg.signer_ids` contain different signers. This enables a malicious coordinator to include an attacker-controlled signer in the private share distribution phase but exclude them from validation, resulting in unvalidated private shares being summed into the final group secret key. This completely compromises the threshold signature scheme's security guarantees.

### Finding Description

**Exact Code Location:**

The vulnerability spans multiple functions in `src/state_machine/signer/mod.rs` and the secret computation in `src/v2.rs` and `src/v1.rs`. [1](#0-0) 

The `can_dkg_end()` function checks that public shares exist for all signers in `dkg_private_begin.signer_ids` (lines 696-701) and private shares exist for all signers in `dkg_end_begin.signer_ids` (lines 705-710), but never validates that these two lists are identical. [2](#0-1) 

In `dkg_ended()`, the function uses only `dkg_end_begin.signer_ids` to determine which commitments to validate and add to `self.commitments` (lines 529-566). However, `self.decrypted_shares` contains shares from ALL signers who sent `DkgPrivateShares`, regardless of which begin message they were in. [3](#0-2) 

In v2's `compute_secret()`, the validation at lines 146-163 only checks for shares from parties in `public_shares.keys()`. When iterating over all private shares (lines 165-186), shares without corresponding commitments only generate a warning (line 174) but are NOT added to `bad_shares`. The final private key sums ALL shares including unvalidated ones (line 191). [4](#0-3) 

The v1 implementation has the identical flaw. Lines 172-180 only check for shares from parties in `public_shares.keys()`. Lines 190-203 warn about shares without commitments but don't error. Line 205 sums ALL shares including unvalidated ones.

**Root Cause:**

The root cause is the incorrect assumption that `private_shares` and `public_shares` will always contain the same set of parties. The state machine allows these sets to diverge by accepting different signer lists in `DkgPrivateBegin` and `DkgEndBegin` messages without cross-validation.

### Impact Explanation

**Specific Harm:**

A malicious coordinator controlling even a single signer ID can completely compromise the threshold signature scheme by injecting arbitrary private shares into honest signers' key derivation without validation against polynomial commitments. This allows:

1. **Private Key Manipulation**: The attacker's unvalidated shares bias the final private key in a known direction, potentially allowing key recovery or signature forgery.

2. **Invalid Signature Generation**: Signatures produced using the compromised key will be mathematically valid under the corrupted group public key, but the key derivation process violated the threshold scheme's security assumptions.

3. **Undetectable Compromise**: Honest signers have no way to detect this attack—`can_dkg_end()` returns true, DKG reports success, and subsequent signatures appear valid.

**Quantified Impact:**

- **Loss of Funds**: An attacker can forge signatures on transactions, directly stealing any assets controlled by the threshold signature group
- **Invalid Transaction Confirmation**: The corrupted signing group will produce signatures that appear valid but result from a compromised key generation process
- **Chain-level Impact**: In Stacks or similar systems using WSTS for consensus, this enables unauthorized state transitions and transaction confirmations

**Severity Justification:**

**CRITICAL** - Maps directly to "Any causing the direct loss of funds" and "Any confirmation of an invalid transaction" from the protocol scope. The vulnerability enables complete bypass of the threshold signature security model.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control over the coordinator role (sends `DkgBegin`, `DkgPrivateBegin`, `DkgEndBegin` messages)
- Control over at least one signer ID's private keys
- No cryptographic breaks required

**Attack Complexity:**
LOW - The attack requires only:
1. Sending `DkgPrivateBegin` with attacker signer included
2. Sending malicious `DkgPrivateShares` from attacker signer
3. Sending `DkgEndBegin` with attacker signer excluded
4. Standard DKG protocol messages for other steps

**Economic Feasibility:**
HIGH - In many WSTS deployments, the coordinator is a known role that could be compromised through:
- Social engineering
- Software vulnerabilities in coordinator infrastructure  
- Insider threat
- Malicious coordinator in adversarial scenarios

**Detection Risk:**
NONE - The attack is completely undetectable by honest signers:
- All state machine checks pass
- DKG reports success status
- No cryptographic validation failures occur
- Resulting signatures appear mathematically valid

**Probability of Success:**
~100% if the attacker controls the coordinator role, as there are no cryptographic or protocol barriers to this attack.

### Recommendation

**Primary Fix:**

Add validation in `can_dkg_end()` to enforce that the signer lists match:

```rust
pub fn can_dkg_end(&self) -> bool {
    if self.state == State::DkgPrivateGather {
        if let Some(dkg_private_begin) = &self.dkg_private_begin_msg {
            if let Some(dkg_end_begin) = &self.dkg_end_begin_msg {
                // NEW: Validate signer lists match
                let private_set: HashSet<u32> = dkg_private_begin.signer_ids.iter().copied().collect();
                let end_set: HashSet<u32> = dkg_end_begin.signer_ids.iter().copied().collect();
                if private_set != end_set {
                    debug!("can_dkg_end: false, signer_ids mismatch between DkgPrivateBegin and DkgEndBegin");
                    return false;
                }
                
                // Existing checks...
                for signer_id in &dkg_private_begin.signer_ids {
                    if !self.dkg_public_shares.contains_key(signer_id) {
                        return false;
                    }
                }
                for signer_id in &dkg_end_begin.signer_ids {
                    if !self.dkg_private_shares.contains_key(signer_id) {
                        return false;
                    }
                }
                return true;
            }
        }
    }
    false
}
```

**Secondary Fix:**

Modify `compute_secret()` in both v1 and v2 to return an error (not just warn) when private shares lack corresponding commitments: [5](#0-4) 

Change line 174 from a warning to adding the sender to `bad_shares`:

```rust
} else {
    bad_shares.push(*sender);  // Changed from warn! to error
}
```

**Testing Recommendations:**
1. Add unit test with mismatched signer lists verifying `can_dkg_end()` returns false
2. Add integration test attempting full DKG with list mismatch, verifying it fails
3. Fuzz test with random signer list variations

**Deployment Considerations:**
- This is a breaking protocol change that requires coordinated upgrade
- Existing DKG sessions in progress may need to be aborted and restarted
- Consider adding protocol version negotiation to handle mixed versions

### Proof of Concept

**Attack Algorithm:**

1. **Setup (Attacker-controlled coordinator):**
   - Honest signers: 0, 1, 2 (with key_ids 1, 2, 3)
   - Attacker signer: 99 (with key_id 100)
   - Threshold: 3, DKG threshold: 3

2. **DKG Public Phase:**
   - Coordinator sends `DkgBegin{dkg_id: 1}`
   - All signers (including attacker 99) send `DkgPublicShares` with polynomial commitments
   - All signers receive and store all public shares

3. **DKG Private Phase - ATTACK BEGINS:**
   - Coordinator sends `DkgPrivateBegin{dkg_id: 1, signer_ids: [0, 1, 2, 99]}` ← includes attacker
   - All signers (0, 1, 2, 99) compute active_key_ids from signer_ids [0, 1, 2, 99]
   - All signers send encrypted `DkgPrivateShares` to key_ids [1, 2, 3, 100]
   - **Attacker (signer 99) sends malicious shares** designed to bias the key
   - All honest signers decrypt and store shares in `self.decrypted_shares`, including attacker's shares

4. **DKG End Phase - ATTACK COMPLETES:**
   - Coordinator sends `DkgEndBegin{dkg_id: 1, signer_ids: [0, 1, 2]}` ← excludes attacker
   - In each honest signer's `can_dkg_end()`:
     * Checks public shares from [0, 1, 2, 99] ✓ all present
     * Checks private shares from [0, 1, 2] ✓ all present
     * **Returns true** (no validation that lists match)
   - In each honest signer's `dkg_ended()`:
     * Only adds commitments from signers [0, 1, 2] to `self.commitments`
     * `self.decrypted_shares` still contains shares from [0, 1, 2, 99]
   - In `compute_secrets()`:
     * Validates shares from [0, 1, 2] against commitments ✓
     * Shares from signer 99 have no commitment → warns but continues
     * **Sums ALL shares including attacker's** into final private key

5. **Result:**
   - Each honest signer's private key = sum of shares from [0, 1, 2, 99]
   - Attacker knows their contributed share
   - Group public key includes attacker's unvalidated contribution
   - Threshold signature security is completely compromised

**Expected Behavior:**
`can_dkg_end()` should return false when signer lists differ, preventing DKG completion.

**Actual Behavior:**  
`can_dkg_end()` returns true, allowing unvalidated shares to contaminate the final secret key.

**Reproduction:**
Run the existing test suite with a modified coordinator that sends different signer lists in `DkgPrivateBegin` and `DkgEndBegin`. The DKG will complete successfully with corrupted keys.

### Citations

**File:** src/state_machine/signer/mod.rs (L504-671)
```rust
    pub fn dkg_ended<R: RngCore + CryptoRng>(&mut self, rng: &mut R) -> Result<Message, Error> {
        if !self.can_dkg_end() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadState),
            }));
        }

        // only use the public shares from the DkgEndBegin signers
        let mut missing_public_shares = HashSet::new();
        let mut missing_private_shares = HashSet::new();
        let mut bad_public_shares = HashSet::new();
        let threshold: usize = self.threshold.try_into().unwrap();

        let Some(dkg_end_begin) = &self.dkg_end_begin_msg else {
            // no cached DkgEndBegin message
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadState),
            }));
        };

        // fist check to see if dkg_threshold has been met
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
        let mut num_dkg_keys = 0u32;
        for id in &signer_ids_set {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(id) {
                let len: u32 = key_ids.len().try_into()?;
                num_dkg_keys = num_dkg_keys.saturating_add(len);
            }
        }

        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
        }

        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }

        if !missing_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPublicShares(missing_public_shares)),
            }));
        }

        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }

        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
        }

        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            status = ?dkg_end.status,
            "sending DkgEnd"
        );

        let dkg_end = Message::DkgEnd(dkg_end);
        Ok(dkg_end)
    }
```

**File:** src/state_machine/signer/mod.rs (L685-721)
```rust
    pub fn can_dkg_end(&self) -> bool {
        debug!(
            "can_dkg_end: state {:?} DkgPrivateBegin {} DkgEndBegin {}",
            self.state,
            self.dkg_private_begin_msg.is_some(),
            self.dkg_end_begin_msg.is_some(),
        );

        if self.state == State::DkgPrivateGather {
            if let Some(dkg_private_begin) = &self.dkg_private_begin_msg {
                // need public shares from active signers
                for signer_id in &dkg_private_begin.signer_ids {
                    if !self.dkg_public_shares.contains_key(signer_id) {
                        debug!("can_dkg_end: false, missing public shares from signer {signer_id}");
                        return false;
                    }
                }

                if let Some(dkg_end_begin) = &self.dkg_end_begin_msg {
                    // need private shares from active signers
                    for signer_id in &dkg_end_begin.signer_ids {
                        if !self.dkg_private_shares.contains_key(signer_id) {
                            debug!("can_dkg_end: false, missing private shares from signer {signer_id}");
                            return false;
                        }
                    }
                    debug!("can_dkg_end: true");

                    return true;
                }
            }
        } else {
            debug!("can_dkg_end: false, bad state {:?}", self.state);
            return false;
        }
        false
    }
```

**File:** src/v2.rs (L123-202)
```rust
    pub fn compute_secret(
        &mut self,
        private_shares: &HashMap<u32, HashMap<u32, Scalar>>,
        public_shares: &HashMap<u32, PolyCommitment>,
        ctx: &[u8],
    ) -> Result<(), DkgError> {
        self.private_keys.clear();
        self.group_key = Point::zero();

        let threshold: usize = self.threshold.try_into()?;

        let mut bad_ids = Vec::new();
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }

        let mut missing_shares = Vec::new();
        for dst_key_id in &self.key_ids {
            for src_key_id in public_shares.keys() {
                match private_shares.get(dst_key_id) {
                    Some(shares) => {
                        if shares.get(src_key_id).is_none() {
                            missing_shares.push((*dst_key_id, *src_key_id));
                        }
                    }
                    None => {
                        missing_shares.push((*dst_key_id, *src_key_id));
                    }
                }
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }

        let mut bad_shares = Vec::new();
        for key_id in &self.key_ids {
            if let Some(shares) = private_shares.get(key_id) {
                for (sender, s) in shares {
                    if let Some(comm) = public_shares.get(sender) {
                        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
                            bad_shares.push(*sender);
                        }
                    } else {
                        warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", sender);
                    }
                }
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }
        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }

        for key_id in &self.key_ids {
            self.private_keys.insert(*key_id, Scalar::zero());
            if let Some(shares) = private_shares.get(key_id) {
                let secret = shares.values().sum();
                self.private_keys.insert(*key_id, secret);
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }

        Ok(())
    }
```

**File:** src/v1.rs (L150-209)
```rust
    pub fn compute_secret(
        &mut self,
        private_shares: HashMap<u32, Scalar>,
        public_shares: &HashMap<u32, PolyCommitment>,
        ctx: &[u8],
    ) -> Result<(), DkgError> {
        self.private_key = Scalar::zero();
        self.group_key = Point::zero();

        let threshold: usize = self.threshold.try_into()?;
        let mut bad_ids = Vec::new(); //: Vec<u32> = polys
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }

        let mut missing_shares = Vec::new();
        for i in public_shares.keys() {
            if private_shares.get(i).is_none() {
                missing_shares.push((self.id, *i));
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }

        // batch verification requires that we multiply each term by a random scalar in order to
        // prevent a bypass attack.  Doing this using p256k1's MultiMult trait is problematic,
        // because it needs to have every term available so it can return references to them,
        // so we wouldn't be able to save any memory since we'd have to multiple each polynomial
        // coefficient by a different random scalar.
        // we could implement a MultiMultCopy trait that allows us to do the multiplication inline,
        // at the cost of many copies, or use large amounts of memory and do a standard multimult.
        // Or we could just verify each set of public and private shares separately, using extra CPU
        let mut bad_shares = Vec::new();
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
            } else {
                warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", i);
            }
        }

        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }

        self.private_key = private_shares.values().sum();
        self.public_key = self.private_key * G;

        Ok(())
    }
```
