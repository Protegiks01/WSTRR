### Title
Unbounded DkgPrivateShares HashMap Entries Enable Memory and CPU Exhaustion DoS

### Summary
The `DkgPrivateShares` message handler does not enforce bounds on the number of entries in the `shares` vector or the inner HashMaps, allowing a malicious signer to send messages with arbitrarily large data structures. This causes memory exhaustion from storing the entire message and CPU exhaustion from iterating through all entries, enabling a remotely-exploitable denial of service attack against victim signers during the DKG phase.

### Finding Description

**Exact Code Location:**
- Message structure: `src/net.rs`, lines 190-199 [1](#0-0) 
- Vulnerable handler: `src/state_machine/signer/mod.rs`, function `dkg_private_shares`, lines 1028-1110 [2](#0-1) 

**Root Cause:**
The `DkgPrivateShares` struct contains a field `shares: Vec<(u32, HashMap<u32, Vec<u8>>)>` with no size constraints. The handler performs validation at lines 1047-1056 [3](#0-2)  that only checks party_id ownership using `validate_party_id`, but does not:
1. Limit the number of party_id entries in the Vec
2. Check for duplicate party_ids
3. Limit the number of dst_key_id entries in each HashMap
4. Limit the size of encrypted share Vec<u8> values

**Why Existing Mitigations Fail:**

The duplicate message check at lines 1058-1061 [4](#0-3)  only prevents receiving multiple messages from the same signer_id, but does not limit the size or structure of a single message. The party_id validation only verifies ownership, not uniqueness or count.

After validation passes, the handler:
- Clones and stores the entire message in memory at lines 1063-1064 [5](#0-4) 
- Iterates through all entries at lines 1072-1102 [6](#0-5)  with O(N×M) complexity where N is the number of party_ids and M is the average number of dst_key_ids per party

Even though decryption only occurs for matching key_ids (line 1075), the iteration and memory allocation occur unconditionally.

### Impact Explanation

**Specific Harm:**
A malicious signer can craft a DkgPrivateShares message containing thousands of duplicate party_id entries, each with thousands of dst_key_id entries and large encrypted shares. This causes:

1. **Memory Exhaustion:** The entire message is stored in `self.dkg_private_shares`. With parameters like 1,000 party_ids × 1,000 dst_key_ids × 1KB encrypted shares = ~1GB per message
2. **CPU Exhaustion:** O(N×M) iteration cost. With 1,000 × 1,000 = 1,000,000 HashMap lookups and iterations, plus HashMap allocations for each party_id

**Who is Affected:**
All signers participating in the DKG are vulnerable. If enough signers are DoS'd, the DKG cannot complete, preventing the threshold signature system from functioning and blocking any operations that depend on it.

**Severity Justification:**
This maps to **Low** severity under the protocol scope: "Any remotely-exploitable denial of service in a node." The attack requires no cryptographic breaks and can be executed by any registered signer to crash or severely degrade victim signer nodes.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a registered signer in the DKG with a valid signer_id and private key
- Ability to send signed messages to other signers during the DKG phase

**Attack Complexity:**
Low. The attacker simply constructs a malicious DkgPrivateShares message with repeated party_ids and large HashMaps, signs it with their private key, and broadcasts it. The message passes all validation checks because:
- In v2: signer_id == party_id validation passes for repeated entries [7](#0-6) 
- In v1: party_id validation passes if attacker owns those key_ids [8](#0-7) 

**Economic Feasibility:**
Trivial. Once registered as a signer, the attack requires minimal resources - just crafting and sending a single large message.

**Detection Risk:**
The attack is easily detectable through memory/CPU monitoring, but by the time it's detected, victim nodes may already be unresponsive.

**Estimated Probability:**
High, given the low prerequisites and attack complexity.

### Recommendation

**Proposed Code Changes:**

Add bounds validation in the `dkg_private_shares` handler before processing:

```rust
// After line 1056, before line 1058, add:

// Validate bounds on shares structure
const MAX_PARTY_IDS_PER_MESSAGE: usize = 100; // Adjust based on max keys per signer
const MAX_DST_KEY_IDS_PER_PARTY: usize = 1000; // Adjust based on max total keys in DKG
const MAX_ENCRYPTED_SHARE_SIZE: usize = 1024; // Encrypted scalar should be ~32 bytes + overhead

if dkg_private_shares.shares.len() > MAX_PARTY_IDS_PER_MESSAGE {
    warn!("DkgPrivateShares has too many party_id entries: {}", dkg_private_shares.shares.len());
    return Ok(vec![]);
}

// Check for duplicate party_ids
let mut seen_party_ids = HashSet::new();
for (party_id, inner_shares) in &dkg_private_shares.shares {
    if !seen_party_ids.insert(*party_id) {
        warn!("DkgPrivateShares contains duplicate party_id: {}", party_id);
        return Ok(vec![]);
    }
    
    if inner_shares.len() > MAX_DST_KEY_IDS_PER_PARTY {
        warn!("DkgPrivateShares party_id {} has too many dst_key_ids: {}", party_id, inner_shares.len());
        return Ok(vec![]);
    }
    
    for (dst_key_id, encrypted_share) in inner_shares {
        if encrypted_share.len() > MAX_ENCRYPTED_SHARE_SIZE {
            warn!("DkgPrivateShares has oversized encrypted share for dst_key_id {}: {} bytes", dst_key_id, encrypted_share.len());
            return Ok(vec![]);
        }
    }
}
```

**Alternative Mitigations:**
- Implement message size limits at the network/serialization layer
- Add rate limiting per signer to prevent repeated large messages
- Consider using bounded collections for the shares structure

**Testing Recommendations:**
- Add unit tests that send DkgPrivateShares with excessive entries and verify rejection
- Add integration tests that measure memory/CPU usage with realistic and malicious messages
- Test with maximum legitimate message sizes to ensure bounds are appropriate

**Deployment Considerations:**
- Coordinate bounds values with network operators based on actual DKG configurations
- Deploy as a non-breaking change since it only adds validation
- Monitor for false positives in production before enforcing strict limits

### Proof of Concept

**Exploitation Algorithm:**

1. Attacker registers as a legitimate signer with signer_id = ATTACKER_ID
2. Wait for DKG to begin and receive DkgPrivateBegin message
3. Construct malicious DkgPrivateShares:
   ```
   DkgPrivateShares {
       dkg_id: <current_dkg_id>,
       signer_id: ATTACKER_ID,
       shares: repeat 1000 times {
           (ATTACKER_ID, HashMap with 1000 entries {
               dst_key_id_i: Vec<u8> of 10KB random data
           })
       }
   }
   ```
4. Sign the message with attacker's private key
5. Broadcast to all signers

**Parameter Values:**
- 1,000 duplicate party_ids
- 1,000 dst_key_ids per party_id  
- 10KB per encrypted share
- Total message size: ~10GB
- Total iteration count: 1,000,000

**Expected vs Actual Behavior:**

Expected: Message should be rejected due to unreasonable size/structure

Actual: 
- Message passes validation at lines 1047-1056 (all party_ids equal ATTACKER_ID, which the attacker owns)
- Entire 10GB message is cloned and stored at line 1064
- Victim signer performs 1,000,000 HashMap iterations at lines 1072-1074
- Victim signer exhausts memory or hangs on CPU-intensive iteration
- DKG cannot complete due to unresponsive signers

**Reproduction Instructions:**
1. Set up a test DKG with multiple signers
2. Modify one signer to send the malicious message structure above
3. Observe memory and CPU usage on victim signers
4. Verify that victim signers become unresponsive or crash

### Citations

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/state_machine/signer/mod.rs (L1028-1110)
```rust
    /// handle incoming DkgPrivateShares
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/v2.rs (L644-650)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        _signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        signer_id == party_id
    }
```

**File:** src/v1.rs (L696-705)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        match signer_key_ids.get(&signer_id) {
            Some(key_ids) => key_ids.contains(&party_id),
            None => false,
        }
    }
```
