### Title
FROST Coordinator State Deserialization Panic Enables Persistent Denial of Service

### Summary
The FROST coordinator's `load()` function performs an unsafe index operation on the `message_nonces` map without validation, causing a panic when restoring state that lacks the expected empty-vector key. An attacker who can inject a malformed `SavedState` (via file corruption, deserialization attack, or direct API access) can crash the coordinator and prevent recovery if the malformed state persists, blocking all signing operations.

### Finding Description

**Exact Location:** [1](#0-0) 

The FROST coordinator's `load()` function on line 837 directly indexes `state.message_nonces[&Vec::new()]` without checking whether this key exists in the BTreeMap. This operation will panic with "key not found" if the map does not contain an entry for the empty vector key.

**Root Cause:**
The function assumes that any `SavedState` passed to it will always contain a `Vec::new()` key in the `message_nonces` field, based on the invariant established by the `save()` function: [2](#0-1) 

However, `SavedState` is a public struct with public fields and a `Default` derive: [3](#0-2) 

This means:
1. Anyone can construct a `SavedState` manually with `SavedState::default()` or by direct field initialization
2. The `message_nonces` map can be empty or contain arbitrary keys
3. No validation is performed before the unsafe indexing operation
4. The FIRE coordinator avoids this issue by safely cloning the entire map: [4](#0-3) 

**Why Existing Mitigations Fail:**
- No validation logic exists in `load()` to check for required keys
- No try-catch mechanism around the indexing operation  
- No bounds checking or safe accessor methods (`.get()`) are used
- The public API allows external construction of invalid `SavedState` instances

### Impact Explanation

**Specific Harm:**
When a coordinator attempts to load a malformed `SavedState`, the process panics and crashes immediately. If this malformed state is persisted to disk or repeatedly provided through an API, the coordinator enters a crash loop and cannot recover.

**Chain-Level Impact:**
In a threshold signature system, coordinators orchestrate DKG and signing rounds. If a coordinator crashes and cannot restart:
1. **Ongoing signing rounds fail** - Any in-progress signature generation is aborted
2. **New signing rounds cannot start** - No new transactions can be signed
3. **DKG rounds cannot complete** - Key generation is blocked

If this affects multiple coordinators or the primary coordinator in a deployment where redundancy is insufficient, the network cannot sign transactions for multiple blocks, meeting the **Critical** severity criteria: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

**Quantified Impact:**
- Single coordinator deployment: Complete signing failure until manual intervention
- Multi-coordinator deployment: Signing may succeed if threshold can be met without crashed coordinator(s)
- Recovery time: Depends on detecting the root cause and manually fixing the persisted state
- Affected operations: All signing, DKG, and coordination operations

**Who Is Affected:**
Any deployment using the FROST coordinator variant (not FIRE) where `SavedState` is loaded from external sources, including:
- Coordinators that persist state to disk and reload on restart
- Coordinators that accept state via network protocols
- Systems that programmatically construct `SavedState` instances

### Likelihood Explanation

**Required Attacker Capabilities:**
1. **File system access**: If state is persisted to disk, attacker needs write access to the state file
2. **Network access**: If state can be provided via API/RPC, attacker needs network access to that interface
3. **Deserialization control**: If state is deserialized from untrusted sources, attacker controls serialized data

**Attack Complexity:**
**Low** - The exploit is trivial:
```rust
// Attacker constructs malformed state
let malicious_state = SavedState {
    message_nonces: BTreeMap::new(), // Empty map - missing Vec::new() key
    ..Default::default()
};

// Coordinator crashes on load
let coordinator = FrostCoordinator::load(&malicious_state); // PANIC!
```

**Exploitation Path:**
1. Attacker identifies coordinator using FROST variant
2. Attacker gains ability to provide/modify `SavedState` (file access, API access, or deserialization vector)
3. Attacker creates `SavedState` with empty or incomplete `message_nonces` map
4. Attacker injects malformed state
5. Coordinator crashes on next load attempt
6. If state persists, coordinator cannot recover without manual intervention

**Economic Feasibility:**
Minimal resources required - only need ability to write a file or send a crafted payload.

**Detection Risk:**
Low - The crash appears as a panic, which might be attributed to various causes. Without deep code inspection, the root cause may not be immediately obvious.

**Probability of Success:**
**High** if attacker has access to state injection vector. The vulnerability is deterministic - a malformed state will always cause a panic.

### Recommendation

**Primary Fix - Add Validation:**
Replace the unsafe index operation in `load()` with safe access:

```rust
fn load(state: &SavedState) -> Self {
    let public_nonces = state.message_nonces
        .get(&Vec::new())
        .map(|info| info.public_nonces.clone())
        .unwrap_or_default();
    
    Self {
        aggregator: Aggregator::new(state.config.num_keys, state.config.threshold),
        config: state.config.clone(),
        // ... other fields ...
        public_nonces,
        // ... remaining fields ...
    }
}
```

**Alternative - Add Comprehensive Validation:**
Create a validation function that checks all invariants:

```rust
impl SavedState {
    fn validate(&self) -> Result<(), Error> {
        // Check message_nonces contains expected keys
        if !self.message_nonces.contains_key(&Vec::new()) {
            return Err(Error::InvalidSavedState("missing default message nonces"));
        }
        
        // Validate other critical fields
        // - Check state enum is valid for current round IDs
        // - Verify polynomial counts match config
        // - Ensure key ID consistency
        
        Ok(())
    }
}

fn load(state: &SavedState) -> Result<Self, Error> {
    state.validate()?;
    // ... rest of load logic ...
}
```

**Testing Recommendations:**
1. Add unit test for loading `SavedState::default()`
2. Add fuzz testing for `load()` with randomized `SavedState` instances
3. Add integration tests for state corruption scenarios
4. Verify FIRE coordinator's safe implementation is used as reference

**Deployment Considerations:**
1. If state files exist in production, validate them before upgrading
2. Add integrity checks (signatures/MACs) for persisted state
3. Implement graceful degradation if state loading fails
4. Add monitoring/alerting for coordinator crashes

### Proof of Concept

**Exploitation Steps:**

1. **Create malformed SavedState:**
```rust
use wsts::state_machine::coordinator::{SavedState, frost::Coordinator};
use wsts::v2::Aggregator; // or v1::Aggregator

// Method 1: Use Default which creates empty message_nonces
let bad_state = SavedState::default();

// Method 2: Manually construct with missing key
let bad_state = SavedState {
    message_nonces: std::collections::BTreeMap::new(),
    ..Default::default()
};
```

2. **Trigger panic:**
```rust
// This will panic: "key not found: []"
let coordinator = Coordinator::<Aggregator>::load(&bad_state);
```

3. **Persist attack:**
If state is persisted to disk:
```rust
// Serialize malformed state and write to coordinator's state file
let malformed = serde_json::to_string(&bad_state)?;
std::fs::write("/path/to/coordinator/state.json", malformed)?;

// Coordinator crashes on next restart when loading state
```

**Expected Behavior:**
The coordinator should either:
- Successfully load with default/empty nonces, OR
- Return a validation error that can be handled gracefully

**Actual Behavior:**
The coordinator panics with a "key not found" error, crashing the process.

**Reproduction Instructions:**
1. Build WSTS with FROST coordinator enabled
2. Create a test that calls `Coordinator::load(&SavedState::default())`
3. Observe panic at line 837 of frost.rs
4. Compare with FIRE coordinator which handles this correctly at line 1320 of fire.rs

### Citations

**File:** src/state_machine/coordinator/frost.rs (L826-847)
```rust
    fn load(state: &SavedState) -> Self {
        Self {
            aggregator: Aggregator::new(state.config.num_keys, state.config.threshold),
            config: state.config.clone(),
            current_dkg_id: state.current_dkg_id,
            current_sign_id: state.current_sign_id,
            current_sign_iter_id: state.current_sign_iter_id,
            dkg_public_shares: state.dkg_public_shares.clone(),
            dkg_private_shares: state.dkg_private_shares.clone(),
            dkg_end_messages: state.dkg_end_messages.clone(),
            party_polynomials: state.party_polynomials.clone(),
            public_nonces: state.message_nonces[&Vec::new()].public_nonces.clone(),
            signature_shares: state.signature_shares.clone(),
            aggregate_public_key: state.aggregate_public_key,
            signature: state.signature.clone(),
            schnorr_proof: state.schnorr_proof.clone(),
            message: state.message.clone(),
            ids_to_await: state.dkg_wait_signer_ids.clone(),
            state: state.state.clone(),
            coordinator_public_key: state.coordinator_public_key,
        }
    }
```

**File:** src/state_machine/coordinator/frost.rs (L849-886)
```rust
    fn save(&self) -> SavedState {
        let round_info = SignRoundInfo {
            public_nonces: self.public_nonces.clone(),
            nonce_recv_key_ids: Default::default(),
            sign_recv_key_ids: Default::default(),
            sign_wait_signer_ids: Default::default(),
        };
        let mut message_nonces = BTreeMap::new();

        message_nonces.insert(Vec::new(), round_info);

        SavedState {
            config: self.config.clone(),
            current_dkg_id: self.current_dkg_id,
            current_sign_id: self.current_sign_id,
            current_sign_iter_id: self.current_sign_iter_id,
            dkg_public_shares: self.dkg_public_shares.clone(),
            dkg_private_shares: self.dkg_private_shares.clone(),
            dkg_end_messages: self.dkg_end_messages.clone(),
            party_polynomials: self.party_polynomials.clone(),
            message_nonces,
            signature_shares: self.signature_shares.clone(),
            aggregate_public_key: self.aggregate_public_key,
            signature: self.signature.clone(),
            schnorr_proof: self.schnorr_proof.clone(),
            message: self.message.clone(),
            dkg_wait_signer_ids: self.ids_to_await.clone(),
            state: self.state.clone(),
            dkg_public_start: Default::default(),
            dkg_private_start: Default::default(),
            dkg_end_start: Default::default(),
            nonce_start: Default::default(),
            sign_start: Default::default(),
            malicious_signer_ids: Default::default(),
            malicious_dkg_signer_ids: Default::default(),
            coordinator_public_key: self.coordinator_public_key,
        }
    }
```

**File:** src/state_machine/coordinator/mod.rs (L247-298)
```rust
/// The saved state required to reconstruct a coordinator
#[derive(Default, Clone, Debug, PartialEq)]
pub struct SavedState {
    /// common config fields
    pub config: Config,
    /// current DKG round ID
    pub current_dkg_id: u64,
    /// current signing round ID
    pub current_sign_id: u64,
    /// current signing iteration ID
    pub current_sign_iter_id: u64,
    /// map of DkgPublicShares indexed by signer ID
    pub dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    /// map of DkgPrivateShares indexed by signer ID
    pub dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
    /// map of DkgEnd indexed by signer ID
    pub dkg_end_messages: BTreeMap<u32, DkgEnd>,
    /// the current view of a successful DKG's participants' commitments
    pub party_polynomials: HashMap<u32, PolyCommitment>,
    /// map of SignatureShare indexed by signer ID
    pub signature_shares: BTreeMap<u32, Vec<SignatureShare>>,
    /// map of SignRoundInfo indexed by message bytes
    pub message_nonces: BTreeMap<Vec<u8>, SignRoundInfo>,
    /// aggregate public key
    pub aggregate_public_key: Option<Point>,
    /// current Signature
    pub signature: Option<Signature>,
    /// current SchnorrProof
    pub schnorr_proof: Option<SchnorrProof>,
    /// which signers we're currently waiting on for DKG
    pub dkg_wait_signer_ids: HashSet<u32>,
    /// the bytes that we're signing
    pub message: Vec<u8>,
    /// current state of the state machine
    pub state: State,
    /// start time for NonceRequest
    pub nonce_start: Option<Instant>,
    /// start time for DkgBegin
    pub dkg_public_start: Option<Instant>,
    /// start time for DkgPrivateBegin
    pub dkg_private_start: Option<Instant>,
    /// start time for DkgEndBegin
    pub dkg_end_start: Option<Instant>,
    /// start time for SignatureShareRequest
    pub sign_start: Option<Instant>,
    /// set of malicious signers during signing round
    pub malicious_signer_ids: HashSet<u32>,
    /// set of malicious signers during dkg round
    pub malicious_dkg_signer_ids: HashSet<u32>,
    /// coordinator public key
    pub coordinator_public_key: Option<ecdsa::PublicKey>,
}
```

**File:** src/state_machine/coordinator/fire.rs (L1309-1337)
```rust
    fn load(state: &SavedState) -> Self {
        Self {
            aggregator: Aggregator::new(state.config.num_keys, state.config.threshold),
            config: state.config.clone(),
            current_dkg_id: state.current_dkg_id,
            current_sign_id: state.current_sign_id,
            current_sign_iter_id: state.current_sign_iter_id,
            dkg_public_shares: state.dkg_public_shares.clone(),
            dkg_private_shares: state.dkg_private_shares.clone(),
            dkg_end_messages: state.dkg_end_messages.clone(),
            party_polynomials: state.party_polynomials.clone(),
            message_nonces: state.message_nonces.clone(),
            signature_shares: state.signature_shares.clone(),
            aggregate_public_key: state.aggregate_public_key,
            signature: state.signature.clone(),
            schnorr_proof: state.schnorr_proof.clone(),
            message: state.message.clone(),
            dkg_wait_signer_ids: state.dkg_wait_signer_ids.clone(),
            state: state.state.clone(),
            dkg_public_start: state.dkg_public_start,
            dkg_private_start: state.dkg_private_start,
            dkg_end_start: state.dkg_end_start,
            nonce_start: state.nonce_start,
            sign_start: state.sign_start,
            malicious_signer_ids: state.malicious_signer_ids.clone(),
            malicious_dkg_signer_ids: state.malicious_dkg_signer_ids.clone(),
            coordinator_public_key: state.coordinator_public_key,
        }
    }
```
