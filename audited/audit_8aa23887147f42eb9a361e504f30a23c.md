### Title
Missing Polynomial Commitment Validation in Coordinator State Initialization

### Summary
The `set_key_and_party_polynomials()` method verifies that polynomial commitments sum to the aggregate key but fails to validate the commitments themselves (Schnorr ID proofs and polynomial lengths). This allows injection of invalid DKG state that can cause signature verification failures or enable signature forgery attacks.

### Finding Description

**Location:**
- File: `src/state_machine/coordinator/frost.rs`, lines 904-926
- File: `src/state_machine/coordinator/fire.rs`, lines 1384-1406 [1](#0-0) 

**Root Cause:**

The method performs only two checks:
1. Verifies that the sum of polynomial constant terms (`comm.poly[0]`) equals the provided `aggregate_key`
2. Checks for duplicate party IDs

It completely omits critical validation that occurs during normal DKG flow:
- **Schnorr ID proof verification** via `PolyCommitment::verify(ctx)` 
- **Polynomial length validation** (should equal threshold) [2](#0-1) 

During normal DKG, polynomial commitments are validated using `check_public_shares()`, which verifies both the Schnorr proof and polynomial length. The `set_key_and_party_polynomials()` method bypasses this entirely.

**Why Existing Mitigations Fail:**

The method is designed for "Initialize Coordinator from partial saved state" and assumes the input is trusted. There are no runtime validations to detect invalid polynomial commitments. The aggregator's `init()` method blindly sums the polynomial coefficients without validation: [3](#0-2) 

### Impact Explanation

**Specific Harm:**

1. **Denial of Service**: Invalid polynomial coefficients cause the aggregator to compute incorrect public keys during signature verification. Valid signature shares from honest signers will fail verification at: [4](#0-3) 

2. **Signature Forgery**: An attacker who carefully crafts polynomial commitments can manipulate the aggregator's polynomial evaluation to output public keys they control. By providing signature shares that verify under these manipulated keys, the attacker can forge signatures that pass verification, leading to **confirmation of invalid transactions** (Critical severity per scope).

**Quantified Impact:**
- All honest signature shares will be rejected if polynomials are corrupted
- Threshold security is completely bypassed if attacker controls t keys through polynomial manipulation
- In blockchain context: invalid transactions signed by forged threshold signatures could be confirmed

**Affected Parties:**
- Any system loading coordinator state from external storage
- Blockchain networks relying on WSTS for transaction authorization
- Multi-signature wallets using WSTS

**Severity Justification:**
Critical - This breaks the fundamental DKG security invariant "Public polynomial commitments must verify and match declared degrees" and can lead to "confirmation of an invalid transaction" per the defined scope.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Ability to call `set_key_and_party_polynomials()` with malicious input
2. Control over coordinator state storage (database, filesystem, network-based state sync)
3. Knowledge of polynomial arithmetic to craft commitments that sum correctly
4. (For forgery) Control of private keys corresponding to manipulated public keys

**Attack Complexity:**
- Medium to High: Requires infrastructure compromise, not pure network attack
- Polynomial manipulation requires cryptographic expertise
- Must carefully balance coefficients to maintain aggregate key constraint

**Economic Feasibility:**
- High value target: Compromising threshold signature coordinator enables fund theft
- Infrastructure attacks are realistic (database injection, file tampering, supply chain)
- Cost depends on deployment security posture

**Detection Risk:**
- Low: Polynomial commitments appear valid (sum to correct aggregate key)
- No runtime warnings or validation failures
- Signature verification errors may be attributed to network issues

**Estimated Probability:**
Medium - The function is an external API not used internally, limiting exposure. However, any system that persists and restores coordinator state is vulnerable.

### Recommendation

**Primary Fix:**
Add comprehensive validation to `set_key_and_party_polynomials()`:

```rust
fn set_key_and_party_polynomials(
    &mut self,
    aggregate_key: Point,
    party_polynomials: Vec<(u32, PolyCommitment)>,
) -> Result<(), Error> {
    // Validate each polynomial commitment
    let threshold: usize = self.config.threshold.try_into()?;
    for (party_id, comm) in &party_polynomials {
        if !check_public_shares(comm, threshold, &self.current_dkg_id.to_be_bytes()) {
            return Err(Error::BadPublicShares(*party_id));
        }
    }
    
    // Existing validation...
    let computed_key = party_polynomials
        .iter()
        .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
    if computed_key != aggregate_key {
        return Err(Error::AggregateKeyPolynomialMismatch(computed_key, aggregate_key));
    }
    // ... rest of function
}
```

**Alternative Mitigations:**
1. Authenticate state storage using HMAC or signatures
2. Document security assumptions about trusted state sources
3. Add runtime monitoring for signature verification anomalies

**Testing Recommendations:**
1. Test with invalid Schnorr proofs (corrupted party IDs)
2. Test with incorrect polynomial lengths (too short, too long)
3. Test with polynomials that sum correctly but have wrong higher-order coefficients
4. Verify signature verification detects manipulated polynomials

**Deployment Considerations:**
- Existing stored states may contain unvalidated polynomials
- Consider migration path to re-validate stored DKG results
- Add security warnings to API documentation

### Proof of Concept

**Exploitation Algorithm:**

```
Step 1: Attacker compromises coordinator state storage
  - Target: Database, filesystem, or state sync mechanism
  - Objective: Inject malicious party_polynomials

Step 2: Construct malicious polynomial commitments
  Input: Target aggregate_key, threshold t
  
  For each party_id i:
    - Generate random polynomial f_i of degree t-1
    - Adjust f_i[0] (constant term) so sum equals aggregate_key
    - Create PolyCommitment with corrupted/missing Schnorr proof
    - Note: poly lengths can be arbitrary (not validated)
  
  Constraint: Î£ f_i[0] = aggregate_key

Step 3: Inject via set_key_and_party_polynomials()
  coordinator.set_key_and_party_polynomials(
    aggregate_key,
    malicious_party_polynomials
  )
  
  Result: Accepted (only checks sum, not proofs/lengths)

Step 4: Exploit during signing
  Scenario A (DoS):
    - Honest signers produce valid shares for their key IDs
    - Aggregator computes wrong public keys from malicious polynomials
    - All signature shares fail verification
  
  Scenario B (Forgery):
    - Attacker controls private key k for some key_id
    - Manipulated polynomial evaluates at key_id to k*G
    - Attacker's signature share verifies under manipulated key
    - Threshold signature accepted with attacker's contribution
```

**Expected vs Actual Behavior:**

Expected: `set_key_and_party_polynomials()` should reject polynomial commitments without valid Schnorr proofs or incorrect lengths

Actual: Method accepts any polynomial commitments as long as their constant terms sum to the aggregate key

**Reproduction:**
1. Create coordinator with valid config
2. Generate polynomial commitments with corrupted Schnorr proofs
3. Ensure sum of poly[0] values equals some aggregate_key
4. Call `set_key_and_party_polynomials(aggregate_key, malicious_polynomials)`
5. Observe: No error returned
6. Attempt signature aggregation
7. Observe: Valid signatures fail verification or invalid signatures accepted

### Citations

**File:** src/state_machine/coordinator/frost.rs (L904-926)
```rust
    fn set_key_and_party_polynomials(
        &mut self,
        aggregate_key: Point,
        party_polynomials: Vec<(u32, PolyCommitment)>,
    ) -> Result<(), Error> {
        let computed_key = party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
        if computed_key != aggregate_key {
            return Err(Error::AggregateKeyPolynomialMismatch(
                computed_key,
                aggregate_key,
            ));
        }
        let party_polynomials_len = party_polynomials.len();
        let party_polynomials = HashMap::from_iter(party_polynomials);
        if party_polynomials.len() != party_polynomials_len {
            return Err(Error::DuplicatePartyId);
        }
        self.aggregate_public_key = Some(aggregate_key);
        self.party_polynomials = party_polynomials;
        Ok(())
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/v2.rs (L395-408)
```rust
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/v2.rs (L431-445)
```rust
    fn init(&mut self, comms: &HashMap<u32, PolyCommitment>) -> Result<(), AggregatorError> {
        let threshold: usize = self.threshold.try_into()?;
        let mut poly = Vec::with_capacity(threshold);

        for i in 0..poly.capacity() {
            poly.push(Point::zero());
            for (_, comm) in comms {
                poly[i] += &comm.poly[i];
            }
        }

        self.poly = poly;

        Ok(())
    }
```
