### Title
Unbounded Polynomial Vector Size in DkgPublicShares Enables Memory and CPU Exhaustion DoS

### Summary
The `DkgPublicShares` message structure allows signers to send polynomial commitment vectors of arbitrary size without validation before deserialization and signature verification. A malicious signer can craft messages with extremely large poly vectors (e.g., millions of points) causing recipient nodes to exhaust memory during deserialization and CPU during hash computation for signature verification, resulting in denial of service that prevents DKG completion.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the `DkgPublicShares` struct and its processing: [1](#0-0) 

The `PolyCommitment` structure contains an unbounded vector: [2](#0-1) 

**Root Cause:**

The `DkgPublicShares` message contains a `comms` field which is a `Vec<(u32, PolyCommitment)>`, where each `PolyCommitment` has a `poly: Vec<Point>` field with no size constraints. When a packet is received and processed:

1. The entire message is deserialized from the network, allocating memory for all Points in all poly vectors
2. If signature verification is enabled, `Packet::verify()` is called: [3](#0-2) 

3. The verification calls `msg.hash()` which iterates over every Point in every poly vector and calls the expensive `compress()` operation on each: [4](#0-3) 

4. Size validation against the expected threshold only occurs much later in `dkg_ended()`: [5](#0-4) 

**Why Existing Mitigations Fail:**

The coordinator's `gather_public_shares` function performs no size validation: [6](#0-5) 

The signer's `dkg_public_share` function also performs no size validation before storing the message: [7](#0-6) 

The `check_public_shares` validation function correctly checks that `poly.len() == threshold`: [8](#0-7) 

However, this validation only occurs AFTER the message has been fully deserialized and hashed for signature verification, making it ineffective against this attack.

### Impact Explanation

**What Specific Harm Occurs:**

A malicious signer can send `DkgPublicShares` messages with poly vectors containing millions of Points, causing:

1. **Memory Exhaustion**: Each Point requires approximately 64 bytes in memory (two 32-byte coordinates). An attacker sending 1,000,000 points across 10 commitments would allocate ~640 MB per message. Multiple such messages can exhaust node memory.

2. **CPU Exhaustion**: The `hash()` function must iterate over all points and perform point compression (extracting x-coordinate and computing y-parity) for each. Processing millions of points causes significant CPU consumption.

3. **DKG Failure**: Victims experiencing memory/CPU exhaustion cannot complete DKG, preventing the protocol from establishing the distributed key required for signing.

4. **Signing Prevention**: Without successful DKG, no signatures can be generated, effectively halting the threshold signature system.

**Quantified Impact:**

Expected poly size based on typical configuration: [9](#0-8) 

For 10 signers with 2 keys each (20 total keys), threshold is 14, meaning poly vectors should contain exactly 14 Points. An attacker sending 1,000,000 Points per commitment represents a 71,000x amplification.

**Who Is Affected:**

All coordinators and signers receiving the malicious message are affected, potentially causing network-wide DKG failure if the attacker is included in the signer set.

**Severity Justification:**

This maps to **Medium severity** under "Any transient consensus failures" if WSTS is used in a blockchain context where DKG failure prevents block production or transaction confirmation. It also qualifies as **Low severity** under "Any remotely-exploitable denial of service in a node."

### Likelihood Explanation

**Required Attacker Capabilities:**

- Must be a registered signer with a valid signing key
- Access to network communication channel
- Ability to construct and sign network messages

**Attack Complexity:**

The attack is trivial to execute:
1. Generate a valid `DkgPublicShares` message structure
2. Populate `comms` with polynomial commitments containing millions of Points
3. Sign the message with the attacker's valid private key
4. Send to coordinators and other signers

**Economic Feasibility:**

The attack is economically feasible:
- Cost: Minimal (only network bandwidth to send large messages)
- Benefit: Complete DoS of DKG process
- No special infrastructure required

**Detection Risk:**

Detection is possible through:
- Message size monitoring (messages would be abnormally large)
- CPU usage monitoring during message processing
- Memory consumption monitoring

However, detection occurs AFTER resource consumption has begun, limiting its effectiveness as a mitigation.

**Estimated Probability of Success:**

High (>90%) - The attack requires only valid signer credentials and basic network access. No timing windows, race conditions, or cryptographic breaks are required.

### Recommendation

**Immediate Fix:**

Validate poly vector sizes BEFORE deserialization and hashing. Add size checks in the message processing pipeline:

1. Add a validation function that checks poly size against threshold before calling `hash()`:

```rust
fn validate_poly_sizes(msg: &DkgPublicShares, threshold: usize) -> Result<(), Error> {
    for (_, comm) in &msg.comms {
        if comm.poly.len() != threshold {
            return Err(Error::InvalidPolySize(comm.poly.len(), threshold));
        }
    }
    Ok(())
}
```

2. Call this validation in both coordinator and signer message handlers before signature verification.

3. For defense in depth, add a reasonable upper bound check even before threshold comparison:

```rust
const MAX_POLY_SIZE: usize = 1000; // Conservative upper bound
if comm.poly.len() > MAX_POLY_SIZE {
    return Err(Error::PolySizeTooLarge(comm.poly.len()));
}
```

**Alternative Mitigations:**

- Implement network-level message size limits
- Use streaming deserialization with size checks
- Add rate limiting on DkgPublicShares messages per signer

**Testing Recommendations:**

1. Unit test with oversized poly vectors
2. Integration test measuring memory consumption
3. Performance test measuring hash time with various poly sizes
4. Fuzzing test with random poly sizes

**Deployment Considerations:**

- This fix requires coordinated deployment across all nodes
- Backwards compatibility: Legitimate messages will continue to work
- No changes to cryptographic operations required

### Proof of Concept

**Exploitation Algorithm:**

```
1. Attacker setup:
   - Obtain valid signer credentials (signer_id, private_key)
   - Identify current DKG round ID

2. Craft malicious DkgPublicShares:
   - Create Vec<(u32, PolyCommitment)> comms
   - For each party_id controlled by attacker:
     * Create PolyCommitment with valid ID proof
     * Set poly vector size to 1,000,000 Points
     * Populate with random/repeated Points
   - Set kex_public_key to valid Point

3. Sign and send:
   - Call msg.sign(private_key) to create valid signature
   - Create Packet { msg, sig }
   - Broadcast to all coordinators and signers

4. Victim impact:
   - Receives and deserializes message (allocates ~640 MB)
   - Calls Packet::verify() which invokes msg.hash()
   - Iterates 10,000,000 times calling Point.compress()
   - Experiences CPU spike and potential OOM
   - DKG fails to complete

5. Result:
   - Network cannot establish distributed key
   - No signatures can be generated
   - Denial of service achieved
```

**Expected vs Actual Behavior:**

- **Expected**: DkgPublicShares rejected early with "invalid poly size" error
- **Actual**: Message fully deserialized and hashed before validation, consuming excessive resources

**Reproduction Instructions:**

1. Set up WSTS test network with verify_packet_sigs=true
2. Modify test to create DkgPublicShares with poly.len() = 1,000,000
3. Send to coordinator/signer and observe:
   - High memory allocation during deserialization
   - CPU spike during hash computation
   - Delayed or failed DKG completion

### Citations

**File:** src/net.rs (L139-164)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}

impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/signer/mod.rs (L557-562)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/mod.rs (L580-582)
```rust
        let num_keys = num_signers * keys_per_signer;
        let threshold = (num_keys * 7) / 10;
        let dkg_threshold = (num_keys * 9) / 10;
```
