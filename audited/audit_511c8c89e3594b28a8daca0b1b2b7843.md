# Audit Report

## Title
FIRE Coordinator Panic Due to Premature Wait List Removal Before Validation

## Summary
The FIRE coordinator's `gather_sig_shares()` function contains a critical ordering bug where signers are removed from the wait list before their signature shares are validated. When validation fails for a signer, the coordinator panics during aggregation because it attempts to access non-existent signature shares. Any malicious signer can exploit this to crash the coordinator process, preventing signature production and potentially halting network transaction confirmation.

## Finding Description

The vulnerability exists in the signature share gathering logic where the coordinator processes responses from signers during the signing protocol.

**Premature Removal:** The coordinator removes a signer from the wait list immediately upon receiving their response, before any validation checks are performed. [1](#0-0) 

**Validation Checks:** After removal, the function performs several validation checks that can fail:
- Verifying the signer's public key exists in the configuration [2](#0-1) 
- Checking that key IDs are configured for the signer [3](#0-2) 
- Validating that the provided key IDs match the configuration [4](#0-3) 

**Missing Insertion:** When any validation check fails, the function returns an error without inserting the signature shares into the coordinator's storage. The insertion only occurs after successful validation. [5](#0-4) 

**Panic During Aggregation:** When all signers have responded (the wait list becomes empty), the coordinator triggers aggregation. [6](#0-5)  The aggregation code iterates over all signers who sent nonces and attempts to access their signature shares using the BTreeMap indexing operator. [7](#0-6)  For signers whose validation failed, this access panics because Rust's BTreeMap `[]` operator panics on missing keys.

**Error Handling Insufficient:** While errors from `gather_sig_shares()` are caught and converted to operation results, [8](#0-7)  panics are not caught and will crash the entire coordinator process.

**Correct Implementation in FROST:** The FROST coordinator implements the correct ordering by removing signers from the wait list only AFTER successful validation and insertion. [9](#0-8)  This prevents the panic condition from occurring.

## Impact Explanation

This vulnerability enables a **denial of service attack** against the FIRE coordinator. A malicious signer can crash the coordinator process by sending valid nonces followed by invalid signature shares. The crash prevents all signature production until the coordinator is manually restarted.

The severity depends on the deployment architecture:
- **Critical impact** if the coordinator is a single point of failure for network consensus (e.g., in blockchain systems using threshold signatures for block signing)
- **Low impact** as a remotely-exploitable node-level denial of service in less critical deployments

In systems like Stacks where the coordinator may be critical for transaction confirmation, this maps to the Critical severity definition: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

The attack is repeatable - a malicious signer can trigger this on every signing round, causing sustained disruption until the malicious signer is identified and removed from the system.

## Likelihood Explanation

**Attacker Capabilities:** Any registered signer in the WSTS system can exploit this vulnerability. No special privileges, cryptographic breaks, or elevated access is required.

**Attack Complexity:** Trivial. The exploitation steps are:
1. Respond normally to `NonceRequest` with valid nonces (to get included in the signing round)
2. When receiving `SignatureShareRequest`, send a response with invalid data (e.g., mismatched `key_ids`, missing public key, etc.)
3. The coordinator removes the attacker from the wait list before validation
4. Validation fails and returns error without inserting shares
5. When all other signers respond, the coordinator attempts aggregation and panics

**Economic Feasibility:** Zero cost beyond standard network participation. No computational resources or financial investment required.

**Detection Risk:** Low. The attacker appears as a signer with validation errors, which could initially be attributed to implementation bugs or network issues rather than malicious behavior.

**Probability of Success:** 100%. The vulnerability is deterministic - any invalid signature share after a valid nonce will trigger the panic when the wait list empties.

## Recommendation

Reorder the operations in `gather_sig_shares()` to match the FROST coordinator's correct implementation:

1. Perform all validation checks FIRST
2. Insert signature shares into storage
3. Only then remove the signer from the wait list

The corrected sequence should be:
- Lines 1046-1076: Perform validation checks (existing code)
- Lines 1088-1091: Insert signature shares (existing code)
- Lines 1042-1044: Remove from wait list (move this block to after insertion)

Additionally, consider adding defensive programming by using `.get()` instead of the indexing operator when accessing `signature_shares` during aggregation, and handling the missing key case gracefully.

## Proof of Concept

```rust
#[test]
fn test_fire_coordinator_panic_on_invalid_sig_share() {
    use crate::state_machine::coordinator::fire::Coordinator as FireCoordinator;
    use crate::v2;
    use crate::net::{Message, Packet, SignatureShareResponse};
    
    // Setup: Create coordinator with 2 signers, threshold 2
    let (mut coordinators, signers) = setup::<FireCoordinator<v2::Aggregator>, v2::Signer>(2, 1);
    let mut coordinator = coordinators.remove(0);
    
    // Run DKG to completion
    run_dkg_sign(&mut coordinator, &signers, SignatureType::Schnorr, false);
    
    // Start new signing round
    coordinator.start_signing_round(b"test message", SignatureType::Schnorr, None).unwrap();
    
    // Signer 0 sends valid nonce (gets added to wait list and public_nonces)
    let nonce_response_0 = signers[0].process_nonce_request(/* ... */);
    coordinator.process_message(&nonce_response_0).unwrap();
    
    // Signer 1 sends valid nonce
    let nonce_response_1 = signers[1].process_nonce_request(/* ... */);
    coordinator.process_message(&nonce_response_1).unwrap();
    
    // Coordinator sends signature share request
    // Signer 1 sends valid signature share
    let sig_share_1 = signers[1].process_signature_share_request(/* ... */);
    coordinator.process_message(&sig_share_1).unwrap();
    
    // Signer 0 sends INVALID signature share (wrong key_ids)
    let invalid_sig_share = SignatureShareResponse {
        signer_id: 0,
        key_ids: vec![999], // Invalid key_id not in config
        signature_shares: vec![],
        // ... other fields
    };
    let invalid_packet = Packet {
        msg: Message::SignatureShareResponse(invalid_sig_share),
        sig: Default::default(),
    };
    
    // This should cause validation to fail, but signer 0 already removed from wait list
    // When both signers have responded, aggregation is triggered
    // Expected: PANIC when trying to access signature_shares[0] which doesn't exist
    coordinator.process_message(&invalid_packet).unwrap();
    // Panic occurs here during aggregation
}
```

This test demonstrates that after signer 0 sends an invalid signature share, the coordinator removes them from the wait list but validation fails. When signer 1's valid response arrives and the wait list becomes empty, aggregation attempts to access `signature_shares[0]` which doesn't exist, causing a panic.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L328-332)
```rust
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1053)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };
```

**File:** src/state_machine/coordinator/fire.rs (L1055-1064)
```rust
        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1113-1114)
```rust
        if message_nonce.sign_wait_signer_ids.is_empty() {
            // Calculate the aggregate signature
```

**File:** src/state_machine/coordinator/fire.rs (L1131-1135)
```rust
            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/state_machine/coordinator/frost.rs (L652-656)
```rust
            self.signature_shares.insert(
                sig_share_response.signer_id,
                sig_share_response.signature_shares.clone(),
            );
            self.ids_to_await.remove(&sig_share_response.signer_id);
```
