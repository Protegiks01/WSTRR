### Title
Malicious Signers Evade Detection by Sending Invalid Nonces Instead of Timing Out

### Summary
The coordinator only marks signers as malicious during signature share timeout, not when they send cryptographically invalid data. Attackers can send invalid nonces with mismatched key IDs or invalid elliptic curve points, causing them to be excluded from the signing wait list before timeout occurs. This allows them to repeatedly disrupt signing rounds without ever being added to the permanent `malicious_signer_ids` set, evading detection and enabling persistent denial of service.

### Finding Description [1](#0-0) 

When a signer sends a nonce response with invalid key IDs, the coordinator validates the data and returns `Ok()` without adding the signer to `sign_wait_signer_ids`. This means the signer's participation is silently rejected. [2](#0-1) 

Similarly, when invalid nonce points are received (points that fail the `is_valid()` check), the response is rejected with `Ok()` return, and the signer is not added to the wait list. [3](#0-2) 

The only mechanism that adds signers to `malicious_signer_ids` is the signature share timeout handler, which marks ALL signers currently in `sign_wait_signer_ids` as malicious. Since attackers who sent invalid nonces were never added to this wait list, they escape being marked as malicious. [4](#0-3) 

The `Error::MaliciousSigner` variant exists but is commented out and never raised. Once a signer is marked malicious via timeout, their future messages are silently dropped with `Ok()` return. [5](#0-4) 

The `reset()` function does not clear `malicious_signer_ids`, meaning the malicious marking persists across signing rounds. However, attackers who send invalid data are never added to this set in the first place.

**Root Cause:** The coordinator conflates two types of bad behavior: (1) timing out due to non-response, and (2) sending cryptographically invalid data. Only timeouts trigger malicious marking, allowing attackers to evade detection by choosing the second attack vector.

### Impact Explanation

An attacker controlling one or more signers can repeatedly disrupt the signing protocol without being permanently excluded:

1. **Signing Disruption**: Each attack prevents threshold from being met, causing signing rounds to fail or timeout
2. **Persistent DoS**: The attacker can repeat this attack indefinitely across multiple signing rounds since they're never marked as malicious
3. **Resource Exhaustion**: Legitimate signers waste computational resources (nonce generation, DH operations) in failed signing attempts
4. **Transient Consensus Failures**: If WSTS is used for blockchain consensus (e.g., Stacks), repeated signing failures could delay block production or transaction confirmation

**Quantified Impact**: With threshold = 28 out of 40 keys, a single malicious signer controlling 13+ keys can prevent signing indefinitely by sending invalid nonces in every round. Even with fewer keys, they can slow down the protocol by forcing retries.

**Severity**: Medium - Maps to "transient consensus failures" in the protocol scope. While invalid signatures cannot be accepted (cryptographic validation prevents this), the repeated disruption can cause consensus delays in dependent systems.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of at least one signer in the WSTS network
- Ability to send messages to the coordinator
- No cryptographic breaks required

**Attack Complexity:** Low
1. Modify nonce response to use wrong key IDs (trivial)
2. Or generate invalid elliptic curve points for nonces (simple)
3. Send crafted response to coordinator
4. Repeat in subsequent signing rounds

**Economic Feasibility:** High - No cost beyond network participation. Attacker joins as legitimate signer and then misbehaves.

**Detection Risk:** Low - The coordinator logs warnings about invalid data but doesn't distinguish between malicious behavior and implementation bugs. External observers see repeated signing failures that could be attributed to network issues.

**Probability of Success:** Very High - The attack is deterministic and requires no race conditions or timing windows.

### Recommendation

**Primary Fix:** Mark signers as malicious when they send invalid cryptographic data, not just on timeout.

```rust
// In gather_nonces(), replace Ok() returns with malicious marking:
if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    self.malicious_signer_ids.insert(nonce_response.signer_id);
    return Ok(());
}

for nonce in &nonce_response.nonces {
    if !nonce.is_valid() {
        warn!("Received invalid nonce from signer {}", nonce_response.signer_id);
        self.malicious_signer_ids.insert(nonce_response.signer_id);
        return Ok(());
    }
}
```

**Alternative Mitigation:** Uncomment and use the `Error::MaliciousSigner` variant to raise errors instead of silently dropping invalid messages, forcing the coordinator to handle malicious behavior explicitly.

**Testing Recommendations:**
1. Add test case where signer sends nonces with wrong key_ids, verify they're marked malicious
2. Add test case where signer sends invalid nonce points, verify they're marked malicious  
3. Verify marked signers remain excluded in subsequent signing rounds
4. Test that threshold can still be met after excluding malicious signers

**Deployment Considerations:** This is a coordinator-side fix only. No changes needed to signers. Deploy to coordinators via rolling update.

### Proof of Concept

**Attack Steps:**

1. Join WSTS network as legitimate signer with ID 5 and key_ids [20, 21, 22]
2. During DKG, participate honestly to establish aggregate public key
3. When coordinator sends `NonceRequest` for signing round:
   ```
   NonceRequest {
       dkg_id: 1,
       sign_id: 1, 
       sign_iter_id: 1,
       message: [0x01, 0x02, ...],
       signature_type: Schnorr
   }
   ```
4. Generate `NonceResponse` with WRONG key_ids:
   ```
   NonceResponse {
       dkg_id: 1,
       sign_id: 1,
       sign_iter_id: 1,
       signer_id: 5,
       key_ids: [23, 24, 25],  // Wrong! Should be [20, 21, 22]
       nonces: [valid_nonce_1, valid_nonce_2, valid_nonce_3],
       message: [0x01, 0x02, ...]
   }
   ```
5. Send response to coordinator

**Expected Behavior:** Coordinator should mark signer 5 as malicious and exclude them from future rounds

**Actual Behavior:**
- Coordinator logs warning: "Nonce response key_ids didn't match config"  
- Returns `Ok()` without adding signer 5 to any tracking structures
- Signer 5 is NOT added to `malicious_signer_ids`
- In next signing round, signer 5 can participate again and repeat attack

**Reproduction:** Use the test framework in `src/state_machine/coordinator/mod.rs::test` to set up 5 signers, then modify one signer's nonce response to use wrong key_ids before sending to coordinator. Verify the signer is not in `malicious_signer_ids` after the round completes.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L178-186)
```rust
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L886-889)
```rust
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L891-900)
```rust
            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
```

**File:** src/state_machine/coordinator/fire.rs (L903-914)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```
