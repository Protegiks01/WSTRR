# Audit Report

## Title
Denial of Service via Empty Polynomial Vector in PolyCommitment During DKG

## Summary
A malicious signer can crash all honest signers and the coordinator participating in DKG by sending a `DkgPublicShares` message containing a `PolyCommitment` with an empty polynomial vector. The vulnerability stems from missing bounds checking in `PolyCommitment::verify()` combined with unsafe evaluation order in `check_public_shares()`, causing an index-out-of-bounds panic before validation can occur.

## Finding Description

The vulnerability exists in the `PolyCommitment::verify()` method which unconditionally accesses `self.poly[0]` without verifying the vector is non-empty: [1](#0-0) 

When a malicious signer constructs a `PolyCommitment` with an empty `poly` vector, this direct array access triggers a runtime panic.

The `PolyCommitment` struct derives `Serialize`/`Deserialize` without any validation constraints: [2](#0-1) 

This allows deserialization of malformed commitments containing empty vectors.

**Attack Path:**

1. **Message Construction**: A malicious signer creates a `DkgPublicShares` message with a `PolyCommitment` where `poly: Vec::new()`. The message structure accepts this: [3](#0-2) 

2. **Storage Without Validation**: When honest signers receive the message, they store it without validation: [4](#0-3) 

The coordinator similarly stores without validation: [5](#0-4) 

3. **Vulnerable Validation**: During `DkgEndBegin` processing, signers call `check_public_shares()` on stored commitments: [6](#0-5) 

The coordinator has identical vulnerable code: [7](#0-6) 

4. **Panic Before Validation**: The `check_public_shares()` function has unsafe evaluation order due to Rust's short-circuit boolean evaluation: [8](#0-7) 

The `verify()` call executes BEFORE the length check. When `verify()` panics on `poly[0]` access, the length validation never runs.

**Security Guarantee Broken**: The protocol assumes all DKG participants can complete validation checks and report malicious behavior. This vulnerability prevents honest nodes from even reaching the validation logic, causing immediate crashes instead of graceful rejection.

## Impact Explanation

**Severity: Low** - Maps to "Any remotely-exploitable denial of service in a node"

A single malicious signer participating in DKG can crash all honest signers and the coordinator by sending one malformed message. This prevents DKG completion for that round.

**Impact Scope:**
- All nodes processing the malicious commitment crash
- DKG cannot complete successfully
- Nodes can restart but will crash again if processing the same malicious message
- Does NOT compromise cryptographic keys, bypass threshold requirements, or affect consensus

**Who is Affected:** All honest signers and coordinators in the same DKG round as the attacker.

This does NOT constitute Critical, High, or Medium severity because it:
- Does not shut down the network
- Does not cause chain splits or forks  
- Does not result in fund loss
- Does not confirm invalid transactions
- Does not enable persistent code execution

## Likelihood Explanation

**Likelihood: High**

**Attacker Capabilities Required:**
- Must be a registered signer in the DKG protocol
- Needs standard message-sending capability (no privilege escalation required)
- No cryptographic secrets or primitives need to be broken

**Attack Complexity:** Trivial. The attacker simply constructs:
```rust
PolyCommitment {
    id: <any_valid_schnorr_id>,
    poly: Vec::new()  // Empty vector
}
```

**Economic Feasibility:** Zero cost beyond normal DKG participation registration. The attack succeeds deterministically on first message processing.

**Detection:** While the crash is immediately observable and the malicious message can be traced through authentication, the damage occurs before detection mechanisms can prevent it.

**Success Rate:** 100% if the attacker is a DKG participant. No timing windows or race conditions exist.

## Recommendation

Add bounds checking before array access and reorder validation logic:

**Fix 1: Add bounds check in `PolyCommitment::verify()`**
```rust
pub fn verify(&self, ctx: &[u8]) -> bool {
    if self.poly.is_empty() {
        return false;
    }
    self.id.verify(&self.poly[0], ctx)
}
```

**Fix 2: Validate at deserialization or before storage**

Add validation when storing public shares:
```rust
// In signer/mod.rs and coordinator/fire.rs
for (party_id, comm) in &dkg_public_shares.comms {
    if comm.poly.is_empty() {
        warn!("Signer {} sent empty polynomial commitment", signer_id);
        return Ok(vec![]);
    }
    // ... continue with existing validation
}
```

**Fix 3: Reorder `check_public_shares()` evaluation (defense in depth)**
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.poly.len() == threshold && poly_comm.verify(ctx)
}
```

This ensures length check occurs first, though bounds checking in `verify()` is still necessary for other call sites.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_empty_poly_commitment_causes_panic() {
    use crate::common::PolyCommitment;
    use crate::schnorr::ID;
    use crate::curve::scalar::Scalar;
    use crate::curve::point::Point;
    
    // Create a PolyCommitment with empty poly vector
    let malicious_commitment = PolyCommitment {
        id: ID {
            id: Scalar::from(1u32),
            kG: Point::identity(),
            kca: Scalar::from(1u32),
        },
        poly: Vec::new(),  // Empty vector - triggers vulnerability
    };
    
    // This call will panic with index out of bounds
    let ctx = 1u64.to_be_bytes();
    malicious_commitment.verify(&ctx);
}
```

### Citations

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L37-39)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/net.rs (L141-150)
```rust
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/state_machine/signer/mod.rs (L557-558)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
```

**File:** src/state_machine/signer/mod.rs (L1023-1024)
```rust
        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L633-637)
```rust
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
```
