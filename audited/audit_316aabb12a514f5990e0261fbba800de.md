### Title
Gather States Can Wait Indefinitely Without Timeout, Enabling Denial of Service

### Summary
The coordinator state machine's gather states (DkgPublicGather, DkgPrivateGather, DkgEndGather, NonceGather, SigShareGather) can wait indefinitely for signer responses when no timeout is configured. The default configuration creates coordinators with all timeouts set to None, and the FROST coordinator implementation has no timeout mechanism at all. A single malicious or unresponsive signer can permanently block DKG completion or signature generation.

### Finding Description

**FROST Coordinator - No Timeout Mechanism:**

The FROST coordinator's `process()` method directly calls `process_message()` without any timeout checking: [1](#0-0) 

The `process_message()` loop waits indefinitely in gather states when `ids_to_await` is not empty: [2](#0-1) [3](#0-2) 

**FIRE Coordinator - Conditional Timeout:**

The FIRE coordinator has a `process_timeout()` method, but it only triggers when timeouts are explicitly configured (not None): [4](#0-3) [5](#0-4) 

The `process()` method calls `process_timeout()` before processing messages, but if timeouts are None, no timeout occurs: [6](#0-5) 

**Default Configuration - No Timeouts:**

The default `Config::new()` constructor sets all timeouts to None: [7](#0-6) 

**Root Cause:**

The coordinators track signers to wait for in gather states (`ids_to_await` for FROST, `dkg_wait_signer_ids` for FIRE). State transitions only occur when this set becomes empty. Without timeouts, if any signer never responds, the coordinator remains stuck in the gather state indefinitely. The default configuration provides no protection against this scenario.

### Impact Explanation

**Specific Harm:**
- A coordinator stuck in a gather state cannot complete DKG, preventing generation of the aggregate public key required for signing
- A coordinator stuck waiting for signature shares cannot produce valid signatures
- If WSTS coordinators are used in critical infrastructure (e.g., Stacks validators), this prevents transaction authorization and block production

**Quantified Impact:**
- Attack requires controlling or disrupting a single signer out of N total signers
- Blocks DKG permanently: no aggregate key generation possible
- Blocks signing permanently: no signatures can be produced
- Affects all users depending on the coordinator for transaction authorization

**Affected Parties:**
- All users of coordinators with default configuration (no timeouts)
- All users of FROST coordinators (no timeout support)
- Systems depending on WSTS for transaction signing

**Severity Justification:**
This maps to the protocol scope as:
- "Any remotely-exploitable denial of service in a node" (Low severity baseline)
- Potentially "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks" (Critical) if used in validator infrastructure
- High severity is justified as this affects critical signing operations and has no default mitigation

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of a single signer in the signing group, OR
- Network-level ability to prevent messages from one signer reaching the coordinator
- No cryptographic breaks required

**Attack Complexity:**
Simple - attacker simply stops sending responses or drops packets from one signer. The attack is:
1. Wait for coordinator to enter a gather state
2. Prevent one signer from sending its response
3. Coordinator waits indefinitely

**Economic Feasibility:**
Highly feasible - requires minimal resources. An attacker who is already a signer can simply stop participating.

**Detection Risk:**
Low - the coordinator appears to be waiting for legitimate responses. Without external monitoring, it's difficult to distinguish from network delays.

**Probability of Success:**
Very high (>90%) for coordinators using default configuration or FROST implementation, as there is no timeout mechanism to prevent indefinite waiting.

### Recommendation

**Primary Fix - Enforce Timeout Configuration:**

1. Make timeouts required in the configuration, with reasonable defaults:
```rust
pub fn new(
    num_signers: u32,
    num_keys: u32,
    threshold: u32,
    message_private_key: Scalar,
) -> Self {
    Config {
        num_signers,
        num_keys,
        threshold,
        dkg_threshold: num_keys,
        message_private_key,
        dkg_public_timeout: Some(Duration::from_secs(30)),
        dkg_private_timeout: Some(Duration::from_secs(30)),
        dkg_end_timeout: Some(Duration::from_secs(30)),
        nonce_timeout: Some(Duration::from_secs(10)),
        sign_timeout: Some(Duration::from_secs(10)),
        public_keys: Default::default(),
        verify_packet_sigs: true,
    }
}
```

2. Add timeout support to FROST coordinator by implementing `process_timeout()` similar to FIRE coordinator

3. Add validation that timeouts are configured before allowing state transitions into gather states

**Alternative Mitigation:**

Add a maximum iteration count for gather state loops to prevent indefinite waiting even without explicit timeouts.

**Testing Recommendations:**
- Add tests verifying timeout behavior with default configuration
- Add tests for FROST coordinator timeout handling
- Test that coordinators properly handle non-responding signers
- Verify timeout enforcement in all gather states

**Deployment Considerations:**
- This is a breaking change if existing code relies on no-timeout behavior
- Provide migration path for users to explicitly opt into None timeouts if needed
- Update documentation to clearly describe timeout security requirements

### Proof of Concept

**Exploitation Steps:**

1. Set up a coordinator using default configuration:
```rust
let mut rng = create_rng();
let config = Config::new(10, 40, 28, Scalar::random(&mut rng));
let mut coordinator = Coordinator::new(config);
```

2. Start a DKG round:
```rust
let dkg_begin = coordinator.start_dkg_round(None).unwrap();
// Coordinator transitions to DkgPublicGather state
assert_eq!(coordinator.get_state(), State::DkgPublicGather);
```

3. Send responses from N-1 signers but withhold response from one signer:
```rust
// Simulate 9 out of 10 signers responding
for signer_id in 0..9 {
    let response = create_dkg_public_shares(signer_id);
    coordinator.process(&response).unwrap();
}
// Coordinator still in DkgPublicGather, waiting for signer 9
assert_eq!(coordinator.get_state(), State::DkgPublicGather);
```

4. Coordinator waits indefinitely:
```rust
// No timeout configured, coordinator blocks forever
// ids_to_await contains {9}, never becomes empty
// No state transition occurs
loop {
    // Coordinator remains stuck, cannot proceed
    assert_eq!(coordinator.get_state(), State::DkgPublicGather);
    std::thread::sleep(Duration::from_secs(1));
}
```

**Expected vs Actual Behavior:**

Expected: Coordinator should timeout after a reasonable period and return an error or skip the non-responding signer.

Actual: Coordinator waits indefinitely in gather state with no timeout, making DKG completion impossible.

**Reproduction:**
Use the test setup from the coordinator test module but remove the timeout configuration and withhold one signer's response. The coordinator will remain stuck in the gather state indefinitely.

### Citations

**File:** src/state_machine/coordinator/frost.rs (L103-108)
```rust
                State::DkgPublicGather => {
                    self.gather_public_shares(packet)?;
                    if self.state == State::DkgPublicGather {
                        // We need more data
                        return Ok((None, None));
                    }
```

**File:** src/state_machine/coordinator/frost.rs (L114-119)
```rust
                State::DkgPrivateGather => {
                    self.gather_private_shares(packet)?;
                    if self.state == State::DkgPrivateGather {
                        // We need more data
                        return Ok((None, None));
                    }
```

**File:** src/state_machine/coordinator/frost.rs (L929-934)
```rust
    fn process(
        &mut self,
        packet: &Packet,
    ) -> Result<(Option<Packet>, Option<OperationResult>), Error> {
        self.process_message(packet)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L77-101)
```rust
            State::DkgPublicGather => {
                if let Some(start) = self.dkg_public_start {
                    if let Some(timeout) = self.config.dkg_public_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_public_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPublicTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.public_shares_gathered()?;
                                let packet = self.start_private_shares()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L105-130)
```rust
            State::DkgPrivateGather => {
                if let Some(start) = self.dkg_private_start {
                    if let Some(timeout) = self.config.dkg_private_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_private_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPrivateTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.private_shares_gathered()?;
                                let packet = self.start_dkg_end()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L1444-1454)
```rust
    fn process(
        &mut self,
        packet: &Packet,
    ) -> Result<(Option<Packet>, Option<OperationResult>), Error> {
        let (outbound_packet, operation_result) = self.process_timeout()?;
        if outbound_packet.is_some() || operation_result.is_some() {
            return Ok((outbound_packet, operation_result));
        }

        self.process_message(packet)
    }
```

**File:** src/state_machine/coordinator/mod.rs (L179-200)
```rust
    /// Create a new config object with no timeouts
    pub fn new(
        num_signers: u32,
        num_keys: u32,
        threshold: u32,
        message_private_key: Scalar,
    ) -> Self {
        Config {
            num_signers,
            num_keys,
            threshold,
            dkg_threshold: num_keys,
            message_private_key,
            dkg_public_timeout: None,
            dkg_private_timeout: None,
            dkg_end_timeout: None,
            nonce_timeout: None,
            sign_timeout: None,
            public_keys: Default::default(),
            verify_packet_sigs: true,
        }
    }
```
