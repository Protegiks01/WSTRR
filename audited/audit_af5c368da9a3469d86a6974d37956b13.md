### Title
Nonce Reuse Across Signing Rounds Enables Private Key Extraction

### Summary
The coordinator does not track nonces across signing rounds, clearing `message_nonces` at the start of each new round. A malicious signer can reuse the same nonce values across multiple signing rounds for different messages by creating new `NonceResponse` packets with updated `sign_id`/`sign_iter_id` but identical nonce values. This violates the fundamental Schnorr signature security requirement that nonces must never be reused, enabling private key extraction attacks.

### Finding Description

**Primary Vulnerability Location:** [1](#0-0) 

**Root Cause:**
The coordinator's `request_nonces` function explicitly clears `message_nonces` at line 815, erasing all history of previously used nonces. There is no persistent cross-round tracking mechanism to detect nonce reuse.

**Validation Weaknesses:** [2](#0-1) 

The `gather_nonces` function validates:
- Round IDs (`dkg_id`, `sign_id`, `sign_iter_id`) match current values
- Signer configuration and key IDs are correct
- Individual nonces are non-zero via `is_valid()`
- No duplicate responses from the same signer *within the current round*

However, it does NOT:
- Track nonces across multiple signing rounds
- Validate that nonces are unique compared to previous rounds
- Persist a nonce history database

**Honest Signer Behavior:** [3](#0-2) 

Honest signers generate fresh nonces for each `NonceRequest` by calling `gen_nonces()`, which creates new random nonces: [4](#0-3) 

**Signature Share Computation:** [5](#0-4) 

The signature share formula is: `z = d + e * binding + challenge * private_key * lambda`, where `d` and `e` are the private nonces. Both the binding coefficient and challenge depend on the message being signed.

**Additional Message Substitution Vulnerability:** [6](#0-5) 

The coordinator groups nonces by `nonce_response.message` without validating it matches the originally requested message. When threshold is reached, the response message becomes the "winning message" even if different from what was requested.

### Impact Explanation

**Cryptographic Impact:**
When a malicious signer reuses nonces (d, e) for two different messages m1 and m2, they produce two signature shares:
- `z1 = d + e*ρ1 + c1*x*λ1` (for message m1)
- `z2 = d + e*ρ2 + c2*x*λ2` (for message m2)

Where ρ (binding), c (challenge), and λ (Lagrange) differ between messages. With two equations and known public values, an attacker can potentially extract the private key share x through algebraic manipulation.

**Chain-Level Impact (CRITICAL):**
1. **Invalid Transaction Confirmation**: A malicious signer with compromised private keys can create invalid signatures that appear valid, confirming transactions with incorrect nonces
2. **Direct Loss of Funds**: Extracted private key shares enable unauthorized spending from threshold-signed addresses
3. **Chain Split Risk**: Different nodes may process signatures differently if some detect the nonce reuse while others don't
4. **Deep Fork Potential**: If the malicious signer controls sufficient weight (near threshold), they can cause sustained disruption requiring manual intervention

**Affected Parties:**
- All participants in threshold signature schemes using this coordinator
- Users whose funds are protected by compromised threshold keys
- Blockchain consensus if WSTS is used for validator signing

**Severity Justification:**
This maps to **CRITICAL** severity under the protocol scope:
- "Any confirmation of an invalid transaction, such as with an incorrect nonce"
- "Any causing the direct loss of funds"
- Potential for "chain split caused by different nodes processing the same block or transaction and yielding different results"

### Likelihood Explanation

**Attacker Prerequisites:**
- Must be a registered signer in the threshold scheme
- Requires no additional privileges beyond normal signer participation
- Needs ability to craft malicious `NonceResponse` packets
- Must maintain persistent state across signing rounds to track and reuse nonces

**Attack Complexity: LOW**
The attack is straightforward:
1. Participate normally in round 1, capturing generated nonces
2. In round 2 with a different message, manually construct `NonceResponse` with old nonces but new `sign_id`/`sign_iter_id`
3. Sign the crafted response with signer's private key
4. Send to coordinator

**Detection Risk: LOW**
- The coordinator has no mechanism to detect this attack
- Other signers cannot observe nonce reuse from network messages alone
- Only becomes apparent if someone independently tracks all nonce usage

**Economic Feasibility: HIGH**
- No additional resources required beyond being a signer
- Attack can be executed immediately across any two signing rounds
- Cost is only the operational cost of being a signer

**Success Probability: ~100%**
Given that the coordinator explicitly clears nonce history and has no cross-round validation, a malicious signer can reliably reuse nonces without detection.

### Recommendation

**Primary Fix - Add Persistent Nonce Tracking:**

1. Extend `SavedState` to include a persistent nonce history:
```rust
pub nonce_history: BTreeMap<(u32, PublicNonce), (u64, u64, Vec<u8>)>
// Maps (signer_id, nonce) -> (sign_id, sign_iter_id, message)
```

2. Modify `gather_nonces` to check nonce history:
   - Before accepting a `NonceResponse`, verify each nonce has not been used before
   - Store accepted nonces in the persistent history
   - Reject any nonce that appears in the history, regardless of round IDs

3. Implement nonce history pruning:
   - Retain history for completed signatures for a configurable period
   - Implement a maximum history size with FIFO eviction
   - Consider cryptographic commitments for space efficiency

**Secondary Fix - Add Message Validation:**

In `gather_nonces`, add validation that `nonce_response.message` matches `self.message`:
```rust
if nonce_response.message != self.message {
    warn!("NonceResponse message doesn't match request");
    return Ok(());
}
```

**Alternative Mitigation:**
If persistent nonce tracking is too expensive, implement deterministic nonce generation where nonces are derived from `H(private_key || sign_id || sign_iter_id || message)`. This makes nonce reuse impossible without creating identical signatures.

**Testing Recommendations:**
1. Unit test: Verify nonce reuse is detected and rejected
2. Integration test: Simulate malicious signer attempting nonce reuse
3. Performance test: Measure impact of nonce history storage
4. Regression test: Ensure legitimate concurrent signing rounds still work

**Deployment Considerations:**
- Requires coordinator state migration to add nonce history
- All coordinators must upgrade simultaneously
- Consider a transition period with logging-only mode before enforcement

### Proof of Concept

**Attack Algorithm:**

```
Setup:
- Malicious signer S with signer_id=1
- Coordinator C with threshold=2 out of 3 signers
- Messages M1 and M2

Round 1 (Message M1):
1. C sends NonceRequest{sign_id=1, sign_iter_id=1, message=M1}
2. S generates nonces N = (d, e) via gen_nonces()
3. S captures private nonces (d, e) and computes public nonces D=d*G, E=e*G
4. S sends NonceResponse{sign_id=1, sign_iter_id=1, nonces=[(D,E)], message=M1}
5. Signing completes for M1 with signature share z1 = d + e*ρ1 + c1*x*λ1

Round 2 (Message M2):
1. C sends NonceRequest{sign_id=2, sign_iter_id=2, message=M2}
2. S DOES NOT call gen_nonces()
3. S manually constructs NonceResponse{sign_id=2, sign_iter_id=2, nonces=[(D,E)], message=M2}
   (Note: SAME nonces D, E as round 1!)
4. S signs the crafted NonceResponse with their network private key
5. S sends the crafted packet to C
6. C validates:
   - sign_id matches current (2 == 2) ✓
   - sign_iter_id matches current (2 == 2) ✓
   - signer_id exists ✓
   - nonces are valid (non-zero) ✓
   - No duplicate from signer 1 in current round ✓
   - NO CHECK: nonces were used in previous round ✗
7. C accepts the response and proceeds
8. Signing completes for M2 with signature share z2 = d + e*ρ2 + c2*x*λ2

Private Key Extraction:
1. Attacker observes both signature shares z1 and z2
2. Computes binding values ρ1 and ρ2 from public data
3. Computes challenge values c1 and c2 from public data
4. Computes Lagrange coefficients λ1 and λ2 from public data
5. Sets up system of equations with unknowns (d, e, x)
6. Solves for private key share x using algebraic manipulation
```

**Expected Behavior:**
Coordinator should reject the second `NonceResponse` with an error: "Nonce reuse detected from signer 1"

**Actual Behavior:**
Coordinator accepts both responses, enabling the private key extraction attack.

**Reproduction Steps:**
1. Set up a coordinator and 3 signers with threshold=2
2. Initiate signing round 1 for message "test1"
3. Have malicious signer capture their nonces
4. Complete round 1
5. Initiate signing round 2 for message "test2"  
6. Have malicious signer send NonceResponse with same nonces from round 1
7. Observe: Coordinator accepts the response (vulnerability confirmed)

**Notes**

The vulnerability exists in both FireCoordinator and FrostCoordinator implementations, as both clear `message_nonces` and lack cross-round validation. The message substitution vulnerability is a separate issue that allows message tampering within a single round, which could enable additional attacks when combined with nonce reuse.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L814-838)
```rust
    fn request_nonces(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.message_nonces.clear();
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
        info!(
            sign_id = %self.current_sign_id,
            sign_iter_id = %self.current_sign_iter_id,
            "Requesting Nonces"
        );
        let nonce_request = NonceRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            message: self.message.clone(),
            signature_type,
        };
        let nonce_request_msg = Packet {
            sig: nonce_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign NonceRequest"),
            msg: Message::NonceRequest(nonce_request),
        };
        self.move_to(State::NonceGather(signature_type))?;
        self.nonce_start = Some(Instant::now());

        Ok(nonce_request_msg)
```

**File:** src/state_machine/coordinator/fire.rs (L846-901)
```rust
        if let Message::NonceResponse(nonce_response) = &packet.msg {
            if nonce_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(nonce_response.dkg_id, self.current_dkg_id));
            }
            if nonce_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    nonce_response.sign_id,
                    self.current_sign_id,
                ));
            }
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&nonce_response.signer_id) {
                warn!(signer_id = %nonce_response.signer_id, "No public key in config");
                return Ok(());
            };

            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L917-954)
```rust
            let nonce_info = self
                .message_nonces
                .entry(nonce_response.message.clone())
                .or_default();

            let have_nonces = nonce_info
                .public_nonces
                .contains_key(&nonce_response.signer_id);

            if have_nonces {
                info!(signer_id = %nonce_response.signer_id, "Received duplicate NonceResponse");
                return Ok(());
            }

            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());

            // ignore the passed key_ids
            for key_id in signer_key_ids {
                nonce_info.nonce_recv_key_ids.insert(*key_id);
            }

            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
            // Because of entry call, it is safe to unwrap here
            info!(
                sign_id = %nonce_response.sign_id,
                sign_iter_id = %nonce_response.sign_iter_id,
                signer_id = %nonce_response.signer_id,
                recv_keys = %nonce_info.nonce_recv_key_ids.len(),
                threshold = %self.config.threshold,
                "Received NonceResponse"
            );
            if nonce_info.nonce_recv_key_ids.len() >= self.config.threshold as usize {
                // We have a winning message!
                self.message.clone_from(&nonce_response.message);
```

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/v2.rs (L77-84)
```rust
    pub fn gen_nonce<RNG: RngCore + CryptoRng>(
        &mut self,
        secret_key: &Scalar,
        rng: &mut RNG,
    ) -> PublicNonce {
        self.nonce = Nonce::random(secret_key, rng);
        PublicNonce::from(&self.nonce)
    }
```

**File:** src/v1.rs (L217-229)
```rust
    pub fn sign(&self, msg: &[u8], signers: &[u32], nonces: &[PublicNonce]) -> SignatureShare {
        let (_, aggregate_nonce) = compute::intermediate(msg, signers, nonces);
        let mut z = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
        z += compute::challenge(&self.group_key, &aggregate_nonce, msg)
            * &self.private_key
            * compute::lambda(self.id, signers);

        SignatureShare {
            id: self.id,
            z_i: z,
            key_ids: vec![self.id],
        }
    }
```
