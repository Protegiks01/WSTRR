### Title
Missing DKG Round ID Validation in Signer DkgPrivateShares Processing Enables Denial of Service

### Summary
The signer's `dkg_private_shares` function does not validate that incoming `DkgPrivateShares` messages match the current `dkg_id` before decrypting and processing them. While existing cryptographic validation prevents replayed shares from producing incorrect group keys, an attacker with network access can replay old encrypted shares to cause DKG failures and denial of service.

### Finding Description

**Location**: [1](#0-0) 

The `dkg_private_shares` function accepts and processes `DkgPrivateShares` messages without validating the `dkg_id` field against the signer's current `self.dkg_id`. This contrasts with the coordinator's implementation, which explicitly checks: [2](#0-1) 

The signer only checks if shares from the same `src_signer_id` have already been received in the current session: [3](#0-2) 

This check prevents duplicate processing within a round but does not verify the message belongs to the current DKG round ID.

**Root Cause**: Asymmetric validation between coordinator and signer state machines. The coordinator enforces round ID matching, but signers do not.

**Why Existing Mitigations Partially Work**: 
When `dkg_ended` is called, it validates decrypted shares against polynomial commitments: [4](#0-3) 

The Schnorr ID proofs in commitments are bound to the specific `dkg_id`: [5](#0-4) 

This prevents replayed old shares from matching new commitments, causing validation failures rather than incorrect key derivation.

### Impact Explanation

**Specific Harm**: An attacker can force DKG round failures by replaying old `DkgPrivateShares` messages from previous rounds. When old shares are decrypted and validated against current-round commitments, the validation fails, causing the DKG to abort with `BadPrivateShares` errors.

**Quantified Impact**: 
- Each successful replay forces DKG retry, delaying key generation
- In threshold signing systems protecting Stacks transactions, delayed DKG prevents signature generation
- Multiple replays can sustain denial of service until network path is secured

**Affected Parties**: All signers in a DKG round are affected when any signer accepts replayed shares, as the entire round must be restarted.

**Severity Justification**: **Low** - Maps to "Any remotely-exploitable denial of service in a node" per the defined scope. Does not cause incorrect keys, invalid signatures, or consensus failures beyond transient delays.

### Likelihood Explanation

**Required Attacker Capabilities**:
- Man-in-the-middle position or network message injection capability on signer communication paths
- Captured `DkgPrivateShares` messages from previous DKG rounds
- Ability to intercept or delay legitimate current-round messages

**Attack Complexity**: Medium
- Attacker must time replay before legitimate messages arrive
- Must have previously captured encrypted shares (passive network monitoring)
- Attack is repeatable across multiple rounds

**Economic Feasibility**: High for motivated attacker with network access. No cryptographic breaks required.

**Detection Risk**: High - Attacks manifest as `BadPrivateShares` failures visible in coordinator logs: [6](#0-5) 

However, failures may be misattributed to malicious signers rather than replay attacks.

**Probability of Success**: High if attacker controls network path; Low otherwise.

### Recommendation

**Primary Fix**: Add `dkg_id` validation in the signer's `dkg_private_shares` function, matching the coordinator's pattern:

```rust
pub fn dkg_private_shares<R: RngCore + CryptoRng>(
    &mut self,
    dkg_private_shares: &DkgPrivateShares,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Add this check at function entry
    if dkg_private_shares.dkg_id != self.dkg_id {
        warn!(
            "Received DkgPrivateShares with dkg_id {} but expected {}",
            dkg_private_shares.dkg_id, self.dkg_id
        );
        return Ok(vec![]);
    }
    // ... rest of existing logic
}
```

**Alternative Mitigation**: Implement message timestamping and freshness checks to detect replayed messages.

**Testing Recommendations**:
- Add unit test that sends `DkgPrivateShares` with mismatched `dkg_id`
- Verify message is rejected before decryption
- Integration test for full DKG round with replay attempts
- Fuzz testing with random `dkg_id` values in messages

**Deployment Considerations**: This is a backward-compatible fix that rejects invalid messages. Deploy with monitoring to ensure no legitimate messages are incorrectly rejected.

### Proof of Concept

**Exploitation Algorithm**:

1. **Setup Phase** (Attacker Position):
   - Position MitM on network between signers
   - Capture `DkgPrivateShares` messages during round N
   - Store encrypted shares indexed by `signer_id`

2. **Attack Phase** (Round N+1):
   - Wait for `DkgBegin` message with `dkg_id = N+1`
   - Intercept and delay legitimate `DkgPrivateShares` messages with `dkg_id = N+1`
   - Replay captured messages with `dkg_id = N` to victim signers
   - Victim signers accept messages (no `dkg_id` validation): [7](#0-6) 

3. **Impact Observation**:
   - Victim signers decrypt old shares: [8](#0-7) 
   - During `dkg_ended`, validation fails against new commitments: [9](#0-8) 
   - DKG round fails with `BadPrivateShares` error
   - Coordinator must initiate retry

**Expected vs Actual Behavior**:
- Expected: Signer rejects `DkgPrivateShares` with mismatched `dkg_id` immediately
- Actual: Signer accepts, decrypts, and only detects mismatch during validation phase

**Reproduction Steps**:
1. Run WSTS test suite with modified test capturing `DkgPrivateShares` from round 1
2. Initiate round 2 with same signers
3. Inject captured round 1 messages before round 2 legitimate messages arrive
4. Observe DKG failure with `BadPrivateShares` status
5. Note that fix (dkg_id validation) prevents acceptance of replayed messages

### Citations

**File:** src/state_machine/signer/mod.rs (L557-559)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
```

**File:** src/state_machine/signer/mod.rs (L612-616)
```rust
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
```

**File:** src/state_machine/signer/mod.rs (L643-649)
```rust
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
```

**File:** src/state_machine/signer/mod.rs (L1029-1033)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
```

**File:** src/state_machine/signer/mod.rs (L1034-1045)
```rust
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };
```

**File:** src/state_machine/signer/mod.rs (L1058-1061)
```rust
        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }
```

**File:** src/state_machine/signer/mod.rs (L1076-1096)
```rust
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
```

**File:** src/state_machine/coordinator/frost.rs (L338-343)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/schnorr.rs (L47-58)
```rust
    /// Compute the schnorr challenge
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
```
