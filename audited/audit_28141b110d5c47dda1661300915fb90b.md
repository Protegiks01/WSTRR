### Title
Missing AES-GCM Nonce Reuse Detection in DKG Private Share Decryption

### Summary
The `decrypt()` function in `src/util.rs` does not detect when the same AES-GCM nonce is used across multiple ciphertexts encrypted with the same key. A malicious signer can deliberately reuse nonces when encrypting DKG private shares to recipients controlling multiple key IDs, causing catastrophic AES-GCM security failure. This enables passive network observers to recover private shares and the GCM authentication key, compromising the entire DKG round without detection.

### Finding Description

The vulnerability exists in the decryption flow for DKG private shares. The `decrypt()` function extracts the nonce from incoming ciphertext data but performs no tracking or validation to detect if the same nonce has been previously used with the same encryption key. [1](#0-0) 

During DKG private share distribution, each signer broadcasts a single ephemeral `kex_public_key` in their `DkgPublicShares` message: [2](#0-1) 

When recipients process these messages, all key IDs belonging to the same signer are mapped to that signer's single `kex_public_key`: [3](#0-2) 

This means when encrypting multiple private shares destined for different key IDs controlled by the same recipient signer, the sender computes the same Diffie-Hellman shared secret for all of them: [4](#0-3) 

A malicious signer can exploit this by deliberately reusing the same nonce when calling `encrypt()` multiple times with this shared secret. Since `encrypt()` accepts an external RNG parameter, the attacker can control nonce generation: [5](#0-4) 

When the recipient decrypts these shares, no error is generated because AES-GCM decryption succeeds even with reused nonces—it just catastrophically breaks the security properties: [6](#0-5) 

**Why Existing Mitigations Fail:**

1. **Message Signatures**: While `DkgPrivateShares` messages are signed by the sender, this only proves the sender created the message. It does not prevent a malicious sender from deliberately signing ciphertexts with reused nonces. [7](#0-6) 

2. **Decryption Error Handling**: The code catches decryption errors and marks shares as invalid, but nonce reuse does not cause AES-GCM decryption to fail—each ciphertext decrypts successfully to its intended plaintext. The security breach is silent.

3. **Cryptographic RNG**: The default RNG is cryptographically secure, but this only prevents accidental collisions. A malicious signer controlling their own code can override the RNG or directly manipulate nonce values.

### Impact Explanation

**Specific Harm:**

When nonces are reused with the same AES-GCM key:
- **Confidentiality Loss**: A passive network observer can XOR two ciphertexts encrypted with the same (key, nonce) pair to obtain the XOR of the two plaintexts. With knowledge of DKG share structure (scalars mod curve order), the observer can recover both plaintexts.
- **Authentication Loss**: The observer can recover the GCM authentication key, enabling them to forge arbitrary authenticated ciphertexts that will decrypt successfully.
- **Key Compromise**: The DKG private shares represent fractions of the distributed private key. If an attacker recovers enough shares, they can reconstruct the threshold private key.

**Quantified Impact:**

Consider a threshold signature system with 5 signers, where each signer controls 3 key IDs (15 total key IDs, threshold = 8). A malicious Signer A can:
1. Reuse nonces when encrypting shares to Signer B's 3 key IDs
2. Expose B's shares to passive observers through nonce reuse
3. Repeat for other recipients
4. With shares from 3-4 compromised recipients (9-12 key IDs), exceed the threshold
5. Allow offline reconstruction of the group private key

**Who Is Affected:**

All WSTS deployments where signers control multiple key IDs are vulnerable. This includes any weighted threshold configuration, which is a core feature of WSTS.

**Severity Justification:**

This vulnerability maps to **High** severity under the protocol scope:
- "Any unintended chain split or network partition" - If the compromised private key is used to sign conflicting blocks or transactions, different nodes may accept different histories.
- "Any confirmation of an invalid transaction, such as with an incorrect nonce" - An attacker with the reconstructed private key can sign arbitrary transactions that appear valid.

The vulnerability enables complete compromise of the DKG security without any detection mechanism, allowing the DKG round to complete successfully while the distributed key is fundamentally insecure.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Position as a legitimate signer in the DKG protocol (insider threat)
- Ability to modify their own signer code or RNG to deliberately reuse nonces
- Knowledge that target recipients control multiple key IDs
- Passive network observation capability to capture ciphertexts

**Attack Complexity:**

The attack is straightforward for a malicious insider:
1. Identify which signers control multiple key IDs (public information in protocol configuration)
2. Modify local `encrypt()` calls to use a fixed nonce when encrypting shares for those recipients
3. Sign and broadcast the malicious `DkgPrivateShares` message
4. Capture network traffic passively or position a network observer
5. Apply standard AES-GCM nonce reuse attacks to recover shares

**Economic Feasibility:**

- No cryptographic breaks required
- Minimal computational cost (XOR operations, known plaintext attacks)
- No special hardware or resources needed
- Attack can be executed in real-time during DKG

**Detection Risk:**

The attack is extremely difficult to detect:
- Decryption succeeds without errors
- No validation failures occur
- The DKG round completes normally
- Only external cryptanalysis of captured ciphertexts would reveal the issue
- No logging or monitoring can detect nonce reuse without explicit tracking

**Estimated Probability:**

In systems with malicious or compromised signers: **High**. The attack requires minimal effort and has no technical barriers. In systems with only honest signers: **Low**, as accidental nonce reuse with a cryptographic RNG is negligibly probable.

### Recommendation

**Primary Fix: Add Nonce Reuse Detection**

Modify the signer state machine to track all nonces received from each sender and detect reuse:

1. In `Signer` struct, add a field to track received nonces per sender:
   ```rust
   // Track (sender_id, shared_secret) -> HashSet<nonce>
   received_nonces: HashMap<(u32, [u8; 32]), HashSet<[u8; 12]>>
   ```

2. In the `dkg_private_shares()` method, before decrypting, extract and validate the nonce:
   - Extract nonce from the first 12 bytes of encrypted data
   - Check if this (sender, shared_secret, nonce) combination has been seen
   - If duplicate detected, immediately mark the sender as malicious and abort the DKG round

3. Clear the nonce tracking when starting a new DKG round in the `reset()` method.

**Alternative Mitigation:**

Implement per-key-ID KEX keys instead of per-signer KEX keys. This would ensure each encrypted share uses a different shared secret, making nonce reuse across shares to the same recipient impossible. However, this requires protocol changes and increased message size.

**Testing Recommendations:**

1. Add unit tests that deliberately reuse nonces and verify detection
2. Test with multiple key IDs per signer to ensure all nonce combinations are tracked
3. Test memory efficiency with large numbers of shares
4. Verify nonce tracking is cleared between DKG rounds

**Deployment Considerations:**

This is a protocol-breaking change that requires coordinated deployment:
- All nodes must upgrade simultaneously
- Old nodes will accept nonce-reused shares; new nodes will reject them
- Consider a phased rollout with detection-only mode before enforcement
- Document the new security requirement in protocol specifications

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup**: Assume Signer A (malicious) knows Signer B controls key IDs [10, 11, 12]

2. **Obtain B's KEX Public Key**: Wait for B to broadcast `DkgPublicShares` containing `kex_public_key`

3. **Compute Shared Secret**: 
   - `shared_secret = ECDH(A.kex_private_key, B.kex_public_key)`

4. **Generate Malicious Shares**:
   ```
   fixed_nonce = [0x01; 12]  // Deliberately reused nonce
   share_10 = generate_dkg_share(party_id=A.party_id, dst_key_id=10)
   share_11 = generate_dkg_share(party_id=A.party_id, dst_key_id=11)
   share_12 = generate_dkg_share(party_id=A.party_id, dst_key_id=12)
   
   // Encrypt all three shares with the SAME nonce
   ciphertext_10 = [fixed_nonce || AES_GCM_encrypt(shared_secret, fixed_nonce, share_10)]
   ciphertext_11 = [fixed_nonce || AES_GCM_encrypt(shared_secret, fixed_nonce, share_11)]
   ciphertext_12 = [fixed_nonce || AES_GCM_encrypt(shared_secret, fixed_nonce, share_12)]
   ```

5. **Broadcast**: Create and sign `DkgPrivateShares` message containing these ciphertexts

6. **Observe Decryption Success**: B will decrypt all three shares successfully without error

7. **Offline Attack** (by network observer):
   ```
   plaintext_10 ⊕ plaintext_11 = ciphertext_10 ⊕ ciphertext_11
   ```
   Using knowledge that shares are 32-byte scalars, apply known-plaintext attacks to recover both shares.

8. **Authentication Key Recovery**: 
   With multiple nonce-reused ciphertext pairs, recover the GCM authentication key polynomial and forge arbitrary authenticated messages.

**Expected vs Actual Behavior:**

- **Expected**: System detects nonce reuse, marks sender as malicious, aborts DKG round with error
- **Actual**: All shares decrypt successfully, no error generated, DKG proceeds with compromised shares

**Reproduction Instructions:**

1. Set up WSTS DKG with at least 2 signers where one signer controls 3+ key IDs
2. Modify the malicious signer's code to replace `rng.fill_bytes(&mut nonce_bytes)` with `nonce_bytes = [0x01; 12]` in all `encrypt()` calls
3. Run DKG protocol normally
4. Observe that the DKG completes without errors
5. Capture network traffic and verify multiple ciphertexts have identical first 12 bytes (the nonce)
6. Apply XOR attack to demonstrate share recovery

### Citations

**File:** src/util.rs (L80-99)
```rust
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
}
```

**File:** src/util.rs (L102-116)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/net.rs (L140-150)
```rust
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/net.rs (L201-217)
```rust
impl Signable for DkgPrivateShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PRIVATE_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // make sure we hash consistently by sorting the keys
        for (src_id, share) in &self.shares {
            hasher.update(src_id.to_be_bytes());
            let mut dst_ids = share.keys().cloned().collect::<Vec<u32>>();
            dst_ids.sort();
            for dst_id in &dst_ids {
                hasher.update(dst_id.to_be_bytes());
                hasher.update(&share[dst_id]);
            }
        }
    }
}
```

**File:** src/state_machine/signer/mod.rs (L934-944)
```rust
            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1074-1097)
```rust
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
```
