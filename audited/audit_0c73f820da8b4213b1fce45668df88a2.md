### Title
Empty Polynomial Vector in PolyCommitment Causes Panic During DKG Validation

### Summary
The `PolyCommitment` struct uses serde's automatic `Deserialize` implementation which allows deserialization of an empty `poly` vector. When this malformed commitment is validated via the `verify()` method or accessed during aggregate key computation, it causes an index-out-of-bounds panic, resulting in a denial of service for all nodes processing the malicious DKG message.

### Finding Description

**Exact Code Location:**
The vulnerability exists in the `PolyCommitment` struct definition and its `verify()` method: [1](#0-0) 

**Root Cause:**
The `PolyCommitment` struct derives `Deserialize` without any custom validation logic. The `poly: Vec<Point>` field can be deserialized as an empty vector. The `verify()` method unconditionally accesses `self.poly[0]` without checking if the vector is non-empty, causing a panic.

**Exploitation Points:**
Multiple code paths trigger the panic when processing a malformed `PolyCommitment`:

1. **Frost Coordinator - Aggregate Key Computation:** [2](#0-1) 
The coordinator directly accesses `comm.poly[0]` when computing the aggregate public key after DKG completion.

2. **Fire Coordinator - Share Validation:** [3](#0-2) 
When validating `BadPublicShares` reports, the coordinator calls `check_public_shares()` which invokes `verify()`.

3. **Signers - Public Share Validation:** [4](#0-3) 
Signers call `check_public_shares()` during DKG validation, triggering the panic.

4. **Validation Function:** [5](#0-4) 
The `check_public_shares()` function calls `poly_comm.verify(ctx)` which panics on empty vectors.

**Why Existing Mitigations Fail:**
Network message authentication via ECDSA signatures does not prevent this attack because the attacker is a legitimate signer who signs their own malicious message. The `DkgPublicShares` message structure allows arbitrary `PolyCommitment` values: [6](#0-5) 

The test suite even demonstrates that empty poly vectors can be created and serialized: [7](#0-6) 

### Impact Explanation

**Specific Harm:**
A malicious signer can crash all honest participants (coordinator and other signers) during the DKG phase by sending a `DkgPublicShares` message containing a `PolyCommitment` with an empty `poly` vector. This causes:

1. **Denial of Service:** All nodes processing the message panic and crash
2. **DKG Failure:** The DKG round cannot complete, preventing distributed key generation
3. **Key Rotation Blocked:** New keys cannot be generated or rotated
4. **Signer Onboarding Blocked:** New signers cannot join the network

**Who Is Affected:**
- All honest signers participating in the DKG round
- The coordinator node
- Any dependent systems waiting for DKG completion

**Severity Justification:**
This maps to **Low** severity under the protocol scope definition: "Any remotely-exploitable denial of service in a node." The attack crashes individual nodes but does not:
- Cause fund loss
- Create consensus failures
- Affect ongoing signing operations (only DKG)
- Shut down the entire network permanently

However, it can affect multiple nodes (>10% of miners) if the malicious message is broadcast to all participants, which also falls under Low severity per the scope.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Attacker must be a registered signer with a configured public key
- Attacker must participate in a DKG round
- Attacker needs network access to send messages to other participants

**Attack Complexity:**
The attack is trivial to execute:
1. Construct a `DkgPublicShares` message with `PolyCommitment { id: <valid_id>, poly: vec![] }`
2. Sign the message with the attacker's private key
3. Broadcast the message to coordinator and other signers during DKG public share phase

**Economic Feasibility:**
Negligible cost - the attacker only needs to send one malformed network message. No computational expense beyond normal DKG participation.

**Detection Risk:**
The attack is immediately detectable when nodes crash, but prevention requires restart and exclusion of the malicious signer from future rounds.

**Estimated Probability:**
High likelihood if an adversary controls even one signer position and wishes to disrupt DKG. The only barrier is that the attacker must be a legitimate participant.

### Recommendation

**Proposed Code Changes:**

1. Add a custom `Deserialize` implementation for `PolyCommitment` that validates `poly` is non-empty:

```rust
impl<'de> Deserialize<'de> for PolyCommitment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(Deserialize)]
        struct PolyCommitmentHelper {
            id: ID,
            poly: Vec<Point>,
        }
        
        let helper = PolyCommitmentHelper::deserialize(deserializer)?;
        
        if helper.poly.is_empty() {
            return Err(serde::de::Error::custom("poly cannot be empty"));
        }
        
        Ok(PolyCommitment {
            id: helper.id,
            poly: helper.poly,
        })
    }
}
```

2. Alternatively, add validation before accessing `poly[0]` in the `verify()` method:

```rust
pub fn verify(&self, ctx: &[u8]) -> bool {
    if self.poly.is_empty() {
        return false;
    }
    self.id.verify(&self.poly[0], ctx)
}
```

3. Add early validation in message processing before storing commitments.

**Testing Recommendations:**
- Add test case attempting to deserialize `PolyCommitment` with empty poly (should fail)
- Add test case where `verify()` is called on empty poly (should return false, not panic)
- Fuzz test DKG message processing with malformed commitments

**Deployment Considerations:**
- This is a breaking change requiring all nodes to upgrade
- Existing serialized data with empty poly vectors (if any) will fail to deserialize after the fix

### Proof of Concept

**Exploitation Steps:**

1. **Create malicious DkgPublicShares message:**
```rust
let malicious_shares = DkgPublicShares {
    dkg_id: 0,
    signer_id: attacker_id,
    comms: vec![(
        party_id,
        PolyCommitment {
            id: ID::new(&secret, &public_key, &ctx, &mut rng),
            poly: vec![], // Empty vector - causes panic
        },
    )],
    kex_public_key: Point::from(Scalar::random(&mut rng)),
};
```

2. **Sign and send message:**
```rust
let msg = Message::DkgPublicShares(malicious_shares);
let sig = msg.sign(&attacker_private_key).expect("Failed to sign");
let packet = Packet { msg, sig };
// Broadcast packet to coordinator and other signers
```

3. **Expected behavior:**
    - Message deserializes successfully (empty vectors are valid in serde)
    - Message signature validates (attacker signs with their own key)
    - Honest participants store the commitment without validation

4. **Actual behavior (triggering panic):**
    - When honest signer calls `check_public_shares()` at line 557 of signer/mod.rs
    - Or when Frost coordinator computes aggregate key at line 438 of frost.rs
    - Access to `poly[0]` triggers: `thread 'main' panicked at 'index out of bounds: the len is 0 but the index is 0'`
    - Process crashes, DKG round fails

**Parameter Values:**
- Empty poly: `vec![]`
- Valid ID with Schnorr proof: Can be generated with any secret
- Valid signature: Attacker signs with their own key

**Reproduction:**
The existing test at lines 716-755 of src/net.rs demonstrates that empty poly vectors can be constructed and serialized. To reproduce the panic, call `poly_comm.verify(&ctx)` or `check_public_shares(&poly_comm, threshold, &ctx)` on a commitment with empty poly.

### Citations

**File:** src/common.rs (L26-40)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}

impl PolyCommitment {
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
}
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/coordinator/frost.rs (L434-438)
```rust
        // Calculate the aggregate public key
        let key = self
            .party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```

**File:** src/state_machine/coordinator/fire.rs (L631-639)
```rust
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
```

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/net.rs (L726-729)
```rust
                PolyCommitment {
                    id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
                    poly: vec![],
                },
```
