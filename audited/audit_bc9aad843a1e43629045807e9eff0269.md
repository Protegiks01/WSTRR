# Audit Report

## Title
Malicious Coordinator Can Frame Honest Parties via Lagrange Coefficient Mismatch in SignatureShareRequest

## Summary
A malicious coordinator can modify the `key_ids` field in `SignatureShareRequest` messages to cause honest signers to compute signature shares using incorrect Lagrange coefficients. When the coordinator later validates these shares using the original (correct) `key_ids`, validation fails and honest parties are incorrectly identified as malicious via `BadPartySigs` error, leading to denial of service.

## Finding Description

The vulnerability exists in the signature share creation and validation flow where signers trust the coordinator to accurately relay `key_ids` from all parties' `NonceResponse` messages, but no cryptographic binding ensures this trust is valid.

**Attack Flow:**

1. Signers send `NonceResponse` messages (each cryptographically signed by the signer) containing their `key_ids` and nonces to the coordinator [1](#0-0) 

2. The coordinator receives and stores these in `self.public_nonces`, validating that received `key_ids` match the configuration [2](#0-1) 

3. When creating a `SignatureShareRequest`, the coordinator collects `nonce_responses` from `self.public_nonces` [3](#0-2) 

4. **ATTACK**: A malicious coordinator can modify the `key_ids` within the `nonce_responses` before including them in the request (e.g., removing a key ID or adding one), then sign the modified request with its legitimate coordinator key [4](#0-3) 

5. Signers receive the request and verify the coordinator's signature (which passes because the coordinator legitimately signed it). Signers then extract all `key_ids` by flattening them from the `nonce_responses` in the request [5](#0-4) 

6. Signers only validate that signer IDs are in range and nonces are valid points, but do NOT validate that the `key_ids` in the request match what they originally sent or what's in the configuration [6](#0-5) 

7. Signers compute their signature shares using the (potentially modified) `key_ids` to calculate Lagrange coefficients: `compute::lambda(*key_id, key_ids)` [7](#0-6) 

8. The coordinator later validates signature shares by extracting `key_ids` from its own `self.public_nonces` (the original, unmodified version) [8](#0-7) 

9. During validation, the coordinator computes expected Lagrange coefficients using the original `key_ids`, creating a mismatch: `compute::lambda(*key_id, key_ids)` where `key_ids` differs from what signers used [9](#0-8) 

10. The validation equation fails because different Lagrange coefficients were used: `if z_i * G != (r_sign * Rs[i] + cx_sign * cx)`, and honest parties are added to `bad_party_sigs` [10](#0-9) 

**Root Cause:**

The Lagrange interpolation coefficient is computed as `lambda = ∏(j/(j-i))` for all `j` in `key_ids` where `j ≠ i` [11](#0-10) . Different `key_ids` sets produce different coefficients, causing the signature share validation to fail even when signers compute shares correctly.

The protocol assumes signers can trust the coordinator to relay `key_ids` accurately, but provides no cryptographic binding or validation to enforce this assumption. The coordinator's signature on `SignatureShareRequest` covers the `nonce_responses` (including modified `key_ids`) [12](#0-11) , but this doesn't protect against the coordinator itself being malicious.

**Threat Model Validation:**

Malicious coordinators are explicitly within the WSTS threat model, as evidenced by defensive measures against coordinator attacks such as nonce regeneration after each signing round [13](#0-12) 

## Impact Explanation

**Denial of Service (Critical)**: A malicious coordinator can systematically frame all honest signers by modifying their `key_ids` in the `SignatureShareRequest`. If the coordinator frames enough honest signers (e.g., all parties above the threshold), no valid signatures can be produced because:

1. Framed signers are identified in `BadPartySigs` errors and may be excluded from future rounds
2. Without sufficient honest signers, the threshold cannot be met
3. The network cannot produce valid signatures for transactions

This directly maps to the Critical impact criterion: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

**Accountability Breakdown**: Honest parties incorrectly appear as malicious in error logs returned by `AggregatorError::BadPartySigs` [14](#0-13) , breaking forensic analysis and making it difficult to identify the actual malicious coordinator.

## Likelihood Explanation

**High Likelihood** - The attack is highly feasible because:

1. **Attacker Position**: Requires controlling a coordinator node, which is standard infrastructure in production deployments
2. **Technical Complexity**: Low - requires only modifying data fields before signing, no cryptographic attacks needed
3. **Resources Required**: None beyond running a legitimate coordinator with its signing key
4. **Detection Difficulty**: The coordinator legitimately signs the modified request, leaving no cryptographic evidence of tampering. Signers cannot detect the modification without out-of-band validation of the `key_ids` they received versus what they sent.

The attack exploits a fundamental protocol design issue where signers implicitly trust the coordinator to relay data accurately without verification mechanisms.

## Recommendation

Implement validation at the signer to ensure `key_ids` in the `SignatureShareRequest` match what was expected:

1. **Immediate Fix**: Signers should validate that the `nonce_responses` for their own `signer_id` in the request match what they originally sent. Specifically, check that `key_ids` and `nonces` for their `signer_id` match their local state before computing signature shares.

2. **Enhanced Defense**: Signers should validate that all `key_ids` in the request match the configuration for each `signer_id`, similar to how the coordinator validates incoming `NonceResponse` messages (lines 502-520 in frost.rs).

```rust
// In sign_share_request function, after line 804:
// Validate that key_ids match configuration for each signer
for nr in &sign_request.nonce_responses {
    if let Some(expected_key_ids) = self.public_keys.signer_key_ids.get(&nr.signer_id) {
        let received_key_ids: HashSet<u32> = nr.key_ids.iter().copied().collect();
        if *expected_key_ids != received_key_ids {
            warn!(signer_id = %nr.signer_id, "key_ids in request don't match config");
            return Err(Error::InvalidSignatureShareRequest);
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn malicious_coordinator_modifies_key_ids() {
    // Setup: Create coordinator and signers with threshold setup
    let mut coordinator = /* initialize coordinator */;
    let mut signers = /* initialize signers */;
    
    // Step 1: Signers send NonceResponse with key_ids=[0,1,2,3,4]
    let nonce_responses = collect_nonce_responses(&signers);
    
    // Step 2: Malicious coordinator modifies key_ids for signer 0
    let mut modified_request = create_signature_share_request(nonce_responses);
    modified_request.nonce_responses[0].key_ids = vec![0, 1, 2, 3]; // Remove key_id 4
    
    // Step 3: Coordinator signs the modified request
    let signed_packet = sign_request(&modified_request, &coordinator_key);
    
    // Step 4: Signers compute shares using modified key_ids
    let sig_shares = signers.process_request(&signed_packet); // Uses modified key_ids
    
    // Step 5: Coordinator validates using original key_ids=[0,1,2,3,4]
    let result = coordinator.validate_shares(&sig_shares); // Uses original key_ids
    
    // Assert: Validation fails and signer 0 is blamed
    assert!(matches!(result, Err(AggregatorError::BadPartySigs(bad_parties)) if bad_parties.contains(&0)));
}
```

The test demonstrates that when the coordinator modifies `key_ids` in the request (Step 2), signers compute shares with wrong Lagrange coefficients (Step 4), causing validation to fail and honest signer 0 to be incorrectly identified as malicious (Step 5).

### Citations

**File:** src/net.rs (L314-368)
```rust
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}

impl Debug for NonceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NonceResponse")
            .field("dkg_id", &self.dkg_id)
            .field("sign_id", &self.sign_id)
            .field("sign_iter_id", &self.sign_iter_id)
            .field("signer_id", &self.signer_id)
            .field("key_ids", &self.key_ids)
            .field(
                "nonces",
                &self
                    .nonces
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>(),
            )
            .field("message", &hex::encode(&self.message))
            .finish()
    }
}

impl Signable for NonceResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }

        for nonce in &self.nonces {
            hasher.update(nonce.D.compress().as_bytes());
            hasher.update(nonce.E.compress().as_bytes());
        }

        hasher.update(self.message.as_slice());
    }
}
```

**File:** src/net.rs (L411-432)
```rust
impl Signable for SignatureShareRequest {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("SIGNATURE_SHARE_REQUEST".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());

        for nonce_response in &self.nonce_responses {
            nonce_response.hash(hasher);
        }

        hasher.update(self.message.as_slice());
        match self.signature_type {
            SignatureType::Frost => hasher.update("SIGNATURE_TYPE_FROST".as_bytes()),
            SignatureType::Schnorr => hasher.update("SIGNATURE_TYPE_SCHNORR".as_bytes()),
            SignatureType::Taproot(merkle_root) => {
                hasher.update("SIGNATURE_TYPE_TAPROOT".as_bytes());
                if let Some(merkle_root) = merkle_root {
                    hasher.update(merkle_root);
                }
            }
        }
    }
```

**File:** src/state_machine/coordinator/frost.rs (L502-520)
```rust
            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
```

**File:** src/state_machine/coordinator/frost.rs (L571-578)
```rust
        let nonce_responses = (0..self.config.num_signers)
            .map(|i| self.public_nonces[&i].clone())
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
```

**File:** src/state_machine/coordinator/frost.rs (L582-587)
```rust
        let sig_share_request_msg = Packet {
            sig: sig_share_request
                .sign(&self.config.message_private_key)
                .expect(""),
            msg: Message::SignatureShareRequest(sig_share_request),
        };
```

**File:** src/state_machine/coordinator/frost.rs (L666-678)
```rust
            let nonce_responses = (0..self.config.num_signers)
                .map(|i| self.public_nonces[&i].clone())
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L762-795)
```rust
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L403-403)
```rust
                cx += compute::lambda(*key_id, key_ids) * c * public_key;
```

**File:** src/v2.rs (L406-408)
```rust
            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/v2.rs (L412-413)
```rust
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
```

**File:** src/compute.rs (L70-79)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
```

**File:** src/state_machine/coordinator/mod.rs (L1373-1375)
```rust
    /// Test if a signer will generate a new nonce after a signing round as a defense
    /// against a malicious coordinator who requests multiple signing rounds
    /// with no nonce round in between to generate a new nonce
```
