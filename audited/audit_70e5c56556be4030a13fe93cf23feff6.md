### Title
Non-Participating Signers Can Force DKG Failure Through Stale Invalid Share Records

### Summary
The `dkg_ended()` function checks if `invalid_private_shares` is empty before attempting to compute secrets, but this map is not filtered to only include participating signers from the current DKG round. A malicious signer can send invalid private shares to victims early in the DKG process, then intentionally fail to complete the DKG themselves. The stale invalid share record will cause victims to report DKG failure even when all actual participating signers have valid shares, resulting in complete DKG denial of service.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The vulnerability exists in the `dkg_ended()` function where the code checks `if self.invalid_private_shares.is_empty()` to decide whether to call `compute_secrets()` or immediately return a failure status.

**Root Cause:**

The `invalid_private_shares` map is populated during the `dkg_private_shares()` processing when decryption or scalar parsing fails: [2](#0-1) 

However, in `dkg_ended()`, the code validates shares only from participating signers (those listed in `dkg_end_begin.signer_ids`): [3](#0-2) 

The critical flaw is that the check at line 611 does not filter `invalid_private_shares` by the set of participating signers (`signer_ids_set`). This means invalid shares from non-participating signers will cause the check to fail, skipping `compute_secrets()` entirely and returning a failure status, even when all participating signers have provided valid shares.

**Why Existing Mitigations Fail:**

The `reset()` function clears `invalid_private_shares` at the start of each DKG round: [4](#0-3) 

However, this occurs at DKG initiation, not between the private share distribution phase and the DKG end phase. Once malformed shares are recorded in `invalid_private_shares`, they persist throughout the entire DKG round, regardless of whether those signers actually participate in the final computation.

The coordinator determines participating signers based on who sends private shares on time: [5](#0-4) 

But signers never receive or check against this filtered list when evaluating their `invalid_private_shares` map.

### Impact Explanation

**Specific Harm:**

When a victim signer reports a DKG failure, the coordinator's `gather_dkg_end()` function detects the failure and aborts the entire DKG for all participants: [6](#0-5) 

This results in:
1. **Complete DKG denial of service** - A single malicious signer can prevent any DKG from completing
2. **Violation of DKG threshold security** - The attacker doesn't need to control threshold signers; a single malicious actor can block all DKG attempts
3. **Network-wide consensus failure** - No new signing keys can be generated, preventing the system from rotating keys or onboarding new signers

**Quantified Impact:**

Consider a WSTS deployment with 10 signers and a DKG threshold of 7:
- Attacker (Signer 0) sends malformed private shares to all 9 other signers
- Attacker then fails to respond to the coordinator's DKG messages
- Coordinator creates `DkgEndBegin` with the 9 responsive signers
- All 9 victims have valid shares from each other (meeting the threshold)
- But all 9 victims report failure due to the attacker's stale invalid share record
- Entire DKG fails despite having 9/10 signers with valid shares (well above threshold of 7)

**Who Is Affected:**

All signers in the WSTS network are affected, as no DKG can complete while the attack is ongoing. This prevents:
- Initial key generation for new deployments
- Key rotation for existing deployments
- Recovery from lost/compromised keys

**Severity Justification:**

This maps to **High severity** under the protocol scope:
- "Any unintended chain split or network partition" - The inability to complete DKG can lead to network partition if different nodes have different key material or cannot agree on a group key
- "Any transient consensus failures" (Medium at minimum) - Complete inability to generate signing keys is a persistent consensus failure

The severity is High (not Critical) because:
- It doesn't directly cause fund loss or invalid transaction confirmation
- It requires the attacker to be a registered signer (insider threat)
- The attack is detectable through coordinator logs

However, it's more than Medium because:
- The impact is persistent, not transient
- It completely blocks critical network functionality (key generation)
- Recovery requires manual intervention to remove the malicious signer

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be registered as a signer in the WSTS network
- Must have network access to send messages to other signers
- No cryptographic breaks required
- No coordinator privileges needed

**Attack Complexity:**

The attack is trivial to execute:
1. When `DkgPrivateShares` message is to be sent, replace encrypted shares with random bytes or deliberately use wrong encryption key
2. Send these malformed shares to target victims during the private share distribution phase
3. Intentionally fail to respond to subsequent coordinator messages or disconnect

**Economic Feasibility:**

- **Cost:** Near zero - just requires sending malformed network messages
- **Resources:** No special hardware or computational power needed
- **Time:** Attack can be executed in seconds and repeated indefinitely

**Detection Risk:**

The attack is detectable but attribution is complex:
- Coordinator logs will show which signers reported failures
- Victims' logs will show which signer sent invalid shares (lines 1082, 1090 generate warnings)
- However, the coordinator verification logic (lines 652-763) attempts to determine if the reporter or the accused is malicious

The coordinator's malicious signer detection logic validates the tuple proof and checks if shares are actually bad. However, this verification happens AFTER the DKG has already failed, and requires coordination among honest signers to identify and exclude the attacker from future rounds.

**Estimated Probability of Success:**

Near 100% - The attack will succeed every time because:
- The logic flaw is deterministic
- No race conditions or timing dependencies
- No randomness in victim behavior
- The only defense is manual exclusion of the attacker by network administrators

### Recommendation

**Proposed Code Change:**

Modify the check at line 611 in `dkg_ended()` to filter `invalid_private_shares` by participating signers:

```rust
// Filter invalid_private_shares to only include participating signers
let participating_invalid_shares: HashMap<u32, BadPrivateShare> = self
    .invalid_private_shares
    .iter()
    .filter(|(signer_id, _)| signer_ids_set.contains(signer_id))
    .map(|(k, v)| (*k, v.clone()))
    .collect();

let dkg_end = if participating_invalid_shares.is_empty() {
    // ... existing compute_secrets logic ...
} else {
    DkgEnd {
        dkg_id: self.dkg_id,
        signer_id: self.signer_id,
        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
            participating_invalid_shares,
        )),
    }
};
```

This ensures that only invalid shares from signers who are actually participating in this DKG round will cause a failure.

**Alternative Mitigations:**

1. **Clear invalid shares when DkgEndBegin is received** - Add logic in `dkg_end_begin()` to filter `invalid_private_shares` against `dkg_end_begin.signer_ids`
2. **Timeout-based clearing** - Clear invalid share records after a timeout period
3. **Coordinator-driven validation** - Have the coordinator pre-validate all shares before sending `DkgEndBegin`

**Testing Recommendations:**

1. Add unit test with scenario: malicious signer sends bad shares, then is excluded from `DkgEndBegin`, verify DKG succeeds
2. Add integration test: simulate network with one malicious signer sending garbage shares but not participating, verify other signers complete DKG
3. Test edge case: malicious signer sends bad shares to subset of signers (not all)
4. Verify backward compatibility: ensure fix doesn't break legitimate failure detection

**Deployment Considerations:**

- This is a consensus-critical fix that must be deployed atomically across all signers
- Coordinate upgrade during a maintenance window
- Consider rolling back any failed DKG attempts after the fix to retry with corrected logic
- Update monitoring to distinguish between "invalid shares from participating signer" vs "stale invalid shares from non-participating signer"

### Proof of Concept

**Exploitation Algorithm:**

```
Setup:
- Network with 5 signers (IDs 0-4)
- DKG threshold: 3
- Attacker: Signer 0
- Victims: Signers 1, 2, 3, 4

Step 1: DKG Initiation
- Coordinator broadcasts DkgBegin(dkg_id=1)
- All signers transition to DkgPublicDistribute state

Step 2: Public Share Distribution
- All signers send DkgPublicShares with valid polynomial commitments
- Attacker sends valid public shares to appear cooperative

Step 3: Private Share Distribution (ATTACK BEGINS)
- Coordinator broadcasts DkgPrivateBegin with signer_ids=[0,1,2,3,4]
- Honest signers (1,2,3,4) send properly encrypted DkgPrivateShares
- Attacker (0) sends DkgPrivateShares with:
  * Valid structure but random bytes instead of encrypted shares
  * OR shares encrypted with wrong key
  * OR shares that decrypt but aren't valid scalars

Step 4: Victim Processing
- Victims (1,2,3,4) receive attacker's malformed shares
- Decryption/parsing fails (lines 1076-1096)
- Each victim adds attacker (signer_id=0) to invalid_private_shares

Step 5: Attacker Drops Out
- Attacker stops responding to coordinator
- OR sends DkgPrivateShares too late
- Coordinator's timeout expires without attacker's private shares

Step 6: DkgEndBegin Distribution
- Coordinator creates DkgEndBegin with signer_ids=[1,2,3,4]
- Only includes signers who sent private shares on time
- Excludes attacker (signer_id=0)

Step 7: DKG End Processing (VULNERABILITY TRIGGERED)
- Victims receive DkgEndBegin(signer_ids=[1,2,3,4])
- Each victim validates shares from [1,2,3,4] - all valid
- Threshold check passes (4 signers with 4 keys >= threshold of 3)
- BUT: At line 611, invalid_private_shares.is_empty() returns false
- Contains entry: {0: BadPrivateShare{...}}
- Skips compute_secrets() entirely
- Each victim sends DkgEnd with status=Failure(BadPrivateShares({0: ...}))

Step 8: DKG Failure
- Coordinator receives 4 DkgEnd failures
- Marks DKG as failed (lines 779-789)
- All signers remain without group key
```

**Parameter Values:**
- `total_signers`: 5
- `dkg_threshold`: 3
- `threshold`: 3
- Malformed share content: `vec![0xFF; 32]` (invalid scalar)

**Expected vs Actual Behavior:**

Expected: DKG should succeed with 4 participating signers (exceeds threshold of 3)

Actual: DKG fails because all 4 victims have stale invalid share records from non-participating attacker

**Reproduction Instructions:**

1. Set up WSTS network with 5 signers
2. Modify Signer 0's code to send random bytes in DkgPrivateShares
3. Have Signer 0 not respond after sending malformed shares
4. Observe Signers 1-4 all report DkgFailure despite having valid shares from each other
5. Check coordinator logs to confirm DKG failure with error "got dkg failures"
6. Verify no aggregate public key was generated despite threshold being met

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L529-582)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
        let mut num_dkg_keys = 0u32;
        for id in &signer_ids_set {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(id) {
                let len: u32 = key_ids.len().try_into()?;
                num_dkg_keys = num_dkg_keys.saturating_add(len);
            }
        }

        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
        }

        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L611-660)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };
```

**File:** src/state_machine/signer/mod.rs (L1076-1096)
```rust
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```
