### Title
Unvalidated DKG Failure Reports Allow Malicious Signers to Cause Repeated DKG Denial of Service

### Summary
The FIRE coordinator's `gather_dkg_end()` function does not validate three types of DKG failure reports (`Threshold`, `MissingPublicShares`, `MissingPrivateShares`), allowing a malicious signer to falsely report these failures and cause indefinite DKG round failures without being detected or marked as malicious. This enables a single compromised signer to prevent the distributed key generation process from completing, affecting all participants in the threshold signature system.

### Finding Description

**Location:** [1](#0-0) [2](#0-1) 

**Root Cause:**
The coordinator's `gather_dkg_end()` function processes DKG failure reports from signers but only validates `BadPublicShares` and `BadPrivateShares` failures. Three failure types have TODO comments indicating they should mark reporters as malicious, but contain no validation logic:

1. `DkgFailure::Threshold` - Reports that DKG threshold was not met
2. `DkgFailure::MissingPublicShares` - Reports missing public shares from specified signers  
3. `DkgFailure::MissingPrivateShares` - Reports missing private shares from specified signers [3](#0-2) 

When any DKG failure is reported, it's added to the `reported_failures` map. If this map is non-empty after processing all DkgEnd messages, the entire DKG round fails and returns an error. [4](#0-3) 

**Why Existing Mitigations Fail:**
The coordinator tracks which signers sent public and private shares in `dkg_public_shares` and `dkg_private_shares` maps, and broadcasts this information in `DkgPrivateBegin` and `DkgEndBegin` messages. [5](#0-4) [6](#0-5) 

This gives the coordinator complete knowledge to validate `MissingPublicShares` and `MissingPrivateShares` claims, but this validation is not implemented. Similarly, the coordinator performs its own threshold checks during timeouts, [7](#0-6)  but doesn't validate signer-reported `Threshold` failures against its own view.

The `malicious_dkg_signer_ids` tracking exists but is never consulted to filter signers from future DKG rounds, making even proper marking ineffective without additional enforcement logic.

### Impact Explanation

**Specific Harm:**
A malicious signer can cause indefinite DKG failures affecting all participants by repeatedly sending false failure reports. Each failed DKG round wastes computational resources (polynomial generation, share encryption/decryption, commitment verification) and network bandwidth across all signers.

**Quantified Impact:**
- Single compromised signer affects 100% of DKG participants
- Each DKG round requires O(nÂ²) encrypted share exchanges where n = number of signers
- No upper bound on repeated attacks since detection is absent
- Prevents establishment of new aggregate public keys required for threshold signing operations

**Affected Parties:**
All signers in the WSTS system are affected, as DKG is a distributed protocol requiring participation from threshold-many honest signers. If WSTS is used for Stacks blockchain consensus (as suggested by the protocol scope definitions), this impacts block signers and transaction validation.

**Severity Justification:**
This vulnerability maps to **Medium severity** under "Any transient consensus failures" because:
1. DKG failure prevents new signer set formation required for consensus participation
2. Affects network-wide operations, not just individual nodes
3. While existing keys can continue signing, key rotation and initial setup are blocked
4. Creates indefinite availability issues without detection mechanisms

Alternatively maps to **Low severity** under "Any network denial of service impacting more than 10 percent of miners that does not shut down the network" if DKG is not directly consensus-critical.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Registered signer with valid signing keys in the WSTS configuration
- Network access to send `DkgEnd` messages to the coordinator
- No additional privileges, cryptographic breaks, or insider knowledge required

**Attack Complexity:**
Extremely low. The attacker simply modifies their signer implementation to return `DkgStatus::Failure` with one of the unvalidated failure types in the `dkg_ended()` method. [8](#0-7) 

Example: Instead of computing shares correctly, return:
```rust
DkgEnd {
    dkg_id: self.dkg_id,
    signer_id: self.signer_id,
    status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
        // Falsely claim all other signers' shares are missing
        other_signer_ids
    )),
}
```

**Economic Feasibility:**
No economic cost to the attacker. There is no slashing mechanism, bond requirement, or reputation system that penalizes false failure reports.

**Detection Risk:**
Zero. The coordinator logs the failure but has no mechanism to distinguish false reports from legitimate ones. [9](#0-8)  The malicious signer is not added to `malicious_signers` and can repeat the attack indefinitely.

**Estimated Probability:**
High. Any compromised or malicious signer can trivially execute this attack with certainty of success and no risk of detection.

### Recommendation

**Primary Fix:**
Implement validation logic for the three unhandled failure types in `gather_dkg_end()`:

1. **For `DkgFailure::Threshold`**: Verify the reporter's claim by checking if `dkg_end_begin.signer_ids` contains sufficient signers to meet `config.dkg_threshold`. If the threshold is met but the signer reports failure, mark them malicious.

2. **For `DkgFailure::MissingPublicShares`**: Validate each reported missing signer_id by checking if it exists in `self.dkg_public_shares`. If shares were actually received, mark the reporter malicious. If shares were legitimately missing, the reporter is honest.

3. **For `DkgFailure::MissingPrivateShares`**: Similarly validate against `self.dkg_private_shares`. Cross-check with the `signer_ids` list from `DkgEndBegin` to confirm which signers should have sent shares.

**Code Changes:**
Replace empty case blocks with validation logic similar to the existing `BadPublicShares` and `BadPrivateShares` handlers. Add malicious reporters to `malicious_signers` set when false reports are detected.

**Additional Mitigation:**
Implement the TODO at line 783: "see if we have sufficient non-malicious signers to continue". [10](#0-9)  This would allow DKG to proceed with honest signers even if some signers report failures.

**Testing Recommendations:**
- Add test cases where a signer falsely reports each of the three failure types
- Verify the coordinator marks false reporters as malicious
- Test that DKG can continue with sufficient honest signers when some report failures
- Verify `malicious_dkg_signer_ids` is consulted in future DKG rounds (requires additional implementation)

**Deployment Considerations:**
This fix should be deployed before production use in consensus-critical systems, as it provides essential accountability for DKG participants.

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Deploy WSTS coordinator and multiple signers with threshold configuration (e.g., 3-of-5)

2. **Attacker Position**: Compromise or control one signer node (signer_id = 2)

3. **Attack Execution**: Modify the compromised signer's `dkg_ended()` method to always return false `MissingPrivateShares` failure:

```rust
// In attacker's modified signer
pub fn dkg_ended<R: RngCore + CryptoRng>(&mut self, rng: &mut R) -> Result<Message, Error> {
    // Malicious: falsely report all other signers' private shares as missing
    let other_signers: HashSet<u32> = (0..self.total_signers)
        .filter(|&id| id != self.signer_id)
        .collect();
    
    Ok(Message::DkgEnd(DkgEnd {
        dkg_id: self.dkg_id,
        signer_id: self.signer_id,
        status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(other_signers)),
    }))
}
```

4. **Expected Behavior**: Coordinator should validate the claim against `self.dkg_private_shares`, detect the false report, and mark signer_id 2 as malicious

5. **Actual Behavior**: 
   - Coordinator adds the failure to `reported_failures` without validation [11](#0-10) 
   - DKG round fails and returns `Error::DkgFailure` [12](#0-11) 
   - Signer_id 2 is NOT marked as malicious
   - Attack can be repeated for every subsequent DKG round

6. **Reproduction**: 
   - Run existing test suite with modified signer implementation
   - Observe DKG failures without malicious signer detection
   - Verify `malicious_signers` set remains empty despite false reports

**Parameter Values:**
- Threshold: 3, Total signers: 5
- Single malicious signer (20% of network)
- Impact: 100% DKG failure rate

### Citations

**File:** src/state_machine/coordinator/fire.rs (L82-92)
```rust
                            let dkg_size = self.compute_dkg_public_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPublicTimeout(
                                        wait,
                                    ))),
                                ));
```

**File:** src/state_machine/coordinator/fire.rs (L432-435)
```rust
        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
            key_ids: vec![],
```

**File:** src/state_machine/coordinator/fire.rs (L461-464)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
```

**File:** src/state_machine/coordinator/fire.rs (L600-610)
```rust
        let mut reported_failures = HashMap::new();
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
        let threshold: usize = self.config.threshold.try_into().unwrap();
        if self.dkg_wait_signer_ids.is_empty() {
            // if there are any errors, mark signers malicious and retry
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L617-619)
```rust
                        DkgFailure::Threshold => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L779-788)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/signer/mod.rs (L504-510)
```rust
    pub fn dkg_ended<R: RngCore + CryptoRng>(&mut self, rng: &mut R) -> Result<Message, Error> {
        if !self.can_dkg_end() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadState),
            }));
```
