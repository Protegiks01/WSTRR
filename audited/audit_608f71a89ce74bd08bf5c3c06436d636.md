### Title
Message Substitution Attack via Unchecked Nonce Response in Coordinator

### Summary
An attacker controlling threshold signers can force the coordinator to sign an arbitrary message by submitting NonceResponse messages with a substituted message field. The coordinator fails to validate that incoming nonce responses match the originally requested message, allowing line 954 to overwrite `self.message` with attacker-controlled data. This results in a valid threshold signature for an unintended message, directly violating the "confirmation of an invalid transaction" critical impact criterion.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:** The coordinator's `gather_nonces()` function accepts NonceResponse messages without validating that the `message` field matches the message originally requested in the NonceRequest. [2](#0-1) 

The coordinator uses `nonce_response.message` as the HashMap key for tracking nonces per message, then when threshold is reached for any message [3](#0-2) , it unconditionally overwrites `self.message` with the "winning" message from the nonce responses.

**Protocol Flow:**
1. Coordinator sets `self.message` to the intended message M1 [4](#0-3) 
2. Sends NonceRequest containing M1 [5](#0-4) 
3. Signers receive NonceRequest and echo back the message field [6](#0-5) 
4. Malicious signers substitute M2 in their NonceResponse
5. Coordinator accepts responses without message validation [7](#0-6) 
6. When threshold met for M2, `self.message` becomes M2
7. Coordinator requests signature shares for M2 [8](#0-7) 
8. Aggregator produces valid signature for M2 [9](#0-8) 

**Why Existing Mitigations Fail:** The coordinator validates dkg_id, sign_id, sign_iter_id, signer_id, key_ids, nonce validity, and malicious signer status, but completely omits validation of the message field itself.

### Impact Explanation

**Severity: CRITICAL**

This vulnerability directly maps to the critical scope criterion: "Any confirmation of an invalid transaction, such as with an incorrect nonce." The coordinator produces a cryptographically valid threshold signature, but for an attacker-chosen message rather than the intended one.

**Concrete Impact:**
- **Blockchain/Stacks Context:** Attacker can authorize arbitrary transactions, transfers, or state changes instead of legitimate operations, leading to direct loss of funds
- **Invalid Transaction Confirmation:** The signature validates correctly but authorizes unintended operations
- **Who is Affected:** All users relying on the coordinator for transaction authorization; the entire network if this is used for consensus-critical operations

**Quantification:** With a typical 2-of-3 or 5-of-7 threshold configuration, an attacker controlling the threshold number of signers can execute this attack with 100% success rate. In a blockchain context where signatures authorize fund transfers, this could result in complete loss of all funds controlled by the threshold key.

### Likelihood Explanation

**Attacker Prerequisites:**
- Control of threshold number of signers (e.g., 2-of-3, 3-of-5, or 5-of-7 depending on configuration)
- Network access to send NonceResponse messages
- Knowledge of when coordinator initiates signing rounds

**Attack Complexity: LOW**
- No cryptographic breaks required
- Simple message field substitution in network protocol
- Deterministic success once threshold controlled

**Economic Feasibility:**
Threshold control is the fundamental security assumption of the protocol. Attackers can achieve this through:
- Compromising threshold number of signer nodes
- Coordinating threshold colluding parties
- Exploiting operational security weaknesses

**Detection Risk: LOW**
- Attack appears as normal protocol operation
- Coordinator has no visibility that substitution occurred
- Signature validates correctly, making post-facto detection difficult
- No error messages or warnings generated

**Success Probability:** 100% if attacker controls threshold signers and coordinator doesn't independently verify the final message before use.

### Recommendation

**Primary Fix:** Add message validation in `gather_nonces()`:

```rust
// After line 861 in gather_nonces(), add:
if nonce_response.message != self.message {
    warn!(
        signer_id = %nonce_response.signer_id,
        "NonceResponse message doesn't match requested message"
    );
    return Ok(());
}
```

**Additional Mitigations:**
1. Before overwriting `self.message` at line 954, verify all nonce responses have the same message
2. Add a check in `request_sig_shares()` to verify `self.message` hasn't changed since `request_nonces()`
3. Log the message hash when starting signing and verify it matches when completing
4. Document that `NonceResponse.message` must exactly match `NonceRequest.message`

**Testing Recommendations:**
1. Add unit test where malicious signers return different messages
2. Verify coordinator rejects mismatched messages
3. Test that attack fails when fix is applied
4. Add integration test for message substitution attack

**Deployment Considerations:**
- This is a protocol-breaking change if signers send different messages legitimately (they shouldn't)
- Review logs to ensure no existing deployments rely on this behavior
- Deploy to coordinator before it affects operations

### Proof of Concept

**Attack Algorithm:**

1. **Setup:** Configure WSTS with threshold T=2, total signers N=3
2. **Attacker controls:** Signers 0 and 1 (meeting threshold)
3. **Coordinator starts signing:** `start_signing_round(message_M1, ...)`
4. **Coordinator sends:** NonceRequest with message=M1 to all signers
5. **Honest signer 2 responds:** NonceResponse with message=M1
6. **Attacker signers 0,1 respond:** NonceResponse with message=M2 (attacker's message)
7. **Coordinator gather_nonces():** 
   - Stores signer 2's nonces under key M1
   - Stores signers 0,1's nonces under key M2
   - Checks threshold: len(nonces[M2]) = 2 ≥ threshold = 2 ✓
   - Executes line 954: `self.message = M2` (OVERWRITE)
8. **Coordinator requests signature shares:** SignatureShareRequest with message=M2
9. **All signers compute shares for M2** (honest signer 2 trusts the coordinator)
10. **Coordinator aggregates:** Valid signature for M2

**Expected vs Actual:**
- **Expected:** Signature for M1 (coordinator's intended message)
- **Actual:** Signature for M2 (attacker's malicious message)
- **Consequence:** Coordinator unknowingly authorizes attacker's operation

**Reproduction:** Use the existing test infrastructure in `src/state_machine/coordinator/fire.rs` tests, modify two signers to return NonceResponse with a different message, verify coordinator produces signature for wrong message.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L826-826)
```rust
            message: self.message.clone(),
```

**File:** src/state_machine/coordinator/fire.rs (L841-962)
```rust
    fn gather_nonces(
        &mut self,
        packet: &Packet,
        signature_type: SignatureType,
    ) -> Result<(), Error> {
        if let Message::NonceResponse(nonce_response) = &packet.msg {
            if nonce_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(nonce_response.dkg_id, self.current_dkg_id));
            }
            if nonce_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    nonce_response.sign_id,
                    self.current_sign_id,
                ));
            }
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&nonce_response.signer_id) {
                warn!(signer_id = %nonce_response.signer_id, "No public key in config");
                return Ok(());
            };

            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }

            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }

            let nonce_info = self
                .message_nonces
                .entry(nonce_response.message.clone())
                .or_default();

            let have_nonces = nonce_info
                .public_nonces
                .contains_key(&nonce_response.signer_id);

            if have_nonces {
                info!(signer_id = %nonce_response.signer_id, "Received duplicate NonceResponse");
                return Ok(());
            }

            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());

            // ignore the passed key_ids
            for key_id in signer_key_ids {
                nonce_info.nonce_recv_key_ids.insert(*key_id);
            }

            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
            // Because of entry call, it is safe to unwrap here
            info!(
                sign_id = %nonce_response.sign_id,
                sign_iter_id = %nonce_response.sign_iter_id,
                signer_id = %nonce_response.signer_id,
                recv_keys = %nonce_info.nonce_recv_key_ids.len(),
                threshold = %self.config.threshold,
                "Received NonceResponse"
            );
            if nonce_info.nonce_recv_key_ids.len() >= self.config.threshold as usize {
                // We have a winning message!
                self.message.clone_from(&nonce_response.message);
                let aggregate_nonce = self.compute_aggregate_nonce();
                info!("Aggregate nonce: {aggregate_nonce}");

                self.move_to(State::SigShareRequest(signature_type))?;
            }
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L970-983)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
            message: self.message.clone(),
```

**File:** src/state_machine/coordinator/fire.rs (L1145-1169)
```rust
            self.aggregator.init(&self.party_polynomials)?;

            if let SignatureType::Taproot(merkle_root) = signature_type {
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    &shares,
                    &key_ids,
                    merkle_root,
                )?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else if let SignatureType::Schnorr = signature_type {
                let schnorr_proof =
                    self.aggregator
                        .sign_schnorr(&self.message, &nonces, &shares, &key_ids)?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else {
                let signature = self
                    .aggregator
                    .sign(&self.message, &nonces, &shares, &key_ids)?;
                debug!("Signature ({}, {})", signature.R, signature.z);
                self.signature = Some(signature);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1467-1467)
```rust
        self.message = message.to_vec();
```

**File:** src/state_machine/signer/mod.rs (L740-740)
```rust
            message: nonce_request.message.clone(),
```
