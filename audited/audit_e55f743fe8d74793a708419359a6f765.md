### Title
V2 Protocol Binding Value Mismatch Causes All Signature Aggregations to Fail

### Summary
The coordinator's `compute_aggregate_nonce()` function incorrectly uses `key_ids` instead of `signer_ids` when computing binding values for v2 protocol operations. This causes a cryptographic mismatch between the aggregate nonce computed by the coordinator and the nonces computed by v2 signers, resulting in 100% signature verification failure for all v2 signing rounds.

### Finding Description

The vulnerability exists in the `compute_aggregate_nonce()` function in both Fire and FROST coordinator implementations. The coordinator always extracts `key_ids` from `NonceResponse` messages to compute the aggregate nonce: [1](#0-0) 

The same pattern exists in the FROST coordinator: [2](#0-1) 

The comment explicitly warns that this needs different handling for v1 vs v2: [3](#0-2) 

**Root Cause:**

In WSTS v2, a single party (identified by `party_id`/`signer_id`) can control multiple keys (identified by `key_ids`). The binding value in the Fiat-Shamir transform must be computed using consistent party identifiers.

V2 signers correctly compute their binding using `party_ids` (signer IDs): [4](#0-3) 

Where `self.id()` returns the party's `party_id`: [5](#0-4) 

The v2 trait implementation confirms this should use `signer_ids`: [6](#0-5) 

However, the coordinator uses `key_ids` for both v1 and v2, creating a mismatch.

**Why Existing Mitigations Fail:**

There are no mitigations. The `NonceResponse` structure contains both `signer_id` and `key_ids`: [7](#0-6) 

But the coordinator always uses `key_ids` regardless of protocol version. The coordinator has no conditional logic to distinguish between v1 and v2 protocol versions when computing the aggregate nonce.

### Impact Explanation

**Specific Harm:**
The binding value is a critical component of the Fiat-Shamir transform in FROST. When the coordinator computes binding values using different party identifiers than the signers:

1. Coordinator computes: `binding(&id(key_id), nonces, msg)` for EACH key_id
2. V2 signer computes: `binding(&id(party_id), nonces, msg)` for their ONE party_id
3. This produces different binding coefficients (ρ values)
4. Different binding coefficients yield different aggregate nonces R
5. Signers compute signature shares using their R
6. Coordinator expects shares based on its different R
7. **Result**: Signature verification FAILS every time

**Quantified Impact:**
- 100% failure rate for all v2 signing operations
- Complete inability to produce valid signatures using v2 protocol
- Any blockchain or system relying on v2 WSTS signatures cannot function

**Who is Affected:**
Any deployment using the v2 protocol for weighted threshold signatures. In Stacks blockchain context, this maps to **Medium severity** (transient consensus failures) at minimum, potentially **Critical** if the network exclusively uses v2 protocol and cannot confirm transactions.

**Severity Justification:**
This meets the definition of "Any network to shut down or otherwise not confirm new valid transactions" if v2 is the primary signing protocol. At minimum, it causes "transient consensus failures" (Medium) by making all v2 signing rounds fail.

### Likelihood Explanation

**Required Capabilities:**
None. This is a deterministic protocol implementation bug, not an attack.

**Attack Complexity:**
Not applicable - no attacker needed. The bug triggers automatically during normal v2 protocol operation.

**Prerequisites:**
- System attempts to use v2 protocol for signing
- No special access or position required
- No secrets needed

**Economic Feasibility:**
Not applicable - this is a protocol bug, not an economic attack.

**Detection Risk:**
The bug would be immediately obvious as 100% of v2 signatures fail verification. However, developers might misdiagnose it as a different issue rather than recognizing the binding value mismatch.

**Probability of Success:**
100% guaranteed to cause signature verification failure on every v2 signing operation.

### Recommendation

**Immediate Fix:**

Modify `compute_aggregate_nonce()` in both coordinator implementations to distinguish between v1 and v2 protocols. The coordinator needs access to protocol version information to determine whether to use `key_ids` or `signer_id`.

**Proposed Code Changes:**

For v2 protocol, extract signer_ids instead of key_ids:
```rust
let party_ids = if is_v2_protocol {
    // For v2: use signer_id from each NonceResponse
    public_nonces
        .values()
        .map(|pn| pn.signer_id)
        .collect::<Vec<u32>>()
} else {
    // For v1: use key_ids (one per party since party_id == key_id)
    public_nonces
        .values()
        .cloned()
        .flat_map(|pn| pn.key_ids)
        .collect::<Vec<u32>>()
};
```

**Alternative Mitigation:**

Add a protocol version field to the coordinator configuration and NonceResponse validation logic to ensure the correct IDs are used based on protocol version.

**Testing Recommendations:**

1. Add integration tests that verify v2 signature aggregation succeeds
2. Test with multiple parties where each controls different numbers of keys
3. Verify that coordinator-computed aggregate nonce matches signer-computed nonces
4. Compare v1 and v2 behavior to ensure both work correctly

**Deployment Considerations:**

This fix is backwards compatible with v1 but fixes broken v2 functionality. If v2 is already deployed, this is a critical hotfix. If v2 is not yet deployed, this must be fixed before v2 launch.

### Proof of Concept

**Step-by-Step Exploitation:**

1. **Setup**: Configure a v2 WSTS system with 3 parties where:
   - Party 1 (party_id=1) controls key_ids=[1, 2]
   - Party 2 (party_id=2) controls key_ids=[3, 4]  
   - Party 3 (party_id=3) controls key_ids=[5, 6]

2. **Nonce Generation**: Each party generates ONE nonce bound to their party_id:
   - Party 1 generates nonce N1, computes binding with id(1)
   - Party 2 generates nonce N2, computes binding with id(2)
   - Party 3 generates nonce N3, computes binding with id(3)

3. **Coordinator Processing**: Coordinator receives NonceResponses:
   ```
   NonceResponse { signer_id: 1, key_ids: [1,2], nonces: [N1] }
   NonceResponse { signer_id: 2, key_ids: [3,4], nonces: [N2] }
   NonceResponse { signer_id: 3, key_ids: [5,6], nonces: [N3] }
   ```

4. **Coordinator Bug**: Coordinator extracts party_ids = [1,2,3,4,5,6] (six key_ids) and computes:
   - `compute::intermediate(msg, [1,2,3,4,5,6], [N1,N2,N3])`
   - This attempts to compute bindings for 6 parties with only 3 nonces
   - Results in incorrect binding values and wrong aggregate nonce R_coord

5. **Signer Computation**: Each signer computes with party_ids = [1,2,3]:
   - `compute::intermediate(msg, [1,2,3], [N1,N2,N3])`
   - Computes correct binding values for 3 parties with 3 nonces
   - Results in correct aggregate nonce R_signer

6. **Signature Failure**: 
   - R_coord ≠ R_signer
   - Signature shares computed with R_signer don't verify with R_coord
   - Aggregated signature fails verification

**Expected Behavior:**
Coordinator and signers should both compute identical aggregate nonce R using party_ids [1,2,3].

**Actual Behavior:**
Coordinator computes different R using key_ids [1,2,3,4,5,6], causing signature verification to fail.

**Reproduction:**
Run any v2 signing operation where at least one party controls multiple keys. The signature will fail verification 100% of the time due to the binding value mismatch.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L1178-1178)
```rust
        // XXX this needs to be key_ids for v1 and signer_ids for v2
```

**File:** src/state_machine/coordinator/fire.rs (L1185-1189)
```rust
        let party_ids = public_nonces
            .values()
            .cloned()
            .flat_map(|pn| pn.key_ids)
            .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/frost.rs (L738-742)
```rust
        let party_ids = self
            .public_nonces
            .values()
            .flat_map(|pn| pn.key_ids.clone())
            .collect::<Vec<u32>>();
```

**File:** src/v2.rs (L204-207)
```rust
    /// Compute a Scalar from this party's ID
    pub fn id(&self) -> Scalar {
        compute::id(self.party_id)
    }
```

**File:** src/v2.rs (L255-257)
```rust
        let (_, R) = compute::intermediate(msg, party_ids, nonces);
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
```

**File:** src/v2.rs (L635-642)
```rust
    fn compute_intermediate(
        msg: &[u8],
        signer_ids: &[u32],
        _key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> (Vec<Point>, Point) {
        compute::intermediate(msg, signer_ids, nonces)
    }
```

**File:** src/net.rs (L318-321)
```rust
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
```
