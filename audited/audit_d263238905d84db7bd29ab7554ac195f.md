### Title
Signature Share Reordering Denial of Service in v1 Implementation

### Summary
A malicious signer in the v1 implementation can deliberately reorder signature shares within their `SignatureShareResponse` message to cause signing rounds to fail. The `SignatureShareResponse::hash()` function includes shares in iteration order, but the coordinator only validates the set of key IDs without checking positional correspondence between nonces and shares, allowing a malicious insider to disrupt signature aggregation.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the interaction between multiple components:

1. **Hash function** (order-dependent but lacks ordering validation): [1](#0-0) 

2. **v1 Signer share generation** (creates shares in deterministic order): [2](#0-1) 

3. **Coordinator validation** (only checks set membership, not order): [3](#0-2) 

4. **Share flattening** (assumes positional correspondence): [4](#0-3) 

5. **Aggregator processing** (relies on nonce-share positional correspondence): [5](#0-4) 

6. **Binding computation** (uses zip to pair nonces with binding values): [6](#0-5) 

**Root Cause:**

The v1 implementation allows a signer to control multiple keys (stored as multiple `Party` objects). When creating signature shares, the signer iterates over parties in order, producing a `Vec<SignatureShare>` where `shares[i]` corresponds to `nonces[i]`. The coordinator assumes this correspondence during aggregation by using `compute::intermediate()`, which zips nonces with binding values computed from party IDs extracted from shares.

However, the coordinator's validation only checks that the set of key IDs in the response matches the expected set using `HashSet` comparison. It does not validate that signature shares are in the correct order relative to the nonces that were previously provided.

**Why Existing Mitigations Fail:**

1. **Packet signature verification** does not prevent this attack because the malicious signer signs their own reordered message with their own private key, which passes verification.

2. **Key ID validation** only compares sets, not ordering or positional correspondence.

3. **check_signature_shares** correctly identifies the malicious signer's shares as invalid after aggregation fails, but the damage (DoS) is already done.

### Impact Explanation

**Specific Harm:**

A malicious v1 signer with multiple keys can cause signing rounds to fail by reordering their signature shares. When shares are reordered (e.g., `[Share3, Share1, Share5]` instead of `[Share1, Share3, Share5]`), the aggregator's `compute::intermediate()` function creates incorrect pairings between nonces and binding values. This causes the aggregate signature to fail verification, aborting the signing round.

**Quantified Impact:**

- Each malicious reordering causes one signing round to fail
- The attack can be repeated indefinitely to prevent any signatures from being produced
- All participants waste computational resources on failed aggregation
- The malicious signer is identified but the signing round still fails

**Who Is Affected:**

Only users who:
1. Enable the optional `with_v1` feature [7](#0-6) 
2. Use the v1 implementation [8](#0-7) 
3. Have signers controlling multiple keys

The v2 implementation is not affected because each signer returns exactly one signature share: [9](#0-8) 

**Severity Justification:**

This maps to **Low** severity according to the protocol scope: "Any remotely-exploitable denial of service in a node". The attack causes signing operations to fail but does not:
- Shut down the network
- Cause loss of funds
- Create chain splits
- Confirm invalid transactions
- Affect nodes not using the v1 feature

### Likelihood Explanation

**Required Attacker Capabilities:**

1. Must be a legitimate participant who passed DKG and holds valid private keys
2. Must control multiple keys (common in v1 architecture)
3. Must have access to send messages to the coordinator
4. Must be selected for the signing committee

**Attack Complexity:**

Low complexity. The attacker simply:
1. Receives a `SignatureShareRequest`
2. Generates valid signature shares normally
3. Reorders the `signature_shares` Vec before sending
4. Signs the reordered message with their own key

**Economic Feasibility:**

Highly feasible. No additional resources required beyond normal participation. The attacker wastes computational resources of all participants but incurs minimal cost themselves.

**Detection Risk:**

The attack is immediately detected after aggregation fails, and `check_signature_shares` correctly identifies the malicious signer. However, detection occurs after the signing round has already failed.

**Estimated Probability:**

Conditional probability is high if:
- An attacker becomes a legitimate participant (requires insider access)
- The system uses the optional v1 feature (low adoption expected since v2 is default)
- The attacker controls multiple keys

Overall probability is low-to-medium due to the feature flag requirement and insider prerequisite.

### Recommendation

**Primary Fix:**

Add ordering validation in the coordinator's `gather_sig_shares()` method to verify that signature shares maintain the same order as the nonces that were previously sent. Specifically, validate that `signature_shares[i].id` corresponds to the key ID that produced `nonces[i]`.

**Proposed Code Changes:**

In `src/state_machine/coordinator/fire.rs`, after the existing set validation (around line 1076), add positional correspondence validation:

```rust
// After line 1076, add:
// Verify that signature shares maintain the correct order relative to nonces
let nonce_response = &message_nonce.public_nonces[&sig_share_response.signer_id];
if sig_share_response.signature_shares.len() != nonce_response.nonces.len() {
    return Err(Error::BadSignatureShareCount);
}
for (sig_share, nonce) in sig_share_response.signature_shares.iter()
    .zip(nonce_response.key_ids.iter()) {
    if !sig_share.key_ids.contains(nonce) {
        warn!(signer_id = %sig_share_response.signer_id, 
              "SignatureShare ordering mismatch with nonces");
        return Err(Error::BadSignatureShareOrdering);
    }
}
```

**Alternative Mitigation:**

Since v1 is an optional feature and v2 is the recommended implementation, consider:
1. Deprecating the v1 feature with a migration guide to v2
2. Adding prominent security warnings in v1 documentation
3. Implementing timeout-based malicious signer exclusion to limit repeated attacks

**Testing Recommendations:**

1. Add unit tests that attempt to reorder signature shares and verify the attack is prevented
2. Add integration tests covering all validation paths
3. Test both v1 and v2 implementations to ensure the fix doesn't affect v2

**Deployment Considerations:**

This is a breaking change for v1 users. Coordinate with v1 feature users before deploying. Since v1 is optional and v2 is default, impact should be minimal.

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup Phase:**
   - Attacker is a legitimate v1 signer with key_ids `[1, 3, 5]`
   - DKG completes successfully
   - Attacker generates nonces normally: `[Nonce1, Nonce3, Nonce5]`

2. **Normal NonceResponse:**
   ```
   NonceResponse {
       signer_id: attacker_id,
       key_ids: [1, 3, 5],
       nonces: [Nonce1, Nonce3, Nonce5],
       ...
   }
   ```

3. **Malicious SignatureShareResponse:**
   ```
   // Normal share generation
   let shares = signer.sign(msg, signer_ids, key_ids, nonces)
   // shares = [Share1, Share3, Share5]
   
   // Attacker reorders before sending
   shares.reverse(); // Now [Share5, Share3, Share1]
   
   SignatureShareResponse {
       signer_id: attacker_id,
       signature_shares: shares, // REORDERED
       ...
   }
   ```

4. **Expected Behavior (Normal):**
   - Coordinator flattens: `nonces=[N1,N3,N5]`, `shares=[S1,S3,S5]`
   - `compute::intermediate` pairs: `(N1, binding(1,...))`, `(N3, binding(3,...))`, `(N5, binding(5,...))`
   - Aggregation succeeds

5. **Actual Behavior (Attack):**
   - Coordinator flattens: `nonces=[N1,N3,N5]`, `shares=[S5,S3,S1]` (reordered)
   - Extract signers: `[5,3,1]` from reordered shares
   - `compute::intermediate` computes binding values: `[binding(5,...), binding(3,...), binding(1,...)]`
   - Zips incorrectly: `(N1, binding(5,...))`, `(N3, binding(3,...))`, `(N5, binding(1,...))` ‚Üê WRONG PAIRINGS
   - Aggregate signature verification fails
   - `check_signature_shares` identifies shares 5, 3, and 1 as invalid
   - Signing round aborted

**Reproduction Instructions:**

1. Enable the `with_v1` feature in `Cargo.toml`
2. Create a v1 signer with multiple keys (at least 2)
3. Complete DKG normally
4. In `sign_share_request()` handler, add code to reorder `signature_shares` before creating the response
5. Observe that signing rounds fail with invalid signature share errors

### Notes

This vulnerability only affects the v1 implementation, which is an optional feature (`with_v1`) that is not enabled by default. The default v2 implementation returns exactly one signature share per signer, making reordering impossible. Users of v2 are not affected.

The attack requires an insider who successfully participated in DKG and controls multiple keys, limiting the attack surface to compromised or intentionally malicious legitimate participants. While the signing round fails, the malicious signer is correctly identified, preventing persistent damage beyond DoS.

### Citations

**File:** src/net.rs (L450-465)
```rust
impl Signable for SignatureShareResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("SIGNATURE_SHARE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for signature_share in &self.signature_shares {
            hasher.update(signature_share.id.to_be_bytes());
            hasher.update(signature_share.z_i.to_bytes());
            for key_id in &signature_share.key_ids {
                hasher.update(key_id.to_be_bytes());
            }
        }
    }
}
```

**File:** src/v1.rs (L321-326)
```rust
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }

        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &signers, nonces);
```

**File:** src/v1.rs (L707-719)
```rust
    fn sign(
        &self,
        msg: &[u8],
        _signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
        self.parties
            .iter()
            .map(|p| p.sign_precomputed(msg, key_ids, nonces, &aggregate_nonce))
            .collect()
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1131-1135)
```rust
            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** Cargo.toml (L16-16)
```text
with_v1 = []
```

**File:** src/lib.rs (L29-31)
```rust
#[cfg(feature = "with_v1")]
#[allow(clippy::op_ref)]
pub mod v1;
```

**File:** src/v2.rs (L652-660)
```rust
    fn sign(
        &self,
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        vec![self.sign(msg, signer_ids, key_ids, nonces)]
    }
```
