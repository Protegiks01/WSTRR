# Audit Report

## Title
Missing DKG Round ID Validation Enables Denial of Service via Message Replay

## Summary
The signer's DKG message handlers do not validate the `dkg_id` field before accepting and storing messages, while the coordinator properly validates this field. This allows an attacker with network access to replay messages from previous DKG rounds, causing honest signers to store mismatched shares that fail validation and abort the DKG round.

## Finding Description

The signer's message handlers accept and store DKG messages without validating that the incoming message's `dkg_id` field matches the signer's current round ID (`self.dkg_id`). Specifically:

The `dkg_public_share()` handler stores public shares without any `dkg_id` validation: [1](#0-0) 

The `dkg_private_shares()` handler accepts and stores private shares without checking the round ID: [2](#0-1) 

The `dkg_end_begin()` handler also lacks this validation: [3](#0-2) 

In contrast, the coordinator properly validates `dkg_id` in both public and private share handlers, returning a `BadDkgId` error when mismatches occur: [4](#0-3) [5](#0-4) 

**Attack Mechanism:**

1. An attacker captures legitimate DKG messages from round N (e.g., `DkgPublicShares` with `dkg_id=N`)
2. When round N+1 begins, the signer's state is reset and `self.dkg_id` is updated to N+1: [6](#0-5) 

3. The attacker replays captured messages from round N before legitimate round N+1 messages arrive
4. The signer stores these replayed messages without validating `dkg_id`
5. When legitimate round N+1 messages arrive from the same signer_id, they are rejected as duplicates: [7](#0-6) 

6. Eventually, when `dkg_ended()` is called, the stored commitments are validated against the current `self.dkg_id`: [8](#0-7) 

7. The validation fails because the Schnorr proofs in the replayed messages were created with context `dkg_id=N` but are being verified against context `dkg_id=N+1`: [9](#0-8) [10](#0-9) 

8. The signer returns `DkgEnd` with failure status: [11](#0-10) 

The DKG messages include `dkg_id` in their signature hash, preventing modification: [12](#0-11) 

This means the attacker cannot modify the `dkg_id` field but can replay the original signed messages, which will pass signature verification but fail the deferred commitment validation.

## Impact Explanation

**Severity: Low**

This vulnerability enables a remotely-exploitable denial of service attack that prevents DKG completion. The impact maps to the defined Low severity scope: "Any remotely-exploitable denial of service in a node" and potentially "Any network denial of service impacting more than 10 percent of miners that does not shut down the network."

**Specific impacts:**
- Individual signers can be forced to abort DKG participation by sending `DkgEnd` with failure status
- If the attacker targets more than `(total_signers - dkg_threshold)` signers, the entire DKG round fails network-wide
- DKG must be restarted, delaying key generation and preventing signing operations until completion
- No compromise of cryptographic material, fund loss, or invalid signature acceptance occurs

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to succeed because:

**Low Attacker Requirements:**
- Network access to inject/replay messages to signers (e.g., man-in-the-middle position)
- Access to previously broadcast DKG messages (publicly observable on the network)
- No cryptographic secrets or private keys required

**Simple Attack Execution:**
- Capture messages from round N during normal DKG operation
- Replay these messages to target signers during round N+1
- If replayed messages arrive before legitimate ones (controllable via network positioning), they will be stored first and legitimate messages rejected as duplicates

**High Success Probability:**
- No race conditions or cryptographic challenges
- Success depends only on message timing, which an attacker with network access can control
- No computational cost or economic stake required

**Detection Difficulty:**
- DKG failures would be logged but distinguishing between network issues and attacks is difficult
- The attack leaves no cryptographic evidence (signatures are valid for the original messages)

## Recommendation

Add `dkg_id` validation in the signer's DKG message handlers, mirroring the coordinator's implementation:

**For `dkg_public_share()`:**
```rust
pub fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Add this check at the beginning
    if dkg_public_shares.dkg_id != self.dkg_id {
        return Err(Error::BadDkgId(
            dkg_public_shares.dkg_id,
            self.dkg_id,
        ));
    }
    // ... rest of the function
}
```

**For `dkg_private_shares()`:**
```rust
pub fn dkg_private_shares<R: RngCore + CryptoRng>(
    &mut self,
    dkg_private_shares: &DkgPrivateShares,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Add this check at the beginning
    if dkg_private_shares.dkg_id != self.dkg_id {
        return Err(Error::BadDkgId(
            dkg_private_shares.dkg_id,
            self.dkg_id,
        ));
    }
    // ... rest of the function
}
```

This matches the defensive pattern already implemented in the coordinator and prevents message replay attacks by rejecting messages from different DKG rounds immediately.

## Proof of Concept

```rust
#[test]
fn test_dkg_message_replay_attack() {
    use rand_core::OsRng;
    
    let mut rng = OsRng;
    let mut signer = /* initialize signer */;
    
    // Round 1: Generate and capture DkgPublicShares
    let dkg_begin_1 = DkgBegin { dkg_id: 1, /* ... */ };
    signer.dkg_begin(&dkg_begin_1, &mut rng).unwrap();
    
    let public_shares_round_1 = /* capture DkgPublicShares from another signer */;
    assert_eq!(public_shares_round_1.dkg_id, 1);
    
    // Round 2: Start new DKG round
    let dkg_begin_2 = DkgBegin { dkg_id: 2, /* ... */ };
    signer.dkg_begin(&dkg_begin_2, &mut rng).unwrap();
    assert_eq!(signer.dkg_id, 2);
    
    // Attack: Replay message from round 1 in round 2
    let result = signer.dkg_public_share(&public_shares_round_1);
    
    // Vulnerability: Message is accepted despite wrong dkg_id
    assert!(result.is_ok()); // Should fail but doesn't!
    
    // Later when DKG ends, validation fails
    signer.dkg_end_begin(&DkgEndBegin { /* ... */ }).unwrap();
    let dkg_end = signer.dkg_ended(&mut rng).unwrap();
    
    // Assert DKG failed due to bad public shares
    match dkg_end {
        Message::DkgEnd(end) => {
            assert!(matches!(end.status, DkgStatus::Failure(_)));
        }
        _ => panic!("Expected DkgEnd message"),
    }
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L593-599)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L959-971)
```rust
    pub fn dkg_end_begin(&mut self, dkg_end_begin: &DkgEndBegin) -> Result<Vec<Message>, Error> {
        let msgs = vec![];

        self.dkg_end_begin_msg = Some(dkg_end_begin.clone());

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            "received DkgEndBegin"
        );

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/signer/mod.rs (L1029-1110)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/fire.rs (L479-484)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/state_machine/coordinator/fire.rs (L527-532)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/common.rs (L36-39)
```rust
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```
