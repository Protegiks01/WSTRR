### Title
Out-of-Order DKG Message Processing Causes Silent Share Loss and DKG Denial of Service

### Summary
The signer's message processing logic accepts `DkgPrivateShares` messages in any state without validation, causing silent failures when messages arrive out of order. When `DkgPrivateShares` arrives before `DkgPublicShares`, the required key exchange public keys are unavailable, causing the private shares to be silently discarded and DKG to fail with missing shares.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the signer's message processing pipeline: [1](#0-0) 

The `process` method dispatches messages based solely on type without state validation. The `dkg_private_shares` handler attempts to process incoming private shares regardless of current state: [2](#0-1) 

The handler requires key exchange public keys to decrypt private shares, calling `get_kex_public_key` at line 1043: [3](#0-2) 

This method retrieves keys from `self.kex_public_keys`, which is only populated when processing `DkgPublicShares`: [4](#0-3) 

The KEX public keys are stored during `DkgPublicShares` processing: [5](#0-4) 

**Root Cause:**

The signer processes all incoming messages without validating that the current state is appropriate for that message type. When `get_kex_public_key` fails due to missing keys, the handler silently returns `Ok(vec![])` without storing the shares or logging an error about the ordering violation.

**Why Existing Mitigations Fail:**

The state machine defines valid state transitions through `can_move_to`: [6](#0-5) 

However, this only protects state transitions, not message acceptance. The coordinator is protected because its `process_message` method checks state before calling handlers: [7](#0-6) 

The signer lacks this protection.

### Impact Explanation

**Specific Harm:**
When `DkgPrivateShares` arrives before `DkgPublicShares`:
1. The private shares are silently discarded during processing
2. When DKG completion is checked via `can_dkg_end()`, the missing shares are detected
3. The signer reports `DkgFailure::MissingPrivateShares` in its `DkgEnd` message
4. DKG fails for the entire signing group
5. The threshold signature group cannot be formed
6. No signatures can be produced until DKG succeeds

**Quantified Impact:**
- Complete DKG denial of service for all participants
- Prevents formation of threshold signing groups
- Blocks all signature operations until successful DKG
- Can be triggered persistently to prevent any DKG completion

**Who is Affected:**
All signers participating in the DKG round. If DKG is required for system initialization or key rotation, this prevents the entire network from becoming operational or rotating compromised keys.

**Severity Justification:**
This maps to **Low** severity per the provided scope: "Any remotely-exploitable denial of service in a node."

While this prevents DKG completion and signature generation, it does not directly cause invalid signatures to be accepted, fund loss, or chain splits. The DKG can be retried, though persistent attacks could prevent group formation indefinitely.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Network-level access to delay or reorder packets between signers
- Man-in-the-middle position on any network path
- No cryptographic secrets required
- No special permissions or node access needed

**Attack Complexity:**
Very low - the attack requires only basic network manipulation:
- Delay `DkgPublicShares` packets by milliseconds
- Forward `DkgPrivateShares` packets immediately
- Can be executed with standard tools (iptables, tc, etc.)

**Economic Feasibility:**
High - extremely low cost attack:
- No computational resources required
- No stake or collateral needed  
- Can be executed continuously with minimal bandwidth

**Detection Risk:**
Low - difficult to distinguish from legitimate issues:
- Appears as normal network jitter or delays
- No cryptographic anomalies
- Only visible as DKG failures in logs
- No attribution to specific attacker

**Estimated Probability of Success:**
High (approaching 100%) - the vulnerability is deterministic:
- If attacker controls network timing, success is guaranteed
- Even brief delays (milliseconds) can trigger the bug
- Natural network conditions may trigger accidentally
- No randomness or race conditions reduce reliability

### Recommendation

**Primary Fix:**
Add state validation before processing messages in the signer's `process` method. Reject messages that arrive in inappropriate states:

```rust
Message::DkgPublicShares(dkg_public_shares) => {
    if self.state != State::DkgPublicGather {
        warn!("Received DkgPublicShares in wrong state {:?}", self.state);
        return Ok(vec![]);
    }
    self.dkg_public_share(dkg_public_shares)
}
Message::DkgPrivateShares(dkg_private_shares) => {
    if self.state != State::DkgPrivateGather {
        warn!("Received DkgPrivateShares in wrong state {:?}", self.state);
        return Ok(vec![]);
    }
    self.dkg_private_shares(dkg_private_shares, rng)
}
```

**Alternative Mitigation:**
Implement message buffering - store out-of-order messages and replay them when the appropriate state is reached. This provides better resilience to network delays but adds complexity.

**Testing Recommendations:**
1. Add unit test that sends `DkgPrivateShares` before `DkgPublicShares` and verifies rejection
2. Add integration test with simulated network delays
3. Test that DKG completes successfully when messages arrive in correct order
4. Verify warning logs are generated for out-of-order messages

**Deployment Considerations:**
This is a protocol-level change affecting message handling timing. All signers should be updated simultaneously to maintain consistent behavior across the network.

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup**: Deploy network-level packet manipulation (iptables/tc rules)
2. **Monitor**: Watch for `DkgBegin` messages starting a DKG round
3. **Attack**: 
   - Delay all `DkgPublicShares` packets by 100ms
   - Allow `DkgPrivateShares` packets to pass immediately
4. **Observe**: Signer logs show DKG failure with `MissingPrivateShares`
5. **Persist**: Repeat for subsequent DKG attempts

**Reproduction Steps:**

```rust
// Create test signer
let mut signer = Signer::<v2::Signer>::new(
    1, 1, 2, 2, 0, vec![1], 
    private_key, public_keys, &mut rng
).unwrap();
signer.verify_packet_sigs = false;

// Start DKG
let dkg_begin_packet = Packet { 
    msg: Message::DkgBegin(DkgBegin { dkg_id: 1 }), 
    sig: vec![] 
};
signer.process(&dkg_begin_packet, &mut rng).unwrap();

// ATTACK: Send DkgPrivateShares BEFORE DkgPublicShares
let private_share_packet = Packet { 
    msg: Message::DkgPrivateShares(DkgPrivateShares {
        dkg_id: 1,
        signer_id: 1,
        shares: vec![(2, HashMap::new())],
    }), 
    sig: vec![] 
};
signer.process(&private_share_packet, &mut rng).unwrap();

// Verify shares were NOT stored (vulnerability!)
assert!(!signer.dkg_private_shares.contains_key(&1));

// Later send public shares (correct order)
let public_share_packet = Packet {
    msg: Message::DkgPublicShares(DkgPublicShares {
        dkg_id: 1,
        signer_id: 1,
        comms: vec![],
        kex_public_key: Point::from(&Scalar::random(&mut rng)),
    }),
    sig: vec![]
};
signer.process(&public_share_packet, &mut rng).unwrap();

// Private shares from earlier are permanently lost
// DKG will fail with MissingPrivateShares
```

**Expected Behavior:** `DkgPrivateShares` should be rejected or buffered when received before `DkgPublicShares`, with a warning logged.

**Actual Behavior:** `DkgPrivateShares` is silently discarded, causing DKG to fail later with `MissingPrivateShares`, with no indication of the ordering violation.

### Citations

**File:** src/state_machine/signer/mod.rs (L458-501)
```rust
    pub fn process<R: RngCore + CryptoRng>(
        &mut self,
        packet: &Packet,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
            Message::DkgPrivateShares(dkg_private_shares) => {
                self.dkg_private_shares(dkg_private_shares, rng)
            }
            Message::SignatureShareRequest(sign_share_request) => {
                self.sign_share_request(sign_share_request, rng)
            }
            Message::NonceRequest(nonce_request) => self.nonce_request(nonce_request, rng),
            Message::DkgEnd(_) | Message::NonceResponse(_) | Message::SignatureShareResponse(_) => {
                Ok(vec![])
            } // TODO
        };

        match out_msgs {
            Ok(mut out) => {
                if self.can_dkg_end() {
                    let dkg_end_msgs = self.dkg_ended(rng)?;
                    out.push(dkg_end_msgs);
                    self.move_to(State::Idle)?;
                }
                Ok(out)
            }
            Err(e) => Err(e),
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1028-1110)
```rust
    /// handle incoming DkgPrivateShares
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/state_machine/signer/mod.rs (L1112-1129)
```rust
    fn get_kex_public_key(&self, signer_id: u32) -> Result<Point, Error> {
        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(signer_key_id) = signer_key_ids.iter().next() else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(kex_public_key) = self.kex_public_keys.get(signer_key_id) else {
            warn!(%signer_id, %signer_key_id, "No KEX public key configured");
            return Err(Error::MissingKexPublicKey(*signer_key_id));
        };

        Ok(*kex_public_key)
    }
```

**File:** src/state_machine/signer/mod.rs (L1157-1179)
```rust
    fn can_move_to(&self, state: &State) -> Result<(), Error> {
        let prev_state = &self.state;
        let accepted = match state {
            State::Idle => true,
            State::DkgPublicDistribute => {
                prev_state == &State::Idle
                    || prev_state == &State::DkgPublicGather
                    || prev_state == &State::DkgPrivateDistribute
            }
            State::DkgPublicGather => prev_state == &State::DkgPublicDistribute,
            State::DkgPrivateDistribute => prev_state == &State::DkgPublicGather,
            State::DkgPrivateGather => prev_state == &State::DkgPrivateDistribute,
            State::SignGather => prev_state == &State::Idle,
        };
        if accepted {
            debug!("state change from {prev_state:?} to {state:?}");
            Ok(())
        } else {
            Err(Error::BadStateChange(format!(
                "{prev_state:?} to {state:?}"
            )))
        }
    }
```

**File:** src/state_machine/coordinator/frost.rs (L72-120)
```rust
            match self.state.clone() {
                State::Idle => {
                    // Did we receive a coordinator message?
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
                    } else if let Message::NonceRequest(nonce_request) = &packet.msg {
                        if self.current_sign_id == nonce_request.sign_id {
                            // We have already processed this sign round
                            return Ok((None, None));
                        }
                        self.current_sign_iter_id = nonce_request.sign_iter_id;
                        // use sign_id from NonceRequest
                        let packet = self.start_signing_round(
                            nonce_request.message.as_slice(),
                            nonce_request.signature_type,
                            Some(nonce_request.sign_id),
                        )?;
                        return Ok((Some(packet), None));
                    }
                    return Ok((None, None));
                }
                State::DkgPublicDistribute => {
                    let packet = self.start_public_shares()?;
                    return Ok((Some(packet), None));
                }
                State::DkgPublicGather => {
                    self.gather_public_shares(packet)?;
                    if self.state == State::DkgPublicGather {
                        // We need more data
                        return Ok((None, None));
                    }
                }
                State::DkgPrivateDistribute => {
                    let packet = self.start_private_shares()?;
                    return Ok((Some(packet), None));
                }
                State::DkgPrivateGather => {
                    self.gather_private_shares(packet)?;
                    if self.state == State::DkgPrivateGather {
                        // We need more data
                        return Ok((None, None));
                    }
                }
```
