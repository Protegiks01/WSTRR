Audit Report

## Title
Missing Duplicate Key ID Validation Enables Signature Generation Denial of Service

## Summary
A malicious signer can send a `NonceResponse` message with duplicate key IDs that bypasses the coordinator's HashSet-based validation. This causes all honest signers to compute incorrect Lagrange coefficients during signature share generation, resulting in aggregate signature verification failure and denial of service.

## Finding Description

The vulnerability exists in the WSTS signing protocol's handling of key IDs across multiple components.

The `compute::intermediate()` function accepts `party_ids` without any validation for duplicates or bounds checking: [1](#0-0) 

Both v1 and v2 Signer implementations pass key_ids directly to computation functions without validation: [2](#0-1) [3](#0-2) 

The root cause is in the coordinator's validation logic. When a `NonceResponse` arrives, the coordinator converts the `key_ids` vector to a HashSet before comparing against the configured signer key IDs: [4](#0-3) 

This HashSet conversion silently removes duplicates, so a malicious `NonceResponse` with `key_ids = [1, 2, 3, 3]` passes validation when the configured key IDs are `{1, 2, 3}`. The coordinator then stores this NonceResponse with duplicates intact: [5](#0-4) 

The coordinator creates `SignatureShareRequest` by collecting all stored `NonceResponse` objects: [6](#0-5) 

When honest signers process the `SignatureShareRequest`, they extract key_ids using `flat_map`, which preserves all duplicates from the malicious signer's response: [7](#0-6) 

These duplicate key_ids are passed to the signing functions, which use them to compute Lagrange coefficients: [8](#0-7) 

The `compute::lambda()` function iterates over all key_ids in the signing set. When duplicates exist (e.g., `[1, 2, 3, 3]`), the function multiplies by the same factor multiple times: [9](#0-8) 

For example, computing `lambda(1, [1, 2, 3, 3])` incorrectly multiplies by `3/(3-1)` twice, producing `1 * 2/(2-1) * 3/(3-1) * 3/(3-1) = 1 * 2 * 3/2 * 3/2 = 9/2` instead of the correct value `1 * 2/(2-1) * 3/(3-1) = 3`.

This breaks the fundamental security guarantee of FROST: that threshold signers computing Lagrange coefficients with the same signing set will produce signature shares that aggregate to a valid signature. With incorrect coefficients, all honest signers produce invalid shares, and signature verification fails.

## Impact Explanation

This vulnerability enables a **remotely-exploitable denial of service** attack that maps to **Low severity** under the defined scope: "Any remotely-exploitable denial of service in a node."

**Specific Harm:**
- Complete failure of signature generation for the affected signing round
- All participating signers waste computational resources producing invalid shares
- The signing ceremony must be restarted or the malicious signer removed

**Affected Parties:**
- All signers in the signing ceremony
- The coordinator
- Any applications waiting for the signature

**Why Not Higher Severity:**
- No direct fund loss occurs
- No chain splits or consensus failures
- No invalid transactions are confirmed
- The network does not shut down
- The attack is immediately detectable through signature verification failure

## Likelihood Explanation

**Attacker Requirements:**
1. Must be a legitimate signer who completed DKG successfully (within FROST threat model of up to threshold-1 malicious signers)
2. Must be able to modify their `NonceResponse` message before sending

**Attack Complexity:** Low. The attacker simply constructs a `NonceResponse` with duplicate key_ids (e.g., repeating one of their legitimate key IDs).

**Economic Cost:** None beyond being a protocol participant.

**Detection:** Immediate upon signature verification failure, but identifying the malicious signer requires inspecting stored `NonceResponse` messages.

**Probability:** High for a motivated adversary, as the attack is trivial to execute and guaranteed to succeed.

## Recommendation

Add validation to reject `NonceResponse` messages containing duplicate key IDs. The coordinator should check that `key_ids.len() == key_ids_set.len()` before accepting the message:

```rust
let nonce_response_key_ids: HashSet<u32> = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect();

// Reject if duplicates exist
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response contains duplicate key_ids");
    return Ok(());
}

// Then check set equality
if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

Additionally, validate that `key_ids.len() == nonces.len()` to ensure structural consistency.

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_cause_incorrect_lambda() {
    use wsts::compute;
    
    // Correct Lagrange coefficient for key_id=1 in set [1,2,3]
    let correct_lambda = compute::lambda(1, &[1, 2, 3]);
    
    // Incorrect Lagrange coefficient with duplicate in set [1,2,3,3]
    let incorrect_lambda = compute::lambda(1, &[1, 2, 3, 3]);
    
    // These should be equal for FROST security, but they're not
    assert_ne!(correct_lambda, incorrect_lambda);
    
    // The incorrect value is wrong by a factor corresponding to the duplicate
    // lambda(1, [1,2,3]) = 1 * 2/(2-1) * 3/(3-1) = 3
    // lambda(1, [1,2,3,3]) = 1 * 2/(2-1) * 3/(3-1) * 3/(3-1) = 9/2
}
```

This test demonstrates that duplicate key IDs produce mathematically incorrect Lagrange coefficients, which directly causes signature share computation to fail.

### Citations

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** src/v1.rs (L687-694)
```rust
    fn compute_intermediate(
        msg: &[u8],
        _signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> (Vec<Point>, Point) {
        compute::intermediate(msg, key_ids, nonces)
    }
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L635-642)
```rust
    fn compute_intermediate(
        msg: &[u8],
        signer_ids: &[u32],
        _key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> (Vec<Point>, Point) {
        compute::intermediate(msg, signer_ids, nonces)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-982)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```
