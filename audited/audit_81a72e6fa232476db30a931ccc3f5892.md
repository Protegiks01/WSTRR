### Title
Timing-Based Denial of Service via Premature Malicious Signer Marking

### Summary
The coordinator's `process()` function checks timeouts before processing incoming messages, causing legitimate messages that arrive after a timeout to be silently dropped. During signature share gathering timeouts, all non-responsive signers are immediately marked as malicious and permanently excluded from future signing operations, even if their messages were sent on time but delayed by network conditions. An attacker with network control can weaponize this to permanently exclude honest signers, or it can occur naturally due to network latency, leading to denial of service.

### Finding Description

**Exact Location:** [1](#0-0) 

The `process()` function calls `process_timeout()` before `process_message()`. When a timeout has fired, the function returns early without processing the incoming packet.

**Root Cause:**

The vulnerability stems from the interaction between timeout handling and message processing:

1. **Timeout Check Before Message Processing**: [2](#0-1) 
The coordinator checks if any timeout has fired before processing the incoming message. If a timeout has occurred, it returns immediately, dropping the packet.

2. **Premature Malicious Marking**: [3](#0-2) 
When a signature share gathering timeout fires, ALL signers who haven't responded yet are marked as malicious, including those whose messages are in-flight but haven't arrived yet.

3. **Permanent Exclusion**: [4](#0-3) 
In subsequent signing rounds, nonces from malicious signers are rejected. There is no mechanism to clear the malicious status.

4. **Timeout Measurement**: [5](#0-4) [6](#0-5) 
Timeouts are measured from when the coordinator starts the gathering phase using `Instant::now()`, not from when signers send their responses. This means timeouts measure network latency + processing time, not signer responsiveness.

**Why Existing Mitigations Fail:**

The comment indicates dropping stale messages is intentional: [7](#0-6) 

However, the implementation fails to account for messages that were sent before the timeout but arrive after it due to network delays. The retry mechanism exists but doesn't help the falsely-marked signers: [8](#0-7) 

The coordinator retries by requesting new nonces, but the marked signers remain malicious and their subsequent messages are rejected.

### Impact Explanation

**Specific Harm:**
1. Honest signers can be permanently marked as malicious due to network delays beyond their control
2. Once marked, signers cannot participate in any future signing operations
3. If enough signers are marked malicious, signing operations fail permanently: [9](#0-8) 

**Quantified Impact:**
- Consider a threshold signature setup with 10 signers, 1 key each, threshold = 7
- If network delays cause 4 signers to be marked malicious (10 - 4 = 6 < 7)
- All subsequent signing operations fail with InsufficientSigners error
- The coordinator must be restarted to recover

**Who Is Affected:**
- Coordinator operators who configure timeouts
- Honest signers in high-latency network environments
- Applications depending on WSTS for transaction/block signing

**Severity Justification:**
This maps to **Low severity** per the protocol scope: "Any remotely-exploitable denial of service in a node". An attacker with network control can deny service by causing honest signers to be excluded. In production blockchain deployments with tight timeouts, this could impact signing operations and potentially rise to **Medium severity** if it causes "transient consensus failures".

### Likelihood Explanation

**Required Attacker Capabilities:**

*Network-level attack:*
- Position to delay network packets (compromised router, BGP hijacking, or ISP-level access)
- Ability to selectively delay messages from specific signers
- No cryptographic keys or insider access required

*Natural occurrence:*
- No attacker needed - normal network conditions can trigger this
- High network latency, packet loss, or jitter
- Coordinator processing delays during high load

**Attack Complexity:**
- **Network delay attack**: Medium complexity (requires network position)
- **Natural occurrence**: Low complexity (happens in real-world networks)
- **Resource exhaustion**: Low to medium (flood coordinator with packets)

**Economic Feasibility:**
- Network-level attacks require infrastructure access but no direct monetary cost
- Natural occurrence requires no resources
- Impact grows with tighter timeout configurations

**Detection Risk:**
- Difficult to distinguish from legitimate network issues
- No cryptographic traces
- Appears as normal timeout behavior in logs

**Estimated Probability:**
- **High** for natural occurrence with aggressive timeouts (< 5 seconds)
- **Medium** for deliberate network-level attacks in adversarial environments
- **Low** for resource exhaustion attacks (requires sustained flooding)

### Recommendation

**Primary Fix - Buffer Late-Arriving Messages:**

Modify `process()` to buffer messages that arrive shortly after a timeout, allowing them to be processed before marking signers as malicious:

```rust
fn process(&mut self, packet: &Packet) -> Result<(Option<Packet>, Option<OperationResult>), Error> {
    // Process message first to allow late arrivals
    let message_result = self.process_message(packet);
    
    // Then check timeouts
    let (outbound_packet, operation_result) = self.process_timeout()?;
    
    // If timeout fired after message was processed, return timeout result
    if outbound_packet.is_some() || operation_result.is_some() {
        return Ok((outbound_packet, operation_result));
    }
    
    message_result
}
```

**Alternative Mitigation - Grace Period:**

Add a grace period after timeout before marking signers as malicious:

```rust
pub struct Config {
    // ... existing fields ...
    pub sign_timeout_grace_period: Option<Duration>,
}

// In process_timeout():
if now.duration_since(start) > timeout + grace_period.unwrap_or_default() {
    // Mark signers as malicious
}
```

**Additional Recommendation - Clearing Mechanism:**

Implement a way to clear malicious status for signers, either:
- Automatically after N successful signing rounds
- Through an explicit coordinator API call
- On DKG completion (fresh start)

**Testing Recommendations:**
1. Add tests with simulated network delays where messages arrive after timeout
2. Test that honest signers are not permanently excluded
3. Verify grace period prevents false positives
4. Test coordinator behavior under various network conditions

**Deployment Considerations:**
- Review and increase timeout values for production deployments
- Configure grace periods based on observed network latency
- Monitor malicious signer markings for false positives
- Implement coordinator restart procedures if too many signers are marked

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Deploy a WSTS coordinator with short timeout (e.g., 1 second) and 5 signers with threshold=3

2. **Normal Operation**: 
   - Coordinator requests signature shares
   - Signers A, B, C, D, E all send responses within 500ms

3. **Trigger Attack**:
   - Attacker (with network control) intercepts messages from signers A and B
   - Delays these messages by 1.5 seconds (beyond 1 second timeout)
   - Signers C, D, E messages arrive normally

4. **Timeout Fires** (at t=1.0s):
   - Coordinator timeout triggers
   - Signers A and B are marked as malicious (haven't responded yet)
   - Coordinator moves to NonceRequest state and prepares retry

5. **Late Messages Arrive** (at t=1.5s):
   - A's and B's signature share messages finally arrive
   - `process()` is called with these messages
   - `process_timeout()` returns the retry nonce request packet
   - Function returns early at line 1450
   - A's and B's messages are dropped without processing

6. **Subsequent Round**:
   - Coordinator requests nonces from all signers for retry
   - Signers A and B send nonce responses
   - Their nonces are rejected at lines 903-915 (marked malicious)
   - Only C, D, E can participate (3 signers = exactly threshold)

7. **Second Attack**:
   - Attacker delays signer C's next message
   - C gets marked malicious
   - Now only 2 non-malicious signers remain (< threshold=3)
   - Signing fails permanently with InsufficientSigners error

**Expected vs Actual Behavior:**

*Expected*: Messages sent before timeout should be processed; signers should only be marked malicious if they don't respond at all.

*Actual*: Messages arriving after timeout are dropped; signers are marked malicious based on arrival time, not send time.

**Reproduction Instructions:**

Test code (add to fire.rs test module):
```rust
#[test]
fn test_late_message_dropped() {
    let timeout = Duration::from_millis(100);
    let (mut coordinators, mut signers) = setup_with_timeouts(..., Some(timeout), ...);
    
    // Start signing round
    let msg = b"test message";
    let request = coordinators[0].start_signing_round(msg, SignatureType::Frost, None).unwrap();
    
    // Process nonce requests
    // ... (signers respond with nonces)
    
    // Start signature share gathering
    // ... (coordinator requests sig shares)
    
    // Simulate: Signer 0 and 1 send shares, but we don't deliver them yet
    let delayed_shares = /* capture signer 0 and 1's signature shares */;
    
    // Other signers respond normally
    // ... (process signers 2-9 responses)
    
    // Sleep past timeout
    thread::sleep(Duration::from_millis(150));
    
    // Now deliver the delayed messages
    for share in delayed_shares {
        let result = coordinators[0].process(&share);
        // Messages are dropped, signers 0 and 1 marked malicious
    }
    
    // Verify signers 0 and 1 are now marked malicious
    assert!(coordinators[0].malicious_signer_ids.contains(&0));
    assert!(coordinators[0].malicious_signer_ids.contains(&1));
}
```

**Notes:**

The vulnerability is particularly severe when:
- Timeouts are configured aggressively (< 5 seconds)
- Network conditions include high latency or jitter
- The system operates near the threshold boundary (small margin for error)

While the message dropping behavior is documented as intentional, the permanent exclusion of honest signers based solely on network timing is a significant security issue that enables denial of service attacks.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L176-186)
```rust
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L191-199)
```rust
                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
```

**File:** src/state_machine/coordinator/fire.rs (L202-204)
```rust
                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L836-836)
```rust
        self.nonce_start = Some(Instant::now());
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L993-993)
```rust
        self.sign_start = Some(Instant::now());
```

**File:** src/state_machine/coordinator/fire.rs (L1441-1443)
```rust
    /// Process the timeouts, and if none of them fire then process the passed packet
    /// If a timeout does fire, then the coordinator state has changed; this means the
    /// packet is now stale and must be dropped
```

**File:** src/state_machine/coordinator/fire.rs (L1444-1454)
```rust
    fn process(
        &mut self,
        packet: &Packet,
    ) -> Result<(Option<Packet>, Option<OperationResult>), Error> {
        let (outbound_packet, operation_result) = self.process_timeout()?;
        if outbound_packet.is_some() || operation_result.is_some() {
            return Ok((outbound_packet, operation_result));
        }

        self.process_message(packet)
    }
```
