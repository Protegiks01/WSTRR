### Title
Incomplete Private Share Validation Allows DKG Denial of Service with Accountability Evasion

### Summary
The private share validation in `dkg_ended()` at lines 569-579 fails to verify that all expected party IDs from a sender's public shares are present in their private shares. This allows a malicious signer to omit shares from some of their parties, causing DKG to fail while avoiding detection and exclusion, enabling persistent denial of service against threshold signature initialization.

### Finding Description

**Location:** `src/state_machine/signer/mod.rs`, function `dkg_ended()`, lines 567-582 [1](#0-0) 

**Root Cause:**

The validation logic checks that `shares.shares` is non-empty and that each present `(src_party_id, shares_map)` tuple contains shares for all of the receiver's `dst_key_ids`. However, it never validates that the sender included shares from ALL of their party IDs that were declared in their `DkgPublicShares`.

The structure of `DkgPrivateShares.shares` is `Vec<(u32, HashMap<u32, Vec<u8>>)>`, representing `[(src_party_id, {dst_key_id: encrypted_share})]`. [2](#0-1) 

During the public shares phase, each signer declares their party IDs in `DkgPublicShares.comms`: [3](#0-2) 

The validation should compare the set of `src_party_ids` in `DkgPrivateShares.shares` against the set of `party_ids` from `DkgPublicShares.comms` to ensure completeness. This check is missing.

**Why Existing Mitigations Fail:**

While `Party::compute_secret()` does detect missing shares by checking for all party IDs in the commitments, the error handling for this case is inadequate: [4](#0-3) 

When `compute_secrets()` returns `DkgError::MissingPrivateShares`, the error handling at lines 622-650 only processes `DkgError::BadPrivateShares`: [5](#0-4) 

The `MissingPrivateShares` error falls into the else branch, logging a warning but not attributing fault to any signer. The resulting `DkgEnd` message reports `Failure(BadPrivateShares({}))` with an empty map, providing no accountability information.

### Impact Explanation

**Specific Harm:**
A malicious signer controlling multiple party IDs (in v1 implementation) can send `DkgPublicShares` declaring parties [1, 2, 3] but only send `DkgPrivateShares` for parties [1, 2], omitting party 3. The validation bypasses allow this through, but `compute_secrets()` later detects the missing shares. Since the error handling doesn't identify the faulty signer, they can repeatedly cause DKG failures without accountability.

**Quantified Impact:**
- DKG failure rate: 100% when attacked
- Persistent DoS: Attacker can repeat indefinitely across all DKG attempts
- Affected nodes: All signers participating in DKG
- Recovery time: Indefinite without manual intervention to exclude the attacker

**Severity Justification:**
This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." In WSTS-based systems like Stacks/sBTC, DKG initialization is critical for threshold signature functionality required for peg operations and multi-signature transactions. Preventing DKG completion blocks these essential node capabilities.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a designated signer in the DKG protocol
- Requires no cryptographic breaks or additional privileges
- Can be any malicious or compromised signer

**Attack Complexity:**
Trivial - attacker simply omits some party IDs when constructing their `DkgPrivateShares` message. The attack requires minimal code modification.

**Economic Feasibility:**
Very low cost - no computational resources required beyond normal DKG participation.

**Detection Risk:**
Low - the attacker is not identified in the failure report, making detection difficult without additional forensic analysis or logging.

**Probability of Success:**
Near 100% if the attacker is an authorized signer, as there are no effective countermeasures in the validation logic.

### Recommendation

**Primary Fix:**
Add validation to verify that all party IDs declared in `DkgPublicShares` are present in `DkgPrivateShares`. Insert after line 566:

```rust
// Get the party_ids from this signer's public shares
if let Some(public_shares) = self.dkg_public_shares.get(signer_id) {
    let expected_party_ids: HashSet<u32> = public_shares.comms
        .iter()
        .map(|(party_id, _)| *party_id)
        .collect();
    
    let provided_party_ids: HashSet<u32> = shares.shares
        .iter()
        .map(|(party_id, _)| *party_id)
        .collect();
    
    if expected_party_ids != provided_party_ids {
        missing_private_shares.insert(*signer_id);
    }
}
```

**Secondary Fix:**
Improve error handling to properly process `DkgError::MissingPrivateShares` by adding a case before line 640:

```rust
} else if let DkgError::MissingPrivateShares(missing_list) = dkg_error {
    for (dst_key_id, src_party_id) in missing_list {
        if let Some((party_signer_id, _)) = self.decryption_keys.get(&src_party_id) {
            bad_private_shares.insert(*party_signer_id, 
                self.make_bad_private_share(*party_signer_id, rng)?);
        }
    }
}
```

**Testing:**
- Add unit tests with a malicious signer omitting party IDs
- Verify validation correctly identifies missing parties
- Test that error handling properly attributes faults
- Validate DKG fails appropriately with correct error reporting

### Proof of Concept

**Attack Algorithm:**

1. Malicious signer participates in DKG with party IDs [1, 2, 3]
2. During public share phase, sends `DkgPublicShares` with `comms` for all three parties
3. During private share phase, constructs `DkgPrivateShares` with only parties [1, 2]:
   ```
   shares: [(1, {all_dst_keys}), (2, {all_dst_keys})]
   // Party 3 is omitted
   ```
4. Validation at lines 569-579 checks each present party has shares for receiver's keys - PASSES
5. All other signers reach `compute_secrets()` which detects missing shares from party 3
6. Error returns `DkgError::MissingPrivateShares([(key, 3), ...])`
7. Error handler logs warning, creates `DkgEnd` with `Failure(BadPrivateShares({}))`
8. Malicious signer not identified, can repeat attack

**Expected vs Actual Behavior:**
- Expected: Validation detects missing party 3, marks signer as faulty, DKG reports specific signer in failure
- Actual: Validation passes, `compute_secrets` detects error but handler fails to attribute fault, DKG reports empty fault map

**Reproduction:**
Create a test in v1 implementation where a signer with 3 parties only sends private shares for 2. Observe that validation passes and error handling fails to identify the signer.

### Citations

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L622-650)
```rust
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
```

**File:** src/net.rs (L141-150)
```rust
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/net.rs (L192-199)
```rust
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/v2.rs (L146-163)
```rust
        let mut missing_shares = Vec::new();
        for dst_key_id in &self.key_ids {
            for src_key_id in public_shares.keys() {
                match private_shares.get(dst_key_id) {
                    Some(shares) => {
                        if shares.get(src_key_id).is_none() {
                            missing_shares.push((*dst_key_id, *src_key_id));
                        }
                    }
                    None => {
                        missing_shares.push((*dst_key_id, *src_key_id));
                    }
                }
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }
```
