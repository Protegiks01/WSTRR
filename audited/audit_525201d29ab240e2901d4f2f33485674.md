### Title
Missing DKG Round ID Validation Enables Denial of Service via Message Replay

### Summary
The signer's DKG message handlers do not validate the `dkg_id` field before accepting and storing messages, while the coordinator properly validates this field. This allows an attacker to replay messages from previous DKG rounds or inject messages from future rounds, causing honest signers to store mismatched shares that later fail validation and abort the DKG round. The automatic state transition to `State::Idle` at line 495 exacerbates this issue by allowing messages to be accepted even after DKG completion, enabling cross-round message injection.

### Finding Description

**Exact Code Location:**
- File: `src/state_machine/signer/mod.rs`
- Functions: `dkg_public_share()` (lines 974-1026), `dkg_private_shares()` (lines 1029-1110), `dkg_end_begin()` (lines 959-971), `dkg_private_begin()` (lines 892-956)
- State transition issue: Line 495 in `process()`

**Root Cause:**
The signer's message handlers accept DKG messages without validating that the `dkg_id` field matches the signer's current `self.dkg_id`. [1](#0-0)  The `dkg_public_share()` handler stores messages from any round without checking the `dkg_id`. [2](#0-1)  Similarly, `dkg_private_shares()` accepts messages without validating the round ID. [3](#0-2)  The `dkg_end_begin()` handler also lacks this validation.

In contrast, the coordinator properly validates `dkg_id` in all its message handlers and returns a `BadDkgId` error when mismatches occur. [4](#0-3) [5](#0-4) [6](#0-5) 

The state transition to `State::Idle` occurs immediately after `can_dkg_end()` returns true and before the `DkgEnd` message is physically transmitted. [7](#0-6)  This creates a window where the signer has transitioned states but late-arriving messages for the previous round can still be accepted and stored. When a new DKG round starts, these stored messages from the wrong round can corrupt the new round's state.

**Why Existing Mitigations Fail:**
While polynomial commitments are eventually validated against the signer's current `dkg_id` in the `dkg_ended()` function, this validation is deferred. [8](#0-7)  Messages with wrong `dkg_id` are first accepted and stored, then later rejected during commitment validation. The ID proof embedded in commitments binds them to a specific `dkg_id` context. [9](#0-8)  However, this deferred validation approach allows the attack to succeed in causing DKG failure.

### Impact Explanation

**Specific Harm:**
An attacker can cause DKG rounds to fail by replaying messages from previous rounds or injecting messages intended for future rounds. When the signer attempts to compute secrets, commitments from the wrong round fail the ID proof verification, causing the signer to send `DkgEnd` with failure status.

**Quantified Impact:**
- Individual signer DoS: Each targeted signer sends `DkgEnd` with `DkgStatus::Failure`, aborting their participation
- Network-level DoS: If the attacker targets sufficient signers such that the remaining honest signers cannot meet the DKG threshold, the entire DKG round fails
- The DKG must be restarted, delaying key generation and preventing signing operations until completion

**Who is Affected:**
Any honest signer can be targeted. If more than `(total_signers - dkg_threshold)` signers are affected, the DKG cannot complete.

**Severity Justification:**
This vulnerability maps to **Low** severity per the defined scope: "Any remotely-exploitable denial of service in a node" and potentially "Any network denial of service impacting more than 10 percent of miners that does not shut down the network" if multiple signers are targeted. The attack prevents DKG completion but does not compromise cryptographic security, enable invalid signature acceptance, or cause permanent damage.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Network access to send messages to signers (man-in-the-middle position or ability to inject packets)
- Access to previously broadcast DKG messages to replay them
- No cryptographic secrets or key material required

**Attack Complexity:**
The attack is straightforward:
1. Observe and record DKG messages from round N
2. Wait for round N+1 to start
3. Replay messages from round N to target signers after they've received some legitimate messages for round N+1
4. Target signer stores mismatched messages and DKG fails when commitments are validated

**Economic Feasibility:**
Very low cost - only requires network bandwidth to replay messages. No computational work or economic stake required.

**Detection Risk:**
Medium - DKG failures would be logged, but distinguishing between network issues and attacks may be difficult. The attack leaves no cryptographic evidence.

**Estimated Probability of Success:**
High (>90%) - No race conditions or cryptographic challenges. Success depends only on message timing, which the attacker can control with network positioning.

### Recommendation

**Proposed Code Changes:**

1. Add `dkg_id` validation to all signer message handlers:

In `dkg_public_share()`, add validation after line 976:
```rust
if dkg_public_shares.dkg_id != self.dkg_id {
    warn!("Received DkgPublicShares with mismatched dkg_id: got {}, expected {}", 
          dkg_public_shares.dkg_id, self.dkg_id);
    return Ok(vec![]);
}
```

In `dkg_private_shares()`, add validation after line 1035:
```rust
if dkg_private_shares.dkg_id != self.dkg_id {
    warn!("Received DkgPrivateShares with mismatched dkg_id: got {}, expected {}", 
          dkg_private_shares.dkg_id, self.dkg_id);
    return Ok(vec![]);
}
```

In `dkg_end_begin()`, add validation after line 959:
```rust
if dkg_end_begin.dkg_id != self.dkg_id {
    warn!("Received DkgEndBegin with mismatched dkg_id: got {}, expected {}", 
          dkg_end_begin.dkg_id, self.dkg_id);
    return Ok(vec![]);
}
```

In `dkg_private_begin()`, add validation after line 894:
```rust
if dkg_private_begin.dkg_id != self.dkg_id {
    warn!("Received DkgPrivateBegin with mismatched dkg_id: got {}, expected {}", 
          dkg_private_begin.dkg_id, self.dkg_id);
    return Ok(vec![]);
}
```

2. Optionally, add a `BadDkgId` error variant to the signer's `Error` enum to match the coordinator's error handling pattern.

**Testing Recommendations:**
- Add unit tests that attempt to send messages with wrong `dkg_id` values and verify they are rejected
- Add integration tests that replay messages from completed DKG rounds to ongoing rounds
- Test cross-round message injection scenarios
- Verify that legitimate late-arriving messages (with correct `dkg_id`) are still accepted

**Deployment Considerations:**
This is a backward-compatible security fix that strengthens validation. Deploy to all signers simultaneously to ensure consistent behavior.

### Proof of Concept

**Attack Algorithm:**

```
Setup:
- Network with signers S1, S2, S3 (dkg_threshold = 3)
- Attacker A has network position to intercept/inject messages

Step 1: DKG Round N Completes Successfully
- All signers exchange DkgPublicShares for dkg_id = N
- A records DkgPublicShares from S2: {dkg_id: N, signer_id: 2, comms: [...]}
- DKG completes, all signers have valid keys

Step 2: DKG Round N+1 Starts
- Coordinator sends DkgBegin {dkg_id: N+1}
- S1 calls reset(), clears state, sets self.dkg_id = N+1
- S1 moves to DkgPublicDistribute state

Step 3: Legitimate Message Exchange Begins
- S1 sends DkgPublicShares {dkg_id: N+1, signer_id: 1, ...}
- S2 sends DkgPublicShares {dkg_id: N+1, signer_id: 2, ...}
- S1 receives and stores S2's message for round N+1

Step 4: Attack - Replay Old Message
- A replays recorded message: DkgPublicShares {dkg_id: N, signer_id: 3, comms: [...]}
- S1's dkg_public_share() handler is called
- NO dkg_id validation occurs (VULNERABILITY)
- Message is stored: self.dkg_public_shares.insert(3, <old_message>)
- S1 now has:
  * signer_id 1: round N+1 commitments
  * signer_id 2: round N+1 commitments  
  * signer_id 3: round N commitments (MISMATCH!)

Step 5: DKG Attempts to Complete
- All expected messages received, can_dkg_end() returns true
- dkg_ended() is called
- For signer_id 3's commitments:
  * check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes())
  * Calls poly_comm.verify(&N+1.to_be_bytes())
  * But commitment's ID proof was created with N.to_be_bytes()
  * Verification FAILS
- S1 adds signer_id 3 to bad_public_shares
- S1 sends DkgEnd {status: Failure(BadPublicShares({3}))}

Step 6: DKG Round N+1 Fails
- S1 reports failure, cannot participate in signing
- If A targets enough signers, entire DKG round fails
- Denial of service achieved
```

**Expected vs Actual Behavior:**

Expected: Signer rejects DkgPublicShares with `dkg_id = N` when `self.dkg_id = N+1`

Actual: Signer accepts and stores the message, later fails DKG when commitment validation detects the mismatch

**Reproduction Instructions:**
1. Run a 3-signer WSTS DKG to completion (round N)
2. Capture all DkgPublicShares messages
3. Start new DKG round (round N+1)
4. After some legitimate messages are exchanged, inject a replayed DkgPublicShares from round N
5. Observe that the message is accepted without error
6. Wait for DKG completion attempt
7. Observe DkgEnd with Failure status indicating bad public shares

### Citations

**File:** src/state_machine/signer/mod.rs (L490-501)
```rust
        match out_msgs {
            Ok(mut out) => {
                if self.can_dkg_end() {
                    let dkg_end_msgs = self.dkg_ended(rng)?;
                    out.push(dkg_end_msgs);
                    self.move_to(State::Idle)?;
                }
                Ok(out)
            }
            Err(e) => Err(e),
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L959-971)
```rust
    pub fn dkg_end_begin(&mut self, dkg_end_begin: &DkgEndBegin) -> Result<Vec<Message>, Error> {
        let msgs = vec![];

        self.dkg_end_begin_msg = Some(dkg_end_begin.clone());

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            "received DkgEndBegin"
        );

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/signer/mod.rs (L1029-1110)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/frost.rs (L290-297)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/state_machine/coordinator/frost.rs (L336-343)
```rust
    fn gather_private_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPrivateShares(dkg_private_shares) = &packet.msg {
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/state_machine/coordinator/frost.rs (L377-386)
```rust
    fn gather_dkg_end(&mut self, packet: &Packet) -> Result<(), Error> {
        debug!(
            dkg_id = %self.current_dkg_id,
            waiting = ?self.ids_to_await,
            "Waiting for Dkg End from signers"
        );
        if let Message::DkgEnd(dkg_end) = &packet.msg {
            if dkg_end.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(dkg_end.dkg_id, self.current_dkg_id));
            }
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```
