# Audit Report

## Title
NonceResponse Accepts Duplicate key_ids Causing Signature Verification Failure

## Summary
A malicious signer can inject duplicate key IDs in their NonceResponse message, bypassing HashSet-based validation while corrupting Lagrange interpolation coefficients for all participants. This causes all subsequent group signatures to fail verification, resulting in a denial of service for the threshold signing group.

## Finding Description

The vulnerability exists in the coordinator's NonceResponse validation logic. The coordinator validates incoming NonceResponse messages by converting the `key_ids` vector to a HashSet for comparison against configured signer key IDs: [1](#0-0) 

This HashSet conversion automatically deduplicates the key_ids, allowing a malicious NonceResponse with `key_ids: [3, 4, 4]` to pass validation when the configured set is `{3, 4}`. Critically, there is no validation that:
1. `key_ids.len() == nonces.len()`
2. `key_ids` contains no duplicate values

The NonceResponse structure allows arbitrary length vectors for both fields: [2](#0-1) 

When the coordinator gathers signature shares, it collects key_ids from all NonceResponses using `flat_map`, which preserves the duplicates: [3](#0-2) 

These corrupted key_ids are then distributed to all signers via SignatureShareRequest. Each signer extracts the key_ids using the same flat_map pattern: [4](#0-3) 

All parties (honest signers, malicious signer, and aggregator) then use these corrupted key_ids to compute Lagrange interpolation coefficients. In the v2 signer implementation, each party computes their signature share using: [5](#0-4) 

The `compute::lambda` function iterates over all key_ids to compute the Lagrange coefficient: [6](#0-5) 

When key_ids contains duplicates (e.g., `[1, 2, 3, 4, 4]`), the lambda calculation becomes incorrect. For example, `lambda(1, [1, 2, 3, 4, 4])` computes `(2/(2-1)) * (3/(3-1)) * (4/(4-1)) * (4/(4-1)) = 16/3`, whereas the correct value should be `lambda(1, [1, 2, 3, 4]) = 4`.

Since all participants use the same corrupted key_ids array, they all compute incorrect Lagrange coefficients. The aggregator combines these signature shares and attempts verification: [7](#0-6) 

The signature verification fails because the Lagrange coefficients used to compute the shares do not correctly reconstruct the group secret key, while the group public key was fixed during DKG and remains unchanged.

## Impact Explanation

**Severity: Low** (Denial of Service)

This vulnerability allows a single malicious signer to prevent any valid signatures from being produced by the threshold signing group. The attack prevents legitimate operations without causing permanent damage:

- All honest signers compute signature shares using incorrect Lagrange coefficients
- The aggregator successfully combines shares but produces an invalid group signature
- Signature verification fails against the fixed group public key established during DKG
- The signing round must be aborted and restarted
- No valid signatures can be produced while the malicious signer continues the attack

In blockchain contexts using WSTS for threshold signatures:
- Multi-signature wallets cannot sign transactions
- Validator groups cannot sign blocks
- Service degradation proportional to affected signing groups

This maps to **Low severity** as defined in the scope: "Any remotely-exploitable denial of service in a node." The attack does not cause permanent loss of funds, chain splits, network shutdown, or consensus failures. Recovery requires identifying and removing the malicious signer, then reconfiguring the signing group.

## Likelihood Explanation

**Likelihood: High**

**Required Attacker Capabilities:**
- Control over a single signer in a threshold signing group (within protocol threat model)
- Ability to modify NonceResponse messages before sending
- No cryptographic breaks or key compromises required

**Attack Complexity:**
The attack is trivial to execute. The attacker modifies their NonceResponse to include duplicate key_ids:
- Normal: `NonceResponse { key_ids: [3, 4], nonces: [n1, n2], ... }`
- Attack: `NonceResponse { key_ids: [3, 4, 4], nonces: [n1, n2, n3], ... }`

The HashSet validation passes because `{3, 4, 4} == {3, 4}`, while downstream processing preserves the duplicates.

**Detection:**
The attack is immediately apparent after the first failed signature verification, but identifying the specific malicious signer requires examining raw NonceResponse messages, as coordinator logs show "valid" responses that passed HashSet validation.

**Success Rate:**
Near 100% for causing denial of service. Any signer in any signing group can execute this attack at will during any signing round.

## Recommendation

Add explicit validation checks in the NonceResponse validation logic to reject messages with duplicate key_ids or mismatched vector lengths:

```rust
// After line 889 in src/state_machine/coordinator/fire.rs
if nonce_response.key_ids.len() != nonce_response.nonces.len() {
    warn!(signer_id = %nonce_response.signer_id, "NonceResponse key_ids length doesn't match nonces length");
    return Ok(());
}

// Check for duplicates by comparing Vec length to HashSet length
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "NonceResponse key_ids contains duplicates");
    return Ok(());
}
```

The same validation should be added to all NonceResponse handling code, including the FROST coordinator variant in `src/state_machine/coordinator/frost.rs`.

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_dos() {
    use crate::compute::lambda;
    use crate::curve::scalar::Scalar;
    
    // Demonstrate that duplicate key_ids corrupt lambda calculation
    let correct_key_ids = [1u32, 2, 3, 4];
    let corrupted_key_ids = [1u32, 2, 3, 4, 4];
    
    // Compute lambda for key_id=1 with both sets
    let correct_lambda = lambda(1, &correct_key_ids);
    let corrupted_lambda = lambda(1, &corrupted_key_ids);
    
    // The corrupted lambda should be different and incorrect
    assert_ne!(correct_lambda, corrupted_lambda);
    
    // Verify the mathematical discrepancy
    // correct_lambda(1, [1,2,3,4]) = (2/1)*(3/2)*(4/3) = 4
    assert_eq!(correct_lambda, Scalar::from(4));
    
    // corrupted_lambda(1, [1,2,3,4,4]) = (2/1)*(3/2)*(4/3)*(4/3) = 16/3
    // This will cause signature verification to fail
    assert_ne!(corrupted_lambda, Scalar::from(4));
}
```

This test demonstrates that duplicate key_ids in the lambda calculation produce incorrect Lagrange coefficients, which will cause signature verification failure when used in threshold signature aggregation.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/net.rs (L311-323)
```rust
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L484-501)
```rust
    fn sign_taproot(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
        merkle_root: Option<[u8; 32]>,
    ) -> Result<SchnorrProof, AggregatorError> {
        let tweak = compute::tweak(&self.poly[0], merkle_root);
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, key_ids, Some(tweak))?;
        let proof = SchnorrProof::new(&sig);

        if proof.verify(&key.x(), msg) {
            Ok(proof)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, Some(tweak)))
        }
    }
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```
