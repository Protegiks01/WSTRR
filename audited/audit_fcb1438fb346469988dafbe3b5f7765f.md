### Title
Message Substitution Attack: Coordinator Can Force Signers to Sign Unintended Messages

### Summary
Signers do not validate that the message in a `SignatureShareRequest` matches the message they committed to when generating nonces in their `NonceResponse`. A malicious coordinator can exploit this by collecting nonces for one message and then requesting signature shares for a completely different message, forcing signers to unknowingly sign unauthorized transactions.

### Finding Description

The binding value computation in WSTS includes the party ID, all public nonces, and the message being signed: [1](#0-0) 

However, the protocol has a critical flaw in the signing flow. When signers receive a `NonceRequest`, they generate fresh nonces and send a `NonceResponse` that includes the message, nonces, and protocol identifiers (dkg_id, sign_id, sign_iter_id): [2](#0-1) 

The `NonceResponse` includes all relevant context and is signed by the signer: [3](#0-2) 

Later, when the coordinator sends a `SignatureShareRequest` containing the collected `NonceResponse` messages, the signer extracts the nonces but **never validates** that the message in the `SignatureShareRequest` matches the message in the `NonceResponse` entries: [4](#0-3) 

At line 807, the signer uses `sign_request.message` directly without verifying it matches `nonce_response.message` for any of the nonce responses. The signer only validates that nonces are cryptographically valid (not zero/identity) and that signer IDs are not duplicated, but does not check message consistency.

The coordinator constructs the `SignatureShareRequest` by retrieving stored `NonceResponse` messages and adding them to the request along with the message field: [5](#0-4) 

A malicious coordinator can manipulate this by using nonce_responses collected for one message while setting the `message` field to a different value at line 983.

**Why existing mitigations fail:**
1. The coordinator's signature on `SignatureShareRequest` authenticates the coordinator's intent but doesn't prevent message substitution since the coordinator is the attacker.
2. Individual `NonceResponse` messages are signed by signers, but signers don't verify that their own `NonceResponse` is correctly included in the `SignatureShareRequest`.
3. Network message authentication validates sender identity but not message consistency across protocol phases.

### Impact Explanation

**Specific Harm:** A malicious coordinator can force threshold signers to generate valid signatures for transactions they never agreed to sign. This directly enables confirmation of invalid/unauthorized transactions.

**Quantification:** With threshold t out of n signers:
- Coordinator tricks all t signers into providing nonces for legitimate message M1
- Coordinator substitutes malicious message M2 in `SignatureShareRequest`
- All t signers unknowingly generate valid signature shares for M2
- Coordinator aggregates these into a valid group signature for M2
- Result: Unauthorized Bitcoin transaction confirmed on-chain

**Who is affected:** All honest signers in the threshold group, and any system relying on WSTS for transaction authorization (e.g., Stacks blockchain peg wallet).

**Severity:** **Critical** per the scope definition: "Any confirmation of an invalid transaction, such as with an incorrect nonce" - this vulnerability allows confirmation of transactions that signers did not authorize, effectively bypassing the threshold signature security model.

### Likelihood Explanation

**Required attacker capabilities:**
- Control of the coordinator node (either compromised or malicious from start)
- Ability to intercept and modify protocol messages between nonce commitment and signature generation phases

**Attack complexity:** Low
1. Wait for legitimate signing request (message M1)
2. Collect all `NonceResponse` messages from honest signers
3. Construct `SignatureShareRequest` with message=M2, nonce_responses=[collected responses]
4. Sign with coordinator key
5. Broadcast to signers
6. Aggregate returned signature shares

**Economic feasibility:** Highly feasible - no additional resources beyond coordinator compromise required.

**Detection risk:** Low - signers have no mechanism to detect the message swap. The attack produces cryptographically valid signatures that verify correctly, making post-incident detection difficult without detailed audit logs comparing NonceRequest vs SignatureShareRequest messages.

**Probability of success:** Nearly 100% if coordinator is compromised, as there are no validation checks to prevent this attack.

### Recommendation

**Proposed code changes:**

1. **Signer-side validation:** Modify `sign_share_request` in `src/state_machine/signer/mod.rs` to validate that:
   - Each `NonceResponse` in the request contains the same message as `sign_request.message`
   - The `NonceResponse` from this signer matches the nonces and message it previously sent
   - The dkg_id, sign_id, and sign_iter_id match across all nonce_responses and the request

2. **Store sent nonces:** Modify the signer's `nonce_request` handler to save the `NonceResponse` it sends in `self.public_nonces` or a new `last_nonce_response` field, enabling validation in `sign_share_request`.

3. **Enhanced binding value:** Include protocol identifiers (dkg_id, sign_id, sign_iter_id) and signature_type in the binding value computation in `src/compute.rs:binding()` to prevent cross-round or cross-signature-type attacks.

**Alternative mitigations:**
- Implement application-level message approval where signers must explicitly approve the final message before computing signature shares
- Add a message commitment phase where signers commit to H(message) before revealing nonces

**Testing recommendations:**
- Add integration test where malicious coordinator attempts message substitution
- Verify signer rejects `SignatureShareRequest` with mismatched message
- Test that proper error is returned and signing aborts

**Deployment considerations:**
- This is a protocol-breaking change requiring coordinated upgrade of all signers
- Existing deployments should be considered compromised if coordinator is untrusted
- Consider emergency patch release given critical severity

### Proof of Concept

**Exploitation Algorithm:**

```
1. Attacker compromises coordinator node

2. Wait for legitimate signing request:
   - Coordinator receives request to sign message M1 (legitimate transaction)

3. Coordinator sends NonceRequest to all signers:
   NonceRequest {
     dkg_id: 1,
     sign_id: 10,
     sign_iter_id: 1,
     message: M1,
     signature_type: Schnorr
   }

4. Honest signers respond with NonceResponse:
   NonceResponse {
     dkg_id: 1,
     sign_id: 10,
     sign_iter_id: 1,
     signer_id: i,
     key_ids: [key_ids_i],
     nonces: [nonce_i],
     message: M1  // Signers committed to M1
   }

5. Coordinator collects all responses, then constructs malicious request:
   SignatureShareRequest {
     dkg_id: 1,
     sign_id: 10,
     sign_iter_id: 1,
     nonce_responses: [all collected responses],  // Still contain M1
     message: M2,  // SUBSTITUTED MESSAGE
     signature_type: Schnorr
   }

6. Coordinator signs this request with coordinator private key

7. Signers receive SignatureShareRequest:
   - Verify coordinator signature (passes)
   - Extract nonces from nonce_responses
   - Use sign_request.message (M2) for binding/challenge computation
   - Generate signature shares for M2 using nonces meant for M1
   - No validation error raised

8. Coordinator aggregates signature shares into valid signature for M2

9. Unauthorized transaction M2 is confirmed on-chain
```

**Expected vs Actual Behavior:**

*Expected:* Signers should detect that message in `SignatureShareRequest` doesn't match message in their `NonceResponse` and reject the request.

*Actual:* Signers blindly use `sign_request.message` without validation, producing valid signature shares for unintended message M2.

**Reproduction Steps:**

1. Set up WSTS test environment with coordinator and 3 signers, threshold=2
2. Modify coordinator to implement attack (swap message between nonce gathering and signature share request)
3. Initiate signing for message M1
4. Observe that coordinator successfully obtains valid signature for different message M2
5. Verify that M2 signature validates correctly despite signers never agreeing to sign M2

### Citations

**File:** src/compute.rs (L15-33)
```rust
#[allow(non_snake_case)]
/// Compute a binding value from the party ID, public nonces, and signed message using XMD-based expansion.
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```

**File:** src/state_machine/signer/mod.rs (L723-754)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
```

**File:** src/state_machine/signer/mod.rs (L757-818)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/net.rs (L309-368)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}

impl Debug for NonceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NonceResponse")
            .field("dkg_id", &self.dkg_id)
            .field("sign_id", &self.sign_id)
            .field("sign_iter_id", &self.sign_iter_id)
            .field("signer_id", &self.signer_id)
            .field("key_ids", &self.key_ids)
            .field(
                "nonces",
                &self
                    .nonces
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>(),
            )
            .field("message", &hex::encode(&self.message))
            .finish()
    }
}

impl Signable for NonceResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }

        for nonce in &self.nonces {
            hasher.update(nonce.D.compress().as_bytes());
            hasher.update(nonce.E.compress().as_bytes());
        }

        hasher.update(self.message.as_slice());
    }
}
```

**File:** src/state_machine/coordinator/fire.rs (L964-996)
```rust
    fn request_sig_shares(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.signature_shares.clear();
        info!(
            sign_id = %self.current_sign_id,
            "Requesting Signature Shares"
        );
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
            message: self.message.clone(),
            signature_type,
        };
        let sig_share_request_msg = Packet {
            sig: sig_share_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign SignatureShareRequest"),
            msg: Message::SignatureShareRequest(sig_share_request),
        };
        self.move_to(State::SigShareGather(signature_type))?;
        self.sign_start = Some(Instant::now());

        Ok(sig_share_request_msg)
    }
```
