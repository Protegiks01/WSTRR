### Title
DKG Private Share Encryption Bypass via Point-at-Infinity in Diffie-Hellman Key Exchange

### Summary
The WSTS DKG implementation fails to validate that the ephemeral key exchange public key (`kex_public_key`) in `DkgPublicShares` messages is not the point-at-infinity (`Point::identity()`). A malicious signer can broadcast `Point::identity()` as their `kex_public_key`, causing all signers encrypting private shares for that signer to use a deterministic, publicly computable encryption key. This allows anyone to decrypt DKG private shares, potentially enabling threshold key reconstruction and unauthorized transaction signing.

### Finding Description

**Exact Code Locations:**

The vulnerability spans multiple locations in the DKG flow:

1. **No validation when storing kex_public_key** (signer side): [1](#0-0) 

2. **No validation when storing kex_public_key** (coordinator side): [2](#0-1) 

3. **Vulnerable encryption using unvalidated key**: [3](#0-2) 

4. **Vulnerable decryption using unvalidated key**: [4](#0-3) 

5. **DH key exchange with no point validation**: [5](#0-4) 

6. **Key derivation from potentially invalid shared key**: [6](#0-5) 

**Root Cause:**

The `DkgPublicShares` message contains a `kex_public_key` field that is intended to be an ephemeral public key for Diffie-Hellman key exchange to encrypt private shares: [7](#0-6) 

When processing these messages, the code stores the `kex_public_key` without checking whether it equals `Point::identity()` (the point-at-infinity). The codebase correctly validates nonces against `Point::identity()` elsewhere: [8](#0-7) 

However, this critical validation is missing for `kex_public_key`.

**Why Existing Mitigations Fail:**

1. No validation of `kex_public_key` against `Point::identity()` exists in any message processing path
2. While polynomial commitments are validated via Schnorr proofs, the ephemeral `kex_public_key` has no such protection
3. The `encrypt()` and `decrypt()` functions accept any 32-byte key, including predictable ones: [9](#0-8) 

4. `Aes256Gcm::new()` accepts all-zero or any deterministic key as valid input

### Impact Explanation

**Specific Harm:**

When a malicious signer broadcasts `kex_public_key = Point::identity()`:
1. Any signer encrypting private shares for the malicious signer computes: `shared_key = private_key * Point::identity() = Point::identity()`
2. The shared secret becomes: `SHA256(Point::identity().compress().as_bytes() || 0x00000001 || "DH_SHARED_SECRET_KEY/")` which is deterministic and publicly computable: [10](#0-9) 

3. Anyone (not just the malicious signer) can compute this encryption key and decrypt all private shares sent to that signer

**Quantified Impact:**

In WSTS, each signer can control multiple `key_ids` (weighted threshold). A single malicious signer's `kex_public_key` is used for ALL their `key_ids`, so all shares for those key IDs become compromised. If the malicious signer controls enough key IDs to meet or approach the threshold (e.g., threshold=15, malicious signer has 14 key IDs), an external attacker who:
- Observes network traffic
- Computes the predictable encryption key
- Decrypts the private shares
- Potentially combines with one legitimate share

Can reconstruct the threshold private key and sign arbitrary transactions, leading to:
- **Confirmation of invalid transactions** (Critical severity per scope)
- **Direct loss of funds** through unauthorized signing (Critical severity per scope)

**Who Is Affected:**

All signers who send DKG private shares to a malicious signer broadcasting `Point::identity()`. In a deployment with N=5 signers, threshold=3, if one signer is malicious and controls sufficient key IDs, the entire DKG is compromised.

**Severity Justification:**

This maps directly to **Critical** severity per the defined scope as it enables "confirmation of an invalid transaction" and "direct loss of funds other than through any form of freezing."

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a signer participant in the DKG protocol (not external)
- Must have network access to broadcast `DkgPublicShares` messages
- Must have ability to observe encrypted traffic (passive network monitoring or man-in-the-middle)

**Attack Complexity:**
Low. The attacker simply:
1. Modifies their `DkgPublicShares` message to set `kex_public_key = Point::identity()`
2. Broadcasts the message through normal protocol channels
3. Computes the deterministic encryption key using public knowledge (ANSI X9.63 KDF)
4. Decrypts observed private share traffic
5. Uses shares if threshold is reached

**Economic Feasibility:**
Highly feasible. No expensive computation or resources required. The attack works in a single DKG round.

**Detection Risk:**
Low detection risk. The malicious `kex_public_key` is syntactically valid (it's a valid `Point` that serializes/deserializes correctly). No existing validation checks would flag it. The encrypted shares appear normal; only decryption with the correct (predictable) key reveals the attack succeeded.

**Estimated Probability:**
High if a malicious signer is present. The attack requires no sophistication beyond understanding the protocol and basic EC cryptography. Given that WSTS is designed for multi-party scenarios where not all parties may be fully trusted, this represents a realistic threat.

### Recommendation

**Immediate Fix:**

Add validation to reject `Point::identity()` for `kex_public_key` in all message processing paths:

```rust
// In src/state_machine/signer/mod.rs, around line 1018:
if dkg_public_shares.kex_public_key == Point::identity() {
    error!("Invalid kex_public_key: cannot be Point::identity()");
    return Ok(vec![]);
}

for key_id in signer_key_ids {
    self.kex_public_keys.insert(*key_id, dkg_public_shares.kex_public_key);
}
```

```rust
// In src/state_machine/coordinator/fire.rs, around line 505:
if dkg_public_shares.kex_public_key == Point::identity() {
    error!("Invalid kex_public_key: cannot be Point::identity()");
    return Ok(());
}

self.dkg_public_shares.insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**Additional Validation:**

Also check that `kex_public_key` is not the generator point `G`:
```rust
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    // reject
}
```

This follows the pattern already used for nonce validation: [8](#0-7) 

**Testing Recommendations:**
1. Add unit test that attempts DKG with `kex_public_key = Point::identity()` and verifies rejection
2. Add unit test that attempts DKG with `kex_public_key = G` and verifies rejection
3. Add integration test simulating malicious signer scenario
4. Verify that legitimate DKG still succeeds after fix

**Deployment Considerations:**
- This is a breaking change that must be deployed to all signers and coordinators simultaneously
- Existing DKG rounds in progress when upgrade occurs should be aborted and restarted
- Consider adding version checking to prevent mixed old/new versions from interoperating during DKG

### Proof of Concept

**Exploitation Algorithm:**

```
1. Attacker Setup (Malicious Signer):
   - Join DKG as legitimate signer with signer_id = A
   - Control key_ids = {1, 2, ..., k} where k approaches threshold

2. Attack Execution:
   - When broadcasting DkgPublicShares:
     * Set kex_public_key = Point::identity()
     * Sign message normally (signature is valid)
   - Broadcast to all signers and coordinator

3. Key Derivation (Anyone can compute):
   - Compute: identity_compressed = Point::identity().compress().as_bytes()
   - Compute: shared_secret = SHA256(identity_compressed || 0x00000001 || "DH_SHARED_SECRET_KEY/")
   - This shared_secret is the encryption key (32 bytes)

4. Traffic Interception:
   - Monitor network for DkgPrivateShares messages
   - Extract encrypted_shares for key_ids {1, 2, ..., k}

5. Decryption:
   - For each encrypted_share:
     * Extract nonce (first 12 bytes)
     * Extract ciphertext (remaining bytes)
     * Decrypt using Aes256Gcm with shared_secret and nonce
     * Parse result as Scalar (private share)

6. Threshold Key Reconstruction:
   - If k >= threshold: directly reconstruct private key using Lagrange interpolation
   - If k < threshold: wait for one more legitimate share to leak or be obtained
   - Once threshold reached: compute full private key
   - Sign arbitrary transactions

Expected Behavior (Vulnerable):
- DkgPublicShares with Point::identity() accepted
- Encryption succeeds with predictable key
- Decryption by attacker succeeds
- Private shares compromised

Desired Behavior (After Fix):
- DkgPublicShares with Point::identity() rejected at ingestion
- Error logged
- Message dropped
- DKG eventually times out or fails due to missing shares from malicious signer
```

**Parameter Values:**
- N = 5 signers
- Threshold = 3 key IDs required
- Malicious signer controls 3 key IDs
- Point::identity() in secp256k1 compressed form is typically 0x00 (1 byte) or 0x00 followed by zeros

**Reproduction Steps:**
1. Set up WSTS DKG with 5 signers, threshold 3
2. Modify one signer to broadcast `kex_public_key = Point::identity()` in `DkgPublicShares`
3. Observe that message is accepted by other signers and coordinator
4. Compute deterministic encryption key using ANSI X9.63 with Point::identity()
5. Intercept `DkgPrivateShares` messages
6. Decrypt shares using computed key
7. Verify decrypted shares are valid Scalars
8. Demonstrate that threshold can be reached with compromised shares

### Citations

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L55-60)
```rust
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/util.rs (L64-77)
```rust
pub fn ansi_x963_derive_key(shared_key: &[u8], shared_info: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    let counter = 1u32;

    hasher.update(shared_key);
    hasher.update(counter.to_be_bytes());
    hasher.update(shared_info);

    let hash = hasher.finalize();
    let mut bytes = [0u8; 32];

    bytes.clone_from_slice(hash.as_slice());
    bytes
}
```

**File:** src/util.rs (L80-99)
```rust
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
}
```

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```
