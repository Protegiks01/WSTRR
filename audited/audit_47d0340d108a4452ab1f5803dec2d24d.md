### Title
Memory Exhaustion DoS via Unbounded DkgEnd Message Cloning

### Summary
A malicious signer can cause coordinator memory exhaustion by sending a DkgEnd message containing an arbitrarily large `BadPrivateShares` HashMap. The coordinator clones this message multiple times without size validation, and the `DkgEnd` signature does not cover the `status` field, allowing post-signature payload inflation. This can cause multi-gigabyte memory allocations and crash the coordinator.

### Finding Description

**Code Locations:**
- [1](#0-0) 
- [2](#0-1) 
- [3](#0-2) 
- [4](#0-3) 
- [5](#0-4) 

**Root Cause:**

The `DkgError` enum derives `Clone`, and its `DkgEndFailure` variant contains `reported_failures: HashMap<u32, DkgFailure>`. [6](#0-5)  The `DkgFailure` enum includes a `BadPrivateShares` variant containing `HashMap<u32, BadPrivateShare>`, where each `BadPrivateShare` holds cryptographic data (Point + TupleProof = ~135 bytes). [4](#0-3) 

When processing DKG end messages, the coordinator performs **two sequential clones** of potentially large data structures:

1. First clone at line 584: stores the entire `DkgEnd` message including its `status` field [7](#0-6) 

2. Second clone at line 610: clones the `DkgFailure` from within the stored message when building `reported_failures` [8](#0-7) 

**Critical vulnerability:** The `DkgEnd::hash()` implementation used for signature verification does NOT include the `status` field in the hash. [5](#0-4)  This means a malicious signer can:
1. Create and sign a legitimate small `DkgEnd` message
2. Replace the `status` field with an inflated `BadPrivateShares` HashMap containing millions of entries
3. The signature remains valid since `status` was never part of the signed data

**No mitigations exist:**
- No size validation before cloning
- No deserialization size limits in message parsing [9](#0-8) 
- Packet signature verification (`verify_packet_sigs`) validates message authenticity but not content size
- The `num_signers` configuration has no hard upper bound (u32 type) [10](#0-9) 

### Impact Explanation

**Specific Harm:**
A single malicious signer can exhaust coordinator memory by sending a `DkgEnd` message with a `BadPrivateShares` HashMap containing 10 million entries:
- Per entry: ~135 bytes (u32 key + Point + TupleProof)
- Total message size: ~1.35 GB
- After two clones: ~2.7 GB memory consumed from one message
- Multiple malicious signers amplify the impact proportionally

**Who is Affected:**
- Coordinator nodes (required for DKG orchestration)
- The entire network if coordinator failure blocks DKG completion

**Severity Justification:**
This maps to **Medium severity** under the protocol scope as a "transient consensus failure." The coordinator DoS prevents DKG round completion, which blocks the generation of new aggregate public keys required for signing operations. While the network can potentially recover by restarting the coordinator with increased memory limits, the attack can be repeated indefinitely by the malicious signer, causing persistent disruption. If the coordinator role is critical and cannot be easily migrated, this constitutes a denial of service impacting consensus operations.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of a single signer with valid ECDSA signing key for packet authentication
- Ability to construct and send custom `DkgEnd` messages
- No cryptographic breaks required

**Attack Complexity:**
Low. The attack requires:
1. Constructing a `DkgEnd` message with `DkgStatus::Failure(DkgFailure::BadPrivateShares(large_hashmap))`
2. Populating the HashMap with millions of dummy entries (each containing arbitrary Point and TupleProof values)
3. Signing the message with the attacker's signer private key
4. Sending to the coordinator

Since the `status` field is not included in the signature, the attacker can even sign a legitimate message first and inflate it afterward.

**Economic Feasibility:**
Extremely low cost. The attacker needs minimal computational resources to generate the inflated message. Network bandwidth required is proportional to the message size (~1-2 GB per attack), which is trivial for modern networks.

**Detection Risk:**
Low. The message appears as a legitimate DKG failure report from an authenticated signer. The coordinator would experience gradual memory growth or sudden OOM crashes without clear attribution to a specific malicious message unless detailed memory profiling is in place.

**Probability of Success:**
Very high (~90%+). The attack has no technical barriers and exploits fundamental design issues (missing size validation and incomplete signature coverage).

### Recommendation

**Immediate Mitigations:**

1. **Add size validation before cloning:**
```rust
// In gather_dkg_end() before line 584
const MAX_FAILURES_PER_SIGNER: usize = 1000; // Based on realistic num_signers
if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
    if let DkgFailure::BadPrivateShares(bad_shares) = dkg_failure {
        if bad_shares.len() > MAX_FAILURES_PER_SIGNER {
            return Err(Error::MaliciousSigner(dkg_end.signer_id));
        }
    }
}
```

2. **Fix signature coverage:** Include `status` field in `DkgEnd::hash()` implementation [5](#0-4) 

3. **Bound collection sizes:** Add compile-time or configuration-based limits:
   - `MAX_SIGNERS` (e.g., 1000)
   - `MAX_REPORTED_FAILURES_PER_SIGNER` equal to `MAX_SIGNERS`
   - Validate all incoming collections against these bounds before processing

4. **Eliminate redundant clones:** Store references or use `Arc<DkgEnd>` to avoid duplicating large data structures

**Testing Recommendations:**
- Add unit tests with artificially large `BadPrivateShares` HashMaps (10K-100K entries)
- Memory profiling during DKG rounds with malicious inputs
- Fuzz testing of `DkgEnd` deserialization with size limits

**Deployment Considerations:**
- This is a breaking protocol change if signature coverage is modified
- Coordinate deployment across all coordinator and signer nodes
- Consider backward compatibility periods or versioning

### Proof of Concept

**Exploitation Steps:**

1. **Construct malicious DkgEnd message:**
```rust
use hashbrown::HashMap;
let mut bad_shares = HashMap::new();
// Create 10 million dummy entries
for i in 0..10_000_000u32 {
    bad_shares.insert(i, BadPrivateShare {
        shared_key: Point::default(), // Arbitrary point
        tuple_proof: TupleProof {
            R: Point::default(),
            rB: Point::default(),
            z: Scalar::default(),
        },
    });
}

let malicious_dkg_end = DkgEnd {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id,
    status: DkgStatus::Failure(DkgFailure::BadPrivateShares(bad_shares)),
};
```

2. **Sign and send to coordinator:**
```rust
let packet = Packet {
    msg: Message::DkgEnd(malicious_dkg_end),
    sig: malicious_dkg_end.sign(&attacker_private_key).unwrap(),
};
// Send packet to coordinator
```

3. **Expected behavior:** Coordinator accepts message (signature valid), clones it twice, consuming ~2.7 GB of memory

4. **Actual behavior:** Coordinator experiences memory exhaustion, potentially crashes with OOM error, DKG round fails

**Parameter Values:**
- HashMap entries: 10,000,000
- Per-entry size: ~135 bytes
- Total memory consumed: ~2.7 GB (after two clones)
- Attack can be repeated each DKG round

**Reproduction:**
Modify the signer's `dkg_ended()` method to artificially inflate the `bad_private_shares` HashMap before returning, or craft custom packets in integration tests to trigger the coordinator's cloning behavior.

### Citations

**File:** src/state_machine/mod.rs (L37-56)
```rust
#[derive(ThisError, Debug, Clone)]
pub enum DkgError {
    /// DKG public timeout
    #[error("DKG public timeout, waiting for {0:?}")]
    DkgPublicTimeout(Vec<u32>),
    /// DKG private timeout
    #[error("DKG private timeout, waiting for {0:?}")]
    DkgPrivateTimeout(Vec<u32>),
    /// DKG end timeout
    #[error("DKG end timeout, waiting for {0:?}")]
    DkgEndTimeout(Vec<u32>),
    /// DKG end failure
    #[error("DKG end failure")]
    DkgEndFailure {
        /// failures reported by signers during DkgEnd
        reported_failures: HashMap<u32, DkgFailure>,
        /// signers who were discovered to be malicious during this DKG round
        malicious_signers: HashSet<u32>,
    },
}
```

**File:** src/state_machine/coordinator/fire.rs (L583-584)
```rust
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L607-610)
```rust
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
```

**File:** src/net.rs (L48-72)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// A bad private share
pub struct BadPrivateShare {
    /// the DH shared key between these participants
    pub shared_key: Point,
    /// prooof that the shared key is a valid DH tuple as per chaum-pedersen
    pub tuple_proof: TupleProof,
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// Final DKG status after receiving public and private shares
pub enum DkgFailure {
    /// DKG threshold not met
    Threshold,
    /// Signer was in the wrong internal state to complete DKG
    BadState,
    /// DKG public shares were missing from these signer_ids
    MissingPublicShares(HashSet<u32>),
    /// DKG public shares were bad from these signer_ids
    BadPublicShares(HashSet<u32>),
    /// DKG private shares were missing from these signer_ids
    MissingPrivateShares(HashSet<u32>),
    /// DKG private shares were bad from these signer_ids
    BadPrivateShares(HashMap<u32, BadPrivateShare>),
}
```

**File:** src/net.rs (L243-252)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG end message from signers to coordinator
pub struct DkgEnd {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// DKG status for this Signer after receiving public/private shares
    pub status: DkgStatus,
}
```

**File:** src/net.rs (L254-260)
```rust
impl Signable for DkgEnd {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_END".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
    }
}
```

**File:** src/state_machine/coordinator/mod.rs (L132-141)
```rust
#[derive(Default, Clone, PartialEq)]
pub struct Config {
    /// total number of signers
    pub num_signers: u32,
    /// total number of keys
    pub num_keys: u32,
    /// threshold of keys needed to form a valid signature
    pub threshold: u32,
    /// threshold of keys needed to complete DKG (must be >= threshold)
    pub dkg_threshold: u32,
```
