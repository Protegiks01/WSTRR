### Title
False Blame Attribution in DKG Private Share Validation When Signature Verification is Disabled

### Summary
The `dkg_private_shares()` function uses the `signer_id` from incoming `DkgPrivateShares` messages without proper authentication when packet signature verification is disabled. This allows an attacker to send malformed shares with a victim's `signer_id`, causing recipients to generate `BadPrivateShare` proofs that falsely blame the victim for the malicious behavior. This can result in DKG failures and exclusion of honest parties.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The vulnerability exists in the `dkg_private_shares()` function at lines 1085 and 1093, where `make_bad_private_share()` is called with `src_signer_id` directly from the message: [2](#0-1) [3](#0-2) 

**Root Cause:**
The `src_signer_id` is extracted directly from the incoming message without cryptographic authentication: [4](#0-3) 

When `verify_packet_sigs` is disabled, the packet verification is skipped entirely: [5](#0-4) 

The `verify_packet_sigs` field is public and can be set to false: [6](#0-5) 

When signature verification is disabled, the only checks on the `signer_id` are that it exists in the configuration and that the party_ids match: [7](#0-6) 

However, an attacker can craft a message with a false `signer_id` and corresponding party_ids to pass these checks. The `make_bad_private_share()` function then uses this false `signer_id` to retrieve the KEX public key: [8](#0-7) 

This creates a valid TupleProof demonstrating knowledge of the DH shared secret with the *falsely claimed* signer, not the actual sender.

**Why Existing Mitigations Fail:**
Packet signature verification (when enabled) does prevent this attack by verifying the message was signed by the claimed signer: [9](#0-8) 

However, signature verification defaults to enabled but can be disabled because the field is public. No defense-in-depth mechanism exists to validate the `signer_id` when signature verification is disabled, and there is no documentation warning against disabling this security feature.

### Impact Explanation

**Specific Harm:**
An attacker can send `DkgPrivateShares` messages with false `signer_id` values, causing recipients to generate cryptographic proofs (`BadPrivateShare`) that blame innocent parties for DKG failures. This false blame can result in:

1. **DKG Failures:** Honest parties are incorrectly identified as malicious and excluded from the DKG round
2. **Persistent DoS:** Attackers can repeatedly frame different honest parties, preventing DKG from ever succeeding
3. **Signer Set Manipulation:** By selectively framing parties, attackers can influence which signers participate in the threshold group

**Quantified Impact:**
In a deployment with N signers where signature verification is disabled:
- A single attacker can frame any subset of the remaining N-1 signers
- Each framed signer will be excluded from DKG based on the false `BadPrivateShare` proofs
- If enough signers are framed, DKG cannot reach the required threshold
- In blockchain contexts (Stacks), inability to form valid signer sets prevents block signing

**Who is Affected:**
All WSTS deployments where `verify_packet_sigs` is set to false, either intentionally (for performance/testing) or by misconfiguration.

**Severity Justification:**
This maps to **Low** severity under the provided scope: "Any network denial of service impacting more than 10 percent of miners that does not shut down the network." An attacker who can frame >10% of signers could prevent those nodes from participating in DKG, though the network could continue with remaining honest signers if threshold requirements are still met.

Could escalate to **Medium** ("Any transient consensus failures") if DKG failures prevent signature generation temporarily.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Ability to send network messages to signers (standard network access)
2. Knowledge of valid `signer_id` values and their associated party_ids (public configuration)
3. Target deployment must have `verify_packet_sigs = false` (non-default configuration)

**Attack Complexity:**
- **Low:** Attacker simply crafts `DkgPrivateShares` messages with false `signer_id`
- Message structure can be copied from legitimate traffic
- No cryptographic operations required beyond basic message formatting

**Economic Feasibility:**
- Minimal cost: standard network bandwidth
- No special hardware or computational resources needed
- Attack can be automated and repeated

**Detection Risk:**
- Difficult to detect: false blame appears as legitimate DKG failures
- Logs would show decryption failures but attribute them to the wrong party
- No clear indicator that `signer_id` was falsified

**Estimated Probability:**
- **If signature verification disabled:** HIGH probability of successful exploitation
- **Overall:** LOW to MEDIUM, as it requires non-default configuration
- However, the public field and lack of warnings increase likelihood of misconfiguration

### Recommendation

**Primary Fix:**
Add authentication of the `signer_id` even when signature verification is disabled. Store and validate the actual sender identity separately from the claimed `signer_id` in the message:

```rust
// In dkg_private_shares(), after line 1035:
// Validate that packet signature (if present) matches src_signer_id
// Or require signature verification for DKG private shares specifically
if let Some(verified_sender_id) = packet.get_verified_sender_id() {
    if verified_sender_id != src_signer_id {
        warn!("signer_id mismatch: claimed {} but verified as {}", 
              src_signer_id, verified_sender_id);
        return Ok(vec![]);
    }
}
```

**Alternative Mitigations:**
1. Make `verify_packet_sigs` private or remove the ability to disable it for security-critical messages like `DkgPrivateShares`
2. Add explicit documentation warning that disabling signature verification enables blame attribution attacks
3. Separate the encryption key used for shares from the blame attribution mechanism
4. Store the actual packet sender identity (from lower network layers) and use that for blame attribution instead of the message-claimed `signer_id`

**Testing Recommendations:**
1. Add test case where attacker sends `DkgPrivateShares` with false `signer_id` and verify it is rejected
2. Test that `BadPrivateShare` proofs correctly identify the actual sender, not claimed `signer_id`
3. Verify behavior with both signature verification enabled and disabled

**Deployment Considerations:**
1. Audit all deployments to ensure `verify_packet_sigs = true` (the default)
2. Add runtime warning when signature verification is disabled
3. Consider removing the ability to disable signature verification for production deployments
4. Document the security implications of the `verify_packet_sigs` field

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:** Three signers with IDs 0, 1, 2. Attacker controls signer 1, victim is signer 2. Target (recipient) is signer 0. Deployment has `verify_packet_sigs = false`.

2. **Attacker crafts malicious message:**
   - Create `DkgPrivateShares` with `signer_id: 2` (falsely claims to be victim)
   - Set `shares` to contain party_ids associated with signer 2
   - Fill shares with invalid encrypted data or data encrypted with attacker's key
   - Sign with attacker's key (but signature won't be checked)

3. **Recipient processes message:**
   ```
   Line 1035: src_signer_id = 2 (false)
   Line 1043: kex_public_key = get_kex_public_key(2) // victim's key
   Line 1069: shared_key = recipient_kex_private * victim_kex_public
   Line 1076: decrypt() fails (shares encrypted with wrong key)
   Line 1085: make_bad_private_share(2, rng) // blames victim!
   ```

4. **In make_bad_private_share(2):**
   ```
   Line 1137: a = recipient_kex_private_key
   Line 1139: B = get_kex_public_key(2) // victim's KEX public key
   Line 1140: K = a * B // valid DH shared secret with victim
   Line 1141: Creates TupleProof(a, A, B, K) // proves recipient can communicate with victim
   ```

5. **Result:** 
   - Recipient stores `BadPrivateShare` for signer_id 2 (victim)
   - Later in `dkg_ended()`, victim is blamed for the failure
   - DKG excludes victim or fails entirely
   - Actual attacker (signer 1) is never identified

**Expected vs Actual Behavior:**

**Expected:** `BadPrivateShare` proof should blame the actual sender (attacker, signer 1)

**Actual:** `BadPrivateShare` proof blames the falsely claimed sender (victim, signer 2)

**Reproduction Instructions:**
1. Set up 3 WSTS signers with `verify_packet_sigs = false` on the recipient
2. From attacker node, send `DkgPrivateShares` with victim's `signer_id` but malformed encrypted data
3. Observe recipient generates `BadPrivateShare` blaming the victim
4. Check `invalid_private_shares` HashMap contains entry for victim's `signer_id`, not attacker's

### Citations

**File:** src/state_machine/signer/mod.rs (L244-245)
```rust
    /// whether to verify the signature on Packets
    pub verify_packet_sigs: bool,
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L1029-1110)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/state_machine/signer/mod.rs (L1132-1147)
```rust
    fn make_bad_private_share<R: RngCore + CryptoRng>(
        &self,
        signer_id: u32,
        rng: &mut R,
    ) -> Result<BadPrivateShare, Error> {
        let a = self.kex_private_key;
        let A = a * G;
        let B = self.get_kex_public_key(signer_id)?;
        let K = a * B;
        let tuple_proof = TupleProof::new(&a, &A, &B, &K, rng);

        Ok(BadPrivateShare {
            shared_key: K,
            tuple_proof,
        })
    }
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```
