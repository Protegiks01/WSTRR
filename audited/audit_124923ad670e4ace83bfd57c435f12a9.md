### Title
Unconditional State Clearing Allows Denial of Signing Service via Malicious DkgBegin Message

### Summary
The coordinator's `start_public_shares()` function unconditionally clears `party_polynomials` when processing a `DkgBegin` message, even after successful DKG completion. An attacker can send a malicious `DkgBegin` message with a new `dkg_id` to erase the cached polynomial commitments required for signing operations, causing complete denial of service until DKG is rerun with potentially different participants.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `start_public_shares()` function unconditionally clears both `dkg_public_shares` and `party_polynomials` on every invocation, without checking whether these contain valid state from a completed DKG round.

**Triggering Condition:** [2](#0-1) 

When the coordinator is in `State::Idle`, it accepts `DkgBegin` messages from the network. If the message contains a `dkg_id` different from `current_dkg_id`, the coordinator calls `start_dkg_round()` which invokes `start_public_shares()`.

**Root Cause:**
After successful DKG completion, the coordinator caches polynomial commitments in `party_polynomials`: [3](#0-2) 

These commitments are essential for all future signing operations, as shown here: [4](#0-3) 

The vulnerability exists because there is no check to prevent initiating a new DKG round when valid `party_polynomials` already exist and the system is operational.

**Existing Mitigation - Packet Signature Verification:** [5](#0-4) 

Packet signature verification is optional via `config.verify_packet_sigs`. The default is `true`: [6](#0-5) 

However, when enabled, `DkgBegin` messages must be signed by the coordinator's key: [7](#0-6) 

**Why Existing Mitigation Fails:**
1. If `verify_packet_sigs` is disabled (as in test configurations), any network attacker can send the message
2. If enabled, the coordinator's message signing key may be compromised through insider threats, key management failures, or system breaches
3. No additional check validates whether starting a new DKG is appropriate when the system is already operational

**Impact on Signing:**
When `party_polynomials` is empty, the aggregator initializes with an all-zero polynomial: [8](#0-7) 

This causes all subsequent signature verifications to fail, rendering the system unable to produce valid signatures.

**Affected Implementations:**
The same vulnerability exists in the FROST coordinator: [9](#0-8) 

### Impact Explanation

**Specific Harm:**
- Complete denial of signing service for all participants
- All signature operations fail verification due to empty polynomial commitments
- System must perform full DKG restart to recover (expensive multi-round protocol)
- Attacker can repeatedly trigger this to prevent signing operations indefinitely
- If WSTS is used for blockchain transaction signing, this prevents transaction confirmation

**Quantified Impact:**
- Recovery requires full DKG protocol: 3 message rounds across all participants
- During attack period: 0% signing success rate
- If used in blockchain context: Unable to confirm transactions for multiple blocks until DKG completes
- Attacker can force inclusion/exclusion of specific participants by controlling which signers respond to the new DKG

**Severity Justification:**
This maps to **HIGH** severity per the protocol scope definition: "Any remotely-exploitable denial of service in a node" combined with the ability to "shut down or otherwise not confirm new valid transactions for multiple blocks" if deployed in a blockchain context. The attack is remotely exploitable (network message), causes persistent denial of critical signing functionality, and can impact transaction confirmation.

### Likelihood Explanation

**Required Attacker Capabilities:**

*Scenario 1 - Disabled Signature Verification (HIGH likelihood):*
- Attacker position: Network access to coordinator
- Required access: Ability to send packets to coordinator's listening port
- Required secrets: None
- Attack complexity: Low (craft single DkgBegin message with new dkg_id)
- Economic cost: Negligible (single network message)

*Scenario 2 - Enabled Signature Verification (MEDIUM likelihood):*
- Attacker position: Compromised coordinator signing key OR insider access
- Required access: Coordinator's message signing private key
- Required secrets: Coordinator's private key
- Attack complexity: Medium (requires key compromise)
- Economic cost: Moderate (social engineering, system compromise, or insider threat)

**Exploitation Steps:**
1. Observe current `dkg_id` from network traffic (included in broadcast DkgBegin messages)
2. Wait for coordinator to complete DKG and transition to `State::Idle`
3. Send malicious `DkgBegin` message with `dkg_id = observed_id + 1`
4. If signature verification disabled: No additional steps needed
5. If signature verification enabled: Sign message with compromised coordinator key
6. Coordinator processes message, clears `party_polynomials`, transitions to DkgPublicGather
7. All subsequent signing attempts fail
8. Repeat attack after each DKG recovery to maintain denial of service

**Detection Risk:**
Low - Attack appears as legitimate DKG initiation. Without additional logging, indistinguishable from authorized DKG restart.

**Estimated Probability:**
- With disabled signature verification: 90%+ (trivial network attack)
- With enabled signature verification: 30-40% (depends on key management security practices)

### Recommendation

**Primary Fix - Add State Validation:**
```rust
pub fn start_public_shares(&mut self) -> Result<Packet, Error> {
    // Only allow starting new DKG if no valid aggregate key exists
    // or if explicitly requested via a cleared state
    if self.aggregate_public_key.is_some() && !self.party_polynomials.is_empty() {
        return Err(Error::BadStateChange(
            "Cannot start new DKG: existing DKG state is valid. Call reset() first.".to_string()
        ));
    }
    
    self.dkg_public_shares.clear();
    self.party_polynomials.clear();
    // ... rest of function
}
```

**Alternative Mitigation - Require Explicit Reset:**
Add a boolean flag `allow_dkg_restart` that must be explicitly set through an authorized API call before accepting new DkgBegin messages. This prevents unsolicited DKG restarts.

**Additional Security Measures:**
1. Always enable `verify_packet_sigs = true` in production deployments
2. Implement key rotation and secure key management for coordinator message signing keys
3. Add logging/alerting when DKG is initiated while `party_polynomials` is non-empty
4. Consider rate-limiting DKG initiation requests
5. Add coordinator authentication for DKG initiation (separate from message signing)

**Testing Recommendations:**
1. Add unit test: Verify `start_public_shares()` rejects calls when valid state exists
2. Add integration test: Attempt DKG restart after successful DKG, verify rejection
3. Add fuzzing test: Random DkgBegin messages after DKG completion should not clear state
4. Test signature verification enforcement in production-like configurations

**Deployment Considerations:**
- Apply fix to both FIRE and FROST coordinator implementations
- Document that resetting coordinator state requires explicit `reset()` call
- Provide migration path for systems that may rely on current behavior
- Audit all coordinator state transitions for similar unconditional state clearing

### Proof of Concept

**Exploitation Algorithm:**

```
Step 1: Network reconnaissance
- Observe DkgBegin broadcast from coordinator to signers
- Extract current_dkg_id from message (e.g., dkg_id = 5)

Step 2: Wait for DKG completion
- Monitor DkgEnd messages from signers
- Wait for coordinator to return OperationResult::Dkg (successful completion)
- Coordinator now in State::Idle with party_polynomials populated

Step 3: Craft malicious DkgBegin message
- Create DkgBegin { dkg_id: 6 }  // current_dkg_id + 1
- If verify_packet_sigs == false:
    - Sign with any key (signature not checked)
- If verify_packet_sigs == true:
    - Sign with compromised coordinator message signing key

Step 4: Send attack packet
- Deliver Packet { msg: DkgBegin, sig: crafted_sig } to coordinator
- Coordinator processes via process_message()
- Condition check passes: dkg_id (6) != current_dkg_id (5)
- Coordinator calls start_dkg_round(Some(6))
- Executes start_public_shares()
- Line 397-398: party_polynomials.clear() executes
- Coordinator transitions to State::DkgPublicGather

Step 5: Verify denial of service
- Attempt to start signing round
- Signing proceeds through nonce collection
- At signature aggregation, aggregator.init(&self.party_polynomials) called
- party_polynomials is empty
- Aggregator initializes with zero polynomial
- All signature verifications fail
- System cannot produce valid signatures

Step 6: Maintain persistent DoS (optional)
- Repeat attack after each DKG recovery attempt
- Prevents system from ever returning to operational state
```

**Expected Behavior:**
Coordinator should reject the malicious DkgBegin message when valid DKG state exists, maintaining operational signing capability.

**Actual Behavior:**
Coordinator accepts the message, clears `party_polynomials`, and enters non-operational state requiring full DKG restart.

**Reproduction Instructions:**
1. Set up coordinator and signers with default configuration
2. Complete successful DKG round (verify aggregate_public_key is set)
3. Send DkgBegin message with dkg_id = current_dkg_id + 1
4. Observe party_polynomials is cleared
5. Attempt signing operation
6. Verify signature verification fails with invalid public key

### Citations

**File:** src/state_machine/coordinator/fire.rs (L218-224)
```rust
        if self.config.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L228-237)
```rust
                State::Idle => {
                    // Did we receive a coordinator message?
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L396-398)
```rust
    pub fn start_public_shares(&mut self) -> Result<Packet, Error> {
        self.dkg_public_shares.clear();
        self.party_polynomials.clear();
```

**File:** src/state_machine/coordinator/fire.rs (L794-812)
```rust
    fn dkg_end_gathered(&mut self) -> Result<(), Error> {
        // Cache the polynomials used in DKG for the aggregator
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
        }

        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
        self.move_to(State::Idle)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1145-1145)
```rust
            self.aggregator.init(&self.party_polynomials)?;
```

**File:** src/state_machine/coordinator/mod.rs (L198-198)
```rust
            verify_packet_sigs: true,
```

**File:** src/net.rs (L494-498)
```rust
            Message::DkgBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgBegin message with an invalid signature.");
                    return false;
                }
```

**File:** src/v2.rs (L431-444)
```rust
    fn init(&mut self, comms: &HashMap<u32, PolyCommitment>) -> Result<(), AggregatorError> {
        let threshold: usize = self.threshold.try_into()?;
        let mut poly = Vec::with_capacity(threshold);

        for i in 0..poly.capacity() {
            poly.push(Point::zero());
            for (_, comm) in comms {
                poly[i] += &comm.poly[i];
            }
        }

        self.poly = poly;

        Ok(())
```

**File:** src/state_machine/coordinator/frost.rs (L226-228)
```rust
    pub fn start_public_shares(&mut self) -> Result<Packet, Error> {
        self.dkg_public_shares.clear();
        self.party_polynomials.clear();
```
