### Title
Lack of Distinction Between Recoverable and Permanent Errors Causes DKG Denial of Service

### Summary
The WSTS error handling design does not distinguish between recoverable errors (e.g., network delays causing missing shares) and permanent errors (e.g., cryptographic failures). Both types of errors result in irreversible protocol abortion of Distributed Key Generation (DKG), enabling a denial of service attack by temporarily disrupting network messages.

### Finding Description
In `src/errors.rs`, the `DkgError` and related enums (e.g. `DkgFailure` in `src/net.rs`) define errors such as `MissingPublicShares`, `MissingPrivateShares`, `BadPublicShares`, and `BadPrivateShares`, but do not provide any mechanism to distinguish between recoverable (e.g., due to transient network failure) and permanent (e.g., cryptographic validation) errors.  

Signers report missing shares (e.g., `DkgFailure::MissingPublicShares`, `DkgFailure::MissingPrivateShares`) when expected messages are absent, regardless of the cause. When any repeated failure is reported to the coordinator, the protocol executes irreversible abortion of the DKG session via `Error::DkgFailure` in `src/state_machine/coordinator/fire.rs` (lines 765-789). No attempt is made to retry or recover from temporary missing shares, nor to distinguish whether the problem was transient or fatal. The code explicitly comments that missing share failures "shouldn't happen", but they are treated equivalently to cryptographic errors: [1](#0-0) .

Timeout logic (lines 80-147 in the same file) only continues if the participation threshold is met -- but missing share failures override this and cancel the round rather than allowing possible recovery or protocol progress [2](#0-1) .

As a result, an attacker able to delay or disrupt network traffic causing missing share conditions can force repeated DKG aborts. There is no error recovery or protocol differentiation between network errors and genuine validation failures: both are fatal. There are no mitigations for this class of error.

### Impact Explanation
A remote attacker capable of interfering with the network (via packet loss, delay, or selective signing path disruption) can force signers or the coordinator to observe missing shares. This consistently results in total and immediate DKG abortion, requiring operator intervention to restart. If repeated, this enables a "denial of DKG service," preventing group setup, and thus blocking signing operations that depend on DKG completion.

This maps to "Any remotely-exploitable denial of service in a node" in the protocol scope, with potential impact on network progress if a critical mass of participants are targeted. The attack does not require cryptographic breaks or insider keys, only network-level interference.

### Likelihood Explanation
- Required attacker capabilities: ability to delay or drop DKG packets between specific signers
- Attack complexity: low (well within capabilities of a network-level adversary in realistic distributed setups)
- Economic feasibility: minimal (requires only network disruption)
- Detection risk: moderate (may blend with normal network instability)
- Probability of success: high, especially in WAN or adversarial environments

### Recommendation
- Redesign error handling in `DkgError`, `DkgFailure`, and the state machines to categorize and treat missing shares as potentially recoverable (e.g., allow timeout-based retries or round extensions).
- Only treat cryptographic validation failures as fatal errors for abort.
- Log and potentially ban signers only for permanent/fatal errors, not transient missing ones.
- Add tests to simulate transient network faults and show recovery without abort.
- Consider making missing shares go through separate state transitions or configurable grace periods.

### Proof of Concept
1. Set up a DKG round with threshold N and multiple honest signers.
2. Use a network proxy or firewall to block just one signer's share messages from reaching another (not the coordinator).
3. Signer B will report `MissingPublicShares` or `MissingPrivateShares` for Signer A.
4. Coordinator receives this status, aborts the session (`Error::DkgFailure`), and DKG setup fails.
5. Repeat step 2 multiple times to achieve persistent denial of service for DKG.

No cryptographic secrets or protocol keys are ever compromised; only selective message delivery is required. [3](#0-2) [4](#0-3) [1](#0-0) [2](#0-1) [5](#0-4) 

Notes:
- There are no mitigations or retries for missing-message errors. A "malicious signer" list exists but is not used to ban nodes for missing shares.
- Robust error recovery is critical in threshold cryptography protocols over realistic networks.
- The exploit is feasible for any party able to influence network routing or packet timing.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L80-147)
```rust
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_public_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPublicTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.public_shares_gathered()?;
                                let packet = self.start_private_shares()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
                }
            }
            State::DkgPrivateDistribute => {}
            State::DkgPrivateGather => {
                if let Some(start) = self.dkg_private_start {
                    if let Some(timeout) = self.config.dkg_private_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_private_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPrivateTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.private_shares_gathered()?;
                                let packet = self.start_dkg_end()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
                }
            }
            State::DkgEndDistribute => {}
            State::DkgEndGather => {
                if let Some(start) = self.dkg_end_start {
                    if let Some(timeout) = self.config.dkg_end_timeout {
                        if now.duration_since(start) > timeout {
                            error!("Timeout gathering DkgEnd for dkg round {} signing round {} iteration {}, unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id);
                            let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                            return Ok((
                                None,
                                Some(OperationResult::DkgError(DkgError::DkgEndTimeout(wait))),
                            ));
                        }
                    }
                }
            }
            State::NonceRequest(_signature_type) => {}
```

**File:** src/state_machine/coordinator/fire.rs (L765-790)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                    }
                }
            }

            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }

            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
        }
```

**File:** src/errors.rs (L11-30)
```rust
pub enum DkgError {
    #[error("missing public shares from {0:?}")]
    /// The public shares which were missing
    MissingPublicShares(Vec<u32>),
    #[error("missing private shares for/from {0:?}")]
    /// The private shares which were missing
    MissingPrivateShares(Vec<(u32, u32)>),
    #[error("bad public shares {0:?}")]
    /// The public shares that failed to verify or were the wrong size
    BadPublicShares(Vec<u32>),
    #[error("bad private shares {0:?}")]
    /// The private shares which failed to verify
    BadPrivateShares(Vec<u32>),
    #[error("point error {0:?}")]
    /// An error during point operations
    Point(#[from] PointError),
    #[error("integer conversion error")]
    /// An error during integer conversion operations
    TryFromInt,
}
```

**File:** src/net.rs (L59-81)
```rust
pub enum DkgFailure {
    /// DKG threshold not met
    Threshold,
    /// Signer was in the wrong internal state to complete DKG
    BadState,
    /// DKG public shares were missing from these signer_ids
    MissingPublicShares(HashSet<u32>),
    /// DKG public shares were bad from these signer_ids
    BadPublicShares(HashSet<u32>),
    /// DKG private shares were missing from these signer_ids
    MissingPrivateShares(HashSet<u32>),
    /// DKG private shares were bad from these signer_ids
    BadPrivateShares(HashMap<u32, BadPrivateShare>),
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// Final DKG status after receiving public and private shares
pub enum DkgStatus {
    /// DKG completed successfully
    Success,
    /// DKG failed
    Failure(DkgFailure),
}
```

**File:** src/state_machine/signer/mod.rs (L584-609)
```rust

        if !missing_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPublicShares(missing_public_shares)),
            }));
        }

        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }

        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
        }
```
