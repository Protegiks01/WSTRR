### Title
Memory Exhaustion DoS via Unbounded DkgPrivateShares Encrypted Share Size

### Summary
The `DkgPrivateShares` message structure accepts encrypted shares as arbitrary-sized `Vec<u8>` values without any size validation. A malicious or compromised signer can send messages containing extremely large encrypted share payloads (gigabytes instead of the expected ~60 bytes), causing memory exhaustion and crashes on all recipients (coordinator and signers), preventing DKG completion and blocking signature generation.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the `DkgPrivateShares` struct definition and its processing: [1](#0-0) 

The encrypted shares are stored in `shares: Vec<(u32, HashMap<u32, Vec<u8>>)>` with no size constraints on the `Vec<u8>` values.

**Processing without validation occurs at:**

Coordinator storage: [2](#0-1) 

Signer storage: [3](#0-2) 

**Root Cause:**

Legitimate encrypted shares contain a scalar (32 bytes) encrypted with AES-GCM, resulting in approximately 60 bytes total (32 + 12-byte nonce + 16-byte authentication tag), as shown in the encryption process: [4](#0-3) [5](#0-4) 

However, the protocol has no validation enforcing this expected size. When a `DkgPrivateShares` message is received:

1. Serde deserializes the message, allocating memory for arbitrary-sized `Vec<u8>` values
2. Signature verification passes if the attacker is a legitimate signer: [6](#0-5) 

3. The entire message is cloned and stored in memory before any content validation
4. Only after storage is decryption attempted, at which point memory is already exhausted: [7](#0-6) 

**Why Existing Mitigations Fail:**

No size validation exists at any layer:
- No Serde deserialization limits configured
- No network-level message size limits
- No application-level size checks before storage
- Signature verification occurs before size validation, and only verifies the attacker is a legitimate signer

### Impact Explanation

**Specific Harm:**

A malicious signer can craft `DkgPrivateShares` messages with encrypted share payloads of gigabytes instead of the expected 60 bytes. When all recipients (coordinator and N-1 other signers) deserialize and store these messages, they exhaust available memory and crash with Out-Of-Memory errors.

**Quantified Impact:**

- Legitimate message size: ~60 bytes Ã— number of destination key IDs (typically hundreds of bytes to low kilobytes)
- Malicious message size: Limited only by available memory and network capacity
- With 10 signers, a single malicious message with 1GB encrypted shares crashes all 10 recipients
- Memory consumption: Deserialization allocates the full Vec<u8>, then cloning doubles it during storage

**Who is Affected:**

- All signers participating in DKG
- The coordinator
- Any dependent system waiting for DKG completion and signature generation

**Severity Justification:**

This maps to **Medium severity** under "Any transient consensus failures" because:
- DKG cannot complete, preventing the establishment of the group signing key
- Without a group key, no threshold signatures can be generated
- In blockchain contexts (WSTS is Bitcoin-compatible per design), this prevents transaction signing and confirmation
- The failure is transient (nodes can restart and exclude the malicious signer) but disrupts service during the attack and recovery period

### Likelihood Explanation

**Required Attacker Capabilities:**

- Must be a legitimate signer with a valid signing key, OR
- Must have compromised a legitimate signer's private key
- Must have network access to send messages to coordinator and other signers

**Attack Complexity:**

Low complexity once prerequisites are met:
1. Craft a `DkgPrivateShares` message with oversized `Vec<u8>` values
2. Sign the message with the valid signer's private key
3. Send to all recipients
4. Recipients automatically deserialize, verify signature, and store the message
5. Memory exhaustion occurs on all recipients

**Economic Feasibility:**

Highly feasible for an insider or attacker who has compromised a signer:
- No computational cost beyond crafting and sending large messages
- Network bandwidth is the only resource constraint
- Single attack message affects all participants

**Detection Risk:**

High detection risk:
- Attack is immediately attributable to the specific `signer_id` in the message
- Crash logs and OOM errors clearly indicate the cause
- Malicious signer can be identified and removed from future DKG rounds

**Estimated Probability:**

Moderate probability given:
- Requires insider threat or key compromise (not external attacker)
- But insider threats are realistic in distributed systems with multiple participants
- No technical barriers once attacker position is achieved

### Recommendation

**Proposed Code Changes:**

1. Add size validation before deserialization or immediately after in the `DkgPrivateShares` processing:

```rust
// In gather_private_shares and dkg_private_shares functions
const MAX_ENCRYPTED_SHARE_SIZE: usize = 128; // Conservative limit above 60 bytes

for (party_id, shares) in &dkg_private_shares.shares {
    for (dst_key_id, encrypted_share) in shares {
        if encrypted_share.len() > MAX_ENCRYPTED_SHARE_SIZE {
            warn!(
                "Rejecting oversized encrypted share from signer {} for key {}: {} bytes",
                dkg_private_shares.signer_id, dst_key_id, encrypted_share.len()
            );
            return Err(Error::OversizedEncryptedShare);
        }
    }
}
```

2. Add total message size validation:

```rust
const MAX_TOTAL_SHARES_SIZE: usize = 1_048_576; // 1MB total limit

let total_size: usize = dkg_private_shares.shares
    .iter()
    .flat_map(|(_, shares)| shares.values())
    .map(|v| v.len())
    .sum();

if total_size > MAX_TOTAL_SHARES_SIZE {
    warn!(
        "Rejecting DkgPrivateShares from signer {} with total size {} bytes",
        dkg_private_shares.signer_id, total_size
    );
    return Err(Error::OversizedMessage);
}
```

**Alternative Mitigations:**

- Implement network-level message size limits in the transport layer
- Use streaming deserialization with size limits
- Add rate limiting per signer to prevent repeated attacks

**Testing Recommendations:**

- Add unit tests verifying rejection of oversized encrypted shares
- Add integration tests simulating malicious signer with large payloads
- Test memory consumption under attack scenarios
- Verify proper error handling and logging

**Deployment Considerations:**

- Choose size limits based on maximum expected number of key IDs
- Add monitoring for rejected oversized messages
- Document the size limits in protocol specification
- Consider backward compatibility if deployed systems exist

### Proof of Concept

**Exploitation Algorithm:**

```rust
// Attacker (legitimate signer with signer_id and valid private key)

// Step 1: Create malicious DkgPrivateShares
let mut malicious_shares = DkgPrivateShares {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id,
    shares: vec![],
};

// Step 2: For each party_id controlled by the attacker
for party_id in attacker_party_ids {
    let mut encrypted_shares = HashMap::new();
    
    // Step 3: For each destination key_id
    for dst_key_id in all_key_ids {
        // Create oversized payload (1GB instead of 60 bytes)
        let oversized_payload = vec![0u8; 1_073_741_824]; // 1GB
        encrypted_shares.insert(dst_key_id, oversized_payload);
    }
    
    malicious_shares.shares.push((party_id, encrypted_shares));
}

// Step 4: Sign the message
let msg = Message::DkgPrivateShares(malicious_shares);
let sig = msg.sign(&attacker_network_private_key).unwrap();
let packet = Packet { msg, sig };

// Step 5: Send to all recipients
send_to_coordinator(packet.clone());
send_to_all_signers(packet);

// Result: All recipients deserialize, allocate 1GB+ per key_id,
// exhaust memory, and crash with OOM
```

**Expected vs Actual Behavior:**

- **Expected:** Encrypted shares are ~60 bytes each, total message size in kilobytes
- **Actual:** No size validation; arbitrary-sized payloads are accepted and stored
- **Expected:** Invalid shares are rejected during decryption
- **Actual:** Memory is exhausted before decryption validation occurs

**Reproduction Instructions:**

1. Set up WSTS coordinator and multiple signers
2. Compromise or simulate a malicious signer
3. During DKG, send `DkgPrivateShares` with 1GB `Vec<u8>` values
4. Observe memory consumption spike on all recipients
5. Observe OOM crashes preventing DKG completion
6. Verify no signatures can be generated until nodes recover

### Citations

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L942-942)
```rust
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1063-1064)
```rust
        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/signer/mod.rs (L1076-1095)
```rust
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
```

**File:** src/util.rs (L79-98)
```rust
/// Encrypt the passed data using the key
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
```
