### Title
Private Nonce Reuse Through State Persistence Enables Private Key Extraction

### Summary
Private nonces stored in `PartyState` are persisted through save/load operations and can be reused across different messages if the signer state is restored from backup or after a crash. This violates the critical invariant that "nonces must never be reused across messages" and enables private key extraction through standard cryptanalytic attacks. While the `public_nonces` field at line 231 is unused and not vulnerable, the underlying `Party` objects within the signer store private nonces that are subject to this vulnerability.

### Finding Description

The question asks about `public_nonces` at line 231, which is a `Vec<PublicNonce>` field that is saved/loaded but never actually populated or used in the signing flow. [1](#0-0) 

However, the ACTUAL vulnerability exists in the private nonce storage within the underlying `Party` implementations. The `PartyState` struct contains a `nonce` field that stores private nonce values (scalar pairs d, e). [2](#0-1) 

Both v1 and v2 implementations persist private nonces through save/load operations:

**v1 implementation:**
- `Party::save()` explicitly saves the private nonce [3](#0-2) 
- `Party::load()` restores the private nonce from saved state [4](#0-3) 
- `Party::sign()` uses these private nonces in signature computation [5](#0-4) 

**v2 implementation:**
- `Party::save()` persists the private nonce [6](#0-5) 
- `Party::load()` restores it [7](#0-6) 

The signer's `sign_share_request` handler does NOT validate that the message in the `SignatureShareRequest` matches the messages in the included `NonceResponse` objects. It simply extracts nonces and signs whatever message is provided. [8](#0-7) 

**Root Cause:** Private nonces are treated as part of persistent state rather than ephemeral cryptographic material that should never be reused.

**Why Existing Mitigations Fail:**
- The `gen_nonces` test verifies fresh nonces are generated after each signing operation [9](#0-8)  but this only prevents reuse in the normal flow, not when state is restored from backup
- Fresh nonces are generated after signing [10](#0-9)  but if state is saved before this occurs and later restored, the old nonces are available again
- No validation exists to prevent signing a different message than the one for which nonces were originally generated

### Impact Explanation

**Specific Harm:**
Using the same private nonce (d, e) to sign two different messages M1 and M2 allows extraction of the private key share through algebraic manipulation. Given two signature shares with the same nonce:
- z₁ = d + e·ρ₁ + c₁·x·λ (for message M1)
- z₂ = d + e·ρ₂ + c₂·x·λ (for message M2)

Where ρ and c values can be computed from public information, an attacker can solve for x (the private key share).

**Quantified Impact:**
- Complete loss of control over one signer's private key shares
- With threshold signatures, losing enough signers' keys allows unauthorized transaction signing
- Enables confirmation of invalid transactions (mapping to **CRITICAL** severity)
- Could cause chain splits if different nodes process conflicting signed transactions

**Affected Parties:**
- Any signer using state persistence/backup features
- All participants in the threshold signature scheme (loss of one key reduces security margin)
- Downstream systems relying on signature validity

**Severity Justification:** CRITICAL - This directly enables "confirmation of an invalid transaction" and "loss of funds" through private key compromise.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Malicious or compromised coordinator to send `SignatureShareRequest` with mismatched message
2. Ability to trigger or wait for signer state save/load at opportune time
3. Access to network communication to observe `NonceResponse` messages

**Attack Complexity:**
- Medium - Requires coordinator compromise or malicious coordinator participation
- State save typically happens for crash recovery or scheduled backups (common operations)
- No cryptographic breaks required

**Exploitation Path:**
1. Coordinator sends `NonceRequest` for message M1
2. Signer generates nonces N=(d,e), sends `NonceResponse`(D,E,M1)
3. Application saves signer state (including private nonces) for backup/crash recovery
4. Either: Signer crashes before signing, OR signer signs then old state is restored from backup
5. Malicious coordinator sends `SignatureShareRequest`(M2, [`NonceResponse`(D,E,M1)]) where M2 ≠ M1
6. Signer uses restored nonces to sign M2
7. Coordinator extracts private key from two signatures with same nonce

**Economic Feasibility:** 
- High - Only requires coordinator compromise, no expensive computational resources
- State management triggers (crashes, backups) occur naturally in production

**Detection Risk:**
- Low - Nonce reuse is not detectable by the signer
- Only aggregator can detect but malicious coordinator controls this

**Probability:** Medium-High in production environments with state persistence and backup procedures.

### Recommendation

**Primary Fix:**
Add nonce tracking and validation to prevent signing with reused nonces:

1. Store a set of used nonce commitments in the `Signer` state
2. Before signing, verify that the current nonce has not been used before
3. Validate that the message in `SignatureShareRequest` matches the message in all included `NonceResponse` objects

**Code Changes:**
In `src/state_machine/signer/mod.rs`:
- Add field to track used nonce commitments
- In `sign_share_request`, validate message consistency
- Check nonce hasn't been used before signing

In `src/traits.rs`:
- Mark `nonce` field in `PartyState` with clear documentation that it should only be used once
- Consider adding a nonce generation counter to detect stale state

**Alternative Mitigation:**
Treat nonces as ephemeral and exclude them from saved state entirely. Generate fresh nonces on every load/restart, requiring a new nonce round before any signing can occur.

**Testing:**
Add test case that explicitly:
1. Generates nonces for message M1
2. Saves state
3. Signs M1
4. Loads saved state
5. Attempts to sign M2 with same nonces
6. Verifies this is rejected

**Deployment:**
- Requires state migration to add used-nonce tracking
- Breaking change for existing saved states - may need version handling

### Proof of Concept

**Exploitation Algorithm:**

```
Setup:
- Compromised coordinator C
- Target signer S with state persistence enabled
- Threshold signature scheme with n signers

Step 1 - Initial Nonce Generation:
C → S: NonceRequest(dkg_id=1, sign_id=1, message=M1)
S generates: nonce=(d,e), public_nonce=(D=d·G, E=e·G)
S → C: NonceResponse(nonces=[(D,E)], message=M1)

Step 2 - State Capture:
Application saves S.state to disk (backup/checkpoint)
Saved state includes: PartyState{nonce=(d,e), ...}

Step 3 - Trigger State Restore:
- Either: S crashes before receiving SignatureShareRequest
- Or: S completes signing M1, then state from Step 2 is restored

Step 4 - Nonce Reuse Attack:
C → S: SignatureShareRequest(
    message=M2,  # DIFFERENT message
    nonce_responses=[NonceResponse(nonces=[(D,E)], message=M1)]
)

S extracts nonces from request: [(D,E)]
S uses restored private nonce: (d,e)  # SAME nonce as Step 1
S computes signature share: z₂ = d + e·H(party_id, M2, nonces) + c₂·x·λ

Step 5 - Private Key Extraction:
C now has (or requests) signature for M1: z₁ = d + e·H(party_id, M1, nonces) + c₁·x·λ
C solves system of equations for x:
  z₁ - z₂ = e·(ρ₁ - ρ₂) + x·λ·(c₁ - c₂)
  Where ρ₁ = H(party_id, M1, nonces), ρ₂ = H(party_id, M2, nonces)
  And c₁ = H(group_key, R, M1), c₂ = H(group_key, R, M2)

All values except x are known to C, allowing x to be computed.
```

**Expected vs Actual Behavior:**
- Expected: Signer should reject signing with reused nonces or prevent nonce persistence
- Actual: Signer signs with restored nonces, enabling private key extraction

**Reproduction:**
Use the existing test framework in `src/state_machine/coordinator/mod.rs` and add a test that saves/loads signer state between nonce generation and signing, then sends a different message to sign.

### Citations

**File:** src/state_machine/signer/mod.rs (L231-231)
```rust
    pub public_nonces: Vec<PublicNonce>,
```

**File:** src/state_machine/signer/mod.rs (L781-817)
```rust
        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
```

**File:** src/state_machine/signer/mod.rs (L820-820)
```rust
            self.signer.gen_nonces(&self.network_private_key, rng);
```

**File:** src/traits.rs (L17-24)
```rust
pub struct PartyState {
    /// The party's private polynomial
    pub polynomial: Option<Polynomial<Scalar>>,
    /// The key IDS and associate private keys for this party
    pub private_keys: Vec<(u32, Scalar)>,
    /// The nonce being used by this party
    pub nonce: Nonce,
}
```

**File:** src/v1.rs (L67-84)
```rust
    /// Load a party from `state`
    pub fn load(id: u32, n: u32, t: u32, group_key: &Point, state: &traits::PartyState) -> Self {
        assert_eq!(state.private_keys.len(), 1);
        assert_eq!(state.private_keys[0].0, id);

        let private_key = state.private_keys[0].1;

        Self {
            id,
            num_keys: n,
            threshold: t,
            f: state.polynomial.clone(),
            public_key: private_key * G,
            private_key,
            group_key: *group_key,
            nonce: state.nonce.clone(),
        }
    }
```

**File:** src/v1.rs (L86-93)
```rust
    /// Save the state required to reconstruct the party
    pub fn save(&self) -> traits::PartyState {
        traits::PartyState {
            private_keys: vec![(self.id, self.private_key)],
            polynomial: self.f.clone(),
            nonce: self.nonce.clone(),
        }
    }
```

**File:** src/v1.rs (L217-229)
```rust
    pub fn sign(&self, msg: &[u8], signers: &[u32], nonces: &[PublicNonce]) -> SignatureShare {
        let (_, aggregate_nonce) = compute::intermediate(msg, signers, nonces);
        let mut z = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
        z += compute::challenge(&self.group_key, &aggregate_nonce, msg)
            * &self.private_key
            * compute::lambda(self.id, signers);

        SignatureShare {
            id: self.id,
            z_i: z,
            key_ids: vec![self.id],
        }
    }
```

**File:** src/v2.rs (L519-540)
```rust
    fn load(state: &traits::SignerState) -> Self {
        // v2 signer contains single party
        assert_eq!(state.parties.len(), 1);

        let party_state = &state.parties[0].1;

        Self {
            party_id: state.id,
            key_ids: state.key_ids.clone(),
            num_keys: state.num_keys,
            num_parties: state.num_parties,
            threshold: state.threshold,
            f: party_state.polynomial.clone(),
            private_keys: party_state
                .private_keys
                .iter()
                .map(|(k, v)| (*k, *v))
                .collect(),
            group_key: state.group_key,
            nonce: party_state.nonce.clone(),
        }
    }
```

**File:** src/v2.rs (L542-557)
```rust
    fn save(&self) -> traits::SignerState {
        let party_state = traits::PartyState {
            polynomial: self.f.clone(),
            private_keys: self.private_keys.iter().map(|(k, v)| (*k, *v)).collect(),
            nonce: self.nonce.clone(),
        };
        traits::SignerState {
            id: self.party_id,
            key_ids: self.key_ids.clone(),
            num_keys: self.num_keys,
            num_parties: self.num_parties,
            threshold: self.threshold,
            group_key: self.group_key,
            parties: vec![(self.party_id, party_state)],
        }
    }
```

**File:** src/state_machine/coordinator/mod.rs (L1376-1445)
```rust
    pub fn gen_nonces<Coordinator: CoordinatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
    ) {
        let mut rng = OsRng;

        let (mut coordinators, mut signers) =
            run_dkg::<Coordinator, SignerType>(num_signers, keys_per_signer);

        let msg = "It was many and many a year ago, in a kingdom by the sea"
            .as_bytes()
            .to_vec();

        let signature_type = SignatureType::Frost;

        // Start a signing round
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_signing_round(&msg, signature_type, None)
            .unwrap();
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::NonceGather(signature_type)
        );

        // Send the NonceRequest to all signers and gather NonceResponses
        // by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::SigShareGather(signature_type)
        );

        // Once the coordinator has received sufficient NonceResponses,
        // it should send out a SignatureShareRequest
        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::SignatureShareRequest(_)),
            "Expected SignatureShareRequest message"
        );

        // Pass the SignatureShareRequest to the first signer and get his SignatureShares
        // which should use the nonce generated before sending out NonceResponse above
        let messages1 = signers[0].process(&outbound_messages[0], &mut rng).unwrap();

        // Pass the SignatureShareRequest to the second signer and get his SignatureShares
        // which should use the nonce generated just before sending out the previous SignatureShare
        let messages2 = signers[0].process(&outbound_messages[0], &mut rng).unwrap();

        // iterate through the responses and collect the embedded shares
        // if the signer didn't generate a nonce after sending the first signature shares
        // then the shares should be the same, since the message and everything else is
        for (message1, message2) in messages1.into_iter().zip(messages2) {
            let share1 = if let Message::SignatureShareResponse(response) = message1 {
                response.signature_shares[0].clone()
            } else {
                panic!("Message should have been SignatureShareResponse");
            };
            let share2 = if let Message::SignatureShareResponse(response) = message2 {
                response.signature_shares[0].clone()
            } else {
                panic!("Message should have been SignatureShareResponse");
            };

            assert_ne!(share1.z_i, share2.z_i);
        }
    }
```
