### Title
Memory Exhaustion via Unbounded Polynomial Degree in DKG Public Shares

### Summary
A malicious authenticated signer can send DKG public shares containing polynomial commitments with arbitrarily large vectors of curve points, causing memory exhaustion and denial of service on receiving nodes. The vulnerability stems from the lack of bounds checking on polynomial degree before deserialization, allowing an attacker to craft messages that allocate gigabytes of memory before any validation occurs.

### Finding Description

**Exact Code Locations:** [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

**Root Cause:**

The `random_poly()` function accepts a `u32` degree parameter with no explicit upper bounds. While legitimate calls use `threshold - 1` as the degree, the `PolyCommitment` structure that is transmitted over the network during DKG contains a `Vec<Point>` with no size constraints enforced during deserialization.

When a `DkgPublicShares` message is received, the entire `PolyCommitment` (including its arbitrarily-sized `poly` vector) is deserialized by Serde before any validation occurs. The polynomial degree validation only happens later in the `dkg_ended()` method: [5](#0-4) [6](#0-5) 

**Why Existing Mitigations Fail:**

1. Threshold validation exists but only applies to locally-generated polynomials: [7](#0-6) 

2. Signature verification (when enabled) occurs after deserialization: [8](#0-7) 

3. Polynomial degree checking via `check_public_shares()` only validates that the length equals the threshold, but this happens after the memory has already been allocated during deserialization.

### Impact Explanation

**Specific Harm:**
A malicious authenticated signer can cause denial of service by sending oversized polynomial commitments. Each `Point` is 32 bytes when compressed, so an attacker sending a polynomial with 100 million points would force allocation of ~3.2 GB of memory on each receiving node. With 1 billion points, this becomes 32 GB per message.

**Quantification:**
- Attacker sends single malicious `DkgPublicShares` message
- Each victim node attempts to deserialize and allocates excessive memory
- Memory exhaustion causes node crash or OOM killer intervention
- DKG round fails, preventing group key generation
- Multiple nodes can be simultaneously targeted with a single broadcast

**Who is Affected:**
All signers and coordinators participating in the DKG round receive and process the malicious message, affecting the entire threshold signature setup.

**Severity Justification:**
This maps to **LOW** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." The attack is remotely exploitable over the network protocol without requiring local access to victim nodes. While it requires the attacker to be an authenticated signer (insider threat), the DoS impact is immediate and affects protocol availability.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a legitimate participant in the threshold signature scheme
- Must possess valid signing credentials (private key for message authentication)
- Must have network connectivity to send messages to other participants

**Attack Complexity:**
Low. The attacker simply needs to:
1. Construct a `PolyCommitment` with a large `Vec<Point>` (e.g., 100 million elements)
2. Wrap it in a `DkgPublicShares` message
3. Sign the message with their legitimate credentials
4. Broadcast to other participants

**Economic Feasibility:**
Negligible cost to the attacker. Creating the oversized message requires minimal computational resources, while victims must allocate substantial memory.

**Detection Risk:**
High detection probability - the malicious signer's identity is included in the message (`signer_id`), and honest participants will report the failure in `DkgEnd` messages marking the attacker's public shares as bad. However, the damage (node crashes) occurs before this reporting.

**Estimated Probability:**
If a malicious authenticated signer exists in the system, this attack has near 100% success rate against unpatched nodes.

### Recommendation

**Primary Fix - Add Maximum Polynomial Degree Constant:**

Add a reasonable upper bound constant and validate before deserialization. Suggested implementation:

1. Define a maximum degree constant (e.g., `MAX_POLYNOMIAL_DEGREE = 10000`) based on realistic threshold requirements
2. Add custom deserialization for `PolyCommitment` that validates the vector length before allocating memory
3. Reject messages with oversized polynomials at the deserialization layer

**Alternative Mitigation:**

Implement streaming deserialization with size limits using Serde's deserializer configuration to cap the maximum size of sequences before allocation.

**Testing Recommendations:**
1. Add unit tests that attempt to create polynomials with various extreme degree values
2. Add integration tests that send oversized `DkgPublicShares` messages and verify they are rejected before memory allocation
3. Test memory usage with legitimate maximum-threshold configurations to ensure the limit doesn't interfere with valid use cases

**Deployment Considerations:**
- The fix should be deployed before any production use where untrusted or semi-trusted signers participate
- Existing deployments with fully trusted participants have lower risk but should still patch for defense in depth
- The maximum degree should be documented and configurable if different deployment scenarios require different limits

### Proof of Concept

**Exploitation Algorithm:**

1. Attacker (authenticated signer with ID `attacker_id`) generates a malicious polynomial commitment:
   ```
   Create Vec<Point> with 100,000,000 random points
   Create PolyCommitment with this oversized vector
   ```

2. Construct malicious DkgPublicShares:
   ```
   Message contains:
   - dkg_id: current round ID
   - signer_id: attacker_id  
   - comms: [(party_id, oversized_PolyCommitment)]
   - kex_public_key: attacker's valid KEX key
   ```

3. Sign and send to all participants:
   ```
   Sign message with attacker's legitimate private key
   Broadcast Packet{msg, sig} to network
   ```

4. Victim nodes process message:
   ```
   - Receive packet over network
   - Serde deserializes entire structure
   - Allocates ~3.2 GB for 100M Points
   - Memory exhaustion â†’ crash or OOM
   - Never reaches signature verification or polynomial validation
   ```

**Expected vs Actual Behavior:**

Expected: Oversized polynomials should be rejected before memory allocation
Actual: Full deserialization occurs, allocating gigabytes of memory before any validation

**Reproduction Instructions:**

On a malicious signer node, modify the DKG public share generation to create an oversized polynomial commitment and observe memory exhaustion on receiving nodes. The attack succeeds because validation in `check_public_shares()` only occurs after the memory allocation during deserialization, and there are no pre-deserialization size limits on the `Vec<Point>` field.

### Citations

**File:** src/vss.rs (L11-14)
```rust
    pub fn random_poly<RNG: RngCore + CryptoRng>(n: u32, rng: &mut RNG) -> Polynomial<Scalar> {
        let params: Vec<Scalar> = (0..n + 1).map(|_| Scalar::random(rng)).collect();
        Polynomial::new(params)
    }
```

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/state_machine/signer/mod.rs (L296-302)
```rust
        if threshold == 0 || threshold > total_keys {
            return Err(Error::Config(ConfigError::InvalidThreshold));
        }

        if dkg_threshold == 0 || dkg_threshold < threshold {
            return Err(Error::Config(ConfigError::InvalidThreshold));
        }
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```
