### Title
Unvalidated DKG Failure Claims Enable Indefinite Denial of Service on Key Generation

### Summary
The coordinator does not validate `DkgFailure::Threshold`, `DkgFailure::MissingPublicShares`, and `DkgFailure::MissingPrivateShares` claims from signers during the DKG end phase. A malicious registered signer can falsely report these failures to cause DKG rounds to fail indefinitely without being marked as malicious, preventing aggregate key generation and blocking signature operations required for consensus.

### Finding Description

**Location:** [1](#0-0)  and [2](#0-1) 

**Root Cause:** The `gather_dkg_end()` function in the FIRE coordinator validates `BadPublicShares` and `BadPrivateShares` claims by re-checking commitments and shares against cryptographic proofs [3](#0-2) , marking false reporters as malicious. However, for `DkgFailure::Threshold`, `MissingPublicShares`, and `MissingPrivateShares` cases, the coordinator performs no validation and does not populate the `malicious_signers` set, as indicated by TODO comments.

The coordinator possesses all information needed to validate the `Threshold` claim. When a signer reports threshold failure [4](#0-3) , it is checking whether the number of participating keys meets `dkg_threshold`. The coordinator can independently compute this same value using its `compute_num_key_ids()` method [5](#0-4)  on the signers who sent private shares [6](#0-5) , exactly as it does in timeout handlers [7](#0-6) .

When any DKG failure is reported, the coordinator returns `Error::DkgFailure` [8](#0-7) , causing the DKG round to fail [9](#0-8) . Since the malicious reporter is not added to `malicious_dkg_signer_ids` [10](#0-9) , they can participate in subsequent retries and repeat the attack indefinitely.

### Impact Explanation

**Specific Harm:** A malicious registered signer can prevent DKG completion, blocking generation of the aggregate public key required for threshold signature operations. Without a valid aggregate key, no signing operations can proceed [11](#0-10) .

**Quantified Impact:** If WSTS is deployed for Stacks consensus where signers must produce threshold signatures for block validation, this vulnerability directly causes transient consensus failures. Each DKG round fails when the malicious signer submits false failure reports, requiring manual intervention to identify and exclude the attacker at the application layer. During this period, no new aggregate keys can be generated and no blocks requiring threshold signatures can be produced.

**Affected Parties:** All participants in the WSTS signer set are affected, as they cannot complete DKG or generate valid signatures. If used for blockchain consensus, this impacts the entire network's ability to confirm transactions.

**Severity Justification:** This maps to **Medium** severity under the protocol scope definition of "Any transient consensus failures." While the attack can cause repeated DKG failures, it is recoverable through manual exclusion of the malicious signer at the application layer, distinguishing it from a permanent network shutdown (Critical severity).

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a registered signer with valid `signer_id` in the coordinator's public key configuration
- Must have network connectivity to send DKG messages to the coordinator
- No cryptographic capabilities or secret knowledge required

**Attack Complexity:** Trivial. The attacker simply participates normally through the DKG public and private share phases, then sends a `DkgEnd` message with `DkgStatus::Failure(DkgFailure::Threshold)` despite the threshold being met [12](#0-11) .

**Economic Feasibility:** No resource expenditure beyond normal network participation. The attack is entirely software-based with no computational cost.

**Detection Risk:** Low. The coordinator logs the failure but does not distinguish between legitimate threshold failures and malicious false reports. Without application-layer monitoring of repeated failures from the same signer, the attack is difficult to detect.

**Probability of Success:** Very high (~100%). The coordinator will process the false failure report, fail the DKG round, and not mark the attacker as malicious, allowing unlimited retries.

### Recommendation

**Primary Fix:** Implement validation for `DkgFailure::Threshold` claims in `gather_dkg_end()`:

```rust
DkgFailure::Threshold => {
    // Verify the threshold claim
    let num_keys = self.compute_num_key_ids(self.dkg_private_shares.keys())?;
    if num_keys >= self.config.dkg_threshold {
        // Threshold is met, this is a false claim
        warn!("Signer {signer_id} falsely reported Threshold failure when threshold is met ({num_keys}/{}))", self.config.dkg_threshold);
        malicious_signers.insert(*signer_id);
    }
    // else: legitimate threshold failure, no one is malicious
}
```

**For MissingShares Cases:** These are more complex to validate due to potential legitimate network issues. Consider:
1. Logging when a signer claims missing shares that the coordinator possesses
2. Implementing reputation tracking for repeated missing share claims
3. If the network topology guarantees coordinator-mediated delivery, validate these claims similarly to the Threshold case

**Testing Recommendations:**
1. Add integration test where a signer falsely reports `DkgFailure::Threshold` when threshold is met
2. Verify the coordinator marks the signer as malicious and includes them in the failure report
3. Test legitimate threshold failures are not incorrectly flagged as malicious
4. Test DKG retries exclude signers in `malicious_dkg_signer_ids`

**Deployment Considerations:** This fix is backward-compatible as it only adds validation logic. Deploy through a coordinated upgrade of all coordinator instances.

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:** Register as a legitimate signer with `signer_id = 5`, participate in a WSTS coordinator set with `dkg_threshold = 10`, `num_signers = 4` where total keys = 12 (exceeds threshold).

2. **Attack Execution:**
   - **Phase 1 (DkgPublicGather):** Coordinator sends `DkgBegin` [13](#0-12) . Attacker sends valid `DkgPublicShares` normally.
   
   - **Phase 2 (DkgPrivateGather):** Coordinator sends `DkgPrivateBegin` [14](#0-13) . Attacker sends valid `DkgPrivateShares` normally.
   
   - **Phase 3 (DkgEndGather):** Coordinator sends `DkgEndBegin` with `signer_ids = [1,2,3,5]` representing 12 total keys [15](#0-14) .
   
   - **Attack:** Despite threshold being met (12 â‰¥ 10), attacker sends:
     ```
     DkgEnd {
         dkg_id: current_dkg_id,
         signer_id: 5,
         status: DkgStatus::Failure(DkgFailure::Threshold)
     }
     ```

3. **Expected vs Actual Behavior:**
   - **Expected (secure):** Coordinator validates threshold is met, marks signer 5 as malicious, includes them in `malicious_signers` set.
   - **Actual (vulnerable):** Coordinator accepts the failure at face value [1](#0-0) , returns `Error::DkgFailure` with empty `malicious_signers`, DKG round fails [8](#0-7) .

4. **Reproduction:** Repeat steps 2-3 on every DKG retry. The coordinator never marks signer 5 as malicious, allowing indefinite DoS.

**Parameter Values:**
- Coordinator: 1 instance
- Signers: 4 total (signer_ids 1-4), attacker controls signer 5
- Keys per signer: 3 each = 12 total
- `dkg_threshold`: 10
- `threshold` (signing): 8

**Verification:** Check coordinator logs show repeated `DkgEnd failure` warnings without any `mark as malicious` entries for the attacker's `signer_id`.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L110-113)
```rust
                            let dkg_size = self.compute_dkg_private_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
```

**File:** src/state_machine/coordinator/fire.rs (L281-293)
```rust
                    if let Err(error) = self.gather_dkg_end(packet) {
                        if let Error::DkgFailure {
                            reported_failures,
                            malicious_signers,
                        } = error
                        {
                            return Ok((
                                None,
                                Some(OperationResult::DkgError(DkgError::DkgEndFailure {
                                    reported_failures,
                                    malicious_signers,
                                })),
                            ));
```

**File:** src/state_machine/coordinator/fire.rs (L395-416)
```rust
    /// Ask signers to send DKG public shares
    pub fn start_public_shares(&mut self) -> Result<Packet, Error> {
        self.dkg_public_shares.clear();
        self.party_polynomials.clear();
        self.dkg_wait_signer_ids = (0..self.config.num_signers).collect();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting Public Share Distribution"
        );
        let dkg_begin = DkgBegin {
            dkg_id: self.current_dkg_id,
        };
        let dkg_begin_packet = Packet {
            sig: dkg_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgBegin"),
            msg: Message::DkgBegin(dkg_begin),
        };

        self.move_to(State::DkgPublicGather)?;
        self.dkg_public_start = Some(Instant::now());
        Ok(dkg_begin_packet)
```

**File:** src/state_machine/coordinator/fire.rs (L420-446)
```rust
    pub fn start_private_shares(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_public_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting Private Share Distribution"
        );

        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
        let dkg_private_begin_msg = Packet {
            sig: dkg_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgPrivateBegin"),
            msg: Message::DkgPrivateBegin(dkg_begin),
        };
        self.move_to(State::DkgPrivateGather)?;
        self.dkg_private_start = Some(Instant::now());
        Ok(dkg_private_begin_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L449-475)
```rust
    pub fn start_dkg_end(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting DkgEnd Distribution"
        );

        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
        let dkg_end_begin_msg = Packet {
            sig: dkg_end_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgPrivateBegin"),
            msg: Message::DkgEndBegin(dkg_end_begin),
        };
        self.move_to(State::DkgEndGather)?;
        self.dkg_end_start = Some(Instant::now());
        Ok(dkg_end_begin_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L617-619)
```rust
                        DkgFailure::Threshold => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L620-763)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
                        }
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L785-788)
```rust
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/coordinator/fire.rs (L1200-1217)
```rust
    fn compute_num_key_ids<'a, I>(&self, signer_ids: I) -> Result<u32, Error>
    where
        I: Iterator<Item = &'a u32>,
    {
        signer_ids
            .map(
                |signer_id| match self.config.public_keys.signer_key_ids.get(signer_id) {
                    Some(key_ids) => key_ids.len(),
                    None => {
                        error!("No key_ids for signer {signer_id}");
                        0usize
                    }
                },
            )
            .sum::<usize>()
            .try_into()
            .map_err(Error::TryFromInt)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1223-1225)
```rust
    fn compute_dkg_private_size(&self) -> Result<u32, Error> {
        self.compute_num_key_ids(self.dkg_private_shares.keys())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1463-1466)
```rust
        // We cannot sign if we haven't first set DKG (either manually or via DKG round).
        if self.aggregate_public_key.is_none() {
            return Err(Error::MissingAggregatePublicKey);
        }
```

**File:** src/state_machine/signer/mod.rs (L543-548)
```rust
        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
```

**File:** src/net.rs (L243-260)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG end message from signers to coordinator
pub struct DkgEnd {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// DKG status for this Signer after receiving public/private shares
    pub status: DkgStatus,
}

impl Signable for DkgEnd {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_END".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
    }
}
```
