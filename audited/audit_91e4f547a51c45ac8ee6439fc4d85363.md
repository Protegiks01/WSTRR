### Title
Missing Polynomial Commitment Validation in FIRE Coordinator Enables Aggregate Key Manipulation

### Summary
The FIRE coordinator computes the aggregate public key by summing polynomial constant terms (poly[0]) without validating their Schnorr ID proofs, relying solely on honest signers to report invalid commitments. When all participating signers are malicious and collude (feasible in FIRE mode with `dkg_threshold < num_signers` if honest signers fail to respond), they can force an arbitrary aggregate key without proving knowledge of corresponding secrets, enabling direct theft of funds controlled by the manipulated key.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The FIRE coordinator receives and stores DkgPublicShares in `gather_public_shares()` without validating the Schnorr ID proofs contained in the polynomial commitments. The function only checks that the `dkg_id` matches and the `signer_id` exists in the configuration, then directly stores the shares. [2](#0-1) 

Subsequently, in `dkg_end_gathered()`, the coordinator computes the aggregate public key by summing all `poly[0]` values from the stored public shares without any cryptographic validation.

**Root Cause:**
The Schnorr ID proof is designed to bind a party's ID to their polynomial constant term and prove knowledge of the corresponding discrete logarithm. The validation function exists: [3](#0-2) [4](#0-3) 

However, the coordinator only invokes this validation reactively when signers report BadPublicShares: [5](#0-4) 

Honest signers do validate public shares proactively: [6](#0-5) 

**Why Existing Mitigations Fail:**
The mitigation depends entirely on honest signers participating in DKG and reporting invalid shares. In FIRE mode, the coordinator supports partial DKG completion via `dkg_threshold`: [7](#0-6) 

If an attacker controls M signers where M ≥ `dkg_threshold`, and honest signers timeout or fail to respond, only the malicious signers' DkgEnd messages are processed: [8](#0-7) 

Since all participating signers are malicious, none report BadPublicShares, and the coordinator proceeds to compute the aggregate key from unvalidated commitments.

### Impact Explanation

**Specific Harm:**
Malicious signers can force the aggregate public key to an arbitrary value K without proving knowledge of the corresponding discrete logarithm. If they control all participating signers, they can coordinate to:
1. Choose poly[0] values that sum to a target key K where they collectively know the secret k
2. Distribute fabricated private shares amongst themselves consistent with K
3. Produce valid threshold signatures under the manipulated aggregate key K

**Quantified Impact:**
- **Direct Loss of Funds (Critical)**: If the manipulated aggregate key is used to derive Bitcoin addresses, Stacks addresses, or other fund-controlling keys, attackers can immediately steal all funds sent to those addresses
- **Example Scenario**: With `dkg_threshold=6` out of 10 total signers, if an attacker compromises 6 signers and the 4 honest signers experience network issues or targeted DoS, the attacker achieves complete control over the aggregate key generation
- All subsequent transactions signed with this key are cryptographically valid but produced by a compromised DKG process

**Who Is Affected:**
Any system using WSTS FIRE coordinator for threshold signature operations where:
- `dkg_threshold < num_signers` (allowing partial DKG)
- The aggregate public key controls real assets (Bitcoin UTXOs, Stacks tokens, etc.)
- No independent verification of DKG integrity exists

**Severity Justification:**
This maps directly to "**Any causing the direct loss of funds other than through any form of freezing**" (Critical severity). The attacker gains unauthorized control over the threshold signature scheme by manipulating the foundational aggregate key, enabling theft of all funds protected by that key.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. **Signer Compromise**: Control ≥ `dkg_threshold` signers in the network (e.g., 6 out of 10)
2. **Network Manipulation**: Prevent enough honest signers from participating through:
   - Targeted DoS attacks against honest signers
   - Network partitioning
   - Timing attacks to exploit the DKG timeout mechanism
3. **Coordination**: Colluding malicious signers must agree on target aggregate key and not report each other's invalid shares

**Attack Complexity:**
- **Medium to High**: Requires compromising multiple signers but no cryptographic breaks
- **Network-based**: Can be executed remotely through the WSTS protocol
- **Time-sensitive**: Must exploit DKG timeout windows [9](#0-8) 

**Economic Feasibility:**
For high-value deployments (e.g., Bitcoin custody systems), the cost of compromising `dkg_threshold` signers may be economically rational if the controlled funds exceed the attack cost.

**Detection Risk:**
- DKG timeouts would be logged but might appear as normal network issues
- The manipulated aggregate key looks cryptographically valid
- No on-chain evidence distinguishes the attack from a legitimate DKG
- Post-compromise, signatures are mathematically correct

**Estimated Probability:**
- **Moderate** in production environments with:
  - `dkg_threshold` set to 50-70% of total signers (common for availability)
  - Known operational signers (enabling targeted compromise)
  - Network-accessible signers (enabling DoS)
- **Low** in environments with:
  - `dkg_threshold` = 100% of signers (no partial DKG)
  - Highly secure signer infrastructure
  - Out-of-band DKG integrity verification

### Recommendation

**Primary Fix:**
Add proactive Schnorr ID proof validation in the coordinator's `gather_public_shares()` function:

```rust
fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
    if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
        // ... existing dkg_id and signer_id checks ...
        
        // VALIDATE POLYNOMIAL COMMITMENTS BEFORE STORING
        let threshold: usize = self.config.threshold.try_into().unwrap();
        for (party_id, comm) in &dkg_public_shares.comms {
            if !check_public_shares(comm, threshold, &self.current_dkg_id.to_be_bytes()) {
                warn!(
                    signer_id = %dkg_public_shares.signer_id,
                    party_id = %party_id,
                    "Invalid polynomial commitment rejected"
                );
                // Mark signer as malicious and reject the shares
                self.malicious_dkg_signer_ids.insert(dkg_public_shares.signer_id);
                return Err(Error::DkgFailure {
                    reported_failures: HashMap::new(),
                    malicious_signers: HashSet::from([dkg_public_shares.signer_id]),
                });
            }
        }
        
        // ... rest of existing logic ...
    }
}
```

**Alternative Mitigation:**
If performance concerns exist (Schnorr proof verification is expensive), implement defense-in-depth:
1. Require `dkg_threshold` to be high (e.g., 80%+ of signers) to reduce attack surface
2. Implement out-of-band DKG verification before accepting the aggregate key
3. Add mandatory delays between DKG completion and key usage for human review

**Testing Recommendations:**
1. Unit test: coordinator rejects DkgPublicShares with invalid Schnorr proofs
2. Integration test: DKG fails when any signer submits unproven poly[0] values
3. Adversarial test: verify that colluding malicious signers cannot manipulate the aggregate key even when meeting `dkg_threshold`

**Deployment Considerations:**
- This is a breaking protocol change requiring coordinator upgrades
- Existing deployments should audit DKG logs for suspicious timeout patterns
- Systems should implement aggregate key verification against expected values where possible

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup**: Attacker compromises M ≥ `dkg_threshold` signers (e.g., 6 out of 10 where `dkg_threshold=6`)

2. **Target Selection**: Choose target aggregate key K = k·G where k is a known secret (e.g., k = sum of attacker-controlled secrets)

3. **DKG Initiation**: Wait for coordinator to broadcast DkgBegin message

4. **Malicious Share Generation**:
   ```
   For each compromised signer i (i = 1 to M):
     - Choose arbitrary polynomial coefficients ensuring poly_i[0] contributes to K
     - Create PolyCommitment WITHOUT valid Schnorr proof:
       * Set comm.poly[0] = chosen_value_i (such that Σ chosen_value_i = K)
       * Set comm.id.kG = random point (invalid proof)
       * Set comm.id.kca = random scalar (invalid proof)
     - Send DkgPublicShares to coordinator
   ```

5. **Honest Signer Suppression**:
   - Launch targeted DoS against (10 - M) honest signers
   - Or exploit network partitioning to prevent their DkgPublicShares from reaching coordinator
   - Wait for `dkg_public_timeout` to expire

6. **Private Share Exchange**:
   - Coordinator broadcasts DkgPrivateBegin with only the M malicious signer_ids
   - Malicious signers exchange fabricated private shares consistent with their chosen poly[0] values
   - Each malicious signer computes secret_i = sum of received fake shares

7. **DKG Completion**:
   - Coordinator broadcasts DkgEndBegin
   - All M malicious signers respond with DkgEnd(status=Success)
   - No BadPublicShares are reported (all collude)
   - Coordinator computes aggregate_public_key = Σ poly_i[0] = K

8. **Exploitation**:
   - System accepts aggregate key K and derives addresses
   - Funds are sent to K-derived addresses
   - Malicious signers produce valid threshold signatures to steal funds

**Expected Behavior**: Coordinator should reject invalid Schnorr proofs in step 4

**Actual Behavior**: Coordinator stores unvalidated shares and computes manipulated aggregate key K

**Reproduction Parameters**:
- Network: 10 signers, threshold=5, dkg_threshold=6
- Compromised signers: IDs 0-5
- Target key: K with known discrete log
- DKG timeout: 30 seconds (sufficient for DoS of honest signers)

### Citations

**File:** src/state_machine/coordinator/fire.rs (L78-99)
```rust
                if let Some(start) = self.dkg_public_start {
                    if let Some(timeout) = self.config.dkg_public_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_public_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPublicTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.public_shares_gathered()?;
                                let packet = self.start_private_shares()?;
                                return Ok((Some(packet), None));
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L633-640)
```rust
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }
```

**File:** src/state_machine/coordinator/fire.rs (L779-781)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
```

**File:** src/state_machine/coordinator/fire.rs (L803-807)
```rust
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```

**File:** src/common.rs (L36-39)
```rust
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/signer/mod.rs (L556-560)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
```
