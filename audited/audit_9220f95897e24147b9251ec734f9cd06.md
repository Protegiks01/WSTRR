### Title
Missing KEX Public Key Validation Allows Coordinator to Decrypt Private Shares and Reconstruct Signer Private Keys

### Summary
The DKG protocol fails to validate KEX (key exchange) public keys when received in `DkgPublicShares` messages, allowing a malicious signer to publish weak or predictable public keys (such as the generator point G or identity point). This causes honest signers to encrypt private shares using predictable shared secrets derivable from public information, enabling the coordinator or any observer to decrypt all private shares sent to the malicious signer and reconstruct their complete private keys, violating the fundamental distributed trust model of threshold signatures.

### Finding Description

**Exact Code Locations:**

1. [1](#0-0) 
   The coordinator derives `shared_secret` from `shared_key` without validating that `shared_key` is not a weak point.

2. [2](#0-1) 
   Signers store received KEX public keys without any validation against weak points (identity, generator G, etc.).

3. [3](#0-2) 
   Coordinator stores `DkgPublicShares` (containing KEX public keys) without validation.

4. [4](#0-3) 
   Honest signers encrypt private shares using unvalidated KEX public keys from other signers.

5. [5](#0-4) 
   The `make_shared_secret_from_key` function accepts any Point without validation.

**Root Cause:**

The codebase validates nonces using `is_valid()` [6](#0-5)  which checks for identity and generator points, but applies no such validation to KEX public keys. The `is_valid()` implementation explicitly rejects `Point::identity()` and `G` (the generator), recognizing these as weak points that "can lead to attacks."

However, when KEX public keys are received in `DkgPublicShares` messages, they are stored and used directly without any validation. The DH key derivation at [7](#0-6)  and [8](#0-7)  proceeds with any provided public key.

**Why Existing Mitigations Fail:**

The TupleProof (Chaum-Pedersen proof) at [9](#0-8)  and its verification at [10](#0-9)  only prove that the DH tuple is correctly formed. A TupleProof with `a=1` (scalar value 1) still verifies correctly when `K = 1 * B = B`, so weak keys pass validation.

### Impact Explanation

**Specific Harm:**

A malicious signer controlling one or more key IDs can publish a weak KEX public key (e.g., the generator G where `kex_private_key = 1`). When honest signers encrypt private shares for the malicious signer's key IDs, they compute:
- `shared_secret = make_shared_secret(honest_kex_private_key, G)`
- `= make_shared_secret_from_key(honest_kex_private_key * G)`  
- `= make_shared_secret_from_key(honest_kex_public_key)`

Since each honest signer's KEX public key is broadcast in their own `DkgPublicShares` message, anyone (including the coordinator) can derive the same shared secret and decrypt the encrypted shares.

The private key computation at [11](#0-10)  shows that each key's private key is the sum of all received shares: `secret = shares.values().sum()`. By decrypting all shares sent to the malicious signer's key IDs from all parties, the coordinator can reconstruct the malicious signer's complete private keys.

**Quantified Impact:**

- The coordinator obtains complete private keys for one signer (potentially controlling multiple key IDs)
- With threshold t, if coordinator colludes with (t-1) honest signers, they can now produce valid signatures without the required t-of-n threshold
- Unauthorized signatures can be generated, potentially confirming invalid transactions on the blockchain
- Maps to **Critical** severity: "Any confirmation of an invalid transaction, such as with an incorrect nonce"

**Who is Affected:**

All deployments where the coordinator is not fully trusted, which is the fundamental assumption of threshold signature schemes. The entire security model assumes the coordinator cannot access any private key material.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control over one signer node in the DKG round
- Ability to modify that node's KEX key generation to use a weak value (e.g., scalar 1)
- No access to other nodes or cryptographic material required

**Attack Complexity:**
- Low - requires modifying ~5 lines of code in the attacker's controlled signer
- No timing constraints or race conditions
- No need to break any cryptographic primitives
- The attack is deterministic and reliable

**Economic Feasibility:**
- Minimal cost - only requires operating one signer node
- No additional computational resources needed
- Attack setup takes minutes once a signer node is compromised or operated by the attacker

**Detection Risk:**
- Very low - weak KEX public keys are indistinguishable from random keys to other participants
- No runtime anomalies or errors occur
- The coordinator's decryption happens silently without network traffic
- Protocol completes successfully with no visible failures

**Estimated Probability:**
- High if any single signer in the DKG is malicious or compromised
- In a trustless deployment model, this is a realistic threat
- Insider threat scenarios make this likely in practice

### Recommendation

**Immediate Fix:**

Add validation for KEX public keys when received in `DkgPublicShares`:

In `src/state_machine/signer/mod.rs` at line 1017, add:
```rust
// Validate KEX public key is not weak point
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    warn!(%signer_id, "Received weak KEX public key");
    return Ok(vec![]);
}
```

In `src/state_machine/coordinator/fire.rs` at line 500, add similar validation before storing public shares.

At line 684, before deriving the shared secret, add:
```rust
if bad_private_share.shared_key == Point::identity() 
    || bad_private_share.shared_key == G {
    warn!("Invalid shared_key in BadPrivateShare");
    continue;
}
```

**Additional Mitigations:**

1. Add a method `Point::is_valid_kex_key()` similar to [6](#0-5)  for consistent validation
2. Consider checking for small-order points using cofactor validation
3. Add explicit documentation that KEX keys must be validated
4. Add integration tests that attempt to use weak KEX keys and verify rejection

**Testing Recommendations:**

1. Unit test: Attempt to send `DkgPublicShares` with `kex_public_key = G`, verify rejection
2. Unit test: Attempt to send `kex_public_key = Point::identity()`, verify rejection  
3. Integration test: Full DKG round where one signer attempts weak keys, verify failure and proper error handling
4. Fuzz testing: Random point generation to identify other potentially weak points

**Deployment Considerations:**

- Breaking change: Existing signers using weak keys (unlikely in practice with proper RNG) would be rejected
- Should be deployed with new DKG round, not mid-session
- Consider adding configuration flag for backwards compatibility during transition period
- Update protocol specification to document KEX key validation requirements

### Proof of Concept

**Attack Algorithm:**

1. **Attacker Setup** (Malicious Signer M):
   ```
   - M controls signer_id = 0 with key_ids = {1, 2}
   - M sets kex_private_key = Scalar::from(1)  // Instead of Scalar::random()
   - M computes kex_public_key = 1 * G = G
   - M publishes DkgPublicShares with kex_public_key = G
   ```

2. **Honest Signer H Encrypts Shares**: [12](#0-11) 
   ```
   - H receives M's DkgPublicShares, stores kex_public_keys[1] = G, kex_public_keys[2] = G
   - For key_id in {1, 2}:
     - shared_secret = make_shared_secret(H.kex_private_key, G)
     - shared_secret = make_shared_secret_from_key(H.kex_private_key * G)
     - shared_secret = make_shared_secret_from_key(H.kex_public_key)  // Public value!
     - encrypted_share = encrypt(shared_secret, private_share, rng)
   - H sends DkgPrivateShares to coordinator
   ```

3. **Coordinator Decrypts** (or any observer with access to messages):
   ```
   - Coordinator knows H.kex_public_key from H's DkgPublicShares
   - For each honest signer H:
     - shared_secret = make_shared_secret_from_key(H.kex_public_key)
     - For key_id in {1, 2}:
       - decrypted_share[H][key_id] = decrypt(shared_secret, encrypted_shares[H][key_id])
   ```

4. **Key Reconstruction**: [11](#0-10) 
   ```
   - For key_id in {1, 2}:
     - M.private_key[key_id] = sum(decrypted_share[H][key_id] for all H)
   - Coordinator now has M's complete private keys
   ```

**Expected vs Actual Behavior:**

- **Expected**: Coordinator cannot decrypt any private shares; shares remain confidential to recipients
- **Actual**: Coordinator successfully decrypts all shares sent to M and reconstructs M's private keys

**Reproduction Instructions:**

1. Modify attacker's signer node: Replace `Scalar::random(rng)` with `Scalar::from(1)` at [13](#0-12) 
2. Run DKG with threshold t=2, n=3 signers where signer_id=0 is malicious
3. In coordinator, after receiving all `DkgPrivateShares`, attempt to decrypt shares sent to signer_id=0
4. Verify decryption succeeds using shared secrets derived from honest signers' public KEX keys
5. Sum decrypted shares to reconstruct signer_id=0's private keys
6. Verify reconstructed keys match by checking `private_key * G == public_key`

### Citations

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L687-688)
```rust
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);
```

**File:** src/state_machine/signer/mod.rs (L429-429)
```rust
        self.kex_private_key = Scalar::random(rng);
```

**File:** src/state_machine/signer/mod.rs (L935-942)
```rust
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L55-60)
```rust
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L268-284)
```rust
    pub fn new<RNG: RngCore + CryptoRng>(
        a: &Scalar,
        A: &Point,
        B: &Point,
        K: &Point,
        rng: &mut RNG,
    ) -> Self {
        let r = Scalar::random(rng);
        let R = r * G;
        let s = Self::challenge(A, B, K, &R);

        Self {
            R,
            rB: r * B,
            z: r + a * s,
        }
    }
```

**File:** src/common.rs (L288-292)
```rust
    pub fn verify(&self, A: &Point, B: &Point, K: &Point) -> bool {
        let s = Self::challenge(A, B, K, &self.R);

        (self.z * G == self.R + s * A) && (self.z * B == self.rB + s * K)
    }
```

**File:** src/v2.rs (L188-192)
```rust
        for key_id in &self.key_ids {
            self.private_keys.insert(*key_id, Scalar::zero());
            if let Some(shares) = private_shares.get(key_id) {
                let secret = shares.values().sum();
                self.private_keys.insert(*key_id, secret);
```
