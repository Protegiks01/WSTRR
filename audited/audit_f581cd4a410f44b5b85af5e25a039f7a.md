### Title
Signature Share Response Replay Attack via Missing Iteration ID Binding

### Summary
The `SignatureShareResponse` message does not include `sign_iter_id` in its hash, and coordinators do not validate this field when processing responses. This inconsistency with `NonceResponse` handling allows malicious signers to replay signature shares from previous iterations, causing signing rounds to fail and potentially triggering false accusations against honest participants through timeout mechanisms.

### Finding Description

**Exact Code Location:**
The vulnerability exists in `src/net.rs` in the `Signable` implementation for `SignatureShareResponse` [1](#0-0) 

The `hash()` function only includes `dkg_id`, `sign_id`, and `signer_id`, but omits the `sign_iter_id` field that exists in the struct [2](#0-1) 

**Root Cause:**
This is an inconsistency in the protocol design. The `NonceResponse` message correctly includes `sign_iter_id` in its hash [3](#0-2) , and both FIRE and FROST coordinators validate this field when processing nonce responses [4](#0-3) [5](#0-4) 

However, neither coordinator validates `sign_iter_id` for `SignatureShareResponse` messages. The FIRE coordinator only checks `dkg_id` and `sign_id` [6](#0-5) , and the FROST coordinator has the same limitation [7](#0-6) 

The `sign_iter_id` is incremented on each signing retry via `request_nonces()` [8](#0-7) 

**Why Existing Mitigations Fail:**
The `Packet` signature verification checks the signer's signature over the message hash, but since `sign_iter_id` is not included in the hash, the signature remains valid across iterations. The duplicate detection only prevents the same signer from submitting multiple times within one iteration [9](#0-8) , but does not prevent replays across iterations.

### Impact Explanation

**Specific Harm:**
1. **Denial of Service**: A malicious signer can force signing rounds to fail by replaying signature shares from iteration N in iteration N+1. The signature shares will fail cryptographic verification [10](#0-9)  because they were computed with different nonces and binding values [11](#0-10) 

2. **False Accusation of Honest Signers**: When a signing round times out, all waiting signers are marked as malicious [12](#0-11) . An attacker who submits their own fresh signature shares while replaying stale shares from honest participants can cause those honest signers to fail verification, potentially leading to timeouts and false accusations.

3. **State Machine Invariant Violation**: This violates the critical invariant that "Round IDs (dkg_id, sign_id, sign_iter_id) must match expected values."

**Severity Mapping:**
- **Low to Medium severity** based on the protocol scope
- Maps to "Any remotely-exploitable denial of service in a node" (Low)
- Could escalate to "Any transient consensus failures" (Medium) if dependent systems rely on timely signature generation

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a valid participant in the signing protocol with legitimate credentials
- Must be able to capture their own `SignatureShareResponse` from iteration N
- Must be able to send messages in iteration N+1

**Attack Complexity:**
The attack is straightforward to execute:
1. Participate normally in signing iteration N, capturing own signature share response
2. Wait for iteration N+1 to start (due to timeout or coordinator retry)
3. Replay the captured message from iteration N
4. Coordinator accepts it because no `sign_iter_id` validation occurs
5. Aggregation fails with `AggregatorError::BadPartySigs`

**Economic Feasibility:**
Minimal cost - requires only the ability to participate as a signer, which may be permissioned but doesn't require breaking cryptography.

**Detection Risk:**
Low detection risk initially, as the replayed message has a valid signature and passes Packet verification. The failure only becomes apparent during aggregation.

**Estimated Probability:**
High probability of success for an insider attacker. The attack will succeed whenever the attacker has access to capture and replay messages.

### Recommendation

**Primary Fix:**
Add `sign_iter_id` to the `SignatureShareResponse::hash()` implementation:

```rust
impl Signable for SignatureShareResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("SIGNATURE_SHARE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());  // ADD THIS LINE
        hasher.update(self.signer_id.to_be_bytes());
        // ... rest of function
    }
}
```

**Secondary Fix:**
Add validation in both coordinators' `gather_sig_shares()` functions:

```rust
if sig_share_response.sign_iter_id != self.current_sign_iter_id {
    return Err(Error::BadSignIterId(
        sig_share_response.sign_iter_id,
        self.current_sign_iter_id,
    ));
}
```

This should be added after the existing `dkg_id` and `sign_id` checks in both `fire.rs` and `frost.rs`.

**Testing Recommendations:**
1. Create a test that captures a `SignatureShareResponse` from iteration N
2. Advance to iteration N+1 
3. Replay the captured response
4. Verify it is rejected with `BadSignIterId` error

**Deployment Considerations:**
This is a protocol-breaking change. All coordinators and signers must upgrade simultaneously. Consider versioning the protocol or using a flag day for the upgrade.

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup Phase:**
   - Attacker A is a valid signer participating in signing round with `sign_id=100`, `sign_iter_id=1`
   - Coordinator requests nonces, signers respond
   - Coordinator sends `SignatureShareRequest` for iteration 1

2. **Capture Phase:**
   - Attacker A computes valid signature shares for iteration 1
   - Attacker A captures their own `SignatureShareResponse` packet P1:
     ```
     P1 = {
       dkg_id: 10,
       sign_id: 100,
       sign_iter_id: 1,  // Iteration 1
       signer_id: A,
       signature_shares: [...]
     }
     ```
   - P1.sig is valid ECDSA signature over hash(P1.msg) which does NOT include `sign_iter_id`

3. **Iteration Failure:**
   - Iteration 1 times out or fails for some reason
   - Coordinator increments to `sign_iter_id=2`
   - Coordinator sends new `NonceRequest` with `sign_iter_id=2`

4. **Replay Attack:**
   - All signers (including A) send new `NonceResponse` messages for iteration 2
   - Coordinator validates iteration 2 nonces (these pass `sign_iter_id` check)
   - Coordinator sends `SignatureShareRequest` for iteration 2 with new nonces
   - Honest signers compute fresh signature shares for iteration 2
   - **Attacker A replays P1 (from iteration 1) instead of computing new shares**

5. **Result:**
   - Coordinator's `gather_sig_shares()` accepts P1 because:
     - Packet signature is valid (sign_iter_id not in hash)
     - No `sign_iter_id` validation occurs
     - `dkg_id=10` matches ✓
     - `sign_id=100` matches ✓
   - Coordinator attempts aggregation with mixed iteration shares
   - Aggregation fails because A's shares have wrong binding values for iteration 2 nonces
   - Attacker A identified in `AggregatorError::BadPartySigs`
   - If timeout occurs, waiting signers marked malicious

**Expected vs Actual Behavior:**
- **Expected:** Replayed messages from old iterations should be rejected
- **Actual:** Coordinator accepts replayed `SignatureShareResponse` from old iterations, causing aggregation failures

**Reproduction Instructions:**
Modify the existing signing tests to inject a replayed `SignatureShareResponse` from a previous iteration and observe that the coordinator accepts it but aggregation fails.

### Notes

This vulnerability is particularly concerning because it creates an asymmetry in the protocol's iteration binding. While `NonceResponse` messages are properly bound to iterations through both hash inclusion and coordinator validation, `SignatureShareResponse` messages lack both protections. This allows Byzantine attackers to violate the fundamental assumption that signature shares correspond to the current iteration's nonces, undermining the protocol's liveness guarantees.

### Citations

**File:** src/net.rs (L349-367)
```rust
impl Signable for NonceResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }

        for nonce in &self.nonces {
            hasher.update(nonce.D.compress().as_bytes());
            hasher.update(nonce.E.compress().as_bytes());
        }

        hasher.update(self.message.as_slice());
    }
```

**File:** src/net.rs (L435-448)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// Signature share response message from signers to coordinator
pub struct SignatureShareResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Signature shares from this Signer
    pub signature_shares: Vec<SignatureShare>,
}
```

**File:** src/net.rs (L450-464)
```rust
impl Signable for SignatureShareResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("SIGNATURE_SHARE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for signature_share in &self.signature_shares {
            hasher.update(signature_share.id.to_be_bytes());
            hasher.update(signature_share.z_i.to_bytes());
            for key_id in &signature_share.key_ids {
                hasher.update(key_id.to_be_bytes());
            }
        }
    }
```

**File:** src/state_machine/coordinator/fire.rs (L177-186)
```rust
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L814-839)
```rust
    fn request_nonces(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.message_nonces.clear();
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
        info!(
            sign_id = %self.current_sign_id,
            sign_iter_id = %self.current_sign_iter_id,
            "Requesting Nonces"
        );
        let nonce_request = NonceRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            message: self.message.clone(),
            signature_type,
        };
        let nonce_request_msg = Packet {
            sig: nonce_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign NonceRequest"),
            msg: Message::NonceRequest(nonce_request),
        };
        self.move_to(State::NonceGather(signature_type))?;
        self.nonce_start = Some(Instant::now());

        Ok(nonce_request_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L856-861)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1027-1038)
```rust
        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1078-1086)
```rust
        let have_shares = self
            .signature_shares
            .contains_key(&sig_share_response.signer_id);

        if have_shares {
            info!(signer_id = %sig_share_response.signer_id, "received duplicate SignatureShareResponse");
            // XXX should this be an error?  We should have already removed signer from wait set
            return Ok(());
        }
```

**File:** src/state_machine/coordinator/frost.rs (L488-492)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/frost.rs (L600-611)
```rust
            if sig_share_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    sig_share_response.dkg_id,
                    self.current_dkg_id,
                ));
            }
            if sig_share_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    sig_share_response.sign_id,
                    self.current_sign_id,
                ));
            }
```

**File:** src/v2.rs (L406-408)
```rust
            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```
