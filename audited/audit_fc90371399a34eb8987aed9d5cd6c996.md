### Title
Permanent Signer Exclusion via Persistent malicious_signer_ids Across Signing Iterations

### Summary
In the FIRE coordinator implementation, signers who timeout during signature share gathering are permanently marked as malicious and excluded from all future signing operations. The `malicious_signer_ids` set is never cleared between signing iterations within the same round or across different signing rounds, causing legitimate signers to be permanently excluded after transient network issues. This enables denial of service attacks and can prevent the system from reaching the signing threshold.

### Finding Description

The vulnerability exists in the FIRE coordinator's timeout handling and state management: [1](#0-0) 

When a signature share gathering timeout occurs, all signers who haven't responded are marked as malicious by inserting them into `malicious_signer_ids`. The coordinator then starts a new signing iteration by calling `request_nonces()`: [2](#0-1) 

The `request_nonces()` function clears `message_nonces` (line 815) but does NOT clear `malicious_signer_ids`. In subsequent iterations, when gathering nonces, the coordinator checks if signers are in the malicious set and silently rejects their responses: [3](#0-2) 

Critically, there is no code path that clears `malicious_signer_ids`:
- Not in `request_nonces()` (called on each iteration)
- Not in `start_signing_round()` (called on each new round): [4](#0-3) 

- Not in `reset()` (manual reset function): [5](#0-4) 

The only place signers are added to `malicious_signer_ids` is during timeouts, not based on cryptographic misbehavior. There are no existing mitigations - once a signer is marked malicious, they remain excluded until the coordinator instance is recreated.

**Root Cause**: The design conflates two distinct failure modes: (1) cryptographic misbehavior requiring permanent exclusion, and (2) transient timeout failures that should allow retry. The timeout-based marking uses the same permanent exclusion mechanism as cryptographic failures without any clearing mechanism.

### Impact Explanation

**Direct Impact**: 
- Signers who experience temporary network issues or legitimate delays are permanently excluded from all future signing operations
- Accumulated exclusions over multiple signing rounds reduce the available signer pool
- Eventually, the remaining non-malicious signers may fall below the threshold, preventing any signatures from being created

**Quantified Scenario**:
With a configuration of `num_keys=40, threshold=28` (as seen in test configurations), if 13 or more key IDs are marked as malicious, the system cannot reach threshold. In a `num_signers=10, keys_per_signer=4` setup, excluding just 4 signers (16 keys) would prevent all future signatures.

**Attack Vector**:
1. Malicious coordinator sets short timeout values
2. Coordinator deliberately delays sending SignatureShareRequest until near timeout
3. Honest signers who respond slightly late are marked malicious
4. After several iterations/rounds, enough honest signers are excluded to prevent threshold
5. System can no longer produce valid signatures

**Affected Systems**: 
Any WSTS-dependent blockchain system (like Stacks) would be unable to confirm transactions if the signer set falls below threshold. This maps to **Low severity** per the protocol scope: "Any remotely-exploitable denial of service in a node" or potentially **Medium severity**: "Any transient consensus failures" if signers cannot be rotated.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Control over the coordinator node (to manipulate timeout values or network conditions)
- OR ability to cause network delays between coordinator and signers (e.g., DDoS, network partitioning)

**Attack Complexity**: Low to Medium
- No cryptographic breaks required
- Simple timeout manipulation or network interference
- Cumulative effect over multiple rounds makes the attack practical

**Economic Feasibility**: High
- Low cost to cause network delays or timeouts
- No financial stake required to execute attack
- Can be repeated across multiple signing rounds

**Detection**: 
- Visible in coordinator logs as signers marked malicious
- However, may appear as legitimate network issues
- Operators may not immediately recognize the permanent exclusion pattern

**Probability of Success**: High
- Natural network variability can trigger the issue without intentional attack
- In production environments, occasional timeouts are expected
- The permanent exclusion guarantees eventual degradation

### Recommendation

**Immediate Fix**: Clear `malicious_signer_ids` at appropriate boundaries:

1. **Option A - Clear on each signing round** (recommended):
```rust
fn start_signing_round(...) -> Result<Packet, Error> {
    // Clear malicious signer tracking from previous rounds
    self.malicious_signer_ids.clear();
    
    // existing code...
}
```

2. **Option B - Separate timeout-based exclusion from cryptographic misbehavior**:
    - Create a separate `timeout_signer_ids` set that is cleared each iteration
    - Reserve `malicious_signer_ids` only for cryptographically-verified misbehavior
    - Check both sets in `gather_nonces()`

3. **Option C - Add explicit TTL or iteration limits**:
    - Track when signers were marked malicious
    - Clear marks after N iterations or time period
    - Allows recovery from transient issues

**Testing**: 
- Add test that verifies malicious_signer_ids is cleared between signing rounds
- Add test that verifies signers excluded in iteration N can participate in iteration N+1 of a different round
- Validate that cryptographic misbehavior (bad shares in DKG) still results in permanent exclusion via `malicious_dkg_signer_ids`

**Deployment**: 
- This fix requires coordinator restart to deploy
- Existing coordinators with accumulated malicious_signer_ids should be restarted
- Update operational runbooks to monitor and clear malicious signer accumulation

### Proof of Concept

**Exploitation Steps**:

1. **Setup**: Deploy coordinator with `num_signers=10, keys_per_signer=4, threshold=28, sign_timeout=100ms`

2. **Round 1, Iteration 1**:
   - Coordinator starts signing round
   - Signers 0-6 respond within timeout (28 keys)
   - Signers 7-9 delayed response (12 keys)
   - Timeout fires: signers 7-9 added to `malicious_signer_ids`
   - New iteration starts

3. **Round 1, Iteration 2**:
   - Coordinator requests nonces
   - Signers 7-9 attempt to respond
   - Their nonces are rejected (line 914 returns Ok() silently)
   - Only signers 0-6 participate (28 keys)
   - If another timeout occurs, more signers marked malicious

4. **Round 2** (different message):
   - Coordinator calls `start_signing_round()` with new message
   - `malicious_signer_ids` still contains {7, 8, 9}
   - Signers 7-9 permanently excluded from this round
   - Available pool reduced to 7 signers (28 keys)

5. **Eventual Failure**:
   - After multiple rounds with different timeout patterns
   - Accumulated exclusions reach 4+ signers (16+ keys)
   - Remaining pool: 6 signers (24 keys) < threshold (28 keys)
   - System cannot produce signatures

**Expected vs Actual Behavior**:
- **Expected**: Signers excluded in one iteration should be able to retry in subsequent iterations or rounds
- **Actual**: Signers remain permanently excluded across all iterations and rounds

**Reproduction**:
Based on the test pattern at lines 2936-3184, modify to add assertions checking `malicious_signer_ids` persistence across iterations and verify excluded signers cannot participate in subsequent rounds.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L173-208)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
                        }
                    }
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L814-839)
```rust
    fn request_nonces(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.message_nonces.clear();
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
        info!(
            sign_id = %self.current_sign_id,
            sign_iter_id = %self.current_sign_iter_id,
            "Requesting Nonces"
        );
        let nonce_request = NonceRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            message: self.message.clone(),
            signature_type,
        };
        let nonce_request_msg = Packet {
            sig: nonce_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign NonceRequest"),
            msg: Message::NonceRequest(nonce_request),
        };
        self.move_to(State::NonceGather(signature_type))?;
        self.nonce_start = Some(Instant::now());

        Ok(nonce_request_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1457-1476)
```rust
    fn start_signing_round(
        &mut self,
        message: &[u8],
        signature_type: SignatureType,
        sign_id: Option<u64>,
    ) -> Result<Packet, Error> {
        // We cannot sign if we haven't first set DKG (either manually or via DKG round).
        if self.aggregate_public_key.is_none() {
            return Err(Error::MissingAggregatePublicKey);
        }
        self.message = message.to_vec();
        if let Some(id) = sign_id {
            self.current_sign_id = id;
        } else {
            self.current_sign_id = self.current_sign_id.wrapping_add(1);
        }
        info!("Starting signing round {}", self.current_sign_id);
        self.move_to(State::NonceRequest(signature_type))?;
        self.request_nonces(signature_type)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```
