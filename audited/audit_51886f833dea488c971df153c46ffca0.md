### Title
Signature Shares Not Cryptographically Verified Before Aggregation, Violating Protocol Specification

### Summary
The implementation aggregates signature shares and verifies the group signature first, only checking individual share validity if the group signature fails. This directly violates the protocol specification which mandates that signature shares "must first verify that they are valid" before aggregation. This allows colluding malicious parties to submit incorrect signature shares (with wrong nonce, binding, challenge, private key, or lambda components) that go undetected when their errors balance out.

### Finding Description

**Exact Code Location:**

The vulnerability exists in both v1 and v2 implementations:
- [1](#0-0) 
- [2](#0-1) 

**Root Cause:**

The protocol specification explicitly requires individual signature share verification before aggregation: [3](#0-2) 

However, the implementation violates this requirement. The `Aggregator::sign()` method first calls `sign_with_tweak()` to aggregate all signature shares into a group signature, then verifies only the group signature. Individual shares are only checked via `check_signature_shares()` if the group signature verification fails.

**Why This Occurs:**

In the `Party::sign()` function, each party computes their signature share: [4](#0-3) 

The z computation is: `z = nonce_d + nonce_e*binding + challenge*private_key*lambda`

If any component (nonce_d, nonce_e, binding, challenge, private_key, or lambda) is incorrect, the share should fail verification. However, the aggregator never verifies individual shares in the normal flow—it only aggregates them: [5](#0-4) 

The verification equation for individual shares exists in `check_signature_shares()`: [6](#0-5) 

But this is only invoked when the group signature fails, not as a pre-aggregation check.

**Why Existing Mitigations Fail:**

The state machine coordinator performs only structural validation (key ID matching, duplicate detection) but no cryptographic validation of signature shares before passing them to the aggregator: [7](#0-6) 

### Impact Explanation

**Specific Harm:**

This vulnerability violates the critical signing invariant: "Signature shares must be consistent with party IDs, nonces, and key ownership." When two or more malicious parties collude, they can:

1. Submit signature shares with incorrect components (wrong nonces, binding, challenge, private_key, or lambda values)
2. Coordinate their incorrect shares so the errors cancel out (e.g., Party A adds δ to z_i, Party B subtracts δ from z_j)
3. The aggregated group signature remains valid and verifies successfully
4. Individual share verification is never performed, so the incorrect shares go undetected

**Concrete Impact:**

- **Accountability Violation:** Cannot forensically determine which parties correctly contributed to a signature, breaking audit trails
- **Protocol Non-Compliance:** Direct violation of the specification's mandatory verification requirement
- **Consensus Risk:** If some implementations follow the specification and verify shares before aggregation while others don't, this creates a protocol divergence that could lead to **transient consensus failures** (Medium severity) or **unintended chain splits** (High severity)
- **Security Assumption Violation:** Dependent systems relying on the assumption that verified group signatures imply verified individual shares would be compromised

**Who Is Affected:**

All users of WSTS v1 and v2, particularly systems that rely on individual signature share accountability or assume specification compliance.

**Severity Justification:**

This maps to **High** severity under the protocol scope definition: "Any unintended chain split or network partition" could occur if different node implementations make different assumptions about signature share verification timing, or if dependent systems incorrectly assume shares were individually verified.

### Likelihood Explanation

**Required Attacker Capabilities:**

- Control of at least 2 signer parties in the threshold signature scheme
- Ability to coordinate between these parties to submit complementary incorrect shares
- No cryptographic breaks required

**Attack Complexity:**

Low to Medium. The attack requires:
1. Two colluding malicious parties computing incorrect z_i values
2. Coordinating the errors so they sum to zero: `Σ(z_i + δ_i) = Σ(z_i)` where `Σ(δ_i) = 0`
3. Submitting these shares during the signing round

**Economic Feasibility:**

Highly feasible. An attacker controlling multiple signer identities (e.g., through Sybil attacks or compromised nodes) can easily coordinate this attack with no additional cost beyond the normal signing operation.

**Detection Risk:**

Very low. Since the group signature verifies successfully, there is no indication that individual shares were incorrect. The malicious behavior is completely undetectable under normal operation.

**Probability of Success:**

High. The attack succeeds with 100% probability if:
- The attacker controls 2+ colluding parties
- The parties correctly coordinate their z_i values to balance errors
- The threshold is reached with their participation

### Recommendation

**Primary Fix:**

Modify the `Aggregator::sign()`, `Aggregator::sign_schnorr()`, and `Aggregator::sign_taproot()` methods to verify individual signature shares BEFORE aggregation, as mandated by the specification:

```
fn sign(...) -> Result<Signature, AggregatorError> {
    // FIRST: Verify all individual signature shares
    self.check_signature_shares_internal(msg, nonces, sig_shares, None)?;
    
    // THEN: Aggregate and verify group signature
    let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, None)?;
    
    if sig.verify(&key, msg) {
        Ok(sig)
    } else {
        // This should now be impossible if shares were valid
        Err(AggregatorError::BadGroupSig)
    }
}
```

Create a new internal method `check_signature_shares_internal()` that performs the verification and returns `Result<(), AggregatorError>` instead of just returning an error type. The existing `check_signature_shares()` can remain for backward compatibility.

**Testing Recommendations:**

1. Add test cases where colluding parties submit coordinated incorrect shares and verify they are rejected before aggregation
2. Add test cases verifying that the group signature verification is still performed after individual share verification
3. Add performance benchmarks to measure the impact of pre-aggregation verification

**Deployment Considerations:**

This is a breaking change that may affect performance (individual share verification must now happen for every signature, not just failed ones). Consider:
- Phased rollout to measure performance impact
- Configuration flag to enable/disable pre-aggregation verification during transition period
- Clear communication that this brings the implementation into specification compliance

### Proof of Concept

**Attack Algorithm:**

1. **Setup:** Attacker controls parties A and B in a threshold signature scheme
2. **Normal signing:** Parties should compute `z_i = d_i + e_i*ρ_i + c*s_i*λ_i`
3. **Malicious computation:**
   - Party A computes: `z_A' = d_A + e_A*ρ_A + c*s_A*λ_A + δ` (adds error δ)
   - Party B computes: `z_B' = d_B + e_B*ρ_B + c*s_B*λ_B - δ` (subtracts error δ)
   - All honest parties compute correct z_i values
4. **Aggregation:** 
   - Coordinator computes: `z_total = Σ(z_i) = z_correct + δ - δ = z_correct`
   - Group signature (R, z_total) verifies successfully
5. **Result:** Parties A and B submitted incorrect shares, but were never detected because `check_signature_shares()` was never called

**Reproduction Steps:**

1. Set up a WSTS threshold signature with at least 3 parties
2. Modify two parties to add/subtract a small scalar δ to their z_i computation
3. Complete the signing round
4. Observe that the group signature verifies successfully
5. Note that no error is returned, proving incorrect shares went undetected

**Expected vs Actual Behavior:**

- **Expected (per specification):** Individual shares should be verified before aggregation; incorrect shares should be rejected with `AggregatorError::BadPartySigs`
- **Actual:** Incorrect shares are aggregated without verification; if they balance out, the attack succeeds silently

### Citations

**File:** src/v1.rs (L217-229)
```rust
    pub fn sign(&self, msg: &[u8], signers: &[u32], nonces: &[PublicNonce]) -> SignatureShare {
        let (_, aggregate_nonce) = compute::intermediate(msg, signers, nonces);
        let mut z = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
        z += compute::challenge(&self.group_key, &aggregate_nonce, msg)
            * &self.private_key
            * compute::lambda(self.id, signers);

        SignatureShare {
            id: self.id,
            z_i: z,
            key_ids: vec![self.id],
        }
    }
```

**File:** src/v1.rs (L314-354)
```rust
    pub fn sign_with_tweak(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        tweak: Option<Scalar>,
    ) -> Result<(Point, Signature), AggregatorError> {
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }

        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &signers, nonces);
        let mut z = Scalar::zero();
        let mut cx_sign = Scalar::one();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = match tweak {
            Some(t) if t != Scalar::zero() => {
                let key = compute::tweaked_public_key_from_tweak(&aggregate_public_key, t);
                if !key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                key
            }
            _ => aggregate_public_key,
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);

        for sig_share in sig_shares {
            z += sig_share.z_i;
        }

        // The signature shares have already incorporated the private key adjustments, so we just have to add the tweak.  But the tweak itself needs to be adjusted if the tweaked public key is odd
        if let Some(t) = tweak {
            z += cx_sign * c * t;
        }

        let sig = Signature { R, z };

        Ok((tweaked_public_key, sig))
    }
```

**File:** src/v1.rs (L361-426)
```rust
    pub fn check_signature_shares(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        tweak: Option<Scalar>,
    ) -> AggregatorError {
        if nonces.len() != sig_shares.len() {
            return AggregatorError::BadNonceLen(nonces.len(), sig_shares.len());
        }

        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (Rs, R) = compute::intermediate(msg, &signers, nonces);
        let mut bad_party_keys = Vec::new();
        let mut bad_party_sigs = Vec::new();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = match tweak {
            Some(t) if t != Scalar::zero() => {
                compute::tweaked_public_key_from_tweak(&aggregate_public_key, t)
            }
            _ => aggregate_public_key,
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r_sign = Scalar::one();
        let mut cx_sign = Scalar::one();
        if let Some(t) = tweak {
            if !R.has_even_y() {
                r_sign = -Scalar::one();
            }
            if t != Scalar::zero() {
                if !tweaked_public_key.has_even_y() ^ !aggregate_public_key.has_even_y() {
                    cx_sign = -Scalar::one();
                }
            } else if !aggregate_public_key.has_even_y() {
                cx_sign = -Scalar::one();
            }
        }

        for i in 0..sig_shares.len() {
            let id = compute::id(sig_shares[i].id);
            let public_key = match compute::poly(&id, &self.poly) {
                Ok(p) => p,
                Err(_) => {
                    bad_party_keys.push(sig_shares[i].id);
                    Point::zero()
                }
            };

            let z_i = sig_shares[i].z_i;

            if z_i * G
                != r_sign * Rs[i]
                    + cx_sign * (compute::lambda(sig_shares[i].id, &signers) * c * public_key)
            {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }

        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
        } else {
            AggregatorError::BadGroupSig
        }
    }
```

**File:** src/v1.rs (L457-471)
```rust
    fn sign(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        _key_ids: &[u32],
    ) -> Result<Signature, AggregatorError> {
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, None)?;

        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, None))
        }
    }
```

**File:** src/v2.rs (L448-462)
```rust
    fn sign(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
    ) -> Result<Signature, AggregatorError> {
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, key_ids, None)?;

        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
    }
```

**File:** wsts.tex (L365-368)
```tex
Once the aggregator has gathered the signature shares $z_{i_p}$, it must first verify that they are valid by checking that:
\begin{align}
  z_{i_p} \cdot G = D_{i_p} + \rho_{i_p} \cdot E_{i_p} + \sum_{j_k \in K_{i_p}}^{} Y_{j_k} \cdot c \cdot \lambda_{j_k}
\end{align}
```

**File:** src/state_machine/coordinator/frost.rs (L594-733)
```rust
    fn gather_sig_shares(
        &mut self,
        packet: &Packet,
        signature_type: SignatureType,
    ) -> Result<(), Error> {
        if let Message::SignatureShareResponse(sig_share_response) = &packet.msg {
            if sig_share_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    sig_share_response.dkg_id,
                    self.current_dkg_id,
                ));
            }
            if sig_share_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    sig_share_response.sign_id,
                    self.current_sign_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
                warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
                return Ok(());
            };

            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&sig_share_response.signer_id)
            else {
                warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
            }

            let have_shares = self
                .signature_shares
                .contains_key(&sig_share_response.signer_id);

            if have_shares {
                info!(signer_id = %sig_share_response.signer_id, "received duplicate SignatureShareResponse");
                return Ok(());
            }

            self.signature_shares.insert(
                sig_share_response.signer_id,
                sig_share_response.signature_shares.clone(),
            );
            self.ids_to_await.remove(&sig_share_response.signer_id);
            debug!(
                sign_id = %sig_share_response.sign_id,
                signer_id = %sig_share_response.signer_id,
                waiting = ?self.ids_to_await,
                "SignatureShareResponse received"
            );
        }
        if self.ids_to_await.is_empty() {
            // Calculate the aggregate signature
            let nonce_responses = (0..self.config.num_signers)
                .map(|i| self.public_nonces[&i].clone())
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = &self
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();

            debug!(
                nonces_len = %nonces.len(),
                shares_len = %shares.len(),
                "aggregator.sign"
            );

            self.aggregator.init(&self.party_polynomials)?;

            if let SignatureType::Taproot(merkle_root) = signature_type {
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    shares,
                    &key_ids,
                    merkle_root,
                )?;
                debug!(
                    r = %schnorr_proof.r,
                    s = %schnorr_proof.s,
                    "SchnorrProof"
                );
                self.schnorr_proof = Some(schnorr_proof);
            } else if let SignatureType::Schnorr = signature_type {
                let schnorr_proof =
                    self.aggregator
                        .sign_schnorr(&self.message, &nonces, shares, &key_ids)?;
                debug!(
                    r = %schnorr_proof.r,
                    s = %schnorr_proof.s,
                    "SchnorrProof"
                );
                self.schnorr_proof = Some(schnorr_proof);
            } else {
                let signature = self
                    .aggregator
                    .sign(&self.message, &nonces, shares, &key_ids)?;
                debug!(
                    R = %signature.R,
                    z = %signature.z,
                    "Signature"
                );
                self.signature = Some(signature);
            }

            self.move_to(State::Idle)?;
        }
        Ok(())
    }
```
