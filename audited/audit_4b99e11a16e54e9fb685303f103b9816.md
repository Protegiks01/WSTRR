### Title
Missing Validation of DH Public Keys Allows Predictable Encryption Keys in DKG Private Share Distribution

### Summary
The `encrypt()` function accepts keys derived from `make_shared_secret()` without validating that the Diffie-Hellman public key is not the identity point or other weak points. A malicious signer can broadcast `Point::identity()` as their ephemeral `kex_public_key`, causing all honest signers to derive a predictable, constant encryption key when encrypting private shares. This completely breaks the confidentiality of DKG private shares, allowing unauthorized reconstruction of the distributed key.

### Finding Description

**Exact Code Locations:**

The `encrypt()` function accepts a 32-byte key without any entropy validation: [1](#0-0) 

The `make_shared_secret()` function performs scalar-point multiplication without validating that the public key is not the identity point: [2](#0-1) 

When signers receive `DkgPublicShares` messages, the `kex_public_key` is stored without any validation: [3](#0-2) 

The unvalidated `kex_public_key` is then used to derive the encryption key: [4](#0-3) 

The coordinator also stores `kex_public_key` without validation: [5](#0-4) 

**Root Cause:**

The root cause is the absence of point validation on the ephemeral DH public keys (`kex_public_key`) used for encrypting DKG private shares. While the codebase implements validation for other points (e.g., `PublicNonce::is_valid()` checks for identity points): [6](#0-5) 

No equivalent validation is performed on `kex_public_key` when `DkgPublicShares` messages are received: [7](#0-6) 

Additionally, the `kex_public_key` is excluded from the `Signable` hash computation, meaning message authentication does not protect it: [8](#0-7) 

**Why Existing Mitigations Fail:**

The `TupleProof` mechanism used for verifying `BadPrivateShare` reports cannot prevent this attack. When `B = Point::identity()`, the proof equations `z * G == R + s * A` and `z * identity == r * identity + s * identity` still verify correctly (both sides equal identity). The proof is checked only after shares are already encrypted and compromised: [9](#0-8) 

The coordinator's verification logic also relies on this flawed proof: [10](#0-9) 

### Impact Explanation

**Specific Harm:**
When a malicious signer broadcasts `Point::identity()` as their `kex_public_key`:
1. Any honest signer computing `private_key * identity = identity`
2. The derived encryption key becomes: `SHA256(identity_compressed || 0x00000001 || "DH_SHARED_SECRET_KEY/")`
3. This is a predictable, constant value computable by anyone
4. The malicious signer (or any network observer) can decrypt all private shares intended for that signer
5. Private shares are polynomial evaluations: `f_i(j)` where `f_i` is signer `i`'s secret polynomial

**Quantified Impact:**
- In a threshold `(t, n)` setup, if a malicious signer collects `t` or more private shares from honest signers, they can reconstruct the group private key
- Even with fewer shares, the attacker gains partial knowledge of the distributed secret, weakening the threshold security
- This enables unauthorized signature creation, potentially leading to:
  - **Loss of funds**: Malicious transactions signed without proper threshold authorization
  - **Invalid signatures accepted**: Signatures from unauthorized key material
  - **Consensus failure**: Different nodes may accept/reject transactions based on compromised keys

**Who is Affected:**
All participants in any DKG round where a malicious signer or network attacker is present.

**Severity Justification:**
This is **Critical** severity per the audit scope because it can cause:
- "Any causing the direct loss of funds other than through any form of freezing" - compromised distributed keys enable theft
- "Any confirmation of an invalid transaction" - unauthorized signatures can be created
- The attack completely breaks the foundational security assumption that private polynomial evaluations remain confidential

### Likelihood Explanation

**Required Attacker Capabilities:**
- **Malicious Insider**: A registered signer with valid credentials can trivially execute this attack by setting their `kex_public_key = Point::identity()` in `DkgPublicShares`
- **Network Attacker**: Since `kex_public_key` is not included in the message signature hash, a Man-in-the-Middle attacker can modify any honest signer's `kex_public_key` to `identity` without detection

**Attack Complexity:**
- Extremely low: Requires only modifying a single field in one message type
- No cryptographic breaks required
- No timing constraints or complex multi-step coordination needed

**Economic Feasibility:**
- Zero cost for malicious insider
- Minimal cost for network attacker (standard MitM capabilities)
- High reward: Complete access to private shares enabling key reconstruction

**Detection Risk:**
- Very low: The attack is silent until shares are used
- TupleProof verification appears to succeed (false negative)
- Honest signers' encryption and decryption operations complete normally
- Only detected if someone attempts to independently verify share confidentiality

**Estimated Probability of Success:**
100% if prerequisites are met (malicious signer or network attacker position)

### Recommendation

**Primary Fix:**
Validate `kex_public_key` when receiving `DkgPublicShares` messages. Add validation in both signer and coordinator handlers:

```rust
// In src/state_machine/signer/mod.rs, dkg_public_share function:
// After line 991, before line 1018:
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    warn!(%signer_id, "Invalid kex_public_key (identity or generator)");
    return Ok(vec![]);
}

// Similar check in src/state_machine/coordinator/fire.rs, gather_public_shares
```

**Secondary Fix:**
Include `kex_public_key` in the `Signable` hash to enable detection of tampering:

```rust
// In src/net.rs, DkgPublicShares Signable implementation:
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // ADD THIS LINE:
        hasher.update(self.kex_public_key.compress().as_bytes());
        for (party_id, comm) in &self.comms {
            // ... rest unchanged
        }
    }
}
```

**Testing Recommendations:**
1. Unit test: Verify that `Point::identity()` is rejected as `kex_public_key`
2. Unit test: Verify that generator `G` is rejected as `kex_public_key`
3. Integration test: Simulate malicious signer sending invalid `kex_public_key` and verify DKG fails safely
4. Regression test: Ensure legitimate DKG rounds still complete successfully

**Deployment Considerations:**
- This is a breaking protocol change requiring coordinated deployment
- All signers and coordinators must upgrade simultaneously
- Consider a grace period where old and new validation coexist with warnings before enforcement

### Proof of Concept

**Exploitation Steps:**

1. **Malicious Signer Setup:**
   - Register as a valid signer with credentials
   - Generate normal polynomial commitments for DKG

2. **Send Malicious DkgPublicShares:**
   ```
   DkgPublicShares {
       dkg_id: <current_round>,
       signer_id: <malicious_signer_id>,
       comms: <valid_polynomial_commitments>,
       kex_public_key: Point::identity(),  // ATTACK HERE
   }
   ```

3. **Honest Signers Encrypt to Malicious Signer:**
   - Each honest signer computes: `shared_secret = make_shared_secret(&their_kex_private_key, &Point::identity())`
   - This yields: `shared_key = their_kex_private_key * identity = identity`
   - Derived key: `SHA256(identity_compressed || 0x00000001 || "DH_SHARED_SECRET_KEY/")`
   - This key is identical for ALL honest signers encrypting to the malicious signer

4. **Malicious Signer Decrypts All Shares:**
   - Compute the same predictable key (no secrets needed)
   - Decrypt all `DkgPrivateShares` intended for malicious signer
   - Extract polynomial evaluations: `f_i(malicious_signer_key_ids)`

5. **Reconstruct Distributed Key:**
   - If malicious signer receives ≥ threshold shares, use Lagrange interpolation
   - Reconstruct group private key or sufficient key material
   - Create unauthorized signatures

**Parameter Values:**
- `Point::identity()`: The identity element of the secp256k1 curve group
- Predictable encryption key: 32-byte output of SHA-256 with known inputs
- No randomness or secrets required for attacker

**Expected vs Actual Behavior:**
- **Expected**: Private shares are confidentially encrypted, only decryptable by intended recipient
- **Actual**: Private shares are encrypted with a publicly-computable key, decryptable by anyone

**Reproduction Instructions:**
1. Set up a WSTS DKG round with ≥3 signers
2. Modify one signer to send `Point::identity()` as `kex_public_key`
3. Observe that DKG completes without error
4. As external observer, compute predictable encryption key
5. Decrypt captured `DkgPrivateShares` messages
6. Verify successful extraction of private polynomial evaluations

### Citations

**File:** src/util.rs (L47-52)
```rust
/// Do a Diffie-Hellman key exchange to create a shared secret from the passed private/public keys
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L79-99)
```rust
/// Encrypt the passed data using the key
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
}
```

**File:** src/state_machine/signer/mod.rs (L941-942)
```rust
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L973-1026)
```rust
    /// handle incoming DkgPublicShares
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L681-688)
```rust
                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L286-292)
```rust
    #[allow(non_snake_case)]
    /// Verify the proof using the transcript and public parameters
    pub fn verify(&self, A: &Point, B: &Point, K: &Point) -> bool {
        let s = Self::challenge(A, B, K, &self.R);

        (self.z * G == self.R + s * A) && (self.z * B == self.rB + s * K)
    }
```

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```
