### Title
Unbounded DKG Encrypted Share Size Enables Memory and CPU Exhaustion DoS

### Summary
The `encrypt()` and `decrypt()` functions in `src/util.rs` accept arbitrarily large plaintexts/ciphertexts without size validation. A malicious signer can exploit this during DKG by sending oversized encrypted shares in `DkgPrivateShares` messages, causing honest nodes to exhaust memory storing the messages and CPU time attempting decryption, effectively denying service to the DKG protocol and potentially the node itself.

### Finding Description

The vulnerability exists in the encryption/decryption flow used for DKG private share distribution: [1](#0-0) 

The `encrypt()` function accepts an unbounded `data: &[u8]` parameter with no size validation. Similarly, `decrypt()` accepts unbounded input: [2](#0-1) 

During DKG, signers encrypt private shares (normally 32-byte Scalars) and send them in `DkgPrivateShares` messages: [3](#0-2) 

The `DkgPrivateShares` message structure stores encrypted shares as unbounded `Vec<u8>`: [4](#0-3) 

When honest nodes receive these messages, they deserialize and store them in memory: [5](#0-4) 

The coordinator also processes and validates these shares: [6](#0-5) 

**Root Cause**: The codebase assumes all encrypted shares will be the expected size (~60 bytes: 12-byte nonce + 32-byte ciphertext + 16-byte auth tag) but enforces no validation. The serde deserialization has no size limits, and neither `encrypt()` nor `decrypt()` validate input sizes.

**Why Existing Mitigations Fail**: There are no size checks at any layer - not in the encryption functions, not in the message structure, not in serde deserialization, and not in the state machine handlers. Message signature verification only confirms authenticity, not size constraints.

### Impact Explanation

**Specific Harm**: A malicious signer can send `DkgPrivateShares` messages containing arbitrarily large encrypted blobs, causing:

1. **Memory Exhaustion**: With typical DKG parameters (10 keys, 4 parties), a single malicious message could contain 40 oversized shares. At 10 MB per share, that's 400 MB per message. Multiple malicious signers or repeated messages quickly exhaust available RAM.

2. **CPU Exhaustion**: AES-GCM decryption is O(n) in ciphertext size. Attempting to decrypt 10 MB blobs instead of 32 bytes causes significant CPU delays. Processing 40 such blobs per message effectively stalls the DKG process.

3. **Network Bandwidth Saturation**: Transmitting hundreds of MB per DKG message saturates network bandwidth, delaying or preventing legitimate protocol messages.

**Who is Affected**: All honest signers and the coordinator receiving the malicious `DkgPrivateShares` messages. In a network with resource-constrained nodes, this could impact the majority of participants.

**Severity Justification**: This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." A malicious signer can remotely crash or severely degrade honest nodes during DKG, preventing the system from generating valid signing keys. While this doesn't directly impact the blockchain layer, it prevents WSTS participants from successfully completing DKG, which could indirectly impact signing operations if DKG cannot complete.

### Likelihood Explanation

**Required Attacker Capabilities**: 
- Position as a registered signer in the DKG protocol with valid message signing keys
- Ability to send messages during the DKG private share distribution phase
- No cryptographic breaks required

**Attack Complexity**: Low. The attacker simply:
1. Constructs a `DkgPrivateShares` message with oversized `Vec<u8>` values
2. Signs it with their valid private key (passes authentication)
3. Broadcasts to honest signers and coordinator

**Economic Feasibility**: Minimal cost. Creating large byte arrays and signing messages requires negligible computational resources compared to the impact on victims.

**Detection Risk**: Medium. Oversized messages are easily detectable if monitored, but the protocol currently has no such monitoring. The attack is noisy (high bandwidth usage) but may complete before detection.

**Estimated Probability**: High. Any malicious signer can execute this attack during any DKG round. The only prerequisite is being registered as a signer, which is assumed possible in the threat model (otherwise malicious signer detection would be unnecessary).

### Recommendation

**Immediate Fix**: Add size validation to encrypted share data at multiple layers:

1. **In `decrypt()` function** - Add early size check:
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    // Maximum expected: 12 (nonce) + 32 (scalar) + 16 (tag) = 60 bytes
    // Add generous buffer for future use
    const MAX_ENCRYPTED_SHARE_SIZE: usize = 256;
    
    if data.len() > MAX_ENCRYPTED_SHARE_SIZE {
        return Err(EncryptionError::OversizedCiphertext);
    }
    // ... rest of function
}
```

2. **In message handlers** - Validate before storing:
```rust
// In dkg_private_shares handler
for (_, shares) in &dkg_private_shares.shares {
    for (_, bytes) in shares {
        if bytes.len() > MAX_ENCRYPTED_SHARE_SIZE {
            return Err(Error::OversizedShare);
        }
    }
}
```

3. **In serde deserialization** - Add custom deserializer with size limits for critical `Vec<u8>` fields.

**Alternative Mitigation**: Implement message size limits at the network layer before deserialization, rejecting packets exceeding a reasonable total size (e.g., 100 KB for DkgPrivateShares).

**Testing Recommendations**: 
- Add unit tests that attempt to encrypt/decrypt oversized data and verify rejection
- Add integration tests simulating malicious signers sending oversized shares
- Test memory usage under attack scenarios

**Deployment Considerations**: This is a breaking change requiring coordinated upgrade. Add feature flag to enable gradual rollout while maintaining backward compatibility during transition.

### Proof of Concept

```rust
// Exploitation algorithm:

// 1. Malicious signer constructs oversized encrypted shares
let mut rng = OsRng;
let malicious_share = vec![0u8; 10_000_000]; // 10 MB instead of 32 bytes

// 2. "Encrypt" it (bypassing normal flow)
let malicious_encrypted = encrypt(&shared_secret, &malicious_share, &mut rng)?;

// 3. Construct DkgPrivateShares with oversized blobs
let mut oversized_shares = HashMap::new();
for key_id in 1..=10 {
    oversized_shares.insert(key_id, malicious_encrypted.clone());
}

let malicious_msg = DkgPrivateShares {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id,
    shares: vec![(party_id, oversized_shares)],
};

// 4. Sign and send
let packet = Packet {
    msg: Message::DkgPrivateShares(malicious_msg),
    sig: malicious_msg.sign(&attacker_private_key)?,
};

// 5. Honest node receives and processes:
// - Deserializes 10 * 10 MB = 100 MB into memory
// - Attempts to decrypt all blobs
// - CPU stalls, memory exhausted, DKG fails
```

**Expected Behavior**: Each encrypted share should be ~60 bytes. Legitimate `DkgPrivateShares` messages should be < 10 KB total.

**Actual Behavior**: No size validation. Messages of arbitrary size (hundreds of MB or GB) are accepted, stored, and processed until memory/CPU exhaustion occurs.

**Reproduction Steps**:
1. Set up WSTS DKG with 4 signers, 10 keys
2. Have one signer send `DkgPrivateShares` with 10 MB blobs per share
3. Monitor memory usage on honest signers - observe spike to hundreds of MB
4. Monitor CPU usage during decryption - observe 100% utilization
5. Observe DKG timeout or node crash due to resource exhaustion

### Citations

**File:** src/util.rs (L80-99)
```rust
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
}
```

**File:** src/util.rs (L102-116)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/state_machine/signer/mod.rs (L934-945)
```rust
            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
```

**File:** src/state_machine/signer/mod.rs (L1063-1076)
```rust
        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/state_machine/coordinator/fire.rs (L708-713)
```rust
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
```
