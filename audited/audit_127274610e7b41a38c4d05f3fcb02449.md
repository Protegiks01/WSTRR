### Title
Missing Identity Element Validation in DKG Aggregate Public Key Generation

### Summary
The DKG process does not validate that the computed aggregate public key is not the identity element (point at infinity) before storing and returning it via `OperationResult::Dkg`. If DKG completes with zero participating parties or through certain edge cases, the aggregate public key becomes `Point::identity()`, resulting in a completely broken threshold signature scheme where any attacker can forge valid signatures without knowledge of private keys.

### Finding Description

**Exact Code Location:** [1](#0-0) [2](#0-1) [3](#0-2) 

**Root Cause:**

Both FIRE and FROST coordinators compute the aggregate public key by folding over polynomial first coefficients with `Point::default()` as the initial value. When the fold operates on an empty collection (no participating parties), it returns `Point::default()` unchanged, which is the identity element. The code then stores this identity element as the aggregate public key without any validation. [4](#0-3) 

The codebase validates that nonces are not the identity element, demonstrating awareness of this class of vulnerability. However, this same validation is missing for the aggregate public key.

**Why Existing Mitigations Fail:**

The `check_public_shares` function validates Schnorr proofs and polynomial degrees, but does not check if individual polynomial coefficients or their sum equals the identity element: [5](#0-4) 

The timeout handling code checks `dkg_threshold` only during timeout scenarios, not in the normal completion path: [6](#0-5) [7](#0-6) 

The `set_key_and_party_polynomials` function validates consistency between provided and computed keys but accepts identity for both: [8](#0-7) 

**Configuration Vulnerability:**

The coordinator configuration constructors perform no validation on parameters: [9](#0-8) 

This allows creation of a coordinator with `num_signers=0` or empty `public_keys`, which leads to immediate DKG "completion" with zero participants.

### Impact Explanation

**Cryptographic Break:**

If the aggregate public key is the identity element, the Schnorr signature verification equation becomes trivially forgeable. The verification `s*G = R + H(R||P||m)*P` reduces to `s*G = R` when `P = Point::identity()`, since `H(...)*identity = identity`. An attacker can choose arbitrary values for `s` and `R` satisfying this simplified equation.

**Bitcoin/Taproot Impact:**

The `tweaked_public_key` function would fail when attempting to extract the x-coordinate from the identity element: [10](#0-9) [11](#0-10) 

This causes either a panic/error (denial of service) or, if handled improperly at a higher layer, could lead to funds being locked to an invalid or trivially forgeable key.

**Scope Mapping:**

This vulnerability maps to **Critical** severity under the protocol scope:
- **"Any causing the direct loss of funds"**: Bitcoin outputs locked to a taproot key derived from `Point::identity()` are immediately stealable by any party who can forge signatures
- **"Any confirmation of an invalid transaction"**: Forged signatures would be accepted as valid

**Quantified Impact:**

- 100% of funds controlled by the compromised aggregate key are at risk
- Attack requires zero cryptographic work (no key grinding, no signature forgery complexity)
- Affects all signing operations using the compromised key
- Complete loss of threshold security properties

### Likelihood Explanation

**Prerequisites:**

1. Coordinator must be initialized with `num_signers=0` OR `public_keys.signers` empty
2. OR all configured signers fail to participate in DKG (but then timeout checks may trigger depending on configuration)
3. No timeouts configured (using `Config::new` with default `None` timeouts)

**Attack Complexity:**

- **Configuration Error Path**: Accidental misconfiguration (HIGH likelihood in misconfigured deployments)
  - Administrator creates coordinator with `Config::new(0, 0, 0, key)` 
  - No validation errors occur
  - DKG immediately "succeeds" with identity key
  
- **State Corruption Path**: Edge case in production (LOW-MEDIUM likelihood)
  - Race condition or state restoration from corrupted `SavedState`
  - Empty collections passed to aggregation logic

**Detection Risk:**

The vulnerability is silent - no errors are raised. The identity element would be logged but may appear as a valid point encoding. Downstream signature operations may fail with cryptic errors, or worse, succeed with forgeable signatures.

**Economic Feasibility:**

Zero cost to exploit once the misconfiguration exists. No computational resources required beyond basic signature arithmetic.

**Estimated Probability:**

- Misconfiguration scenario: LOW in production (assumes competent setup), but HIGH impact when it occurs
- Edge case scenario: VERY LOW probability but possible in long-running systems

Overall assessment: **MEDIUM likelihood** (configuration errors do occur) with **CRITICAL impact** = **CRITICAL severity**

### Recommendation

**Primary Fix - Add Identity Validation:**

Add validation in both `dkg_end_gathered` functions immediately after computing the aggregate key:

```rust
let key = /* existing computation */;

// Validate aggregate key is not identity element
if key == Point::identity() {
    return Err(Error::InvalidAggregatePublicKey);
}

info!("Aggregate public key: {key}");
self.aggregate_public_key = Some(key);
```

Add new error variant:
```rust
#[error("Invalid aggregate public key: identity element")]
InvalidAggregatePublicKey,
```

**Secondary Fix - Configuration Validation:**

Add validation to `Config::new` and `Config::with_timeouts`:

```rust
pub fn new(...) -> Result<Self, ConfigError> {
    if num_signers == 0 {
        return Err(ConfigError::InvalidSignerCount);
    }
    if num_keys == 0 {
        return Err(ConfigError::InvalidKeyCount);
    }
    if threshold == 0 || threshold > num_keys {
        return Err(ConfigError::InvalidThreshold);
    }
    // ... rest of constructor
}
```

**Additional Validation:**

Add validation in `set_key_and_party_polynomials`:

```rust
if aggregate_key == Point::identity() {
    return Err(Error::InvalidAggregatePublicKey);
}
```

**Testing Recommendations:**

1. Add unit test attempting DKG with `num_signers=0` - should fail gracefully
2. Add test attempting to set `aggregate_public_key = Point::identity()` - should fail
3. Add integration test for empty `party_polynomials` - should fail at aggregation
4. Fuzz test configuration parameters to catch similar edge cases

**Deployment Considerations:**

- This is a breaking change requiring error handling updates
- Existing deployments should audit configurations for `num_signers=0` or empty participants
- Consider adding runtime assertions during development builds

### Proof of Concept

**Exploitation Steps:**

1. Create coordinator with zero signers:
```rust
let config = Config::new(
    0,  // num_signers = 0
    0,  // num_keys = 0  
    0,  // threshold = 0
    Scalar::random(&mut rng),
);
let mut coordinator = FireCoordinator::<v2::Aggregator>::new(config);
```

2. Initiate DKG round:
```rust
coordinator.start_dkg_round(None)?;
```

3. Process through state machine (no signers respond):
    - State transitions: `Idle -> DkgPublicDistribute -> DkgPublicGather`
    - `dkg_wait_signer_ids = (0..0).collect() = {}`  (empty set)
    - Immediately proceeds to `DkgPrivateDistribute` (line 514-516)
    - `dkg_wait_signer_ids` remains empty
    - Proceeds to `DkgEndDistribute` (line 567-569)
    - `dkg_wait_signer_ids` remains empty  
    - Proceeds to `DkgEndGather` (line 605)

4. DKG completes with identity key:
    - Line 603-807: fold over empty `dkg_end_messages`
    - Returns `Point::default()` = `Point::identity()`
    - Stored in `self.aggregate_public_key`
    - Returned as `OperationResult::Dkg(Point::identity())`

**Expected vs Actual Behavior:**

- **Expected**: Configuration validation error or DKG failure due to insufficient participants
- **Actual**: DKG "succeeds" and returns identity element as aggregate public key

**Reproduction:**

The vulnerability can be reproduced by modifying existing coordinator tests to use `num_signers=0` and observing that no error occurs during DKG completion, with the aggregate key equaling `Point::identity()`.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L605-612)
```rust
        if self.dkg_wait_signer_ids.is_empty() {
            // if there are any errors, mark signers malicious and retry
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());

                    match dkg_failure {
```

**File:** src/state_machine/coordinator/fire.rs (L779-781)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
```

**File:** src/state_machine/coordinator/fire.rs (L802-811)
```rust
        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
        self.move_to(State::Idle)
```

**File:** src/state_machine/coordinator/fire.rs (L1389-1405)
```rust
        let computed_key = party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
        if computed_key != aggregate_key {
            return Err(Error::AggregateKeyPolynomialMismatch(
                computed_key,
                aggregate_key,
            ));
        }
        let party_polynomials_len = party_polynomials.len();
        let party_polynomials = HashMap::from_iter(party_polynomials);
        if party_polynomials.len() != party_polynomials_len {
            return Err(Error::DuplicatePartyId);
        }
        self.aggregate_public_key = Some(aggregate_key);
        self.party_polynomials = party_polynomials;
        Ok(())
```

**File:** src/state_machine/coordinator/frost.rs (L434-445)
```rust
        // Calculate the aggregate public key
        let key = self
            .party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!(
            %key,
            "Aggregate public key"
        );
        self.aggregate_public_key = Some(key);
        self.move_to(State::Idle)
```

**File:** src/state_machine/mod.rs (L76-86)
```rust
/// Result of a DKG or sign operation
#[derive(Debug, Clone)]
pub enum OperationResult {
    /// DKG succeeded with the wrapped public key
    Dkg(Point),
    /// Sign succeeded with the wrapped Signature
    Sign(Signature),
    /// Sign schnorr succeeded with the wrapped SchnorrProof
    SignSchnorr(SchnorrProof),
    /// Sign taproot succeeded with the wrapped SchnorrProof
    SignTaproot(SchnorrProof),
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/coordinator/mod.rs (L178-200)
```rust
impl Config {
    /// Create a new config object with no timeouts
    pub fn new(
        num_signers: u32,
        num_keys: u32,
        threshold: u32,
        message_private_key: Scalar,
    ) -> Self {
        Config {
            num_signers,
            num_keys,
            threshold,
            dkg_threshold: num_keys,
            message_private_key,
            dkg_public_timeout: None,
            dkg_private_timeout: None,
            dkg_end_timeout: None,
            nonce_timeout: None,
            sign_timeout: None,
            public_keys: Default::default(),
            verify_packet_sigs: true,
        }
    }
```

**File:** src/compute.rs (L156-165)
```rust
pub fn tweak(public_key: &Point, merkle_root: Option<[u8; 32]>) -> Scalar {
    let mut hasher = tagged_hash("TapTweak");

    hasher.update(public_key.x().to_bytes());
    if let Some(root) = merkle_root {
        hasher.update(root);
    }

    hash_to_scalar(&mut hasher)
}
```

**File:** src/compute.rs (L177-179)
```rust
pub fn tweaked_public_key_from_tweak(public_key: &Point, tweak: Scalar) -> Point {
    Point::lift_x(&public_key.x()).unwrap() + tweak * G
}
```
