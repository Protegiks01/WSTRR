> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2)

### Citations

**File:** src/v1.rs (L246-295)
```rust
    pub fn sign_precomputed_with_tweak(
        &self,
        msg: &[u8],
        signers: &[u32],
        nonces: &[PublicNonce],
        aggregate_nonce: &Point,
        tweak: Option<Scalar>,
    ) -> SignatureShare {
        let mut r = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
        if tweak.is_some() && !aggregate_nonce.has_even_y() {
            r = -r;
        }

        // When using BIP-340 32-byte public keys, we have to invert the private key if the
        // public key is odd.  But if we're also using BIP-341 tweaked keys, we have to do
        // the same thing if the tweaked public key is odd.  In that case, only invert the
        // public key if exactly one of the internal or tweaked public keys is odd
        let mut cx_sign = Scalar::one();
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                let key = compute::tweaked_public_key_from_tweak(&self.group_key, t);
                if key.has_even_y() ^ self.group_key.has_even_y() {
                    cx_sign = -cx_sign;
                }

                key
            } else {
                if !self.group_key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                self.group_key
            }
        } else {
            self.group_key
        };

        let c = compute::challenge(&tweaked_public_key, aggregate_nonce, msg);
        let mut cx = c * &self.private_key * compute::lambda(self.id, signers);

        cx = cx_sign * cx;

        let z = r + cx;

        SignatureShare {
            id: self.id,
            z_i: z,
            key_ids: vec![self.id],
        }
    }
}
```

**File:** src/v1.rs (L474-490)
```rust
    fn sign_schnorr(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        _key_ids: &[u32],
    ) -> Result<SchnorrProof, AggregatorError> {
        let tweak = Scalar::from(0);
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, Some(tweak))?;
        let proof = SchnorrProof::new(&sig);

        if proof.verify(&key.x(), msg) {
            Ok(proof)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, Some(tweak)))
        }
    }
```

**File:** src/taproot.rs (L30-44)
```rust
    /// Verify a BIP-340 schnorr proof
    #[allow(non_snake_case)]
    pub fn verify(&self, public_key: &field::Element, msg: &[u8]) -> bool {
        let Ok(Y) = Point::lift_x(public_key) else {
            return false;
        };
        let Ok(R) = Point::lift_x(&self.r) else {
            return false;
        };
        let c = compute::challenge(&Y, &R, msg);
        let Rp = self.s * G - c * Y;

        Rp.has_even_y() && Rp.x() == self.r
    }

```
