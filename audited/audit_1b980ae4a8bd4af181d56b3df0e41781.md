Audit Report

## Title
Unvalidated DKG Failure Reports Enable DoS and False Accusations Against Honest Signers

## Summary
The WSTS coordinator fails to validate `MissingPublicShares` and `MissingPrivateShares` failure reports during DKG finalization. A malicious signer can falsely claim they did not receive shares from honest signers, causing DKG to fail indefinitely without marking anyone as malicious. This enables permanent denial-of-service attacks against the DKG protocol.

## Finding Description

During DKG finalization, signers send `DkgEnd` messages containing success or failure status. The `DkgFailure` enum defines six failure types that signers can report: [1](#0-0) 

When the coordinator's `gather_dkg_end` function processes these reports, it performs extensive cryptographic validation for `BadPublicShares` and `BadPrivateShares`:

**BadPublicShares Validation** (FIRE coordinator): [2](#0-1) 

The coordinator checks if the accused signer actually sent shares (line 625), validates them cryptographically using `check_public_shares` (lines 633-640), and marks either the false reporter or the actual malicious sender based on validation results.

**BadPrivateShares Validation** (FIRE coordinator): [3](#0-2) 

This performs DH tuple proof verification and decrypts shares to validate the claim.

**However, for MissingPublicShares and MissingPrivateShares, there is NO validation**: [4](#0-3) 

The empty blocks contain only comments "maybe mark signer malicious?" but take no action.

The FROST coordinator has even less validation - it simply collects all failure reports without any validation whatsoever: [5](#0-4) 

**Root Cause**: The coordinator receives and stores all public and private shares: [6](#0-5) [7](#0-6) 

When a signer reports missing shares from another signer, the coordinator possesses ground truth: if it received shares from signer A, then A did broadcast shares. If signer B claims not to have received them, B is either experiencing network issues or is lying. The coordinator can validate this by checking its local storage, but it doesn't.

**Attack Execution**: A malicious signer creates false reports by checking local storage in `dkg_ended()`: [8](#0-7) 

The signer checks `self.dkg_public_shares` and `self.dkg_private_shares`. A malicious signer can receive shares from honest signers but intentionally not store them (or delete them), causing these checks to fail and generating false `MissingPublicShares` or `MissingPrivateShares` reports.

**Consequences**: When any failure is reported, DKG fails: [9](#0-8) 

The error returns with `malicious_signers` set to `Default::default()` (empty), so no one is marked malicious. The `malicious_dkg_signer_ids` field is populated at line 776, but searching the codebase reveals it is never read or used to exclude signers from future DKG rounds.

The DkgError returned to the application is: [10](#0-9) 

## Impact Explanation

This vulnerability enables a **Low severity denial-of-service attack** as defined by the scope: "Any remotely-exploitable denial of service in a node."

**Specific Harm**:
1. **DKG Cannot Complete**: The attack prevents generation of the aggregate public key required for threshold signatures
2. **False Accusations**: Honest signers are listed in `reported_failures`, potentially damaging their reputation
3. **No Attribution**: The `malicious_signers` field remains empty, providing no way to identify the attacker
4. **Permanent DoS**: The attack can be repeated on every DKG retry since no exclusion mechanism exists

**Quantified Impact**: With N total signers and 1 malicious signer, the attacker can prevent DKG completion indefinitely. Even with threshold T < N, the protocol cannot proceed because DKG must complete successfully before signing can begin.

The vulnerability does NOT enable key compromise, fund theft, or chain splits.

## Likelihood Explanation

**Likelihood: Very High (100% success rate)**

**Required Attacker Capabilities**:
- Must be a participating signer in the DKG protocol (within the threat model of up to threshold-1 malicious signers)
- No special cryptographic knowledge required
- No additional network access or privileges needed

**Attack Complexity: Trivial**
1. Attacker receives `DkgPublicShares` or `DkgPrivateShares` from honest signers via normal protocol message flow
2. Attacker intentionally does not store the received shares locally, or deletes them after initial storage
3. When coordinator sends `DkgEndBegin`, attacker's `dkg_ended()` function checks local storage
4. Local check fails (shares not present in `self.dkg_public_shares` or `self.dkg_private_shares`)
5. Attacker sends `DkgEnd` with false `MissingPublicShares` or `MissingPrivateShares` report
6. Coordinator's `gather_dkg_end` performs no validation (empty blocks for these failure types)
7. DKG fails with empty `malicious_signers` set
8. Attacker repeats on every DKG retry

**Detection Risk**: Low. The malicious signer's reports appear identical to legitimate complaints about network issues. Without validation logic, operators cannot distinguish false accusations from genuine problems.

## Recommendation

Implement validation logic for `MissingPublicShares` and `MissingPrivateShares` in the coordinator's `gather_dkg_end` function:

```rust
DkgFailure::MissingPublicShares(missing_signers) => {
    for missing_signer_id in missing_signers {
        // Check if coordinator received shares from the accused signer
        if self.dkg_public_shares.contains_key(missing_signer_id) {
            // Coordinator has the shares, so accused signer DID broadcast
            // Reporter is either experiencing network issues or is malicious
            warn!("Signer {signer_id} reported MissingPublicShares from {missing_signer_id} but coordinator received them, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        } else {
            // Coordinator also doesn't have the shares
            // This is a legitimate complaint about missing shares
            warn!("Signer {missing_signer_id} failed to broadcast public shares");
            malicious_signers.insert(*missing_signer_id);
        }
    }
}

DkgFailure::MissingPrivateShares(missing_signers) => {
    for missing_signer_id in missing_signers {
        // Check if coordinator received shares from the accused signer
        if self.dkg_private_shares.contains_key(missing_signer_id) {
            warn!("Signer {signer_id} reported MissingPrivateShares from {missing_signer_id} but coordinator received them, mark {signer_id} as malicious");
            malicious_signers.insert(*signer_id);
        } else {
            warn!("Signer {missing_signer_id} failed to broadcast private shares");
            malicious_signers.insert(*missing_signer_id);
        }
    }
}
```

Additionally, use `malicious_dkg_signer_ids` to exclude identified malicious signers from future DKG rounds.

## Proof of Concept

```rust
#[test]
fn test_malicious_missing_shares_report() {
    // Setup: Create coordinator and 3 signers with threshold 2
    let mut rng = create_rng();
    let config = setup_coordinator_config(3, 2);
    let mut coordinator = Coordinator::<Aggregator>::new(config);
    
    // All signers send valid DkgPublicShares
    let shares_0 = create_valid_public_shares(0, &mut rng);
    let shares_1 = create_valid_public_shares(1, &mut rng);
    let shares_2 = create_valid_public_shares(2, &mut rng);
    
    coordinator.process_message(&shares_0).unwrap();
    coordinator.process_message(&shares_1).unwrap();
    coordinator.process_message(&shares_2).unwrap();
    
    // Coordinator transitions to DkgPrivateDistribute
    // All signers send valid DkgPrivateShares
    // ... (similar for private shares)
    
    // Malicious signer 2 falsely reports missing shares from honest signer 0
    let malicious_dkg_end = DkgEnd {
        dkg_id: 0,
        signer_id: 2,
        status: DkgStatus::Failure(
            DkgFailure::MissingPublicShares(hashset![0])
        ),
    };
    
    let result = coordinator.process_message(&malicious_dkg_end);
    
    // Vulnerability: DKG fails but malicious_signers is empty
    match result {
        Ok((_, Some(OperationResult::DkgError(DkgError::DkgEndFailure {
            reported_failures,
            malicious_signers,
        })))) => {
            // False report was accepted
            assert!(reported_failures.contains_key(&2));
            // BUG: Malicious signer 2 is NOT marked as malicious
            assert!(malicious_signers.is_empty()); // This proves the vulnerability
            // Even though coordinator has shares from signer 0!
        }
        _ => panic!("Expected DkgEndFailure"),
    }
}
```

### Citations

**File:** src/net.rs (L59-72)
```rust
pub enum DkgFailure {
    /// DKG threshold not met
    Threshold,
    /// Signer was in the wrong internal state to complete DKG
    BadState,
    /// DKG public shares were missing from these signer_ids
    MissingPublicShares(HashSet<u32>),
    /// DKG public shares were bad from these signer_ids
    BadPublicShares(HashSet<u32>),
    /// DKG private shares were missing from these signer_ids
    MissingPrivateShares(HashSet<u32>),
    /// DKG private shares were bad from these signer_ids
    BadPrivateShares(HashMap<u32, BadPrivateShare>),
}
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```

**File:** src/state_machine/coordinator/frost.rs (L400-417)
```rust
        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
```

**File:** src/state_machine/signer/mod.rs (L551-582)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/mod.rs (L48-55)
```rust
    /// DKG end failure
    #[error("DKG end failure")]
    DkgEndFailure {
        /// failures reported by signers during DkgEnd
        reported_failures: HashMap<u32, DkgFailure>,
        /// signers who were discovered to be malicious during this DKG round
        malicious_signers: HashSet<u32>,
    },
```
