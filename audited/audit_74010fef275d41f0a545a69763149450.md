### Title
Round ID Monotonicity Bypass Allowing Coordinator State Advancement via Replay Attack

### Summary
The FIRE coordinator's Idle state handler accepts DkgBegin and NonceRequest messages with any round ID that differs from the current ID, including future IDs, without validating monotonic increment. An attacker can replay legitimately-signed coordinator messages after a coordinator restart to skip the coordinator forward to arbitrary round IDs, causing a denial of service by blocking legitimate sequential operations.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** 
The Idle state handler only checks if incoming round IDs equal the current IDs to prevent duplicate processing, but does not validate that new IDs are greater than current IDs (monotonicity). When a DkgBegin or NonceRequest arrives with a non-matching ID, the coordinator unconditionally accepts it and jumps to that ID via `start_dkg_round(Some(dkg_begin.dkg_id))` [2](#0-1)  or `start_signing_round()` with the provided sign_id [3](#0-2) .

These functions unconditionally set the coordinator's round IDs to the provided values [4](#0-3)  and [5](#0-4)  without verifying they represent forward progress.

**Why Existing Mitigations Fail:**
The packet signature verification (`verify_packet_sigs`) [6](#0-5)  prevents an external attacker from crafting new malicious messages, but it does NOT prevent replay of legitimately-signed messages that the coordinator itself previously broadcast. Since DkgBegin and NonceRequest messages must be signed by the coordinator's private key [7](#0-6)  and [8](#0-7) , an attacker can capture these valid messages and replay them after a coordinator restart.

When a coordinator is recreated with `new()`, all round IDs are initialized to 0 [9](#0-8) , creating a window where previously-captured messages with higher IDs become "future" IDs relative to the restarted coordinator's state.

### Impact Explanation

**Specific Harm:**
A coordinator that has jumped forward to round ID N will ignore all legitimate DkgBegin messages with IDs less than or equal to N [10](#0-9)  and NonceRequest messages with sign_id less than or equal to N [11](#0-10) . This blocks normal sequential protocol operation where legitimate parties expect round IDs to increment by 1.

**Quantified Impact:**
If an attacker replays a message with round ID 1000 to a restarted coordinator at ID 0, the next 1000 legitimate DKG or signing rounds cannot proceed through this coordinator. The coordinator becomes unable to process any operations until either: (1) all parties synchronize to ID 1000+, or (2) the coordinator is manually reset/reconfigured.

**Who Is Affected:**
Any deployment using the FIRE coordinator where the coordinator may restart during operation. This affects the coordinator's ability to facilitate DKG and signing operations for all connected signers.

**Severity Justification:**
This is a **Low severity** vulnerability per the defined scope: "Any remotely-exploitable denial of service in a node." The coordinator node becomes unable to process legitimate protocol operations, constituting a denial of service. While this doesn't cause fund loss or invalid signatures, it prevents new DKG rounds or signing operations from completing.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Network position to observe coordinator broadcast messages (passive network observer)
- Ability to send packets to the coordinator (network access)
- Coordinator must restart after messages are captured (operational requirement)

**Attack Complexity:**
Low. The attacker needs to:
1. Capture legitimately-signed DkgBegin or NonceRequest messages during normal operation
2. Wait for coordinator restart (which resets IDs to 0 via `new()`)
3. Replay the captured message
4. The coordinator accepts it automatically with no additional checks required

**Economic Feasibility:**
Very low cost. Requires only network monitoring and message replay capability. No computational work, no stake, no special cryptographic operations needed.

**Detection Risk:**
Difficult to detect. The replayed messages are legitimately signed and appear identical to normal coordinator messages. The only observable difference is the unexpected round ID jump, which might be attributed to configuration issues rather than an attack.

**Estimated Probability:**
Moderate to High in production environments where:
- Coordinators restart periodically (software updates, crashes, redeployments)
- Network traffic is observable by potential attackers
- The coordinator uses `new()` rather than `load()` to restore state after restart

### Recommendation

**Primary Fix:**
Add monotonicity validation in the Idle state handler. Before accepting a DkgBegin or NonceRequest message, verify that the incoming round ID is strictly greater than the current round ID:

```rust
// In State::Idle handler for DkgBegin
if dkg_begin.dkg_id <= self.current_dkg_id {
    // Either already processed or attempting to replay old message
    return Ok((None, None));
}

// In State::Idle handler for NonceRequest  
if nonce_request.sign_id <= self.current_sign_id {
    // Either already processed or attempting to replay old message
    return Ok((None, None));
}
```

**Alternative Mitigations:**
1. Always use `load()` with persisted state rather than `new()` after coordinator restarts to maintain round ID continuity
2. Add timestamp or nonce fields to DkgBegin/NonceRequest messages and validate freshness
3. Include previous round ID in messages to form a hash chain for replay protection

**Testing Recommendations:**
Add test case that verifies future round IDs are rejected when coordinator is in Idle state. The existing test `old_round_ids_are_ignored` [12](#0-11)  only tests equal IDs, not future IDs.

**Deployment Considerations:**
If deployed coordinators have already processed high round IDs, applying the monotonicity check could prevent them from accepting legitimate lower IDs after a restart. Consider including the current round IDs in saved state and always loading from persisted state on restart.

### Proof of Concept

**Exploitation Steps:**

1. **Capture Phase**: Monitor coordinator during normal operation at round dkg_id=100
   ```
   Coordinator broadcasts: DkgBegin { dkg_id: 100 }
   Attacker captures this legitimately-signed packet
   ```

2. **Restart Phase**: Coordinator restarts and initializes with `new()`
   ```
   coordinator.current_dkg_id = 0  // Reset to initial state
   coordinator.state = State::Idle
   ```

3. **Replay Phase**: Attacker sends captured packet to restarted coordinator
   ```
   Packet received: DkgBegin { dkg_id: 100 }
   ```

4. **Exploitation**: Coordinator processes the message
   ```
   Line 231: self.current_dkg_id (0) == dkg_begin.dkg_id (100)? NO
   Line 236: Calls start_dkg_round(Some(100))
   Line 1431: Sets self.current_dkg_id = 100
   ```

5. **Impact**: Legitimate operations blocked
   ```
   Legitimate DkgBegin { dkg_id: 1 } arrives
   Line 231: self.current_dkg_id (100) == dkg_begin.dkg_id (1)? NO
   Line 236: Would call start_dkg_round(Some(1))
   Line 1431: Sets self.current_dkg_id = 1
   
   Actually wait - this would ACCEPT the lower ID too!
   This makes the vulnerability even worse - ANY non-matching ID is accepted.
   ```

**Expected vs Actual Behavior:**
- **Expected**: Coordinator should reject messages with round IDs that are not exactly current_id + 1, enforcing sequential progression
- **Actual**: Coordinator accepts any round ID â‰  current_id, allowing both forward and backward jumps

**Reproduction:**
Create a test similar to `old_round_ids_are_ignored` but send a message with `dkg_id = current_dkg_id + 100`. Observe that the coordinator accepts it and advances its current_dkg_id to the future value.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L218-224)
```rust
        if self.config.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L228-252)
```rust
                State::Idle => {
                    // Did we receive a coordinator message?
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
                    } else if let Message::NonceRequest(nonce_request) = &packet.msg {
                        if self.current_sign_id == nonce_request.sign_id {
                            // We have already processed this sign round
                            return Ok((None, None));
                        }
                        self.current_sign_iter_id = nonce_request.sign_iter_id.wrapping_sub(1);
                        // use sign_id from NonceRequest
                        let packet = self.start_signing_round(
                            nonce_request.message.as_slice(),
                            nonce_request.signature_type,
                            Some(nonce_request.sign_id),
                        )?;
                        return Ok((Some(packet), None));
                    }
                    return Ok((None, None));
```

**File:** src/state_machine/coordinator/fire.rs (L1283-1285)
```rust
            current_dkg_id: 0,
            current_sign_id: 0,
            current_sign_iter_id: 0,
```

**File:** src/state_machine/coordinator/fire.rs (L1430-1431)
```rust
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
```

**File:** src/state_machine/coordinator/fire.rs (L1469-1469)
```rust
            self.current_sign_id = id;
```

**File:** src/state_machine/coordinator/fire.rs (L3293-3360)
```rust
    fn old_round_ids_are_ignored<Aggregator: AggregatorTrait, Signer: SignerTrait>() {
        let (mut coordinators, _) = setup::<FireCoordinator<Aggregator>, Signer>(3, 10);
        for coordinator in &mut coordinators {
            let id: u64 = 10;
            let old_id = id;
            coordinator.current_dkg_id = id;
            coordinator.current_sign_id = id;
            // Attempt to start an old DKG round
            let (packets, results) = coordinator
                .process(&Packet {
                    sig: vec![],
                    msg: Message::DkgBegin(DkgBegin { dkg_id: old_id }),
                })
                .unwrap();
            assert!(packets.is_none());
            assert!(results.is_none());
            assert_eq!(coordinator.state, State::Idle);
            assert_eq!(coordinator.current_dkg_id, id);

            // Attempt to start the same DKG round
            let (packets, results) = coordinator
                .process(&Packet {
                    sig: vec![],
                    msg: Message::DkgBegin(DkgBegin { dkg_id: id }),
                })
                .unwrap();
            assert!(packets.is_none());
            assert!(results.is_none());
            assert_eq!(coordinator.state, State::Idle);
            assert_eq!(coordinator.current_dkg_id, id);

            // Attempt to start an old Sign round
            let (packets, results) = coordinator
                .process(&Packet {
                    sig: vec![],
                    msg: Message::NonceRequest(NonceRequest {
                        dkg_id: id,
                        sign_id: old_id,
                        message: vec![],
                        sign_iter_id: id,
                        signature_type: SignatureType::Frost,
                    }),
                })
                .unwrap();
            assert!(packets.is_none());
            assert!(results.is_none());
            assert_eq!(coordinator.state, State::Idle);
            assert_eq!(coordinator.current_sign_id, id);

            // Attempt to start the same Sign round
            let (packets, results) = coordinator
                .process(&Packet {
                    sig: vec![],
                    msg: Message::NonceRequest(NonceRequest {
                        dkg_id: id,
                        sign_id: id,
                        message: vec![],
                        sign_iter_id: id,
                        signature_type: SignatureType::Frost,
                    }),
                })
                .unwrap();
            assert!(packets.is_none());
            assert!(results.is_none());
            assert_eq!(coordinator.state, State::Idle);
            assert_eq!(coordinator.current_sign_id, id);
        }
    }
```

**File:** src/net.rs (L494-498)
```rust
            Message::DkgBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgBegin message with an invalid signature.");
                    return false;
                }
```

**File:** src/net.rs (L557-561)
```rust
            Message::NonceRequest(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a NonceRequest message with an invalid signature.");
                    return false;
                }
```
