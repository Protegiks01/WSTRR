# Audit Report

## Title
Nonce Timeout Handler Fails to Mark Non-Responsive Signers as Malicious

## Summary
The FIRE coordinator's nonce timeout handler does not mark non-responsive signers as malicious, unlike the signature share timeout handler. This asymmetry allows Byzantine signers to cause indefinite signing failures by refusing to send nonces, as they remain eligible for subsequent retry attempts.

## Finding Description

The vulnerability exists in the `process_timeout()` method of the FIRE coordinator. When the nonce gathering phase times out, the handler collects signers who successfully responded and returns them in a `NonceTimeout` error, but critically fails to mark non-responsive signers as malicious. [1](#0-0) 

During nonce gathering, when a signer responds successfully, their ID is added to `sign_wait_signer_ids`: [2](#0-1) 

The coordinator actively excludes known malicious signers by rejecting their nonce responses: [3](#0-2) 

However, this exclusion mechanism is only effective if non-responsive signers are actually marked as malicious. The nonce timeout handler fails to do this.

In stark contrast, the signature share timeout handler explicitly marks all non-responsive signers (those remaining in `sign_wait_signer_ids` after timeout) as malicious, checks if sufficient non-malicious signers remain, and either retries or returns an error: [4](#0-3) 

This inconsistency breaks the protocol invariant that malicious or unresponsive signers should be systematically excluded from future signing attempts.

**Attack Scenario:**

1. Configuration: 10 signers with 1 key each, threshold = 7
2. Byzantine attacker controls 4 signers
3. Coordinator broadcasts `NonceRequest` to all signers
4. 6 honest signers respond, 4 Byzantine signers refuse
5. Only 6 responses < 7 threshold, nonce timeout fires
6. Byzantine signers NOT marked as malicious
7. Coordinator or application layer retries signing
8. `request_nonces()` clears state and broadcasts to all signers again (including the 4 non-responders)
9. Byzantine signers refuse again
10. Timeout fires again, loop repeats indefinitely [5](#0-4) 

## Impact Explanation

This vulnerability enables a denial-of-service attack against the signing protocol. Byzantine signers can cause persistent signing failures by simply refusing to send nonces. Since they are never marked as malicious, they remain included in every retry attempt, preventing the protocol from making progress.

The impact severity maps to **Low** under the scope definition: "Any remotely-exploitable denial of service in a node." If this affects consensus-critical signing operations (such as Stacks block signing), it could escalate to **Medium**: "Any transient consensus failures."

The asymmetric handling of timeouts creates an exploitable weakness where nonce gathering is less robust than signature share gathering, violating the principle of consistent malicious signer detection throughout the protocol state machine.

## Likelihood Explanation

**Likelihood: High**

The attack requires only:
- Control of legitimate signing parties (within protocol threat model)
- Ability to passively ignore `NonceRequest` messages
- No cryptographic operations or special capabilities

**Attack Complexity:** Trivial. The attacker simply participates normally in DKG, then refuses to respond to nonce requests during signing.

**Economic Cost:** Zero. The attacker expends no computational resources.

**Detection Difficulty:** High. Coordinators cannot distinguish between genuine network failures, crashed signers, or malicious non-response. Without marking non-responders as malicious, there is no mechanism to exclude them from future attempts.

**Success Probability:** Very high (>90%). The attack is deterministicâ€”if an attacker controls enough signers to prevent the threshold from being met and refuses to send nonces, signing will fail indefinitely until manual intervention occurs.

## Recommendation

The nonce timeout handler should be made consistent with the signature share timeout handler. Specifically:

1. When nonce timeout fires, calculate which signers failed to respond (all configured signers minus responders minus already-known malicious signers)
2. Mark these non-responsive signers as malicious by adding them to `self.malicious_signer_ids`
3. Check if sufficient non-malicious signers remain to meet the threshold
4. If yes, automatically retry by transitioning to `NonceRequest` state
5. If no, return `InsufficientSigners` error

Example fix (pseudo-code for the nonce timeout handler):

```rust
State::NonceGather(signature_type) => {
    if let Some(start) = self.nonce_start {
        if let Some(timeout) = self.config.nonce_timeout {
            if now.duration_since(start) > timeout {
                warn!("Timeout gathering nonces for signing round {} iteration {}", 
                      self.current_sign_id, self.current_sign_iter_id);
                
                // Get all signers who should have responded
                let all_signer_ids: HashSet<u32> = self.config.public_keys.signers.keys().copied().collect();
                let responders = self.message_nonces
                    .get(&self.message)
                    .ok_or(Error::MissingMessageNonceInfo)?
                    .sign_wait_signer_ids.clone();
                
                // Calculate non-responders (excluding already-known malicious)
                let non_responders: HashSet<u32> = all_signer_ids
                    .difference(&responders)
                    .filter(|id| !self.malicious_signer_ids.contains(id))
                    .copied()
                    .collect();
                
                // Mark non-responders as malicious
                for signer_id in &non_responders {
                    warn!("Mark signer {signer_id} as malicious due to nonce timeout");
                    self.malicious_signer_ids.insert(*signer_id);
                }
                
                // Check if we have enough non-malicious signers
                let num_malicious_keys = self.compute_num_key_ids(self.malicious_signer_ids.iter())?;
                if self.config.num_keys - num_malicious_keys < self.config.threshold {
                    error!("Insufficient non-malicious signers, unable to continue");
                    let mal = self.malicious_signer_ids.iter().copied().collect();
                    return Ok((
                        None,
                        Some(OperationResult::SignError(SignError::InsufficientSigners(mal))),
                    ));
                }
                
                // Retry with remaining signers
                self.move_to(State::NonceRequest(signature_type))?;
                let packet = self.request_nonces(signature_type)?;
                return Ok((Some(packet), None));
            }
        }
    }
}
```

## Proof of Concept

The following test demonstrates the vulnerability by showing that after a nonce timeout, non-responsive signers are not marked as malicious and would be expected to participate in retry attempts:

```rust
#[test]
fn test_nonce_timeout_does_not_mark_malicious() {
    use std::time::Duration;
    
    let num_signers = 10;
    let keys_per_signer = 1;
    let (mut coordinators, mut signers) = setup_with_timeouts::<FireCoordinator<v2::Aggregator>, v2::Signer>(
        num_signers,
        keys_per_signer,
        None,
        None,
        None,
        Some(Duration::from_millis(100)), // nonce timeout
        Some(Duration::from_millis(100)), // sign timeout
    );
    
    // Complete DKG first
    let dkg_begin = coordinators[0].start_dkg_round(None).unwrap();
    feedback_messages(&mut coordinators, &mut signers, &[dkg_begin]);
    
    // Start signing round
    let msg = "test message".as_bytes();
    let nonce_request = coordinators[0].start_signing_round(msg, SignatureType::Frost, None).unwrap();
    
    // Only respond with 6 signers (threshold is 7)
    let mut limited_signers = signers.clone();
    limited_signers.truncate(6);
    feedback_messages(&mut coordinators, &mut limited_signers, &[nonce_request]);
    
    // Wait for timeout
    std::thread::sleep(Duration::from_millis(150));
    let (_, result) = coordinators[0].process_timeout().unwrap();
    
    // Verify timeout occurred
    assert!(matches!(result, Some(OperationResult::SignError(SignError::NonceTimeout(..)))));
    
    // VULNERABILITY: Non-responsive signers (7-9) are NOT in malicious_signer_ids
    assert_eq!(coordinators[0].malicious_signer_ids.len(), 0);
    
    // This means on retry, the same non-responsive signers would be expected to participate
    // causing indefinite signing failures
}
```

This test verifies that after a nonce timeout with insufficient responses, the coordinator's `malicious_signer_ids` set remains empty, confirming that non-responsive signers are not marked as malicious and would be included in subsequent retry attempts.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L149-172)
```rust
            State::NonceGather(_signature_type) => {
                if let Some(start) = self.nonce_start {
                    if let Some(timeout) = self.config.nonce_timeout {
                        if now.duration_since(start) > timeout {
                            error!("Timeout gathering nonces for signing round {} iteration {}, unable to continue", self.current_sign_id, self.current_sign_iter_id);
                            let recv = self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                                .iter()
                                .copied()
                                .collect();
                            let mal = self.malicious_signer_ids.iter().copied().collect();
                            return Ok((
                                None,
                                Some(OperationResult::SignError(SignError::NonceTimeout(
                                    recv, mal,
                                ))),
                            ));
                        }
                    }
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L173-208)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
                        }
                    }
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L814-839)
```rust
    fn request_nonces(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.message_nonces.clear();
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
        info!(
            sign_id = %self.current_sign_id,
            sign_iter_id = %self.current_sign_iter_id,
            "Requesting Nonces"
        );
        let nonce_request = NonceRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            message: self.message.clone(),
            signature_type,
        };
        let nonce_request_msg = Packet {
            sig: nonce_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign NonceRequest"),
            msg: Message::NonceRequest(nonce_request),
        };
        self.move_to(State::NonceGather(signature_type))?;
        self.nonce_start = Some(Instant::now());

        Ok(nonce_request_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L940-942)
```rust
            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```
