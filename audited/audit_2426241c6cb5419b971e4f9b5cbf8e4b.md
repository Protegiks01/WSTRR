### Title
Signature Type Mismatch Between NonceRequest and SignatureShareRequest Causes Signature Verification Failures

### Summary
Signers do not validate that the `signature_type` in `SignatureShareRequest` matches the `signature_type` from the original `NonceRequest`. This allows a malicious or buggy coordinator to send mismatched signature types, causing signers to compute signature shares with an incorrect challenge value, resulting in aggregated signatures that fail verification and denial of service.

### Finding Description

The vulnerability exists in the signer's message processing logic where nonces are generated in response to `NonceRequest` but the signature type is not stored or validated when processing the subsequent `SignatureShareRequest`.

**Code Locations:**

1. **NonceRequest processing** [1](#0-0) 
   - Signer receives `NonceRequest` containing `signature_type` field
   - Generates nonces via `gen_nonces()` but does NOT store the `signature_type`
   - Returns `NonceResponse` which does NOT include `signature_type`

2. **SignatureShareRequest processing** [2](#0-1) 
   - Signer receives `SignatureShareRequest` with potentially DIFFERENT `signature_type`
   - Uses the signature type to dispatch to `sign_taproot()`, `sign_schnorr()`, or `sign()` (lines 808-818)
   - No validation that this signature type matches the original `NonceRequest`

3. **Signature type definitions** [3](#0-2) 
   - `NonceRequest` includes `signature_type` field
   - `NonceResponse` does NOT include `signature_type` field [4](#0-3) 

4. **Challenge computation differs by signature type** [5](#0-4) 
   - Line 238-254: Different `tweaked_public_key` computed based on tweak parameter
   - Line 256: Challenge computed as `challenge(&tweaked_public_key, &R, msg)`
   - FROST uses `group_key`, Taproot uses `tweaked_public_key`, causing different challenges

5. **Three different signing methods** [6](#0-5) 
   - `sign()`: calls `sign_with_tweak()` with `None` (FROST)
   - `sign_schnorr()`: calls `sign_with_tweak()` with `Some(Scalar::from(0))`
   - `sign_taproot()`: calls `sign_with_tweak()` with computed taproot tweak

6. **Signer state does not track signature type** [7](#0-6) 
   - `SavedState` struct has no `signature_type` field
   - Cannot validate consistency between nonce request and signature share request

**Root Cause:**
The protocol design assumes signers will use nonces generated for one signature type with the same signature type during signature share computation. However, there is no enforcement mechanism. The `NonceResponse` message does not carry the signature type, and signers do not cache it, making validation impossible.

**Why Existing Mitigations Fail:**
While the coordinator state machine correctly tracks signature type through states [8](#0-7) , this only ensures a correctly-implemented coordinator behaves properly. A malicious coordinator can bypass its own state machine and send arbitrary messages. Signers have no defense against this.

### Impact Explanation

**Specific Harm:**
When signature types are mismatched, the challenge value used in signature share computation will differ from what the verifier expects. The Schnorr signature verification equation `R == z * G - c * PublicKey` will fail because `c` was computed with a different public key [9](#0-8) .

**Quantified Impact:**
- All signing rounds where the coordinator sends mismatched signature types will produce invalid signatures
- 100% failure rate for affected signing attempts
- Complete denial of service for threshold signing functionality
- No signatures can be successfully generated while attack is active

**Who Is Affected:**
- All signers participating in the threshold signature protocol
- Any application relying on WSTS for threshold signatures
- Downstream systems (e.g., Stacks blockchain) waiting for signatures

**Severity Justification:**
This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." A malicious coordinator can prevent successful signature generation, but cannot:
- Forge signatures
- Steal private keys
- Cause consensus failures (signatures simply fail to be created)
- Accept invalid signatures (only prevents valid signature creation)

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must control or compromise the coordinator
- Must have ability to modify `SignatureShareRequest` messages before sending to signers
- No cryptographic breaks required

**Attack Complexity:**
Simple. The attacker merely needs to:
1. Receive legitimate `NonceResponse` messages from signers
2. Send `SignatureShareRequest` with a different `signature_type` than the original `NonceRequest`
3. Example: Send `NonceRequest` with `SignatureType::Frost`, then send `SignatureShareRequest` with `SignatureType::Taproot(Some([0u8; 32]))`

**Economic Feasibility:**
- No computational cost beyond normal coordinator operation
- No need to control multiple nodes
- Single coordinator compromise sufficient

**Detection Risk:**
- Attack is immediately detectable: signatures fail verification
- However, could be disguised as implementation bugs
- Difficult to prove malicious intent vs. software defect

**Estimated Probability:**
- **Malicious coordinator scenario**: High probability if coordinator is compromised, as attack is trivial
- **Accidental scenario**: Low to medium probability due to potential implementation bugs in coordinator software
- **Overall**: Medium likelihood, weighted by coordinator trust assumptions in deployment

### Recommendation

**Primary Fix:**
Add signature type tracking and validation to the signer state machine:

1. **Store signature type in signer state** - Add `current_signature_type: Option<SignatureType>` field to `SavedState` and `Signer` structs
   
2. **Cache signature type during NonceRequest** - In `nonce_request()` method, store `nonce_request.signature_type`

3. **Validate signature type in SignatureShareRequest** - In `sign_share_request()` method, add validation:
   ```rust
   if let Some(expected_type) = self.current_signature_type {
       if sign_request.signature_type != expected_type {
           warn!("signature_type mismatch: expected {:?}, got {:?}", 
                 expected_type, sign_request.signature_type);
           return Err(Error::SignatureTypeMismatch);
       }
   }
   ```

4. **Include signature type in NonceResponse** - Add `signature_type: SignatureType` field to `NonceResponse` struct to make the protocol more auditable

**Alternative Mitigation:**
If storing state is undesirable, include a cryptographic commitment to the signature type in the nonce generation:
- Hash the signature type with the nonce seed
- Include this commitment in `NonceResponse`
- Validate commitment matches when processing `SignatureShareRequest`

**Testing Recommendations:**
1. Add integration test where coordinator sends mismatched signature types
2. Verify signers reject with appropriate error
3. Test all combinations: Frost↔Schnorr, Frost↔Taproot, Schnorr↔Taproot
4. Test with and without merkle_root variations in Taproot

**Deployment Considerations:**
- This is a protocol-breaking change requiring coordinated upgrade
- Backward compatibility: Old signers won't validate, so phased rollout needed
- Update message serialization version to distinguish new protocol

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup Phase:**
   - Coordinator completes DKG with N signers
   - Threshold T signers needed for valid signature
   - Group public key `PK_group` established

2. **Attack Execution:**
   ```
   Step 1: Coordinator sends NonceRequest
   - signature_type: SignatureType::Frost
   - message: [0x01, 0x02, 0x03, ...]
   - dkg_id: 1
   - sign_id: 1
   
   Step 2: Signers generate nonces
   - Each signer generates nonce (d, e) and public nonce (D, E)
   - Nonce generation is signature-type agnostic
   - Signers respond with NonceResponse containing (D, E)
   
   Step 3: Coordinator sends malicious SignatureShareRequest
   - signature_type: SignatureType::Taproot(Some([0xAB; 32]))  // DIFFERENT!
   - nonce_responses: [collected NonceResponse messages]
   - message: [same message as Step 1]
   - dkg_id: 1
   - sign_id: 1
   
   Step 4: Signers compute signature shares
   - Compute binding: ρ = binding(party_id, nonces, msg)  // Same for all types
   - Compute tweaked key: PK_tweaked = PK_group + tweak * G  // DIFFERENT from FROST
   - Compute challenge: c = challenge(PK_tweaked, R, msg)  // WRONG challenge value
   - Compute share: z_i = r_i + c * s_i * λ_i
   - Return SignatureShare(z_i)
   
   Step 5: Coordinator aggregates
   - Aggregate z = Σ z_i
   - Create signature (R, z)
   
   Step 6: Verification fails
   - Verifier computes: c_verify = challenge(PK_frost, R, msg)  // Different PK!
   - Check: R ?= z * G - c_verify * PK_frost
   - Result: FAIL (because c_signer ≠ c_verify)
   ```

**Expected vs Actual Behavior:**
- **Expected**: Signers should reject `SignatureShareRequest` with mismatched signature type
- **Actual**: Signers accept the request and produce invalid signature shares, resulting in failed aggregation

**Reproduction Steps:**
1. Run WSTS with coordinator and 3 signers, threshold 2
2. Complete DKG phase
3. Coordinator sends `NonceRequest` with `SignatureType::Frost`
4. Collect `NonceResponse` messages from signers
5. Coordinator sends `SignatureShareRequest` with `SignatureType::Schnorr` (different type)
6. Observe: Signers return signature shares without error
7. Coordinator aggregates signature
8. Verify signature against expected public key
9. Result: Verification fails with probability 1.0

**Key Parameters:**
- Any message bytes
- Any valid DKG setup
- Any pair of different signature types from {Frost, Schnorr, Taproot}
- Attack succeeds 100% of the time when signature types differ

### Citations

**File:** src/state_machine/signer/mod.rs (L112-169)
```rust
/// The saved state required to reconstruct a signer
#[derive(Clone)]
pub struct SavedState {
    /// current DKG round ID
    pub dkg_id: u64,
    /// current signing round ID
    pub sign_id: u64,
    /// current signing iteration ID
    pub sign_iter_id: u64,
    /// the threshold of the keys needed for a valid signature
    pub threshold: u32,
    /// the threshold of the keys needed for a valid DKG
    pub dkg_threshold: u32,
    /// the total number of signers
    pub total_signers: u32,
    /// the total number of keys
    pub total_keys: u32,
    /// the Signer object
    pub signer: SignerSavedState,
    /// the Signer ID
    pub signer_id: u32,
    /// the current state
    pub state: State,
    /// map of polynomial commitments for each party
    /// party_id => PolyCommitment
    pub commitments: HashMap<u32, PolyCommitment>,
    /// map of decrypted DKG private shares
    /// src_party_id => (dst_key_id => private_share)
    decrypted_shares: HashMap<u32, HashMap<u32, Scalar>>,
    /// shared secrets used to decrypt private shares
    /// src_party_id => (signer_id, dh shared key)
    decryption_keys: HashMap<u32, (u32, Point)>,
    /// invalid private shares
    /// signer_id => {shared_key, tuple_proof}
    pub invalid_private_shares: HashMap<u32, BadPrivateShare>,
    /// public nonces for this signing round
    pub public_nonces: Vec<PublicNonce>,
    /// the private key used to sign messages sent over the network
    network_private_key: Scalar,
    /// the public keys for all signers and coordinator
    pub public_keys: PublicKeys,
    /// the DKG public shares received in this round
    pub dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    /// the DKG private shares received in this round
    pub dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
    /// the DKG private begin message received in this round
    pub dkg_private_begin_msg: Option<DkgPrivateBegin>,
    /// the DKG end begin message received in this round
    pub dkg_end_begin_msg: Option<DkgEndBegin>,
    /// whether to verify the signature on Packets
    pub verify_packet_sigs: bool,
    /// coordinator public key
    pub coordinator_public_key: Option<ecdsa::PublicKey>,
    /// Ephemeral private key for key exchange
    kex_private_key: Scalar,
    /// Ephemeral public keys for key exchange indexed by key_id
    kex_public_keys: HashMap<u32, Point>,
}
```

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L757-842)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };

            self.signer.gen_nonces(&self.network_private_key, rng);

            let response = SignatureShareResponse {
                dkg_id: sign_request.dkg_id,
                sign_id: sign_request.sign_id,
                sign_iter_id: sign_request.sign_iter_id,
                signer_id: self.signer_id,
                signature_shares,
            };
            info!(
                signer_id = %self.signer_id,
                dkg_id = %sign_request.dkg_id,
                sign_id = %sign_request.sign_id,
                sign_iter_id = %sign_request.sign_iter_id,
                "sending SignatureShareResponse"
            );

            Ok(vec![Message::SignatureShareResponse(response)])
        } else {
            debug!(signer_id = %self.signer_id, "signer not included in SignatureShareRequest");
            Ok(Vec::new())
        }
    }
```

**File:** src/net.rs (L262-307)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce request message from coordinator to signers
pub struct NonceRequest {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// The message to sign
    pub message: Vec<u8>,
    /// What type of signature to create
    pub signature_type: SignatureType,
}

impl Debug for NonceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NonceRequest")
            .field("dkg_id", &self.dkg_id)
            .field("sign_id", &self.sign_id)
            .field("sign_iter_id", &self.sign_iter_id)
            .field("message", &hex::encode(&self.message))
            .field("signature_type", &self.signature_type)
            .finish()
    }
}

impl Signable for NonceRequest {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_REQUEST".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.message.as_slice());
        match self.signature_type {
            SignatureType::Frost => hasher.update("SIGNATURE_TYPE_FROST".as_bytes()),
            SignatureType::Schnorr => hasher.update("SIGNATURE_TYPE_SCHNORR".as_bytes()),
            SignatureType::Taproot(merkle_root) => {
                hasher.update("SIGNATURE_TYPE_TAPROOT".as_bytes());
                if let Some(merkle_root) = merkle_root {
                    hasher.update(merkle_root);
                }
            }
        }
    }
}
```

**File:** src/net.rs (L310-368)
```rust
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}

impl Debug for NonceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("NonceResponse")
            .field("dkg_id", &self.dkg_id)
            .field("sign_id", &self.sign_id)
            .field("sign_iter_id", &self.sign_iter_id)
            .field("signer_id", &self.signer_id)
            .field("key_ids", &self.key_ids)
            .field(
                "nonces",
                &self
                    .nonces
                    .iter()
                    .map(|x| x.to_string())
                    .collect::<Vec<_>>(),
            )
            .field("message", &hex::encode(&self.message))
            .finish()
    }
}

impl Signable for NonceResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }

        for nonce in &self.nonces {
            hasher.update(nonce.D.compress().as_bytes());
            hasher.update(nonce.E.compress().as_bytes());
        }

        hasher.update(self.message.as_slice());
    }
}
```

**File:** src/v2.rs (L225-276)
```rust
    pub fn sign_with_tweak(
        &self,
        msg: &[u8],
        party_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
        tweak: Option<Scalar>,
    ) -> SignatureShare {
        // When using BIP-340 32-byte public keys, we have to invert the private key if the
        // public key is odd.  But if we're also using BIP-341 tweaked keys, we have to do
        // the same thing if the tweaked public key is odd.  In that case, only invert the
        // public key if exactly one of the internal or tweaked public keys is odd
        let mut cx_sign = Scalar::one();
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                let key = compute::tweaked_public_key_from_tweak(&self.group_key, t);
                if key.has_even_y() ^ self.group_key.has_even_y() {
                    cx_sign = -cx_sign;
                }

                key
            } else {
                if !self.group_key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                self.group_key
            }
        } else {
            self.group_key
        };
        let (_, R) = compute::intermediate(msg, party_ids, nonces);
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
        if tweak.is_some() && !R.has_even_y() {
            r = -r;
        }

        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }

        cx = cx_sign * cx;

        let z = r + cx;

        SignatureShare {
            id: self.party_id,
            z_i: z,
            key_ids: self.key_ids.clone(),
        }
    }
```

**File:** src/v2.rs (L652-682)
```rust
    fn sign(
        &self,
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        vec![self.sign(msg, signer_ids, key_ids, nonces)]
    }

    fn sign_schnorr(
        &self,
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        vec![self.sign_with_tweak(msg, signer_ids, key_ids, nonces, Some(Scalar::from(0)))]
    }

    fn sign_taproot(
        &self,
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
        merkle_root: Option<[u8; 32]>,
    ) -> Vec<SignatureShare> {
        let tweak = compute::tweak(&self.group_key, merkle_root);
        vec![self.sign_with_tweak(msg, signer_ids, key_ids, nonces, Some(tweak))]
    }
```

**File:** src/state_machine/coordinator/mod.rs (L40-46)
```rust
    NonceRequest(SignatureType),
    /// The coordinator is gathering nonces
    NonceGather(SignatureType),
    /// The coordinator is requesting signature shares
    SigShareRequest(SignatureType),
    /// The coordinator is gathering signature shares
    SigShareGather(SignatureType),
```

**File:** src/common.rs (L242-250)
```rust
impl Signature {
    #[allow(non_snake_case)]
    /// Verify the aggregated group signature
    pub fn verify(&self, public_key: &Point, msg: &[u8]) -> bool {
        let c = challenge(public_key, &self.R, msg);
        let R = &self.z * G + (-c) * public_key;

        R == self.R
    }
```
