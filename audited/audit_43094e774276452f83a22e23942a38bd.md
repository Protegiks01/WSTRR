### Title
Insufficient Validation of Reported Signer IDs in DKG Failure Reports Enables Denial of Service

### Summary
The coordinator's `gather_dkg_end` function in both FROST and FIRE implementations fails to validate that signer IDs contained within `DkgFailure` reports reference legitimate participants. In the FROST coordinator, no validation occurs for any failure type. In the FIRE coordinator, only `BadPublicShares` and `BadPrivateShares` are validated, while `MissingPublicShares` and `MissingPrivateShares` accept arbitrary signer IDs without verification. This allows a malicious participant to inject false failure reports with non-existent signer IDs, causing DKG to fail repeatedly without detection.

### Finding Description

**Exact Locations:**

1. **FROST Coordinator** - `src/state_machine/coordinator/frost.rs`, function `gather_dkg_end`: [1](#0-0) 
   
   No validation of reported signer IDs occurs for any `DkgFailure` variant. The coordinator simply clones all failures into `reported_failures` without checking if the signer IDs inside the failure reports are legitimate participants.

2. **FIRE Coordinator** - `src/state_machine/coordinator/fire.rs`, function `gather_dkg_end`: [2](#0-1) 
   
   `MissingPublicShares` and `MissingPrivateShares` variants have TODO comments but no actual validation. Arbitrary signer IDs are accepted without verification.

**Root Cause:**

The vulnerability exists because the coordinator validates the **reporting** signer ID (the HashMap key) but not the **reported** signer IDs (contained in the DkgFailure enum values). 

In FROST coordinator: [3](#0-2) 

The check at line 387 ensures only legitimate participants can send DkgEnd messages, but the content of those messages is not validated.

In FIRE coordinator: [4](#0-3) 

Similarly, line 581 validates the reporting signer, but lines 620-650 only validate `BadPublicShares`: [5](#0-4) 

And lines 652-763 only validate `BadPrivateShares`: [6](#0-5) 

**Why Existing Mitigations Fail:**

The FIRE coordinator's `malicious_dkg_signer_ids` tracking mechanism only marks signers as malicious for validated failure types: [7](#0-6) 

For `MissingPublicShares` and `MissingPrivateShares`, no malicious marking occurs. In FROST, the `malicious_signers` field is always empty: [8](#0-7) 

### Impact Explanation

**Specific Harm:**
A malicious DKG participant can cause DKG to fail indefinitely by reporting false failures with arbitrary signer IDs (e.g., `MissingPublicShares([999999, 888888])`). This prevents the generation of the aggregate public key and thus prevents any threshold signatures from being created by this coordinator group.

**Quantified Impact:**
- **FROST coordinator**: 100% DKG failure rate with zero detection. Attacker can disrupt every DKG attempt.
- **FIRE coordinator**: Partial failure - attacker can use `MissingPublicShares`/`MissingPrivateShares` variants without detection, or `BadPublicShares`/`BadPrivateShares` with risk of detection only if coordinator successfully validates the claims.

**Affected Parties:**
- Any node or miner relying on this coordinator for DKG operations
- If DKG is used for consensus-critical operations (e.g., signing blocks), the entire dependent chain could be affected
- The `reported_failures` HashMap containing invalid data could cause issues in caller logic if not properly handled

**Severity Justification:**
This vulnerability maps to **Low** severity under the defined scope: "Any remotely-exploitable denial of service in a node." A single malicious participant can prevent DKG completion, which blocks signature generation. If multiple nodes use coordinators with this vulnerability and are targeted, it could potentially reach "network denial of service impacting more than 10 percent of miners."

### Likelihood Explanation

**Required Attacker Capabilities:**
- Attacker must be a legitimate DKG participant with a valid signer ID
- Attacker must control their signer implementation to craft malicious DkgEnd messages
- No cryptographic breaks required
- No special network position required beyond being an authorized participant

**Attack Complexity:**
1. Attacker participates normally through DKG public shares phase (validated at lines 486-491 in fire.rs, 299-304 in frost.rs)
2. Attacker participates normally through DKG private shares phase (validated at lines 534-539 in fire.rs, 345-350 in frost.rs)
3. Attacker receives `DkgEndBegin` message from coordinator
4. Attacker crafts `DkgEnd` message with `DkgStatus::Failure(DkgFailure::MissingPublicShares([arbitrary_ids]))`
5. Coordinator accepts message (reporting signer ID is valid)
6. Coordinator processes failure without validating reported IDs
7. DKG fails and returns error with polluted `reported_failures`
8. In FROST: Attacker is never marked as malicious
9. Process repeats for every DKG attempt

**Economic Feasibility:**
Very low cost. Attacker only needs to be an authorized participant. No additional resources required beyond normal participation costs.

**Detection Risk:**
In FROST: Zero detection risk - malicious behavior is never identified.
In FIRE: Low detection risk for `MissingPublicShares`/`MissingPrivateShares` variants. Higher detection risk for `BadPublicShares`/`BadPrivateShares` variants if validation succeeds.

**Estimated Probability:**
High probability of success. The attack requires no special timing, no race conditions, and no cryptographic operations. A determined attacker with participant access can execute this attack with near 100% reliability in FROST coordinator and high reliability for certain failure types in FIRE coordinator.

### Recommendation

**Primary Fix - Add Validation:**

For FROST coordinator (`src/state_machine/coordinator/frost.rs`), add validation in `gather_dkg_end`:

```rust
for (signer_id, dkg_end) in &self.dkg_end_messages {
    if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
        // Validate reported signer IDs before accepting
        let is_valid = match dkg_failure {
            DkgFailure::MissingPublicShares(ids) 
            | DkgFailure::BadPublicShares(ids) 
            | DkgFailure::MissingPrivateShares(ids) => {
                ids.iter().all(|id| validate_signer_id(*id, self.config.num_signers))
            },
            DkgFailure::BadPrivateShares(map) => {
                map.keys().all(|id| validate_signer_id(*id, self.config.num_signers))
            },
            _ => true,
        };
        
        if !is_valid {
            warn!(%signer_id, "Reported invalid signer IDs in failure report");
            // Mark reporter as malicious
            continue;
        }
        
        reported_failures.insert(*signer_id, dkg_failure.clone());
    }
}
```

For FIRE coordinator (`src/state_machine/coordinator/fire.rs`), replace TODO comments at lines 765-770 with:

```rust
DkgFailure::MissingPublicShares(missing) => {
    for id in missing {
        if !validate_signer_id(*id, self.config.num_signers) {
            warn!("Signer {signer_id} reported invalid signer_id {id} in MissingPublicShares");
            malicious_signers.insert(*signer_id);
            break;
        }
    }
}
DkgFailure::MissingPrivateShares(missing) => {
    for id in missing {
        if !validate_signer_id(*id, self.config.num_signers) {
            warn!("Signer {signer_id} reported invalid signer_id {id} in MissingPrivateShares");
            malicious_signers.insert(*signer_id);
            break;
        }
    }
}
```

**Alternative Mitigation:**

Implement stricter validation by checking not just `validate_signer_id` but also that reported IDs exist in `dkg_public_shares` or `dkg_private_shares`, similar to the existing validation for `BadPublicShares` and `BadPrivateShares`.

**Testing Recommendations:**
1. Add unit tests where a malicious signer reports failures with signer_ids >= num_signers
2. Add unit tests where a malicious signer reports failures with negative/invalid signer_ids (if using signed types)
3. Verify that false reporters are correctly marked in `malicious_signers` or `malicious_dkg_signer_ids`
4. Test that legitimate failure reports with valid signer_ids still work correctly

**Deployment Considerations:**
This fix should be deployed before any production use of FROST or FIRE coordinators, especially in consensus-critical roles.

### Proof of Concept

**Exploitation Algorithm:**

```
1. Setup: Attacker is signer_id=1, coordinator expects num_signers=5 (IDs 0-4)

2. DKG Public Shares Phase:
   - Attacker sends valid DkgPublicShares message
   - All other signers (0,2,3,4) send valid messages
   - Coordinator advances to DkgPrivateGather state

3. DKG Private Shares Phase:
   - Attacker sends valid DkgPrivateShares message
   - All other signers send valid messages
   - Coordinator advances to DkgEndDistribute state

4. DKG End Phase:
   - Coordinator sends DkgEndBegin message
   - Honest signers (0,2,3,4) send DkgEnd with Success status
   - Attacker sends:
     DkgEnd {
       dkg_id: <current>,
       signer_id: 1,
       status: Failure(MissingPublicShares([999, 888, 777]))
     }

5. Coordinator Processing (FROST):
   - Line 387: Check passes (signer_id=1 is in ids_to_await)
   - Line 390: Insert into dkg_end_messages
   - Line 403-406: Loop through dkg_end_messages
   - Line 406: Insert into reported_failures WITHOUT validation
   - Line 413: Return Error::DkgFailure with invalid IDs
   - Attacker is NOT marked as malicious

6. Coordinator Processing (FIRE):
   - Line 581: Check passes (signer_id=1 is in dkg_wait_signer_ids)
   - Line 584: Insert into dkg_end_messages
   - Line 607-610: Loop through dkg_end_messages
   - Line 610: Insert into reported_failures
   - Line 765: Match MissingPublicShares, but just TODO comment
   - Line 785: Return Error::DkgFailure
   - Attacker is NOT marked as malicious

7. Result:
   - DKG fails with reported_failures containing [1 -> MissingPublicShares([999,888,777])]
   - Invalid signer IDs 999, 888, 777 pollute the failure report
   - Attacker can repeat this for every DKG attempt
   - System cannot generate aggregate public key
   - Threshold signatures cannot be created
```

**Expected vs Actual Behavior:**

**Expected:** Coordinator should validate that signer IDs 999, 888, 777 are invalid (>= num_signers=5), mark signer_id=1 as malicious, exclude the false report from `reported_failures`, and continue DKG with honest participants.

**Actual:** Coordinator accepts the false report, includes it in `reported_failures`, fails DKG, and never marks signer_id=1 as malicious (in FROST) or marks for limited failure types (in FIRE).

**Reproduction Instructions:**

1. Set up FROST or FIRE coordinator with 5 signers (num_signers=5)
2. Configure one signer (signer_id=1) with modified code that sends false failure reports
3. Start DKG round
4. Allow all signers to complete public and private share phases
5. In DkgEnd phase, have signer_id=1 send `DkgStatus::Failure(DkgFailure::MissingPublicShares([999]))`
6. Observe that coordinator returns `DkgError::DkgEndFailure` with reported_failures containing invalid signer ID
7. Observe that signer_id=1 is not in malicious_signers (FROST) or malicious_dkg_signer_ids (FIRE for this variant)
8. Repeat to confirm persistent DoS with no detection

### Citations

**File:** src/state_machine/coordinator/frost.rs (L387-397)
```rust
            if self.ids_to_await.contains(&dkg_end.signer_id) {
                self.ids_to_await.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.ids_to_await,
                    "DkgEnd received"
                );
            }
```

**File:** src/state_machine/coordinator/frost.rs (L403-406)
```rust
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
```

**File:** src/state_machine/coordinator/frost.rs (L413-416)
```rust
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
```

**File:** src/state_machine/coordinator/fire.rs (L581-597)
```rust
            if self.dkg_wait_signer_ids.contains(&dkg_end.signer_id) {
                self.dkg_wait_signer_ids.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.dkg_wait_signer_ids,
                    "DkgEnd received"
                );
            } else {
                warn!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    "Got DkgEnd from signer who we weren't waiting on"
                );
            }
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L652-676)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-788)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }

            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```
