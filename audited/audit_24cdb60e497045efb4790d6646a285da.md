# Audit Report

## Title
Missing DKG Round ID Validation Enables Replay Attack and Denial of Service

## Summary
The `dkg_public_share()` function in the signer state machine accepts `DkgPublicShares` messages without validating that the message's `dkg_id` matches the signer's current `self.dkg_id`. This allows a malicious participant to replay legitimately-signed `DkgPublicShares` from previous DKG rounds, causing the current DKG round to fail when cryptographic verification detects the context mismatch during finalization.

## Finding Description

The vulnerability exists in the signer's message processing logic. When a signer receives a `DkgPublicShares` message, it performs several validations but critically omits checking whether the message's `dkg_id` matches the current DKG round. [1](#0-0) 

The function validates:
- Signer ID exists in configuration
- Party ID ownership
- Duplicate detection by signer_id only

However, it never validates `dkg_public_shares.dkg_id == self.dkg_id` before storing the shares. In contrast, the coordinator properly validates this field: [2](#0-1) 

**Attack Mechanism:**

The `DkgPublicShares` struct contains a `dkg_id` field: [3](#0-2) 

When a malicious participant replays a `DkgPublicShares` message from a previous DKG round (e.g., round N) during a current round (round M where M > N):

1. The message signature is valid because it was legitimately created by the attacker in round N. The signature covers the `dkg_id` field: [4](#0-3) 

2. The duplicate detection only checks by `signer_id`, not by `(signer_id, dkg_id)` pair: [5](#0-4) 

3. The replayed shares are stored without validation. Later, during `dkg_ended()`, the polynomial commitments are verified using the **current** `dkg_id`: [6](#0-5) 

4. The verification fails because the Schnorr proof was bound to the old `dkg_id` context. The Schnorr challenge computation includes the context parameter: [7](#0-6) [8](#0-7) 

5. When verification fails, the signer is marked as having "bad public shares" and DKG fails: [9](#0-8) 

**Why This Breaks Security Guarantees:**

The DKG protocol assumes that all `DkgPublicShares` messages processed in a given round belong to that round. The Schnorr proof binding ensures cryptographic integrity, but this binding is only checked at finalization, not at message acceptance. This creates a time-of-check to time-of-use vulnerability where invalid shares are accepted early and detected late.

## Impact Explanation

This vulnerability enables a **remotely-exploitable denial of service** attack on the DKG process, which maps to **Low severity** according to the provided scope: "Any remotely-exploitable denial of service in a node."

**Concrete Impact:**
- Any participant from previous DKG rounds can force current DKG rounds to fail
- Multiple signers receiving replayed messages will all report DKG failure
- The attack requires minimal resources (storing and replaying a small message)
- No funds are directly lost, no invalid signatures are accepted, and no chain consensus is affected

**Affected Parties:**
All signers participating in DKG rounds are vulnerable. In the WSTS deployment context (Stacks blockchain), this could prevent threshold signing setup, blocking operations that require the distributed key. However, it does not shut down the network or prevent existing keys from functioning.

## Likelihood Explanation

**High Likelihood of Exploitation:**

**Attacker Capabilities Required:**
- Must be a legitimate participant in at least one DKG round (within threat model for WSTS)
- Must have network access to send P2P messages to signers
- No compromised private keys or broken cryptography required

**Attack Complexity:** Very Low
1. Participate normally in any DKG round N
2. Save the signed `DkgPublicShares` message
3. During any subsequent DKG round M, replay the saved message
4. Optionally, also send legitimate shares for round M (they will be rejected as duplicates)
5. DKG fails during finalization with no immediate detection

**Economic Feasibility:** Minimal
- One-time participation cost to become a legitimate signer
- Storage of small messages (~1-10 KB)
- Negligible network bandwidth

**Detection Difficulty:** The replayed messages are legitimately signed and indistinguishable from valid messages until cryptographic verification during `dkg_ended()`. By then, the DKG round has already failed.

**Success Probability:** Very high (~95%+) unless signers exclusively communicate through a coordinator that validates `dkg_id` (which would bypass peer-to-peer message handling where the vulnerability exists).

## Recommendation

Add `dkg_id` validation in the `dkg_public_share()` function, matching the coordinator's validation pattern:

```rust
pub fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Add this validation early
    if dkg_public_shares.dkg_id != self.dkg_id {
        warn!(
            signer_id = %dkg_public_shares.signer_id,
            received_dkg_id = %dkg_public_shares.dkg_id,
            current_dkg_id = %self.dkg_id,
            "Rejected DkgPublicShares with mismatched dkg_id"
        );
        return Ok(vec![]);
    }
    
    // ... existing validation logic continues
```

This change ensures that only shares from the current DKG round are accepted, preventing replay attacks from previous rounds.

## Proof of Concept

**Conceptual PoC:**

The vulnerability can be demonstrated through the following sequence:

1. **Setup:** Create a signer participating in DKG round with `dkg_id = 5`
2. **Legitimate Operation:** Signer generates and signs `DkgPublicShares` message with `dkg_id = 5`
3. **Attack:** Start new DKG round with `dkg_id = 10` by calling `reset(10, rng)` which clears old shares: [10](#0-9) 

4. **Replay:** Submit the saved `DkgPublicShares` message (with `dkg_id = 5`) to the victim signer
5. **Acceptance:** The message passes all validations in `dkg_public_share()` despite wrong `dkg_id`
6. **Failure:** During `dkg_ended()`, call to `check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes())` fails because Schnorr proof was bound to `dkg_id = 5` but is verified with `dkg_id = 10`
7. **Result:** DKG fails with `DkgFailure::BadPublicShares`

The core issue is observable by tracing through the code: no validation exists at lines 974-1026 in `signer/mod.rs` to check `dkg_public_shares.dkg_id == self.dkg_id`, while the coordinator performs this exact check at lines 479-484 in `fire.rs`.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L551-562)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L593-598)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/fire.rs (L479-484)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/net.rs (L141-150)
```rust
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/schnorr.rs (L47-59)
```rust
    /// Compute the schnorr challenge
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }
```

**File:** src/common.rs (L36-39)
```rust
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```
