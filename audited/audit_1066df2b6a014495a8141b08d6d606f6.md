Audit Report

## Title
Incorrect Malicious Signer Identification Due to Unauthenticated SignatureShare.id Field in v2

## Summary
The v2 coordinator does not validate that the `id` field within `SignatureShare` objects matches the authenticated `signer_id` of the sender. A malicious signer can create signature shares with an incorrect `id` field, causing signature verification to fail and blame to be incorrectly assigned to an innocent party instead of the actual malicious signer.

## Finding Description

The vulnerability exists due to insufficient validation of the `SignatureShare` structure in v2. While packet-level authentication ensures messages come from legitimate signers, the coordinator fails to validate that the `id` field within signature shares matches the authenticated sender.

**The Attack Flow:**

1. The coordinator stores signature shares indexed by the authenticated `signer_id` from the packet but never validates that `SignatureShare.id` matches this sender ID. [1](#0-0) 

2. The coordinator validates that `key_ids` match the configured keys for the sender, but does NOT validate the `id` field. [2](#0-1) 

3. During aggregation, the aggregator extracts party IDs from `SignatureShare.id` (not from the authenticated sender) for binding computation. [3](#0-2) 

4. The binding computation depends critically on the party ID - it is serialized directly into the hash input used to compute the binding value. [4](#0-3) 

5. When an honest signer creates their signature share, they compute it using their actual party ID for the binding value. But if a malicious signer provides a signature share with a spoofed `id`, the aggregator will pair this share with nonces using the *spoofed* party ID for binding computation, creating a mismatch that causes verification to fail.

6. When verification fails, blame is assigned based on `SignatureShare.id`, incorrectly identifying the innocent party whose ID was spoofed. [5](#0-4) 

**Why v1 is Not Affected:**

In v1, each party controls exactly one key where `party_id == key_id`. When a signer creates a signature share, they set `key_ids: vec![self.id]`. [6](#0-5) 

If a malicious v1 signer tries to spoof another party's ID, they would need to use that party's key_id (since party_id == key_id). However, the coordinator validates that key_ids match the sender's configured keys, which would fail. In v2, party_id and key_ids are decoupled (one party controls multiple keys), so this protection does not apply. [7](#0-6) 

**The Exploit:**

A compromised signer modifies their code to create signature shares with an incorrect `id` field. In `v2::Party::sign_with_tweak()`, they change the assignment from `id: self.party_id` to `id: <target_victim_id>`. [8](#0-7) 

## Impact Explanation

This vulnerability enables a compromised signer to frame honest parties for signing failures:

1. A malicious signer provides a signature share with a spoofed `id` field
2. The signature verification fails due to binding value mismatch
3. The `BadPartySigs` error incorrectly identifies the innocent party
4. External systems relying on blame assignment may exclude the innocent signer
5. Repeated attacks could exclude enough honest signers to drop below the signing threshold

In a deployment with 10 signers and threshold 7, an attacker who compromises 1 signer could frame 3 innocent signers over multiple rounds, reducing the system to 6 uncompromised, non-excluded signers - below the threshold and unable to produce signatures.

This maps to **Medium severity** per the protocol scope: "Any transient consensus failures." The vulnerability causes signing protocol failures with incorrect blame assignment, potentially leading to exclusion of honest parties and temporary loss of signing capability.

## Likelihood Explanation

**Required Attacker Capabilities:**
- Control of one signer node (within the threshold-1 threat model)
- Ability to modify signer software to create malformed `SignatureShare` objects
- No additional cryptographic secrets required beyond being a legitimate signer

**Attack Complexity:**
Low. The attack requires only modifying a single line of code in the signer software running on the compromised node. No timing constraints, race conditions, or complex cryptographic operations are needed.

**Estimated Probability:**
If a signer is compromised: High (>70%). The attack is trivial to execute once a signer node is controlled, requiring only a single-line code modification.

## Recommendation

Add validation in the coordinator's `gather_sig_shares` method to ensure that `SignatureShare.id` matches the authenticated `signer_id` for v2 implementations:

```rust
// After line 1076 in fire.rs, add:
for sig_share in &sig_share_response.signature_shares {
    if sig_share.id != sig_share_response.signer_id {
        warn!(
            signer_id = %sig_share_response.signer_id,
            share_id = %sig_share.id,
            "SignatureShare id doesn't match authenticated signer_id"
        );
        return Err(Error::BadSignatureShareId(
            sig_share.id,
            sig_share_response.signer_id
        ));
    }
}
```

This validation should be added to both the FIRE coordinator and FROST coordinator implementations that handle v2 signature shares.

## Proof of Concept

```rust
#[test]
fn test_signature_share_id_spoofing() {
    use crate::v2;
    use crate::traits::{Aggregator, Signer};
    use crate::util::create_rng;
    
    let mut rng = create_rng();
    let msg = b"test message";
    let n_k: u32 = 10;
    let t: u32 = 7;
    let party_key_ids: Vec<Vec<u32>> = vec![
        vec![1, 2, 3],
        vec![4, 5],
        vec![6, 7, 8],
        vec![9, 10],
    ];
    let n_p = party_key_ids.len() as u32;
    
    // Create and run DKG
    let mut signers: Vec<v2::Party> = party_key_ids
        .iter()
        .enumerate()
        .map(|(pid, pkids)| v2::Party::new(pid as u32, pkids, n_p, n_k, t, &mut rng))
        .collect();
    
    let comms = v2::test_helpers::dkg(&mut signers, &mut rng).expect("DKG failed");
    
    // Generate nonces and signature shares
    let (nonces, mut sig_shares, key_ids) = v2::test_helpers::sign(msg, &mut signers, &mut rng);
    
    // ATTACK: Malicious signer (index 0) spoofs signer 2's ID
    sig_shares[0].id = 2; // Should be 0, but attacker sets it to 2
    
    // Try to aggregate - this should fail
    let mut aggregator = v2::Aggregator::new(n_k, t);
    aggregator.init(&comms).expect("Init failed");
    
    // Signature verification will fail
    let result = aggregator.sign(msg, &nonces, &sig_shares, &key_ids);
    
    // Verify that the error blames the WRONG party (party 2 instead of party 0)
    match result {
        Err(crate::errors::AggregatorError::BadPartySigs(bad_parties)) => {
            assert!(bad_parties.contains(&2), "Innocent party 2 is blamed");
            assert!(!bad_parties.contains(&0), "Actual malicious party 0 is NOT blamed");
        }
        _ => panic!("Expected BadPartySigs error with incorrect blame assignment"),
    }
}
```

This test demonstrates that when a malicious signer spoofs another party's ID in their signature share, the signature verification fails and blame is incorrectly assigned to the innocent party whose ID was spoofed, rather than the actual malicious signer.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/v2.rs (L271-275)
```rust
        SignatureShare {
            id: self.party_id,
            z_i: z,
            key_ids: self.key_ids.clone(),
        }
```

**File:** src/v2.rs (L308-309)
```rust
        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &party_ids, nonces);
```

**File:** src/v2.rs (L406-408)
```rust
            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/v2.rs (L644-650)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        _signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        signer_id == party_id
    }
```

**File:** src/compute.rs (L17-33)
```rust
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```

**File:** src/v1.rs (L290-293)
```rust
            id: self.id,
            z_i: z,
            key_ids: vec![self.id],
        }
```
