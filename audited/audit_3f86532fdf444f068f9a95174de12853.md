### Title
Coordinator Fails to Validate Polynomial Commitment Length Enabling Aggregation Failure via Equivocation Attack

### Summary
The coordinator in the WSTS state machine does not validate that received polynomial commitments have the correct length (`poly.len() == threshold`) unless a signer explicitly reports a failure. A malicious signer can exploit this by sending different polynomial commitments to the coordinator versus honest signers (equivocation attack), causing all future signature aggregations to fail even after successful DKG completion.

### Finding Description

**Exact Code Locations:**

The vulnerability spans multiple components:

1. **Coordinator commitment gathering without validation:** [1](#0-0) 

The `gather_public_shares` method receives `DkgPublicShares` messages and stores them without calling `check_public_shares` to validate polynomial length.

2. **Coordinator caches unvalidated commitments:** [2](#0-1) 

During `dkg_end_gathered`, the coordinator copies commitments from `self.dkg_public_shares` to `self.party_polynomials` without validation.

3. **Aggregator init assumes valid length:** [3](#0-2) 

The `Aggregator::init` function directly accesses `p.poly[i]` without checking that `i < p.poly.len()`, causing a panic if any commitment has fewer than `threshold` coefficients.

4. **Coordinator only validates on reported failures:** [4](#0-3) 

The coordinator calls `check_public_shares` only when a signer reports `DkgFailure::BadPublicShares`, not proactively on all received commitments.

**Root Cause:**

The WSTS protocol assumes that polynomial commitments broadcast by signers are received identically by all parties. However, the coordinator acts as a separate entity that receives commitments directly from signers without cross-validating them against what honest signers received. This creates an equivocation opportunity where a malicious signer can send different commitments to different recipients.

The validation function exists: [5](#0-4) 

But honest signers validate commitments during `compute_secret`: [6](#0-5) 

While the coordinator never calls this validation unless explicitly triggered by failure reports.

**Why Existing Mitigations Fail:**

1. **Message authentication** (when enabled) only prevents third-party tampering, not equivocation by the legitimate sender who can create multiple validly-signed messages with different content.

2. **Signer-side validation** catches bad commitments received by signers, but doesn't protect the coordinator if it receives different commitments.

3. **Conditional coordinator validation** only activates when a signer reports `BadPublicShares`, which won't occur if all signers receive valid commitments (just different from what the coordinator received).

### Impact Explanation

**Specific Harm:**

A successful attack causes complete and permanent denial of service on the signing protocol:

1. All signature aggregation attempts fail because the coordinator computes incorrect public keys using the wrong aggregate polynomial
2. The coordinator's `check_signature_shares` function computes public keys via: [7](#0-6) 

Using the corrupted aggregate polynomial, causing all verification checks to fail.

3. Even though DKG completed successfully and signers possess valid private keys, no signatures can be produced because the coordinator rejects all signature shares as invalid.

**Quantified Impact:**

- **Threshold**: Any (e.g., 7 of 10)
- **Attacker requirement**: Control of 1 malicious signer
- **Result**: 0% signature success rate (complete system failure)
- **Recovery**: Requires full DKG restart with malicious signer removal

**Who Is Affected:**

All participants in the WSTS deployment. The entire threshold signature system becomes non-functional despite having sufficient honest signers above the threshold.

**Severity Justification:**

This maps to **High severity** under the provided scope: "Any unintended chain split or network partition." 

A WSTS-based system that cannot produce signatures cannot process transactions, approve blocks, or perform any protocol operations requiring threshold signatures. In a blockchain context, this causes network partition or halt. The attack is persistent (survives until DKG restart) and affects 100% of signing operations.

### Likelihood Explanation

**Required Attacker Capabilities:**

1. **Position**: Control one signer identity in the WSTS network
2. **Network access**: Ability to send targeted messages to specific recipients (the coordinator separately from honest signers)
3. **No cryptographic breaks required**: The attack exploits missing validation logic, not cryptographic weaknesses

**Attack Complexity:**

**Low complexity** - The attack requires:
- Creating two `DkgPublicShares` messages with different polynomial commitments
- Ensuring both have the same constant term `poly[0]` to pass ID proof verification: [8](#0-7) 

- Signing both messages (attacker has their private key)
- Network-level routing to send different messages to different recipients

**Economic Feasibility:**

Highly feasible - requires only:
- One compromised signer (no threshold-level compromise needed)
- Standard network capabilities (message routing)
- No expensive computation or cryptographic attacks

**Detection Risk:**

**Low detection risk** during attack execution:
- Both messages are validly signed, appearing legitimate
- No cryptographic anomalies to detect
- Attack surface is network message routing
- Only detectable post-DKG when signing fails, but root cause is non-obvious

**Estimated Probability:**

**High** if the attacker has the prerequisites:
- Network infrastructure supporting targeted messaging: very common in distributed systems
- Malicious signer: depends on signer vetting process
- Technical sophistication: moderate (understanding protocol, crafting messages)

### Recommendation

**Primary Fix - Add Coordinator Validation:**

Modify the coordinator's `gather_public_shares` to validate all commitments immediately upon receipt:

```rust
fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
    if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
        // ... existing dkg_id and signer_id checks ...
        
        // ADD: Validate polynomial commitments before storing
        let threshold: usize = self.config.threshold.try_into()
            .map_err(|_| Error::InvalidThreshold)?;
        let ctx = self.current_dkg_id.to_be_bytes();
        
        for (party_id, comm) in &dkg_public_shares.comms {
            if !check_public_shares(comm, threshold, &ctx) {
                warn!(
                    signer_id = %dkg_public_shares.signer_id,
                    party_id = %party_id,
                    poly_len = comm.poly.len(),
                    threshold = threshold,
                    "Invalid polynomial commitment length or proof"
                );
                return Err(Error::BadPolyCommitment(
                    dkg_public_shares.signer_id,
                    *party_id
                ));
            }
        }
        
        // ... existing storage logic ...
    }
    // ... rest of function ...
}
```

**Secondary Defense - Add Aggregator Init Validation:**

Add defensive bounds checking in `Aggregator::init`:

```rust
fn init(&mut self, comms: &HashMap<u32, PolyCommitment>) -> Result<(), AggregatorError> {
    let threshold = self.threshold.try_into()?;
    
    // Validate all commitments have correct length
    for (party_id, comm) in comms {
        if comm.poly.len() != threshold {
            return Err(AggregatorError::BadPolyLen(
                *party_id,
                comm.poly.len(),
                threshold
            ));
        }
    }
    
    // ... existing aggregation logic ...
}
```

**Testing Recommendations:**

1. Add unit test for coordinator receiving commitment with `poly.len() != threshold`
2. Add integration test simulating equivocation attack (different commitments to coordinator vs signers)
3. Test aggregator panic scenarios with malformed commitments
4. Verify proper error propagation and malicious signer detection

**Deployment Considerations:**

- This is a breaking protocol change requiring coordinator update
- Existing deployments remain vulnerable until patched
- Consider adding commitment hash gossip for cross-validation
- Monitor for `BadPolyCommitment` errors indicating attack attempts

### Proof of Concept

**Exploitation Algorithm:**

```
Setup:
- Network: 10 signers (IDs 1-10), threshold = 7
- Attacker controls signer ID 10
- Honest signers: IDs 1-9

Attack Steps:

1. DKG begins, all signers create polynomials

2. Attacker (signer 10) creates TWO polynomial commitments:
   
   Commitment A (for honest signers):
   - Polynomial of degree 6 (threshold - 1)
   - Coefficients: [P0, P1, P2, P3, P4, P5, P6]
   - poly.len() = 7 (equals threshold ✓)
   - ID proof binds P0 to context
   
   Commitment B (for coordinator):
   - SAME constant term: P0 (to pass ID proof)
   - DIFFERENT higher coefficients: [P0, Q1, Q2, Q3, Q4, Q5, Q6]
   - where Qi ≠ Pi for at least one i ∈ {1..6}
   - poly.len() = 7 (appears valid)

3. Attacker creates DkgPublicShares messages:
   - Message A = DkgPublicShares { ..., comms: [(10, CommitmentA)] }
   - Message B = DkgPublicShares { ..., comms: [(10, CommitmentB)] }
   - Both signed with attacker's private key (both valid signatures)

4. Attacker sends messages:
   - Message A → broadcast to signers 1-9
   - Message B → send to coordinator only

5. Honest signers process:
   - Receive Commitment A
   - Validate: check_public_shares(A, 7, ctx) → TRUE (poly.len == 7 ✓, ID proof valid ✓)
   - Store Commitment A
   - Compute secrets using polynomial A
   - Report DkgStatus::Success

6. Coordinator processes:
   - Receives Commitment B
   - Does NOT validate (no check_public_shares call)
   - Stores Commitment B in dkg_public_shares
   - All signers report Success → DKG succeeds
   - Caches Commitment B in party_polynomials

7. DKG completes:
   - Honest signers have group_key = ... + P0 + ...
   - Coordinator has aggregate_public_key = ... + P0 + ... (SAME, P0 matches)
   - But aggregate polynomials differ in higher coefficients!

8. Later, during signing:
   - Coordinator calls aggregator.init(&party_polynomials)
   - Aggregator computes: aggregate_poly = sum of all commitments
   - For party 10: uses [P0, Q1, Q2, Q3, Q4, Q5, Q6] instead of [P0, P1, P2, P3, P4, P5, P6]
   - aggregate_poly is WRONG

9. Signature share verification:
   - Honest signer 1 creates valid signature share based on their private key
   - Coordinator computes expected public_key_1 = compute::poly(&id_1, &aggregate_poly)
   - This uses the WRONG aggregate_poly (contains Q coefficients instead of P)
   - computed public_key_1 ≠ actual public_key_1
   - Verification: z_i * G != expected_R + expected_c * wrong_public_key
   - FAIL: Coordinator marks signer 1 as having bad signature

10. Result:
    - ALL signature shares fail verification (even from honest signers)
    - Signing operation fails completely
    - Error persists for all future signing attempts
    - Only recovery: restart DKG (expensive)

Expected Behavior: DKG should fail or detect equivocation
Actual Behavior: DKG succeeds, all signing permanently fails

Variant (Panic Attack):
- Attacker sends Commitment B with poly.len() = 5 (< threshold)
- Coordinator doesn't validate
- During aggregator.init():
  - Loop: for i in 0..7 (threshold)
  - When i >= 5: poly[i] access on Commitment B → INDEX OUT OF BOUNDS PANIC
- Coordinator crashes (DoS)
```

**Reproduction:**

Requires modifying network layer to route attacker's messages differently to coordinator vs signers. In test environment, this can be simulated by directly calling coordinator and signer methods with different commitment objects.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L633-649)
```rust
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
```

**File:** src/state_machine/coordinator/fire.rs (L794-812)
```rust
    fn dkg_end_gathered(&mut self) -> Result<(), Error> {
        // Cache the polynomials used in DKG for the aggregator
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
        }

        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
        self.move_to(State::Idle)
    }
```

**File:** src/v1.rs (L113-118)
```rust
            Some(PolyCommitment {
                id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
                poly: (0..poly.data().len())
                    .map(|i| &poly.data()[i] * G)
                    .collect(),
            })
```

**File:** src/v1.rs (L159-170)
```rust
        let threshold: usize = self.threshold.try_into()?;
        let mut bad_ids = Vec::new(); //: Vec<u32> = polys
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }
```

**File:** src/v1.rs (L401-407)
```rust
            let public_key = match compute::poly(&id, &self.poly) {
                Ok(p) => p,
                Err(_) => {
                    bad_party_keys.push(sig_shares[i].id);
                    Point::zero()
                }
            };
```

**File:** src/v1.rs (L440-454)
```rust
    fn init(&mut self, comms: &HashMap<u32, PolyCommitment>) -> Result<(), AggregatorError> {
        let threshold = self.threshold.try_into()?;
        let mut poly = Vec::with_capacity(threshold);

        for i in 0..poly.capacity() {
            poly.push(Point::zero());
            for (_, p) in comms {
                poly[i] += &p.poly[i];
            }
        }

        self.poly = poly;

        Ok(())
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```
