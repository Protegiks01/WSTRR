### Title
Missing Point-at-Infinity Validation in DKG Key Exchange Enables Denial of Service

### Summary
The `make_shared_secret()` function in `src/util.rs` does not validate whether the `public_key` parameter is the point at infinity (identity element), allowing malicious DKG participants to provide `Point::identity()` as their key exchange public key. This produces a predictable shared secret that any party can compute, enabling attackers to cause DKG failures through encrypted share manipulation, resulting in denial of service of the distributed key generation process.

### Finding Description

**Exact Code Location:**
- Vulnerable function: [1](#0-0) 
- Missing validation in DKG flow: [2](#0-1) 
- Encryption usage: [3](#0-2) 
- Decryption usage: [4](#0-3) 

**Root Cause:**
The `make_shared_secret()` function performs ECDH key exchange without validating that the public key is a valid non-identity point. When `public_key` is `Point::identity()`, the multiplication `private_key * public_key` always yields `Point::identity()` regardless of the private key value, resulting in a predictable shared secret.

Unlike `PublicNonce` which explicitly validates points are not the identity element [5](#0-4) , the `kex_public_key` received in `DkgPublicShares` messages is stored without any validation [2](#0-1) .

**Why Existing Mitigations Are Insufficient:**
While polynomial commitment validation prevents forged shares from being accepted [6](#0-5) , this only provides integrity protection, not availability protection. A malicious signer can:

1. Send `Point::identity()` as their `kex_public_key` in the `DkgPublicShares` message [7](#0-6) 
2. Compute the predictable shared secret used by honest signers
3. Send encrypted shares that either fail decryption or fail polynomial validation
4. Trigger `BadPrivateShare` complaints and coordinator validation overhead [8](#0-7) 
5. Force DKG round failure and restart

### Impact Explanation

**Specific Harm:**
A malicious DKG participant can cause denial of service by forcing DKG rounds to fail. Each failed round requires:
- Detection and reporting of bad private shares
- Coordinator validation of complaints [9](#0-8) 
- DKG round restart without the malicious party
- Additional computational and network overhead

**Quantified Impact:**
- Single malicious signer can force one DKG round to fail
- If the attacker can rejoin or control multiple signer identities, they can cause repeated failures
- Each failure delays threshold signature generation required for block confirmation
- With sufficient disruption, could impact more than 10% of miners attempting to participate in DKG

**Who Is Affected:**
All honest participants in a DKG round where a malicious signer provides `Point::identity()` as their key exchange public key.

**Severity Justification:**
This maps to **Low** severity per the defined scope: "Any remotely-exploitable denial of service in a node" and potentially "Any network denial of service impacting more than 10 percent of miners that does not shut down the network" if multiple signers or rounds are affected.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Attacker must be an authorized DKG participant with a valid `signer_id`
- Ability to send network messages during DKG protocol
- No cryptographic breaks required

**Attack Complexity:**
Trivial. The attacker simply needs to:
1. Generate and send a `DkgPublicShares` message with `kex_public_key` set to `Point::identity()`
2. The secp256k1 curve library allows serialization/deserialization of the identity point
3. No sophisticated cryptographic or timing attacks needed

**Economic Feasibility:**
Minimal cost. Only requires network bandwidth to send malicious DKG messages.

**Detection Risk:**
High detectability. The attack causes visible DKG failures and `BadPrivateShare` reports that identify the malicious signer. However, by the time detection occurs, the DKG round has already failed.

**Estimated Probability:**
High if attacker has DKG participant access. The attack will succeed in causing at least one DKG round failure before the malicious party is identified and excluded.

### Recommendation

**Proposed Code Changes:**

Add validation in `make_shared_secret()` to reject the identity point:

```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> Result<[u8; 32], EncryptionError> {
    if public_key == &Point::identity() {
        return Err(EncryptionError::InvalidPublicKey);
    }
    let shared_key = private_key * public_key;
    Ok(make_shared_secret_from_key(&shared_key))
}
```

**Alternative Mitigation:**

Add validation when storing `kex_public_key` from `DkgPublicShares` messages, following the pattern used for `PublicNonce::is_valid()`:

```rust
// In dkg_public_share() at line 1019-1020
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!(%signer_id, "Signer sent identity point as kex_public_key");
    return Ok(vec![]);
}
```

**Testing Recommendations:**
1. Unit test: Verify `make_shared_secret()` rejects `Point::identity()`
2. Integration test: Verify DKG rejects `DkgPublicShares` with identity point as `kex_public_key`
3. Test that the identity point check also rejects the generator point `G` (similar to nonce validation)

**Deployment Considerations:**
This is a protocol-level change that requires coordinated deployment across all DKG participants. Consider versioning the DKG protocol to ensure compatibility during transition.

### Proof of Concept

**Exploitation Steps:**

1. Malicious signer M with ID 1 participates in DKG
2. M generates `DkgPublicShares` message with:
   - `signer_id`: 1
   - `kex_public_key`: `Point::identity()` (serialized as point at infinity)
   - Valid polynomial commitments in `comms`
3. Honest signer H receives and stores: `kex_public_keys[key_id_1] = Point::identity()`
4. When H encrypts private share for M's key_id_1:
   - Computes: `shared_secret = make_shared_secret(H.kex_private_key, Point::identity())`
   - Result: `Point::identity()` compressed to predictable bytes
   - ANSI X9.63 derives encryption key from predictable input
5. M (or any observer) computes the same predictable encryption key
6. M sends `DkgPrivateShares` encrypted with wrong/manipulated shares
7. H attempts decryption using predictable key, resulting in:
   - Decryption failure, OR
   - Successful decryption but polynomial validation failure at line 728
8. H generates `BadPrivateShare` complaint
9. Coordinator processes complaint, confirms M is malicious
10. DKG round fails, restart required without M

**Expected vs Actual Behavior:**

Expected: ECDH shared secret should be unpredictable and known only to parties with the corresponding private keys.

Actual: When `public_key` is `Point::identity()`, the shared secret is predictable: `SHA256(identity_compressed || 0x00000001 || "DH_SHARED_SECRET_KEY/")`, which any party can compute.

**Reproduction:**
Implement a malicious signer that sends `Point::identity()` as `kex_public_key` in `DkgPublicShares`. Observe that the DKG round fails with `BadPrivateShare` complaints, requiring restart and exclusion of the malicious signer.

### Citations

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1076)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
```

**File:** src/state_machine/signer/mod.rs (L1083-1086)
```rust
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/state_machine/coordinator/fire.rs (L681-730)
```rust
                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

```

**File:** src/net.rs (L149-149)
```rust
    pub kex_public_key: Point,
```
