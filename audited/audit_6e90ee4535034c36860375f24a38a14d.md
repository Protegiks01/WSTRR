### Title
Missing Signer ID Validation in Signature Aggregation Enables Denial of Service

### Summary
The `compute_intermediate()` function and aggregation methods in both v1 and v2 do not validate that signer IDs match the expected set of participating signers established during the nonce phase. Instead, they extract IDs directly from signature shares without verification, allowing a malicious coordinator to cause valid signatures to fail verification by manipulating these IDs, resulting in a denial of service.

### Finding Description

**Exact Code Locations:**

In `src/traits.rs`, the `compute_intermediate()` trait method signature shows it accepts `signer_ids` as a parameter but performs no validation: [1](#0-0) 

The v1 implementation ignores the `signer_ids` parameter entirely (note the underscore prefix): [2](#0-1) 

The v2 implementation uses `signer_ids` but still performs no validation: [3](#0-2) 

**Critical vulnerability in aggregation:** Both v1 and v2 aggregators extract signer/party IDs directly from signature shares without validating they match the expected participants:

v1 Aggregator: [4](#0-3) 

v1 check_signature_shares: [5](#0-4) 

v2 Aggregator: [6](#0-5) 

v2 check_signature_shares: [7](#0-6) 

**Root Cause:**
The underlying `compute::intermediate()` function computes binding values based on the provided party IDs without any validation: [8](#0-7) 

The binding values `rho_i = binding(&id(i), nonces, msg)` MUST use the same party IDs that signers used when computing their signature shares. If different IDs are used during aggregation, the binding values will be incorrect, causing signature verification to fail.

**Why Existing Mitigations Fail:**
The coordinator validates that signature share responses come from expected signers but does NOT validate that the `SignatureShare.id` fields within those responses match: [9](#0-8) 

The coordinator checks `signer_id` in the response envelope but never validates the `id` field inside each `SignatureShare` object: [10](#0-9) 

### Impact Explanation

**Specific Harm:**
A malicious coordinator can manipulate the `SignatureShare.id` fields before aggregation, causing the aggregator to compute incorrect binding values. This makes valid signature shares fail verification, preventing transaction confirmation.

**Quantified Impact:**
- Valid signatures are rejected, blocking legitimate transactions
- Affects all signature operations (FROST, Schnorr, Taproot)
- Can target specific messages or cause systematic DoS
- Does NOT allow invalid signatures to be accepted (cannot bypass threshold or forge signatures)

**Who is Affected:**
Any system relying on WSTS for threshold signatures where the coordinator could be compromised or malicious, including Stacks blockchain nodes using WSTS for multi-sig operations.

**Severity Justification:**
This maps to **Low severity** per the protocol scope: "Any remotely-exploitable denial of service in a node". The attack prevents valid transactions from being signed but cannot cause invalid transaction confirmation, chain splits, or fund loss.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Malicious or compromised coordinator with ability to modify signature shares before aggregation
- OR network attacker capable of manipulating messages (though message authentication should prevent this if enabled)

**Attack Complexity:**
Low - the coordinator simply modifies `SignatureShare.id` fields in memory before calling aggregator methods.

**Economic Feasibility:**
High - no special resources required beyond coordinator compromise.

**Detection Risk:**
Medium - signatures fail verification which is detectable, but may appear as legitimate failures.

**Estimated Probability:**
Medium - requires coordinator compromise, which depends on the deployment's security model.

### Recommendation

**Primary Fix:**
Add validation in aggregation methods to verify signature share IDs match the expected participants from the nonce phase. Store the expected signer ID set during nonce collection and validate against it during aggregation:

```rust
// In Aggregator::sign_with_tweak and check_signature_shares
fn sign_with_tweak(
    &mut self,
    msg: &[u8],
    nonces: &[PublicNonce],
    sig_shares: &[SignatureShare],
    expected_signer_ids: &[u32], // Add this parameter
    tweak: Option<Scalar>,
) -> Result<(Point, Signature), AggregatorError> {
    // Extract IDs from shares
    let actual_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
    
    // Validate they match expected set
    if actual_ids.len() != expected_signer_ids.len() {
        return Err(AggregatorError::InvalidSignerIds);
    }
    for id in &actual_ids {
        if !expected_signer_ids.contains(id) {
            return Err(AggregatorError::UnexpectedSignerId(*id));
        }
    }
    
    // Continue with existing logic...
}
```

**Alternative Mitigation:**
The coordinator should validate `SignatureShare.id` matches `SignatureShareResponse.signer_id` when collecting shares: [11](#0-10) 

Add validation here to ensure each share's ID matches the response's signer_id.

**Testing Recommendations:**
- Add unit tests with manipulated signature share IDs
- Test that aggregation rejects mismatched IDs
- Add integration tests simulating malicious coordinator

### Proof of Concept

**Exploitation Steps:**

1. Honest signers participate in nonce phase with IDs {1, 2, 3}
2. Coordinator sends `SignatureShareRequest` with those nonce responses
3. Signers compute shares using party_ids {1, 2, 3} and create `SignatureShare` objects with their respective IDs
4. Malicious coordinator modifies one signature share: changes `sig_shares[0].id` from 1 to 4
5. Aggregator calls `compute::intermediate(msg, &[4, 2, 3], nonces)` 
6. Binding value for first signer is computed as `binding(&id(4), nonces, msg)` instead of `binding(&id(1), nonces, msg)`
7. This doesn't match the binding used when the signer computed their share
8. Aggregate signature verification fails

**Expected vs Actual Behavior:**
- Expected: Aggregator uses IDs {1, 2, 3} matching what signers used
- Actual: Aggregator uses manipulated IDs {4, 2, 3}, causing binding mismatch

**Reproduction:**
Modify coordinator code at: [12](#0-11) 

Before passing to aggregator, mutate: `shares[0].id = 999;`
The resulting signature will fail verification despite all signers being honest.

### Citations

**File:** src/traits.rs (L110-115)
```rust
    fn compute_intermediate(
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> (Vec<Point>, Point);
```

**File:** src/v1.rs (L325-326)
```rust
        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &signers, nonces);
```

**File:** src/v1.rs (L372-373)
```rust
        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (Rs, R) = compute::intermediate(msg, &signers, nonces);
```

**File:** src/v1.rs (L687-694)
```rust
    fn compute_intermediate(
        msg: &[u8],
        _signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> (Vec<Point>, Point) {
        compute::intermediate(msg, key_ids, nonces)
    }
```

**File:** src/v2.rs (L308-309)
```rust
        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &party_ids, nonces);
```

**File:** src/v2.rs (L359-360)
```rust
        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (Rs, R) = compute::intermediate(msg, &party_ids, nonces);
```

**File:** src/v2.rs (L635-642)
```rust
    fn compute_intermediate(
        msg: &[u8],
        signer_ids: &[u32],
        _key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> (Vec<Point>, Point) {
        compute::intermediate(msg, signer_ids, nonces)
    }
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** src/state_machine/coordinator/fire.rs (L1015-1025)
```rust
        let waiting = response_info
            .sign_wait_signer_ids
            .contains(&sig_share_response.signer_id);

        if !waiting {
            warn!(
                "Sign round {} SignatureShareResponse for round {} from signer {} not in the wait list",
                self.current_sign_id, sig_share_response.sign_id, sig_share_response.signer_id,
            );
            return Ok(());
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1131-1135)
```rust
            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/common.rs (L213-220)
```rust
pub struct SignatureShare {
    /// The ID of the party
    pub id: u32,
    /// The party signature
    pub z_i: Scalar,
    /// The key IDs of the party
    pub key_ids: Vec<u32>,
}
```
