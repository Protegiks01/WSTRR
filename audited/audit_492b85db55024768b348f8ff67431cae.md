### Title
DKG Participant Manipulation via Timeout and Network Attack

### Summary
When `dkg_threshold` is met but not all signers have responded during the `DkgPublicGather` phase, the coordinator proceeds with only the responding signers without validating that non-responding signers were legitimately unavailable. An attacker who has compromised `dkg_threshold` worth of signers and can perform network-level attacks (DDoS, packet filtering) against honest signers can force the DKG to complete with only compromised participants, gaining complete control of the resulting aggregate signing key rather than just threshold participation.

### Finding Description

**Code Location:** [1](#0-0) 

The timeout handling in `process_timeout()` for `State::DkgPublicGather` checks if `dkg_threshold` is met and proceeds if true, without any validation that excluded signers were legitimately unavailable versus being actively blocked by network attacks.

**Root Cause:**

The coordinator proceeds with a reduced participant set when the threshold is met: [2](#0-1) 

After timeout, only responding signers are included in subsequent DKG phases: [3](#0-2) 

The participant list from `DkgPrivateBegin` is accepted by signers without validation: [4](#0-3) 

Signers only expect shares from the reduced participant list: [5](#0-4) 

**Why Existing Mitigations Fail:**

1. No validation that timeouts were caused by legitimate unavailability versus network attacks
2. No minimum signer diversity or participation requirements beyond `dkg_threshold`
3. Signers do not validate or reject reduced participant lists; they accept whatever list the coordinator provides
4. No out-of-band verification mechanism to confirm DKG participants
5. The `dkg_threshold` feature is designed for fault tolerance but lacks security validation against selective exclusion attacks

### Impact Explanation

**Specific Harm:**

An attacker who successfully executes this attack gains complete control of the aggregate signing key, allowing them to:
- Sign arbitrary transactions without cooperation from honest signers
- Bypass threshold signature security entirely
- Cause direct loss of funds by signing unauthorized transfers
- Confirm invalid transactions

**Quantified Impact:**

If the system manages a multi-signature wallet or blockchain signing (as in Stacks):
- Complete loss of threshold security guarantees
- All funds controlled by the compromised key are at risk
- Invalid transactions can be confirmed with properly formatted signatures
- No detection possible through signature verification alone

**Who Is Affected:**

- All parties relying on the threshold signature system's security
- Fund holders whose assets are protected by the compromised aggregate key
- Network participants who assume threshold security holds

**Severity Justification:**

This maps to **Critical** severity under the protocol scope:
- "Any confirmation of an invalid transaction" - Attacker can sign arbitrary invalid transactions
- "Any causing the direct loss of funds" - Complete control of signing key enables fund theft

### Likelihood Explanation

**Required Attacker Capabilities:**

1. **Signer Compromise**: Attacker must compromise M signers where the sum of their `key_ids` ≥ `dkg_threshold`
2. **Network Attack Capability**: Ability to perform DDoS, BGP hijacking, or packet filtering against specific signer nodes
3. **Timing Control**: Ability to sustain network attacks for the duration of `dkg_public_timeout`

**Attack Complexity:**

The attack requires sophisticated capabilities but is technically feasible:
- Signer compromise is the highest barrier (social engineering, software vulnerabilities, supply chain attacks)
- Network-level attacks are within reach of well-resourced attackers (nation-states, organized crime)
- Timing is relatively straightforward once network position is achieved

**Economic Feasibility:**

For high-value targets (e.g., blockchain signing keys controlling significant funds), the attack becomes economically rational:
- Cost of compromising threshold signers varies by security posture (estimated $10K-$1M+ per signer)
- Network attack infrastructure costs $10K-$100K depending on scale
- If target controls >$10M in funds, attack ROI is positive

**Detection Risk:**

Detection is difficult:
- Network attacks may appear as legitimate network issues
- Coordinator logs would show timeout but not distinguish attack from genuine unavailability
- Excluded honest signers would eventually notice but cannot prove malicious exclusion
- Resulting signatures are cryptographically valid

**Estimated Probability:**

- For well-secured, high-value deployments: Low but non-zero (1-5% over deployment lifetime)
- For lower-security deployments: Moderate (10-20%)
- Prerequisites are high but not insurmountable for sophisticated attackers

### Recommendation

**Primary Fix:**

Implement participant validation and minimum diversity requirements:

```rust
// In process_timeout() for DkgPublicGather
if self.config.dkg_threshold > dkg_size {
    // existing error path
} else {
    // NEW: Check minimum participation ratio
    let participation_ratio = (dkg_size as f64) / (self.config.num_keys as f64);
    if participation_ratio < self.config.min_dkg_participation_ratio {
        error!("DKG participation too low ({:.2}%), possible network attack", 
               participation_ratio * 100.0);
        return Ok((None, Some(OperationResult::DkgError(
            DkgError::InsufficientParticipation(wait)
        ))));
    }
    
    // NEW: Log excluded signers for monitoring
    warn!("Proceeding with partial DKG: {} of {} keys", dkg_size, self.config.num_keys);
    for excluded_id in &self.dkg_wait_signer_ids {
        warn!("Signer {} excluded from DKG", excluded_id);
    }
    
    // existing success path
}
```

Add configuration field: [6](#0-5) 

```rust
pub struct Config {
    // existing fields...
    
    /// Minimum ratio of keys that must participate in DKG (0.0 to 1.0)
    /// Recommended: 0.8 (80%) to prevent selective exclusion attacks
    pub min_dkg_participation_ratio: f64,
}
```

**Alternative Mitigations:**

1. **Signer-side validation**: Have signers validate and optionally reject `DkgPrivateBegin` messages with unexpectedly low participant counts
2. **Out-of-band verification**: Implement secondary communication channel for signers to confirm DKG participants
3. **Attestation mechanism**: Require network health attestations from excluded signers before proceeding
4. **Disable fault tolerance**: Set `dkg_threshold = num_keys` to require all signers (trades availability for security)

**Testing Recommendations:**

1. Unit test: Verify that low participation ratio triggers error
2. Integration test: Simulate network partition and verify detection
3. Adversarial test: Attempt selective exclusion and verify rejection
4. Monitor production logs for patterns of excluded signers

**Deployment Considerations:**

- Choose `min_dkg_participation_ratio` based on expected network reliability (recommend 0.75-0.9)
- Deploy with monitoring alerts for partial DKG completions
- Document the security/availability tradeoff for operators
- Consider gradual rollout with conservative ratio first

### Proof of Concept

**Exploitation Steps:**

1. **Setup (Attacker Prerequisites)**
   - Compromise 3 signers controlling 10 key_ids total
   - Configure coordinator with: `dkg_threshold = 10`, `num_keys = 15`, `dkg_public_timeout = 30s`
   - Position network attack infrastructure (DDoS or packet filter)

2. **Execution**
   ```
   T=0s:  Coordinator broadcasts DkgBegin to all 10 signers
   T=1s:  Compromised signers (3) send DkgPublicShares
   T=1s:  Attacker activates network attack against 7 honest signers
   T=2-29s: Honest signers' DkgPublicShares blocked/delayed
   T=30s: Coordinator timeout fires
   ```

3. **Coordinator Logic** [7](#0-6) 
   ```
   dkg_size = compute_dkg_public_size() = 10 (from 3 compromised signers)
   dkg_threshold = 10
   Check: dkg_threshold > dkg_size? → 10 > 10? → FALSE
   Result: Proceed with only 3 compromised signers
   ```

4. **Subsequent Phases**
   - `DkgPrivateBegin` sent with only 3 signer_ids [8](#0-7) 
   - Private shares exchanged only among compromised signers
   - `DkgEnd` completes with aggregate key from only compromised signers [9](#0-8) 

5. **Result Verification**
   - Aggregate public key = sum of only compromised signers' polynomial constants
   - Attacker has complete control (all secret shares known)
   - Can sign arbitrary messages: `signature = sign(aggregate_key, message)`
   - Signatures verify correctly but security is completely compromised

**Expected vs Actual Behavior:**

- **Expected**: DKG should fail or wait for sufficient signer diversity
- **Actual**: DKG proceeds with reduced participant set, no validation of exclusion legitimacy

**Reproduction Instructions:**

1. Set up coordinator with `dkg_threshold < num_keys`
2. Configure firewall rules to block traffic from subset of signers
3. Initiate DKG and observe timeout behavior
4. Verify DKG completes with only non-blocked signers
5. Examine aggregate key composition (will include only non-blocked signers)

### Citations

**File:** src/state_machine/coordinator/fire.rs (L78-102)
```rust
                if let Some(start) = self.dkg_public_start {
                    if let Some(timeout) = self.config.dkg_public_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_public_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPublicTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.public_shares_gathered()?;
                                let packet = self.start_private_shares()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L420-446)
```rust
    pub fn start_private_shares(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_public_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting Private Share Distribution"
        );

        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
        let dkg_private_begin_msg = Packet {
            sig: dkg_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgPrivateBegin"),
            msg: Message::DkgPrivateBegin(dkg_begin),
        };
        self.move_to(State::DkgPrivateGather)?;
        self.dkg_private_start = Some(Instant::now());
        Ok(dkg_private_begin_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L802-807)
```rust
        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```

**File:** src/state_machine/signer/mod.rs (L685-710)
```rust
    pub fn can_dkg_end(&self) -> bool {
        debug!(
            "can_dkg_end: state {:?} DkgPrivateBegin {} DkgEndBegin {}",
            self.state,
            self.dkg_private_begin_msg.is_some(),
            self.dkg_end_begin_msg.is_some(),
        );

        if self.state == State::DkgPrivateGather {
            if let Some(dkg_private_begin) = &self.dkg_private_begin_msg {
                // need public shares from active signers
                for signer_id in &dkg_private_begin.signer_ids {
                    if !self.dkg_public_shares.contains_key(signer_id) {
                        debug!("can_dkg_end: false, missing public shares from signer {signer_id}");
                        return false;
                    }
                }

                if let Some(dkg_end_begin) = &self.dkg_end_begin_msg {
                    // need private shares from active signers
                    for signer_id in &dkg_end_begin.signer_ids {
                        if !self.dkg_private_shares.contains_key(signer_id) {
                            debug!("can_dkg_end: false, missing private shares from signer {signer_id}");
                            return false;
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L892-913)
```rust
    fn dkg_private_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_begin: &DkgPrivateBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let mut private_shares = DkgPrivateShares {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            shares: Vec::new(),
        };
        let mut active_key_ids = HashSet::new();
        for signer_id in &dkg_private_begin.signer_ids {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
                for key_id in key_ids {
                    active_key_ids.insert(*key_id);
                }
            }
        }

        self.dkg_private_begin_msg = Some(dkg_private_begin.clone());
        self.move_to(State::DkgPrivateDistribute)?;
```

**File:** src/state_machine/coordinator/mod.rs (L133-158)
```rust
pub struct Config {
    /// total number of signers
    pub num_signers: u32,
    /// total number of keys
    pub num_keys: u32,
    /// threshold of keys needed to form a valid signature
    pub threshold: u32,
    /// threshold of keys needed to complete DKG (must be >= threshold)
    pub dkg_threshold: u32,
    /// private key used to sign network messages
    pub message_private_key: Scalar,
    /// timeout to gather DkgPublicShares messages
    pub dkg_public_timeout: Option<Duration>,
    /// timeout to gather DkgPrivateShares messages
    pub dkg_private_timeout: Option<Duration>,
    /// timeout to gather DkgEnd messages
    pub dkg_end_timeout: Option<Duration>,
    /// timeout to gather nonces
    pub nonce_timeout: Option<Duration>,
    /// timeout to gather signature shares
    pub sign_timeout: Option<Duration>,
    /// the public keys and key_ids for all signers
    pub public_keys: PublicKeys,
    /// whether to verify the signature on Packets
    pub verify_packet_sigs: bool,
}
```
