# Audit Report

## Title
Unvalidated Private Shares Included in DKG Key Derivation

## Summary
The `Party::compute_secret()` function in both v1 and v2 implementations contains a critical logic flaw where private shares lacking corresponding public commitments are included in the final private key computation instead of being rejected. This breaks the Verifiable Secret Sharing (VSS) property of DKG, resulting in a group private key that is inconsistent with the group public key, causing all subsequent signatures to fail verification.

## Finding Description

The vulnerability exists in the private share validation logic of the DKG key derivation process:

**In v1.rs `Party::compute_secret()`:** [1](#0-0) 

When iterating through private shares, if a share has no corresponding public commitment in `public_shares`, the code logs a warning at line 197 but does NOT add the sender to `bad_shares`. Subsequently, line 205 sums ALL values from `private_shares`, including those that were never validated against public commitments.

**In v2.rs `Party::compute_secret()`:** [2](#0-1) 

The same flaw exists where unvalidated shares trigger a warning at line 174 but are still summed at line 191 via `shares.values().sum()`.

**Attack Vector Through State Machine:**

The vulnerability is exploitable through the DKG flow when there's a mismatch between which signers send shares to the coordinator versus honest signers:

1. In FireCoordinator, the `DkgEndBegin` message's `signer_ids` field contains only signers from which the coordinator received `DkgPrivateShares`: [3](#0-2) 

2. When honest signers process `DkgEndBegin`, they only add commitments for signers in the `signer_ids` list: [4](#0-3) 

3. However, `compute_secrets` is called with ALL `decrypted_shares` that were received and decrypted earlier: [5](#0-4) 

4. Private shares are decrypted and stored regardless of whether the sender is later included in the final signer set: [6](#0-5) 

If an attacker broadcasts `DkgPrivateShares` to honest signers but the coordinator doesn't receive them (due to network issues, timeouts, or selective delivery), the coordinator will exclude the attacker from `DkgEndBegin.signer_ids`. Honest signers will then have the attacker's decrypted shares but no corresponding commitments, triggering the vulnerability.

## Impact Explanation

This vulnerability breaks the fundamental VSS property that ensures all shares are verifiable against public commitments. The resulting inconsistency is:

- **Group public key** = sum of polynomial constants from commitments (excluding attacker)
- **Group private key** = sum of all private shares (including attacker's unvalidated shares)

Since the private key doesn't correspond to the public key, any signature generated using this key will fail verification. The cryptographic equation `z*G = R + c*P` (where P is the public key) will not hold.

This maps to **Medium** severity: "Any transient consensus failures" - the DKG appears to succeed but produces unusable keys, causing temporary inability to sign transactions until a new DKG round is performed. All honest parties that participated in the compromised DKG round are affected.

## Likelihood Explanation

The attack requires:
1. A malicious signer participating in DKG (within threat model of up to threshold-1)
2. Network conditions where the malicious signer's `DkgPrivateShares` reaches honest signers but not the coordinator
3. Knowledge of DKG protocol timing

In a P2P network deployment, selective message delivery can occur through:
- Natural network partitions, packet loss, or timeouts
- Malicious control of network routing at the P2P layer
- Coordinator-side filtering or validation differences

The attack is undetectable during DKG execution (DkgEnd shows "Success") and only manifests when signatures fail verification in subsequent signing rounds, making attribution difficult.

**Likelihood Assessment:** Medium-High - The prerequisites are achievable for a motivated attacker with network-level access within RPC/P2P channels, and the attack can be repeated with low cost.

## Recommendation

The code should explicitly reject and return an error when private shares lack corresponding public commitments, rather than just logging a warning:

**For v1.rs (lines 191-205):**
```rust
let mut bad_shares = Vec::new();
for (i, s) in private_shares.iter() {
    if let Some(comm) = public_shares.get(i) {
        if s * G != compute::poly(&self.id(), &comm.poly)? {
            bad_shares.push(*i);
        }
    } else {
        // FIXED: Add to bad_shares instead of just warning
        warn!("private share from {} has no corresponding public commitment", i);
        bad_shares.push(*i);
    }
}
```

**For v2.rs (lines 165-186):** Apply the same fix - add the sender to `bad_shares` when no corresponding public commitment exists.

Additionally, consider adding validation in the state machine's `dkg_ended()` to ensure `decrypted_shares` and `commitments` have matching key sets before calling `compute_secrets`.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create a DKG setup with multiple signers
2. Have one signer's shares stored in a victim's `decrypted_shares`
3. Call `compute_secret()` with these shares but WITHOUT including that signer's commitment in `public_shares`
4. Observe that the function returns Ok() and includes the unvalidated shares in the final key
5. Verify that signatures using this key fail verification

The test would directly call `Party::compute_secret()` with mismatched `private_shares` and `public_shares` maps to demonstrate that unvalidated shares are incorrectly included in the final key derivation.

### Citations

**File:** src/v1.rs (L191-205)
```rust
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
            } else {
                warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", i);
            }
        }

        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }

        self.private_key = private_shares.values().sum();
```

**File:** src/v2.rs (L165-199)
```rust
        let mut bad_shares = Vec::new();
        for key_id in &self.key_ids {
            if let Some(shares) = private_shares.get(key_id) {
                for (sender, s) in shares {
                    if let Some(comm) = public_shares.get(sender) {
                        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
                            bad_shares.push(*sender);
                        }
                    } else {
                        warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", sender);
                    }
                }
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }
        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }

        for key_id in &self.key_ids {
            self.private_keys.insert(*key_id, Scalar::zero());
            if let Some(shares) = private_shares.get(key_id) {
                let secret = shares.values().sum();
                self.private_keys.insert(*key_id, secret);
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }
```

**File:** src/state_machine/coordinator/fire.rs (L448-475)
```rust
    /// Ask signers to compute shares and send DKG end
    pub fn start_dkg_end(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting DkgEnd Distribution"
        );

        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
        let dkg_end_begin_msg = Packet {
            sig: dkg_end_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgPrivateBegin"),
            msg: Message::DkgEndBegin(dkg_end_begin),
        };
        self.move_to(State::DkgEndGather)?;
        self.dkg_end_start = Some(Instant::now());
        Ok(dkg_end_begin_msg)
    }
```

**File:** src/state_machine/signer/mod.rs (L551-566)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L611-616)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
```

**File:** src/state_machine/signer/mod.rs (L1072-1102)
```rust
        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
```
