### Title
Nonce Reuse in ID Proof Generation Leaks Polynomial Secret via Deterministic RNG

### Summary
The `ID::new()` function generates Schnorr ID proofs using a random nonce without any safeguards against RNG state reuse. If an application uses a deterministically seeded RNG with the same seed across multiple DKG rounds, the same nonce will be generated with the same polynomial constant but different contexts (dkg_id), allowing an attacker to algebraically extract the secret polynomial constant through challenge equation solving.

### Finding Description

**Code Location:** [1](#0-0) 

The `ID::new()` function generates a Schnorr proof of knowledge for the polynomial constant `a`:
- Line 37: `let k = Scalar::random(rng)` generates the nonce
- Line 38: `let c = Self::challenge(id, &(&k * &G), &(a * &G), ctx)` computes challenge with context
- Line 43: `kca: &k + c * a` computes the response

**Root Cause:**

The nonce `k` is generated using `Scalar::random(rng)` which directly consumes randomness from the provided RNG. If an application uses a deterministically seeded RNG (e.g., `ChaCha20Rng::from_seed(seed)`) and reseeds with the same seed across multiple DKG rounds, the entire random sequence repeats.

**Attack Flow:** [2](#0-1) 

The signer's `reset()` function is called at the start of each DKG round:
- Line 424: `self.signer.reset_polys(rng)` regenerates polynomial with same RNG
- Line 429: `self.kex_private_key = Scalar::random(rng)` consumes more randomness [3](#0-2) 

Then `dkg_begin()` calls:
- Line 849: `self.reset(dkg_begin.dkg_id, rng)` 
- Line 854: `self.dkg_public_begin(rng)` [4](#0-3) 

Which leads to:
- Line 864: `self.signer.get_poly_commitments(&self.dkg_id.to_be_bytes(), rng)` using `dkg_id` as context [5](#0-4) 

Finally, for each party:
- Line 114: `ID::new(&self.id(), &poly.data()[0], ctx, rng)` generates the ID proof

If the RNG is reseeded identically for DKG round 2, the same polynomial coefficient `a` and nonce `k` are regenerated, but with different `dkg_id` in the context.

**Why Existing Mitigations Fail:** [6](#0-5) 

The documentation mentions RNG requirements but provides no warnings about:
- Nonce reuse risks across DKG rounds
- Dangers of deterministic seeding with repeated seeds
- Requirements for fresh entropy per DKG round

The protocol provides no runtime checks to detect or prevent RNG state reuse.

### Impact Explanation

**Specific Harm:**

An attacker who observes two `DkgPublicShares` messages from different DKG rounds can extract the secret polynomial constant `a`:

Given two ID proofs with the same nonce `k` but different contexts:
- Proof 1: `kca₁ = k + c₁·a` where `c₁ = challenge(id, k·G, a·G, dkg_id₁)`
- Proof 2: `kca₂ = k + c₂·a` where `c₂ = challenge(id, k·G, a·G, dkg_id₂)`

Since `k·G` is public and `c₁ ≠ c₂` (different dkg_id):
- `a = (kca₂ - kca₁) / (c₂ - c₁)`

**Quantified Impact:**

The polynomial constant `a` (the first coefficient `poly.data()[0]`) is the party's secret contribution to the group public key. Leaking this value:

1. **Violates zero-knowledge property**: The ID proof is supposed to prove knowledge of `a` without revealing it
2. **Enables key share reconstruction**: If t-1 polynomial constants are leaked (where t is the threshold), an attacker can reconstruct the group secret key
3. **Consensus impact**: Compromised key material could lead to forged signatures, invalid transaction confirmations, or transient consensus failures

**Who is Affected:**

Any application using WSTS that:
- Uses deterministic RNG seeding for testing/reproducibility
- Has bugs causing RNG state reuse
- Clones/saves RNG state across DKG rounds

**Severity Justification:**

Medium severity - while this doesn't directly cause critical impacts, it leaks cryptographic secrets that could enable consensus failures if multiple parties are affected. The attack requires application-level misconfiguration but is realistic in testing environments and could propagate to production.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Passive network observer (can see `DkgPublicShares` messages)
- No access to private keys or RNG state needed
- Simple algebraic computation to extract secret

**Prerequisites:**
1. Target application uses deterministically seeded RNG (e.g., `ChaCha20Rng::from_seed()`)
2. Application reseeds with the same seed for multiple DKG rounds
3. At least two DKG rounds occur with the vulnerable configuration

**Attack Complexity:**

Low - the attack is straightforward:
1. Capture `DkgPublicShares` from round N and round N+1
2. Extract `kG`, `kca₁`, `kca₂` from the ID proofs
3. Compute challenges `c₁` and `c₂` using public information
4. Solve for `a = (kca₂ - kca₁) / (c₂ - c₁)`

**Economic Feasibility:**

Minimal cost - requires only:
- Network observation capability
- Basic computational resources for scalar arithmetic
- No significant infrastructure or resources

**Detection Risk:**

Very low - the attack is entirely passive observation and offline computation. No suspicious activity is visible to the target.

**Probability Assessment:**

- **In Production**: Low (assuming proper RNG usage with `OsRng`)
- **In Testing**: Medium to High (deterministic seeding is common for reproducibility)
- **Risk of Production Propagation**: Medium (testing code/patterns sometimes reach production)

### Recommendation

**Primary Fix - Deterministic Nonce Generation:**

Implement deterministic nonce generation for ID proofs similar to RFC 6979 for ECDSA signatures:

```rust
// In src/schnorr.rs, ID::new()
pub fn new<RNG: RngCore + CryptoRng>(
    id: &Scalar,
    a: &Scalar,
    ctx: &[u8],
    rng: &mut RNG,
) -> Self {
    // Generate nonce deterministically from (a, id, ctx)
    let mut hasher = Sha256::new();
    hasher.update("WSTS/id-proof-nonce".as_bytes());
    hasher.update(a.to_bytes());
    hasher.update(id.to_bytes());
    hasher.update(ctx);
    let k = hash_to_scalar(&mut hasher);
    
    let c = Self::challenge(id, &(&k * &G), &(a * &G), ctx);
    
    Self {
        id: *id,
        kG: &k * G,
        kca: &k + c * a,
    }
}
```

**Alternative Mitigation - Documentation:**

Add prominent warnings in USAGE.md:

```markdown
## Critical RNG Requirements

⚠️ **WARNING**: Never reuse the same RNG seed across multiple DKG rounds.
Each DKG round MUST use fresh entropy. Reusing RNG state can leak secret
polynomial constants through nonce reuse attacks on ID proofs.

For testing with deterministic RNGs, ensure each DKG round uses a unique seed:
- Include the dkg_id in the seed derivation
- Or use a counter-based seed progression
```

**Testing Recommendations:**

1. Add unit test that verifies deterministic nonce generation produces different nonces for same (id, a) with different contexts
2. Add integration test that simulates RNG reuse scenario and verifies it doesn't leak secrets (with deterministic nonce fix)
3. Fuzz test with various RNG configurations to detect nonce reuse

**Deployment Considerations:**

- If using deterministic fix: Requires protocol version bump as ID proofs change
- Must coordinate rollout across all signers
- Backward compatibility testing required
- Document migration path for existing deployments

### Proof of Concept

**Setup:**
```rust
use rand_chacha::ChaCha20Rng;
use rand_core::SeedableRng;

let seed = [42u8; 32]; // Fixed seed
let id = Scalar::from(1u32);
let a = Scalar::from(12345u32); // Secret polynomial constant
```

**Round 1:**
```rust
let mut rng1 = ChaCha20Rng::from_seed(seed);
// Simulate reset_polys + other randomness consumption
let _ = Scalar::random(&mut rng1); // polynomial coefficient
let _ = Scalar::random(&mut rng1); // kex_private_key

let ctx1 = 1u64.to_be_bytes(); // dkg_id = 1
let proof1 = ID::new(&id, &a, &ctx1, &mut rng1);
```

**Round 2 with same seed:**
```rust
let mut rng2 = ChaCha20Rng::from_seed(seed); // SAME SEED
let _ = Scalar::random(&mut rng2); // Same sequence
let _ = Scalar::random(&mut rng2);

let ctx2 = 2u64.to_be_bytes(); // dkg_id = 2 (different context)
let proof2 = ID::new(&id, &a, &ctx2, &mut rng2);
```

**Extraction:**
```rust
// Attacker observes: proof1.kG, proof1.kca, proof2.kca
assert_eq!(proof1.kG, proof2.kG); // Same nonce commitment

let c1 = ID::challenge(&id, &proof1.kG, &(a * G), &ctx1);
let c2 = ID::challenge(&id, &proof2.kG, &(a * G), &ctx2);

// Solve for a:
// kca2 - kca1 = (c2 - c1) * a
// a = (kca2 - kca1) / (c2 - c1)
let extracted_a = (proof2.kca - proof1.kca) / (c2 - c1);

assert_eq!(extracted_a, a); // SECRET LEAKED!
```

**Expected vs Actual:**
- **Expected**: ID proofs are zero-knowledge, reveal nothing about `a`
- **Actual**: With RNG reuse, two proofs leak `a` through nonce reuse

**Reproduction:**
1. Create integration test with the above code
2. Run with same seed across two DKG rounds
3. Verify that `extracted_a == a`
4. Apply deterministic nonce fix
5. Verify that nonces differ even with same RNG seed

### Citations

**File:** src/schnorr.rs (L31-45)
```rust
    pub fn new<RNG: RngCore + CryptoRng>(
        id: &Scalar,
        a: &Scalar,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Self {
        let k = Scalar::random(rng);
        let c = Self::challenge(id, &(&k * &G), &(a * &G), ctx);

        Self {
            id: *id,
            kG: &k * G,
            kca: &k + c * a,
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/signer/mod.rs (L857-865)
```rust
    fn dkg_public_begin<R: RngCore + CryptoRng>(
        &mut self,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let comms = self
            .signer
            .get_poly_commitments(&self.dkg_id.to_be_bytes(), rng);

```

**File:** src/v1.rs (L107-123)
```rust
    pub fn get_poly_commitment<RNG: RngCore + CryptoRng>(
        &self,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Option<PolyCommitment> {
        if let Some(poly) = &self.f {
            Some(PolyCommitment {
                id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
                poly: (0..poly.data().len())
                    .map(|i| &poly.data()[i] * G)
                    .collect(),
            })
        } else {
            warn!("get_poly_commitment called with no polynomial");
            None
        }
    }
```

**File:** USAGE.md (L8-32)
```markdown
To ensure flexibility, these state machines require the user to provide a random number generator (RNG) that implements the `RngCore` and `CryptoRng` traits.

### Providing an RNG

You can use the following RNG implementations:

- **Operating System RNG (`OsRng`)**
  
  ```rust
  use rand_core::OsRng;

  let mut rng = OsRng;
  ```

- **ChaCha20 RNG**
  
  ```rust
  use rand_chacha::ChaCha20Rng;

  let mut rng = ChaCha20Rng::from_entropy();
  ```

- **Custom RNGs**

  Implement your own RNG by adhering to the `RngCore` and `CryptoRng` traits.
```
