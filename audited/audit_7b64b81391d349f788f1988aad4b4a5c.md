### Title
Unauthenticated KEX Public Key Enables Man-in-the-Middle Decryption of DKG Private Shares via Point-at-Infinity Substitution

### Summary
The `kex_public_key` field in `DkgPublicShares` messages is neither authenticated by the message signature nor validated against the point-at-infinity. A man-in-the-middle attacker can replace any participant's `kex_public_key` with all-zero bytes (representing `Point::identity()`), causing all encrypted private shares for that participant to be encrypted with a predictable, publicly-computable shared secret. This allows the attacker to decrypt private polynomial shares and, with sufficient shares, reconstruct the group private key and sign unauthorized transactions.

### Finding Description

**Root Cause 1: Missing Authentication**

The `DkgPublicShares` message signature does not include the `kex_public_key` field in its hash computation: [1](#0-0) 

The signature only authenticates `dkg_id`, `signer_id`, and polynomial commitments (`comms`), but omits `kex_public_key`. This means an attacker can modify the `kex_public_key` field without invalidating the signature.

**Root Cause 2: Missing Validation**

When processing incoming `DkgPublicShares` messages, the `kex_public_key` is stored directly without validating that it is not the point-at-infinity: [2](#0-1) 

The code performs various validation checks (signer_id existence, party_id validation, duplicate detection) but never validates that `kex_public_key != Point::identity()` or `kex_public_key != Point::new()`.

**Root Cause 3: Predictable Shared Secret from Point-at-Infinity**

The `make_shared_secret()` function performs scalar multiplication without checking if the public key is the point-at-infinity: [3](#0-2) 

When `public_key` is `Point::identity()`, the computation `private_key * public_key` yields `Point::identity()` regardless of the `private_key` value. The subsequent key derivation from `Point::identity().compress().as_bytes()` produces a constant, predictable value.

**Why Existing Mitigations Fail**

While similar validation exists for public nonces (checking `!= Point::identity()`): [4](#0-3) 

No such validation is applied to `kex_public_key` in the DKG flow. Message signature verification also fails to protect because the signature hash excludes `kex_public_key`: [5](#0-4) 

### Impact Explanation

**Specific Harm:**
A man-in-the-middle attacker who can intercept and modify network traffic can:
1. Decrypt all private polynomial shares intended for any DKG participant
2. With threshold `t` intercepted shares, reconstruct the group private key
3. Sign arbitrary transactions using the compromised group key
4. Steal all funds controlled by the group key

**Quantified Impact:**
- **Funds at Risk:** All assets controlled by any WSTS-generated key in a compromised DKG round
- **Threshold for Attack:** Attacker needs to successfully MITM `t` participants out of `n` total (e.g., 28 out of 40 in typical configuration)
- **Attack Window:** Active during DKG private share distribution phase

**Affected Parties:**
- All participants in any DKG round where attacker has MITM position
- Downstream systems (Stacks blockchain nodes) that rely on these threshold signatures for transaction validation
- Users whose funds are secured by compromised threshold keys

**Severity Justification:**
This vulnerability maps to **Critical** severity under the protocol scope:
- "Any causing the direct loss of funds other than through any form of freezing" - Attacker gains private key control enabling unauthorized fund transfers
- "Any confirmation of an invalid transaction" - Attacker can sign and broadcast transactions without legitimate authorization

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Network position: Man-in-the-middle access to observe and modify DKG network traffic between participants
2. Technical capability: Ability to deserialize/reserialize DkgPublicShares messages and replace the `kex_public_key` field with all-zero bytes
3. No cryptographic breaks required
4. No need for compromised private keys or insider access

**Attack Complexity:**
- **Low to Medium:** The attack requires only passive network interception plus active modification of a single message field
- Common MITM techniques (ARP spoofing, DNS hijacking, BGP hijacking, compromised network infrastructure) suffice
- No timing constraints beyond the DKG round duration

**Economic Feasibility:**
- For high-value targets (e.g., Stacks mining rewards, institutional custody), attackers have strong financial incentives
- MITM attacks on 28 of 40 participants could be achieved by compromising a few network intermediaries (ISPs, data centers, cloud providers)
- Cost-benefit ratio favors attack when controlled funds exceed attack costs

**Detection Risk:**
- **Low:** The modified `kex_public_key` field passes signature verification
- Honest participants see no abnormal behavior until attempting to use encrypted shares
- Decryption failures might be attributed to network errors or implementation bugs
- No cryptographic alarms trigger because the attack exploits protocol logic, not crypto primitives

**Estimated Probability:**
- **High** for well-resourced attackers targeting high-value deployments
- **Medium** for opportunistic attackers on vulnerable network infrastructure
- Probability increases with number of DKG rounds and value at stake

### Recommendation

**Primary Fix - Add Authentication:**
Include `kex_public_key` in the `DkgPublicShares` signature hash: [1](#0-0) 

Add after line 162:
```rust
hasher.update(self.kex_public_key.compress().as_bytes());
```

**Secondary Fix - Add Validation:**
Validate `kex_public_key` when processing `DkgPublicShares`: [2](#0-1) 

Add after line 1017:
```rust
// Validate kex_public_key is not the point-at-infinity
if dkg_public_shares.kex_public_key == Point::identity() || 
   dkg_public_shares.kex_public_key == Point::new() {
    warn!(%signer_id, "Invalid kex_public_key: point-at-infinity");
    return Ok(vec![]);
}
```

**Defense-in-Depth:**
Add validation in `make_shared_secret()`: [3](#0-2) 

Add check before line 49:
```rust
if public_key == &Point::identity() || public_key == &Point::new() {
    panic!("Invalid public key: point-at-infinity");
}
```

**Testing Recommendations:**
1. Unit test: Verify `DkgPublicShares` with `kex_public_key = Point::new()` is rejected
2. Unit test: Verify modified `kex_public_key` causes signature verification failure
3. Integration test: Simulate MITM attack and confirm it's detected/prevented
4. Fuzzing: Test Point deserialization with various invalid encodings (all zeros, malformed compressed points)

**Deployment Considerations:**
- **Breaking Change:** Modified signature hash is incompatible with existing deployments
- **Migration:** Coordinate upgrade across all participants before next DKG round
- **Backward Compatibility:** Consider versioning in message format to support staged rollout

### Proof of Concept

**Exploitation Steps:**

1. **Attacker Setup:**
   - Position as MITM between DKG participants
   - Monitor network for `DkgPublicShares` messages

2. **Message Interception:**
   - Honest Signer A broadcasts `DkgPublicShares` with legitimate `kex_public_key = a*G` where `a` is their private key
   - Message includes valid signature over `dkg_id`, `signer_id`, and `comms`

3. **Message Modification:**
   - Attacker deserializes `DkgPublicShares`
   - Replaces `kex_public_key` field with all-zero bytes (33 bytes: `0x00` followed by 32 zero bytes for compressed point encoding)
   - Forwards modified message to other participants

4. **Victim Processing:** [2](#0-1) 
   - Signer B receives modified message
   - Signature verification passes (kex_public_key not authenticated)
   - `Point::identity()` is stored as A's kex_public_key

5. **Share Encryption:** [6](#0-5) 
   - Signer B encrypts private share for Signer A
   - Computes: `shared_secret = make_shared_secret(b, Point::identity())`
   - Result: `shared_key = b * Point::identity() = Point::identity()`
   - Derives: `shared_secret = ansi_x963_derive_key(Point::identity().compress().as_bytes(), "DH_SHARED_SECRET_KEY/")`
   - This produces a **constant predictable value** independent of `b`

6. **Attacker Decryption:**
   - Attacker computes same constant: `ansi_x963_derive_key(Point::identity().compress().as_bytes(), "DH_SHARED_SECRET_KEY/")`
   - Uses this to decrypt AES-256-GCM ciphertext
   - Recovers Scalar representing private polynomial evaluation

7. **Key Reconstruction:**
   - Repeat for threshold `t` participants
   - Use Lagrange interpolation to reconstruct group private key
   - Sign arbitrary transactions

**Expected vs Actual Behavior:**

*Expected:* Encrypted shares should only be decryptable by the holder of the corresponding `kex_private_key`.

*Actual:* When `kex_public_key = Point::identity()`, encrypted shares are decryptable by anyone who knows the constant predictable shared secret derived from `Point::identity()`.

**Reproduction Instructions:**

1. Deploy WSTS with 3 participants (threshold t=2)
2. Configure attacker as network proxy
3. Initiate DKG round
4. When participant broadcasts `DkgPublicShares`:
   - Intercept message
   - Replace `kex_public_key` bytes with compressed point-at-infinity encoding
   - Forward modified message
5. Observe encrypted private shares in `DkgPrivateShares` messages
6. Decrypt using shared secret derived from `Point::identity()`
7. Verify successful recovery of private polynomial shares

### Citations

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/net.rs (L526-538)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
```

**File:** src/state_machine/signer/mod.rs (L941-942)
```rust
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```
