### Title
Message Substitution Attack via Unvalidated Nonce Response Messages in FIRE Coordinator

### Summary
The FIRE coordinator's `gather_nonces()` function fails to validate that incoming `NonceResponse` messages contain the originally requested message, allowing malicious signers controlling ≥threshold key IDs to force the coordinator to compute binding values and produce valid threshold signatures for attacker-chosen messages instead of the intended message. This completely breaks the coordinator's control over what gets signed, enabling arbitrary message substitution attacks.

### Finding Description

**Exact Code Location:**
- File: `src/state_machine/coordinator/fire.rs`
- Primary vulnerability: `gather_nonces()` function, line 919 and line 954
- Affected computation: `compute_aggregate_nonce()` function, line 1195

**Root Cause:**
The coordinator accepts nonce responses for ANY message without validation. [1](#0-0) 

When nonces are received, they are stored in a map keyed by the nonce response's message field, with no check that this message matches `self.message` (the originally requested message). [2](#0-1) 

When any message accumulates enough nonces to meet the threshold, the coordinator overwrites `self.message` with that message: [3](#0-2) 

The coordinator then computes binding values using the substituted message: [4](#0-3) 

The binding value computation at line 1195 uses `self.message` (now the attacker's message), along with `party_ids` and `nonces` extracted from responses for that same attacker-controlled message. [5](#0-4) 

**Why Existing Mitigations Fail:**
The `gather_nonces()` function validates multiple fields but crucially NOT the message field:
- Validates `dkg_id`, `sign_id`, `sign_iter_id` [6](#0-5) 
- Validates signer_id exists in config [7](#0-6) 
- Validates key_ids match config [8](#0-7) 
- Validates nonce points are valid [9](#0-8) 
- Checks malicious signer list [10](#0-9) 

However, there is **no validation** that `nonce_response.message` equals the coordinator's expected `self.message`.

### Impact Explanation

**Specific Harm:**
A malicious coalition controlling ≥threshold key IDs can force the coordinator to produce valid threshold signatures for arbitrary attacker-chosen messages instead of the legitimate messages the coordinator intended to sign.

**Quantified Impact:**
- In Bitcoin/Stacks context: Attackers can cause signing of fraudulent transactions instead of legitimate ones
- Direct financial loss through unauthorized fund transfers
- Maps to **Critical** severity: "Any confirmation of an invalid transaction, such as with an incorrect nonce"
- Also maps to: "Any causing the direct loss of funds other than through any form of freezing"

**Who is Affected:**
- Any system using WSTS FIRE coordinator for transaction signing
- All users whose funds are controlled by affected threshold signature schemes
- Stacks blockchain operations relying on threshold signatures for consensus or asset management

**Severity Justification:**
This breaks a fundamental security invariant: "Binding values must commit to all public nonces and the exact message." While the binding values are internally consistent, they commit to the wrong message. The coordinator loses control over what gets signed, which is the core security property of any signing coordinator.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control ≥threshold of the total signing key IDs (standard weighted threshold)
- Ability to participate in the signing protocol as a legitimate signer
- Network access to send `NonceResponse` messages to the coordinator

**Attack Complexity:**
Low - the attack requires only:
1. Responding to legitimate `NonceRequest` with modified message field
2. Coordinating responses among malicious signers to reach threshold first
3. No cryptographic breaks, no timing attacks, no sophisticated exploitation

**Economic Feasibility:**
If attacker already controls ≥threshold (which is the threat model for any threshold scheme), the attack costs nothing beyond normal protocol participation.

**Detection Risk:**
Low - the attack produces valid signatures that pass all cryptographic checks. The only detection would be off-protocol monitoring of coordinator message intentions versus actual signed messages.

**Estimated Probability:**
Very High if prerequisites are met. The attack succeeds deterministically when malicious signers control ≥threshold and coordinate their responses.

### Recommendation

**Proposed Code Change:**
In `gather_nonces()` function, add validation immediately after extracting the `NonceResponse`:

```rust
// After line 846 in gather_nonces()
if let Message::NonceResponse(nonce_response) = &packet.msg {
    // ADD THIS VALIDATION:
    if nonce_response.message != self.message {
        warn!(
            signer_id = %nonce_response.signer_id,
            "Nonce response message does not match requested message"
        );
        return Ok(());
    }
    
    // ... rest of existing validation
```

**Alternative Mitigations:**
1. Remove the message field from stored nonces entirely, always use `self.message`
2. Remove line 954 that overwrites `self.message` 
3. Add assertion that all stored nonces are for `self.message` before computing aggregate nonce

**Testing Recommendations:**
1. Add unit test where malicious signer sends nonces for different message - should be rejected
2. Add integration test attempting message substitution attack - should fail
3. Verify honest flow still works with all signers responding with correct message
4. Test with mix of honest/malicious signers below threshold

**Deployment Considerations:**
- This is a breaking protocol change that will reject previously "valid" (but insecure) responses
- Deploy urgently to all FIRE coordinator instances
- Consider adding similar validation to FROST coordinator which has the same vulnerability [11](#0-10) 

### Proof of Concept

**Exploitation Algorithm:**

```
1. Setup:
   - Attacker controls signers S1, S2, ..., Sn with total key IDs ≥ threshold T
   - Honest coordinator H starts signing round for legitimate message M_legit
   
2. Coordinator sends NonceRequest:
   - H.start_signing_round(M_legit, signature_type, sign_id)
   - H broadcasts NonceRequest{message: M_legit, ...}
   
3. Malicious Response:
   - Each attacker signer Si generates valid nonces for M_attack (≠ M_legit)
   - Si sends NonceResponse{message: M_attack, nonces: [nonces for M_attack], ...}
   
4. Coordinator Processing:
   - H stores nonces in message_nonces[M_attack] (line 919)
   - When threshold T key IDs accumulated for M_attack:
     * H sets self.message = M_attack (line 954)
     * H computes binding values for M_attack (line 1195)
   
5. Signature Completion:
   - H sends SignatureShareRequest{message: M_attack, ...}
   - Attacker signers provide valid shares for M_attack
   - H aggregates into valid signature for M_attack
   
6. Result:
   - Expected: Signature for M_legit
   - Actual: Valid signature for M_attack
   - Impact: Coordinator signed attacker's message
```

**Reproduction Steps:**
1. Configure FIRE coordinator with threshold=2, total_keys=3
2. Control 2 of 3 signing key IDs as attacker
3. Initiate signing for message "transfer 1 BTC to Alice"
4. Respond with nonces for message "transfer 100 BTC to Attacker"
5. Observe coordinator produces signature for attacker's message
6. Verify signature validates correctly for attacker's message but not original message

**Expected vs Actual Behavior:**
- Expected: Coordinator rejects nonces with wrong message, waits for correct nonces, or times out
- Actual: Coordinator accepts wrong-message nonces, switches to attacker's message, produces valid signature for wrong message

### Citations

**File:** src/state_machine/coordinator/fire.rs (L847-860)
```rust
            if nonce_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(nonce_response.dkg_id, self.current_dkg_id));
            }
            if nonce_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    nonce_response.sign_id,
                    self.current_sign_id,
                ));
            }
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L863-868)
```rust
            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&nonce_response.signer_id) {
                warn!(signer_id = %nonce_response.signer_id, "No public key in config");
                return Ok(());
            };
```

**File:** src/state_machine/coordinator/fire.rs (L870-889)
```rust
            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L891-901)
```rust
            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L917-920)
```rust
            let nonce_info = self
                .message_nonces
                .entry(nonce_response.message.clone())
                .or_default();
```

**File:** src/state_machine/coordinator/fire.rs (L952-956)
```rust
            if nonce_info.nonce_recv_key_ids.len() >= self.config.threshold as usize {
                // We have a winning message!
                self.message.clone_from(&nonce_response.message);
                let aggregate_nonce = self.compute_aggregate_nonce();
                info!("Aggregate nonce: {aggregate_nonce}");
```

**File:** src/state_machine/coordinator/fire.rs (L1177-1198)
```rust
    fn compute_aggregate_nonce(&self) -> Point {
        // XXX this needs to be key_ids for v1 and signer_ids for v2
        let public_nonces = self
            .message_nonces
            .get(&self.message)
            .cloned()
            .unwrap_or_default()
            .public_nonces;
        let party_ids = public_nonces
            .values()
            .cloned()
            .flat_map(|pn| pn.key_ids)
            .collect::<Vec<u32>>();
        let nonces = public_nonces
            .values()
            .cloned()
            .flat_map(|pn| pn.nonces)
            .collect::<Vec<PublicNonce>>();
        let (_, R) = compute::intermediate(&self.message, &party_ids, &nonces);

        R
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1467-1467)
```rust
        self.message = message.to_vec();
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** src/state_machine/coordinator/frost.rs (L542-543)
```rust
            self.public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```
