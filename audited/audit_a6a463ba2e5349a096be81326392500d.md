### Title
Aggregator Threshold Mismatch in Coordinator State Loading

### Summary
The `load()` function in the FIRE coordinator reconstructs the aggregator using `state.config.threshold` without validating that this value matches the actual polynomial degree in `state.party_polynomials`. This mismatch can cause index-out-of-bounds panics or incorrect signature aggregation, leading to transient consensus failures or denial of service.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `load()` function reconstructs the coordinator from a `SavedState`, creating a new aggregator at line 1311 using `state.config.threshold`. However, the `party_polynomials` stored in the state were created during a previous DKG round with a potentially different threshold value.

**Root Cause:**
During DKG, parties generate polynomials of degree `threshold - 1` (i.e., length `threshold`): [2](#0-1) 

These polynomials are cached in `party_polynomials` during DKG completion: [3](#0-2) 

When the aggregator's `init()` method is called during signing, it allocates a polynomial vector using `self.threshold` and attempts to access each polynomial coefficient: [4](#0-3) 

At line 438, the code directly accesses `comm.poly[i]` without bounds checking. If `self.threshold` (from the loaded config) exceeds the actual polynomial length in `party_polynomials`, this will panic. If `self.threshold` is smaller than the polynomial length, only a subset of coefficients will be summed, producing an incorrect aggregate polynomial.

**Why Existing Mitigations Fail:**
- The `check_public_shares` function validates polynomial length during DKG: [5](#0-4) 

However, this validation does not occur during `load()`. The `set_key_and_party_polynomials` function only validates that the aggregate key matches the polynomials, not that the threshold matches: [6](#0-5) 

- While `get_config_mut()` is test-only, the config can still be modified through direct SavedState manipulation or application-level bugs.

### Impact Explanation

**Specific Harm:**
1. **If `config.threshold > polynomial_length`**: The aggregator initialization will panic with an index-out-of-bounds error when attempting to access `comm.poly[i]`, causing a denial of service. All signing operations will fail.

2. **If `config.threshold < polynomial_length`**: The aggregator will compute an incorrect aggregate polynomial by summing only the first `threshold` coefficients. This produces a wrong group public key (`poly[0]`), causing all signature verifications to fail: [7](#0-6) 

**Who Is Affected:**
Any coordinator instance that loads state with a threshold mismatch will be unable to complete signing operations, affecting all participants in that signing round.

**Severity Justification:**
This vulnerability causes **transient consensus failures**, which maps to **Medium severity** per the protocol scope definitions. While it does not compromise cryptographic security or allow invalid signatures to be accepted, it prevents valid signing operations from completing, disrupting protocol operation.

### Likelihood Explanation

**Required Attacker Capabilities:**
An attacker would need one of the following:
1. **Write access to persisted SavedState**: Ability to modify the serialized state before it's loaded by the coordinator
2. **Software bug exploitation**: Trigger or exploit a bug in the application using WSTS that causes the config to differ from the DKG parameters
3. **State corruption**: Exploit a vulnerability in the persistence layer to corrupt the threshold value

**Attack Complexity:**
- **Low complexity** if attacker has file system or database access to the persisted state
- **Medium complexity** if exploiting an application-level bug to cause threshold modification
- Does not require breaking cryptographic primitives

**Economic Feasibility:**
Minimal resources required if attacker has already gained system access to modify persisted state.

**Detection Risk:**
- The mismatch would be immediately detected when signing operations fail
- However, by that point, the signing round has already been disrupted
- Difficult to distinguish from other operational failures

**Estimated Probability:**
Medium likelihood in production environments with:
- Complex state persistence mechanisms
- Multiple coordinator instances with potentially different configurations
- Application bugs that modify config after DKG

### Recommendation

**Proposed Code Changes:**

Add validation in the `load()` function to verify that `config.threshold` matches the polynomial lengths in `party_polynomials`:

```rust
fn load(state: &SavedState) -> Self {
    // Validate threshold consistency with party_polynomials
    if !state.party_polynomials.is_empty() {
        for (party_id, poly_comm) in &state.party_polynomials {
            let poly_len: u32 = poly_comm.poly.len().try_into()
                .expect("Polynomial length conversion failed");
            if poly_len != state.config.threshold {
                panic!("Threshold mismatch: config.threshold={} but party {} has polynomial length={}",
                    state.config.threshold, party_id, poly_len);
            }
        }
    }
    
    Self {
        aggregator: Aggregator::new(state.config.num_keys, state.config.threshold),
        // ... rest of initialization
    }
}
```

**Alternative Mitigation:**
Add bounds checking in `Aggregator::init()` to detect and report threshold mismatches before attempting array access.

**Testing Recommendations:**
1. Create unit tests that attempt to load SavedState with mismatched threshold values
2. Verify that the validation properly catches both cases (threshold too large and too small)
3. Test save/load round-trips with threshold modifications between save and load

**Deployment Considerations:**
- This change will cause existing corrupted states to fail loudly on load rather than silently during signing
- Applications should implement state integrity verification in their persistence layer
- Consider adding checksums or signatures to SavedState to detect tampering

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Run DKG with threshold T1=7, creating polynomials of length 7
2. **Save**: Coordinator calls `save()`, persisting the state with threshold=7 and party_polynomials of length 7
3. **Modify**: Attacker modifies the persisted SavedState, changing `config.threshold` to T2=10
4. **Load**: Application loads the corrupted state via `load()`, creating an aggregator with threshold=10
5. **Trigger**: Initiate a signing operation, causing `aggregator.init(&party_polynomials)` to be called: [8](#0-7) 

6. **Crash**: The `init()` function attempts to access `comm.poly[7]`, `comm.poly[8]`, and `comm.poly[9]`, which don't exist, causing an index-out-of-bounds panic

**Expected vs Actual Behavior:**
- **Expected**: Signing operation completes successfully or fails gracefully with a validation error
- **Actual**: Panic with index-out-of-bounds error, crashing the coordinator process

**Reproduction Instructions:**
```rust
// Create coordinator with threshold 7
let config = Config::new(10, 40, 7, message_key);
let mut coordinator = Coordinator::new(config);

// Run DKG (polynomials created with length 7)
coordinator.start_dkg_round(None);
// ... complete DKG ...

// Save state
let mut saved_state = coordinator.save();

// Corrupt the threshold
saved_state.config.threshold = 10;

// Load corrupted state
let loaded_coordinator = Coordinator::load(&saved_state);

// Attempt signing (will panic in aggregator.init)
loaded_coordinator.start_signing_round(&msg, SignatureType::Frost, None);
// ... complete signing round ... -> PANIC
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L794-800)
```rust
    fn dkg_end_gathered(&mut self) -> Result<(), Error> {
        // Cache the polynomials used in DKG for the aggregator
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1145-1145)
```rust
            self.aggregator.init(&self.party_polynomials)?;
```

**File:** src/state_machine/coordinator/fire.rs (L1309-1336)
```rust
    fn load(state: &SavedState) -> Self {
        Self {
            aggregator: Aggregator::new(state.config.num_keys, state.config.threshold),
            config: state.config.clone(),
            current_dkg_id: state.current_dkg_id,
            current_sign_id: state.current_sign_id,
            current_sign_iter_id: state.current_sign_iter_id,
            dkg_public_shares: state.dkg_public_shares.clone(),
            dkg_private_shares: state.dkg_private_shares.clone(),
            dkg_end_messages: state.dkg_end_messages.clone(),
            party_polynomials: state.party_polynomials.clone(),
            message_nonces: state.message_nonces.clone(),
            signature_shares: state.signature_shares.clone(),
            aggregate_public_key: state.aggregate_public_key,
            signature: state.signature.clone(),
            schnorr_proof: state.schnorr_proof.clone(),
            message: state.message.clone(),
            dkg_wait_signer_ids: state.dkg_wait_signer_ids.clone(),
            state: state.state.clone(),
            dkg_public_start: state.dkg_public_start,
            dkg_private_start: state.dkg_private_start,
            dkg_end_start: state.dkg_end_start,
            nonce_start: state.nonce_start,
            sign_start: state.sign_start,
            malicious_signer_ids: state.malicious_signer_ids.clone(),
            malicious_dkg_signer_ids: state.malicious_dkg_signer_ids.clone(),
            coordinator_public_key: state.coordinator_public_key,
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1384-1406)
```rust
    fn set_key_and_party_polynomials(
        &mut self,
        aggregate_key: Point,
        party_polynomials: Vec<(u32, PolyCommitment)>,
    ) -> Result<(), Error> {
        let computed_key = party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
        if computed_key != aggregate_key {
            return Err(Error::AggregateKeyPolynomialMismatch(
                computed_key,
                aggregate_key,
            ));
        }
        let party_polynomials_len = party_polynomials.len();
        let party_polynomials = HashMap::from_iter(party_polynomials);
        if party_polynomials.len() != party_polynomials_len {
            return Err(Error::DuplicatePartyId);
        }
        self.aggregate_public_key = Some(aggregate_key);
        self.party_polynomials = party_polynomials;
        Ok(())
    }
```

**File:** src/v2.rs (L69-69)
```rust
            f: Some(VSS::random_poly(threshold - 1, rng)),
```

**File:** src/v2.rs (L312-312)
```rust
        let aggregate_public_key = self.poly[0];
```

**File:** src/v2.rs (L431-444)
```rust
    fn init(&mut self, comms: &HashMap<u32, PolyCommitment>) -> Result<(), AggregatorError> {
        let threshold: usize = self.threshold.try_into()?;
        let mut poly = Vec::with_capacity(threshold);

        for i in 0..poly.capacity() {
            poly.push(Point::zero());
            for (_, comm) in comms {
                poly[i] += &comm.poly[i];
            }
        }

        self.poly = poly;

        Ok(())
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```
