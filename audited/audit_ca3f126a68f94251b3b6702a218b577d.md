### Title
DkgEndGather Timeout Handler Missing Threshold Check Enables Denial of Service on DKG

### Summary
The FIRE coordinator's `process_timeout()` function lacks a threshold check in the DkgEndGather timeout handler, unlike the DkgPublicGather and DkgPrivateGather phases. A malicious signer can exploit this inconsistency to force DKG abortion by delaying their DkgEnd message, even when sufficient participants (meeting `dkg_threshold`) have already responded. This violates the partial DKG completion design and enables a persistent denial of service attack.

### Finding Description

**Exact Code Location:**
File: `src/state_machine/coordinator/fire.rs`, function `process_timeout()`, lines 133-145

**Root Cause:**
The DkgEndGather timeout handler immediately aborts DKG without checking if the `dkg_threshold` requirement has been met: [1](#0-0) 

This contrasts sharply with the DkgPublicGather timeout handler, which checks if `dkg_threshold` is satisfied before deciding to abort: [2](#0-1) 

Similarly, the DkgPrivateGather timeout handler performs the same threshold check: [3](#0-2) 

The coordinator implements `compute_dkg_public_size()` and `compute_dkg_private_size()` helper functions to calculate the number of keys from responding signers: [4](#0-3) 

However, no equivalent `compute_dkg_end_size()` function exists, and the DkgEndGather timeout handler performs no threshold validation.

**Configuration Context:**
The `Config` struct defines both `threshold` (minimum keys for signing) and `dkg_threshold` (minimum keys to complete DKG, where `threshold <= dkg_threshold <= num_keys`): [5](#0-4) 

The DKG end timeout is configurable: [6](#0-5) 

**Why Existing Mitigations Fail:**
The `gather_dkg_end()` function only processes DkgEnd messages when ALL expected signers have responded (`dkg_wait_signer_ids.is_empty()`), but provides no fallback for partial completion during timeout: [7](#0-6) 

The `start_dkg_end()` function sets `dkg_wait_signer_ids` to include all signers who sent DkgPrivateShares: [8](#0-7) 

Therefore, if a single signer delays their DkgEnd message and the timeout expires, DKG aborts regardless of how many other signers have responded.

### Impact Explanation

**Specific Harm:**
A malicious signer can prevent DKG completion indefinitely by withholding their DkgEnd message until timeout, even when `N-1` signers representing `>= dkg_threshold` keys have responded. This blocks establishment of the aggregate public key, preventing all subsequent signing operations.

**Quantified Impact:**
Consider a realistic configuration with 10 signers, 4 keys per signer (40 total keys), `threshold = 28` (70%), and `dkg_threshold = 36` (90%):
- 9 signers respond with DkgEnd messages = 36 keys (meets `dkg_threshold`)
- 1 malicious signer delays their message = 4 keys missing
- Timeout fires → DKG aborts with `DkgEndTimeout` error
- Expected behavior: Should continue with partial DKG since `36 >= 36` threshold met
- Actual behavior: DKG fails despite sufficient participation

**Who is Affected:**
All participants in the DKG round cannot establish the group key. Any dependent system requiring WSTS signatures cannot operate.

**Severity Justification:**
This maps to **Medium severity** under the protocol scope. While it constitutes "remotely-exploitable denial of service" (Low per scope), if WSTS DKG is required for critical network operations and this blocks DKG indefinitely, it approaches "transient consensus failures" (Medium). The attack doesn't shut down the entire network but can prevent specific signing groups from ever becoming operational, which may impact consensus if those groups are critical infrastructure components.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a registered signer in the DKG round (legitimate participant), OR
- Control network infrastructure to delay DkgEnd messages from one or more signers

**Attack Complexity:**
Trivial. The attacker simply:
1. Participates normally in DkgPublicShares and DkgPrivateShares phases
2. When DkgEndBegin message is received, deliberately withholds or delays the DkgEnd response beyond the configured timeout
3. No cryptographic operations required, no special privileges needed beyond being a signer

**Economic Feasibility:**
Extremely low cost. The attack requires no computational resources and can be executed passively by not sending a message.

**Detection Risk:**
Moderate. Coordinator logs will show timeout and list waiting signers, but determining malicious intent vs. network issues requires additional analysis. The malicious signer can plausibly claim network problems or system failures.

**Probability of Success:**
Very high (~95%). The attack succeeds with certainty if:
- The coordinator has configured `dkg_end_timeout` (common in production deployments)
- The attacker can reliably delay their message beyond timeout duration
- No external monitoring forces signer behavior

The attack can be repeated indefinitely across multiple DKG rounds.

### Recommendation

**Primary Fix:**
Add threshold-aware timeout handling to the DkgEndGather state, mirroring the DkgPublicGather and DkgPrivateGather implementations:

1. Implement a `compute_dkg_end_size()` function:
```rust
fn compute_dkg_end_size(&self) -> Result<u32, Error> {
    self.compute_num_key_ids(self.dkg_end_messages.keys())
}
```

2. Modify the DkgEndGather timeout handler in `process_timeout()` to check threshold:
```rust
State::DkgEndGather => {
    if let Some(start) = self.dkg_end_start {
        if let Some(timeout) = self.config.dkg_end_timeout {
            if now.duration_since(start) > timeout {
                let dkg_size = self.compute_dkg_end_size()?;
                
                if self.config.dkg_threshold > dkg_size {
                    error!("Timeout gathering DkgEnd for dkg round {}, dkg_threshold not met ({}/{}), unable to continue", 
                        self.current_dkg_id, dkg_size, self.config.dkg_threshold);
                    let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                    return Ok((
                        None,
                        Some(OperationResult::DkgError(DkgError::DkgEndTimeout(wait))),
                    ));
                } else {
                    warn!("Timeout gathering DkgEnd for dkg round {}, dkg_threshold was met ({}/{}), continuing with partial DKG", 
                        self.current_dkg_id, dkg_size, self.config.dkg_threshold);
                    self.dkg_end_gathered()?;
                    return Ok((
                        None,
                        Some(OperationResult::Dkg(
                            self.aggregate_public_key.ok_or(Error::MissingAggregatePublicKey)?
                        )),
                    ));
                }
            }
        }
    }
}
```

**Alternative Mitigation:**
If partial DKG completion at the DkgEnd phase is intentionally disallowed (design decision), document this explicitly and consider:
- Removing `dkg_threshold` parameter or requiring `dkg_threshold == num_keys`
- Adding configuration validation to prevent misleading timeout behavior
- Documenting that partial DKG only applies to Public/Private phases

**Testing Recommendations:**
1. Add test case with 10 signers where 9 respond to DkgEnd before timeout
2. Verify DKG completes successfully when threshold is met
3. Verify DKG aborts when threshold is NOT met
4. Test malicious signer detection and tracking across multiple rounds

**Deployment Considerations:**
- This is a backward-compatible enhancement if partial DKG is intended
- No state migration required
- Consider logging which signers timed out for operational monitoring

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup Phase:**
   - Network has 10 signers, each controlling 4 key IDs (40 total keys)
   - Configuration: `threshold = 28`, `dkg_threshold = 36`, `dkg_end_timeout = 5 seconds`
   - Attacker controls Signer #9

2. **DKG Execution:**
   - Coordinator sends DkgBegin → all signers respond with DkgPublicShares
   - Coordinator sends DkgPrivateBegin → all signers respond with DkgPrivateShares
   - Coordinator sends DkgEndBegin at time T₀

3. **Attack Execution:**
   - Signers #0-8 immediately respond with DkgEnd messages (36 keys total)
   - Attacker (Signer #9) receives DkgEndBegin but does not respond
   - At T₀ + 5 seconds, `dkg_end_timeout` expires

4. **Expected vs Actual Behavior:**
   - **Expected (with threshold check):** DKG should complete with 36 keys (meets `dkg_threshold`), compute aggregate public key from 9 signers, return `OperationResult::Dkg(aggregate_key)`
   - **Actual (current code):** DKG aborts with `OperationResult::DkgError(DkgError::DkgEndTimeout([9]))`, no aggregate key established

5. **Result:**
   - DKG fails despite 90% participation meeting threshold
   - Signing group cannot be established
   - Attacker can repeat this indefinitely by participating normally until DkgEnd phase

**Reproduction Instructions:**
1. Configure test environment per setup parameters above
2. Modify test harness to withhold Signer #9's DkgEnd message
3. Observe timeout triggers DkgEndTimeout error
4. Count received keys: `9 signers × 4 keys = 36 >= 36 threshold`
5. Confirm DKG aborted despite meeting threshold requirement

**Code Reference for Test Setup:** [9](#0-8)

### Citations

**File:** src/state_machine/coordinator/fire.rs (L77-102)
```rust
            State::DkgPublicGather => {
                if let Some(start) = self.dkg_public_start {
                    if let Some(timeout) = self.config.dkg_public_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_public_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPublicTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.public_shares_gathered()?;
                                let packet = self.start_private_shares()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L105-130)
```rust
            State::DkgPrivateGather => {
                if let Some(start) = self.dkg_private_start {
                    if let Some(timeout) = self.config.dkg_private_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_private_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPrivateTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.private_shares_gathered()?;
                                let packet = self.start_dkg_end()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L133-145)
```rust
            State::DkgEndGather => {
                if let Some(start) = self.dkg_end_start {
                    if let Some(timeout) = self.config.dkg_end_timeout {
                        if now.duration_since(start) > timeout {
                            error!("Timeout gathering DkgEnd for dkg round {} signing round {} iteration {}, unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id);
                            let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                            return Ok((
                                None,
                                Some(OperationResult::DkgError(DkgError::DkgEndTimeout(wait))),
                            ));
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L449-455)
```rust
    pub fn start_dkg_end(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/coordinator/fire.rs (L572-605)
```rust
    fn gather_dkg_end(&mut self, packet: &Packet) -> Result<(), Error> {
        debug!(
            "DKG Round {}: waiting for Dkg End from signers {:?}",
            self.current_dkg_id, self.dkg_wait_signer_ids
        );
        if let Message::DkgEnd(dkg_end) = &packet.msg {
            if dkg_end.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(dkg_end.dkg_id, self.current_dkg_id));
            }
            if self.dkg_wait_signer_ids.contains(&dkg_end.signer_id) {
                self.dkg_wait_signer_ids.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.dkg_wait_signer_ids,
                    "DkgEnd received"
                );
            } else {
                warn!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    "Got DkgEnd from signer who we weren't waiting on"
                );
            }
        }

        let mut reported_failures = HashMap::new();
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
        let threshold: usize = self.config.threshold.try_into().unwrap();
        if self.dkg_wait_signer_ids.is_empty() {
```

**File:** src/state_machine/coordinator/fire.rs (L1219-1225)
```rust
    fn compute_dkg_public_size(&self) -> Result<u32, Error> {
        self.compute_num_key_ids(self.dkg_public_shares.keys())
    }

    fn compute_dkg_private_size(&self) -> Result<u32, Error> {
        self.compute_num_key_ids(self.dkg_private_shares.keys())
    }
```

**File:** src/state_machine/coordinator/mod.rs (L136-141)
```rust
    /// total number of keys
    pub num_keys: u32,
    /// threshold of keys needed to form a valid signature
    pub threshold: u32,
    /// threshold of keys needed to complete DKG (must be >= threshold)
    pub dkg_threshold: u32,
```

**File:** src/state_machine/coordinator/mod.rs (L148-149)
```rust
    /// timeout to gather DkgEnd messages
    pub dkg_end_timeout: Option<Duration>,
```

**File:** src/state_machine/coordinator/mod.rs (L563-582)
```rust
    pub fn setup_with_timeouts<Coordinator: CoordinatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
        dkg_public_timeout: Option<Duration>,
        dkg_private_timeout: Option<Duration>,
        dkg_end_timeout: Option<Duration>,
        nonce_timeout: Option<Duration>,
        sign_timeout: Option<Duration>,
    ) -> (Vec<Coordinator>, Vec<Signer<SignerType>>) {
        INIT.call_once(|| {
            tracing_subscriber::registry()
                .with(fmt::layer())
                .with(EnvFilter::from_default_env())
                .init();
        });

        let mut rng = create_rng();
        let num_keys = num_signers * keys_per_signer;
        let threshold = (num_keys * 7) / 10;
        let dkg_threshold = (num_keys * 9) / 10;
```
