### Title
Unauthenticated DH Public Key Exchange Allows Complete DKG Compromise via MITM Attack

### Summary
The DKG protocol uses Diffie-Hellman key exchange to encrypt private shares between parties, but the ephemeral public keys (`kex_public_key`) transmitted in `DkgPublicShares` messages are not included in the message signature. This allows a network-level attacker to perform a man-in-the-middle attack by replacing all parties' public keys with their own, decrypt all private shares, and reconstruct the group private key, gaining complete control over the threshold signature scheme.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the `Signable` trait implementation for `DkgPublicShares`: [1](#0-0) 

**Root Cause:**

The `hash()` function for `DkgPublicShares` does not include the `kex_public_key` field (line 149) in the signature hash computation (lines 153-163). The hash only includes `dkg_id`, `signer_id`, and polynomial commitments, completely omitting the critical `kex_public_key` field used for encrypting private shares.

When a signer creates their public shares, they include their ephemeral `kex_public_key`: [2](#0-1) 

The message is signed using the sender's `network_private_key`, but since `kex_public_key` is not in the hash, an attacker can modify this field without invalidating the signature.

When other parties receive `DkgPublicShares`, they verify the signature: [3](#0-2) 

But then blindly store the unauthenticated `kex_public_key`: [4](#0-3) 

**Why Existing Mitigations Fail:**

1. **Packet signature verification exists but is incomplete**: While `verify_packet_sigs` is enabled by default and signatures are verified, the signature doesn't cover `kex_public_key`.

2. **No additional validation**: There is no proof-of-possession or binding of the `kex_public_key` to the signer's identity beyond the incomplete signature.

3. **TupleProof used only for blame, not prevention**: The `BadPrivateShare` mechanism with `TupleProof` only helps identify who sent bad shares after-the-fact, but doesn't prevent the MITM attack during key exchange.

### Impact Explanation

**Specific Harm:**

A successful MITM attack allows the attacker to:
1. Decrypt all DKG private shares exchanged between parties
2. Reconstruct the group private key if they obtain threshold-many shares
3. Sign arbitrary messages on behalf of the group
4. Spend funds controlled by the threshold signature scheme

**Quantification:**

- **Threshold = t**: Attacker needs to intercept shares from any t parties to reconstruct the key
- **Typical deployment (t=2, n=3)**: Attacker intercepts 3 signers, gets all shares, trivially reconstructs group key
- **All funds controlled by the multisig are at risk**: 100% loss of funds

**Who is Affected:**

- All signers participating in DKG
- Any system relying on WSTS for custody (e.g., Stacks blockchain miners)
- End users whose funds are protected by the compromised multisig

**Severity Justification:**

**Critical** - Maps directly to "Any causing the direct loss of funds other than through any form of freezing" in the protocol scope. With the group private key, an attacker can:
- Create valid signatures for unauthorized transactions
- Bypass the entire threshold signature security model
- Cause "confirmation of an invalid transaction" by signing transactions without proper authorization from threshold signers
- Cause permanent loss of all funds controlled by the multisig

### Likelihood Explanation

**Required Attacker Capabilities:**

1. **Network-level MITM position**: Ability to intercept and modify packets between signers and coordinator
2. **Active attack capability**: Ability to modify packet contents in real-time
3. **No cryptographic secrets required**: Attack requires no key material

**Attack Complexity:**

- **Low technical barrier**: Standard MITM techniques (ARP spoofing, BGP hijacking, malicious ISP/VPN)
- **Silent attack**: Signatures verify normally, no errors raised
- **Single DKG round**: Only needs to compromise one DKG session
- **No coordination required**: Attacker acts independently

**Economic Feasibility:**

- **Malicious ISP/hosting provider**: Zero additional cost
- **Cross-datacenter attacks**: Feasible via BGP hijacking or compromised peering points
- **State-level adversaries**: Trivial
- **ROI**: If multisig protects significant funds, attack is highly profitable

**Detection Risk:**

- **Extremely low**: All signatures verify correctly, no protocol violations
- **No anomalous behavior**: Private shares decrypt successfully (just with wrong key)
- **Post-DKG detection impossible**: Once attacker has the key, there's no way to detect the prior compromise

**Estimated Probability:**

**High** for any deployment where:
- Signers communicate over untrusted networks (Internet)
- Signers use shared hosting or cloud infrastructure
- Signers communicate across international boundaries
- Any network path involves potentially compromised infrastructure

### Recommendation

**Immediate Fix:**

Modify the `Signable` implementation for `DkgPublicShares` to include `kex_public_key` in the signature hash:

```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // ADD THIS LINE:
        hasher.update(self.kex_public_key.compress().as_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**Alternative/Additional Mitigations:**

1. **Proof-of-Possession**: Require signers to prove knowledge of the private key corresponding to `kex_public_key` using a Schnorr proof
2. **Key binding**: Derive `kex_public_key` deterministically from `network_private_key` and `dkg_id` to create cryptographic binding
3. **Mutual authentication**: Use authenticated encryption (e.g., AEAD with public key authentication)

**Testing Recommendations:**

1. Add integration test that verifies signature invalidation when `kex_public_key` is modified
2. Fuzzing test that attempts to modify all fields in `DkgPublicShares` and verifies signature rejection
3. MITM simulation test that demonstrates the attack is prevented after the fix

**Deployment Considerations:**

- **Breaking change**: Modified signature hash breaks compatibility with existing deployments
- **Migration path**: Increment DKG protocol version, reject old-format messages
- **Emergency response**: All active DKG sessions should be aborted and restarted after fix deployment
- **Key rotation**: Any group keys generated before the fix should be considered compromised and rotated

### Proof of Concept

**Attack Algorithm:**

```
Setup: N signers with threshold t
Attacker position: Network MITM between all signers

Phase 1: DKG Public Shares Exchange
For each signer S_i:
  1. S_i generates kex_private_key_i, computes kex_public_key_i = kex_private_key_i * G
  2. S_i creates DkgPublicShares{kex_public_key: kex_public_key_i, ...}
  3. S_i signs message (signature does NOT cover kex_public_key_i)
  4. Attacker intercepts Packet{msg: DkgPublicShares, sig: signature_i}
  5. Attacker replaces kex_public_key_i with attacker_public_key_M = m * G
  6. Attacker forwards modified Packet{msg: DkgPublicShares{kex_public_key: M, ...}, sig: signature_i}
  7. Recipients verify signature â†’ PASSES (kex_public_key not in hash!)
  8. Recipients store M as S_i's kex_public_key

Phase 2: DKG Private Shares Exchange
For each pair (S_i, S_j):
  1. S_i encrypts share for S_j using:
     shared_secret_ij = make_shared_secret(kex_private_key_i, M)
                      = kex_private_key_i * M
                      = kex_private_key_i * (m * G)
  2. Attacker intercepts encrypted share
  3. Attacker decrypts using:
     shared_secret_ij = make_shared_secret(m, kex_public_key_i)
                      = m * kex_public_key_i
                      = m * (kex_private_key_i * G)
     (Same shared secret! DH property: (a*m)*G = (m*a)*G)
  4. Attacker now has plaintext private share

Phase 3: Key Reconstruction
  1. Attacker collects shares from t different signers
  2. Attacker reconstructs group private key using Lagrange interpolation
  3. Attacker can now sign arbitrary messages

Expected behavior: Signature verification should FAIL when kex_public_key is modified
Actual behavior: Signature verification SUCCEEDS, attack proceeds undetected
```

**Reproduction Steps:**

1. Deploy 3 signers with threshold=2
2. Position network proxy between all signers
3. Configure proxy to intercept `DkgPublicShares` messages
4. In proxy, parse each `DkgPublicShares` and replace `kex_public_key` with attacker's key
5. Forward modified packets
6. Observe: All signatures verify successfully at recipients
7. Intercept `DkgPrivateShares` messages
8. Decrypt using attacker's private key and observed sender public keys
9. Reconstruct group key from collected shares
10. Sign a test message with reconstructed key and verify against group public key

**Key Evidence:**

The attack succeeds because:
- [5](#0-4)  omits `kex_public_key`
- [6](#0-5)  uses unauthenticated key for encryption
- [7](#0-6)  uses unauthenticated key for decryption
- [8](#0-7)  implements standard DH (no authentication)

### Citations

**File:** src/net.rs (L139-164)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}

impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L872-890)
```rust
        let mut public_share = DkgPublicShares {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            comms: Vec::new(),
            kex_public_key: self.kex_private_key * G,
        };

        for poly in &comms {
            public_share
                .comms
                .push((poly.id.id.get_u32(), poly.clone()));
        }

        let public_share = Message::DkgPublicShares(public_share);
        msgs.push(public_share);

        self.move_to(State::DkgPublicGather)?;
        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L937-946)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1076)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
```

**File:** src/util.rs (L47-52)
```rust
/// Do a Diffie-Hellman key exchange to create a shared secret from the passed private/public keys
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```
