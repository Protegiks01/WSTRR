### Title
Unvalidated DKG Failure Reports Enable DoS and False Accusations Against Honest Signers

### Summary
The coordinator fails to validate `MissingPublicShares` and `MissingPrivateShares` failure reports during DKG finalization, allowing a malicious signer to falsely claim they did not receive shares from honest signers. This causes DKG to fail indefinitely without marking anyone as malicious, enabling denial-of-service attacks and false accusations against honest participants.

### Finding Description

The `DkgFailure` enum in `src/net.rs` defines six failure types that signers can report during DKG finalization: [1](#0-0) 

When signers send `DkgEnd` messages to the coordinator, the coordinator's `gather_dkg_end` function processes these failure reports and determines which signers are malicious. However, for `MissingPublicShares` and `MissingPrivateShares` failures, the coordinator performs no validation: [2](#0-1) 

In contrast, for `BadPublicShares` and `BadPrivateShares` failures, the coordinator cryptographically validates the claims and marks either the reporter or the accused as malicious: [3](#0-2) [4](#0-3) 

**Root Cause:**

The coordinator collects all public and private shares from signers and stores them locally: [5](#0-4) [6](#0-5) 

When a signer reports missing shares from another signer, the coordinator has sufficient information to validate the claim by checking whether it received shares from the accused signer. If the coordinator received shares from signer A, then A did broadcast shares. If signer B claims not to have received them, B is either experiencing network issues or is malicious.

However, the current implementation performs no such validation and takes no action. When any signer reports `MissingPublicShares` or `MissingPrivateShares`, DKG fails with no consequences for the reporter: [7](#0-6) 

**Existing Mitigations:**

The `malicious_dkg_signer_ids` field is designed to track malicious signers across DKG rounds, but it is never populated for these failure types. Additionally, the field is not used to exclude signers from future DKG rounds: [8](#0-7) 

### Impact Explanation

A malicious signer can execute a denial-of-service attack by falsely reporting `MissingPublicShares` or `MissingPrivateShares` for honest signers. Each false report causes DKG to fail and return an error to the application: [9](#0-8) 

The `DkgError::DkgEndFailure` includes both `reported_failures` (showing which signers reported problems) and `malicious_signers` (which will be empty for these failure types): [10](#0-9) 

**Specific Harm:**
- DKG cannot complete, preventing generation of the group public key required for threshold signatures
- Honest signers are falsely accused in the `reported_failures` map, potentially damaging their reputation
- No mechanism exists to identify or exclude the malicious reporter
- The attack can be repeated on every DKG retry, causing permanent DoS

**Quantified Impact:**
With N total signers and 1 malicious signer, the malicious signer can prevent DKG completion indefinitely. Even with threshold T < N, the protocol cannot proceed because DKG must complete before signing can begin.

**Severity Justification:**
Per the protocol scope, this maps to **Low** severity: "Any remotely-exploitable denial of service in a node." The attack prevents DKG completion but does not compromise keys, enable fund theft, or cause chain splits.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a participating signer in the DKG protocol
- Requires no special cryptographic knowledge or computational resources
- No additional network access or privileges needed

**Attack Complexity:**
The attack is trivial to execute:
1. Attacker receives `DkgPublicShares` or `DkgPrivateShares` from honest signers
2. Attacker intentionally does not store the received shares (or deletes them after storage)
3. When coordinator sends `DkgEndBegin`, attacker checks local storage
4. Attacker reports `MissingPublicShares` or `MissingPrivateShares` for the honest signers
5. DKG fails, no one is marked malicious
6. Attacker repeats the attack on every DKG retry

**Detection Risk:**
Low. The malicious signer's reports appear as legitimate complaints about network issues. Without validation logic, operators cannot distinguish between honest reports and false accusations.

**Estimated Probability:**
100% success rate. The lack of validation means every false report will cause DKG failure.

### Recommendation

**Immediate Fix:**

Implement validation logic for `MissingPublicShares` and `MissingPrivateShares` reports in the `gather_dkg_end` function:

1. For `MissingPublicShares(accused_signer_ids)`:
   - Check if `self.dkg_public_shares.contains_key(accused_signer_id)`
   - If coordinator has shares from accused: mark reporter as malicious (false accusation)
   - If coordinator lacks shares from accused: mark accused as malicious (legitimate claim)

2. For `MissingPrivateShares(accused_signer_ids)`:
   - Check if `self.dkg_private_shares.contains_key(accused_signer_id)`
   - Apply same logic as `MissingPublicShares`

3. Exclude malicious signers from future DKG rounds by checking `malicious_dkg_signer_ids` when populating `dkg_wait_signer_ids` in `start_public_shares`.

**Alternative Mitigation:**

If network reliability is a concern and legitimate message loss is expected, implement a retry mechanism with timeouts before marking signers as malicious. However, this increases complexity and may not fully address the DoS risk.

**Testing Recommendations:**
- Add unit tests that verify malicious reporters are correctly identified when falsely claiming missing shares
- Add integration tests that verify DKG can complete even with one malicious signer making false reports
- Test that `malicious_dkg_signer_ids` correctly excludes bad actors from future rounds

**Deployment Considerations:**
- Review existing DKG failures to determine if any were caused by this vulnerability
- Consider implementing metrics/logging to track missing share reports for operational visibility

### Proof of Concept

**Exploitation Algorithm:**

```
Setup:
- N = 5 signers (IDs 0-4)
- Signer 3 is malicious
- Threshold T = 3

Attack Execution:
1. Coordinator sends DkgBegin to all signers
2. All signers (including honest signer 1) broadcast DkgPublicShares
3. Malicious signer 3 receives DkgPublicShares from signer 1
4. Malicious signer 3 intentionally deletes signer 1's shares from storage
5. Coordinator sends DkgPrivateBegin with signer_ids = [0,1,2,3,4]
6. All signers exchange DkgPrivateShares
7. Coordinator sends DkgEndBegin with signer_ids = [0,1,2,3,4]
8. Malicious signer 3 checks local storage, finds no shares from signer 1
9. Malicious signer 3 sends DkgEnd with status = Failure(MissingPublicShares({1}))
10. Coordinator processes the report at lines 765-767 (no action taken)
11. Coordinator returns Error::DkgFailure with:
    - reported_failures = {3: MissingPublicShares({1})}
    - malicious_signers = {} (empty)
12. DKG fails, must restart
13. Malicious signer 3 repeats attack on retry

Expected Behavior:
- Coordinator should verify: "Do I have public shares from signer 1?"
- Answer: YES (signer 1 sent to coordinator)
- Conclusion: Signer 3 is lying, mark signer 3 as malicious
- DKG continues without signer 3

Actual Behavior:
- Coordinator takes no action (lines 765-767)
- DKG fails
- No one marked malicious
- Attack can be repeated indefinitely
```

**Reproduction Steps:**
1. Set up a 5-signer DKG with threshold 3
2. Modify signer 3 to drop received public shares from signer 1
3. Run DKG protocol
4. Observe that signer 3 reports `MissingPublicShares({1})`
5. Verify that DKG returns `DkgError::DkgEndFailure` with empty `malicious_signers`
6. Retry DKG and observe the same failure repeats

---

**Notes:**

The vulnerability exists specifically in the lack of validation for `MissingPublicShares` and `MissingPrivateShares` failure types. While `BadPublicShares` and `BadPrivateShares` are properly validated with cryptographic proofs, missing share reports are accepted without verification. The coordinator has sufficient information to validate these claims but fails to do so, enabling both denial-of-service attacks and false accusations against honest participants.

### Citations

**File:** src/net.rs (L57-72)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// Final DKG status after receiving public and private shares
pub enum DkgFailure {
    /// DKG threshold not met
    Threshold,
    /// Signer was in the wrong internal state to complete DKG
    BadState,
    /// DKG public shares were missing from these signer_ids
    MissingPublicShares(HashSet<u32>),
    /// DKG public shares were bad from these signer_ids
    BadPublicShares(HashSet<u32>),
    /// DKG private shares were missing from these signer_ids
    MissingPrivateShares(HashSet<u32>),
    /// DKG private shares were bad from these signer_ids
    BadPrivateShares(HashMap<u32, BadPrivateShare>),
}
```

**File:** src/state_machine/coordinator/fire.rs (L282-293)
```rust
                        if let Error::DkgFailure {
                            reported_failures,
                            malicious_signers,
                        } = error
                        {
                            return Ok((
                                None,
                                Some(OperationResult::DkgError(DkgError::DkgEndFailure {
                                    reported_failures,
                                    malicious_signers,
                                })),
                            ));
```

**File:** src/state_machine/coordinator/fire.rs (L395-399)
```rust
    /// Ask signers to send DKG public shares
    pub fn start_public_shares(&mut self) -> Result<Packet, Error> {
        self.dkg_public_shares.clear();
        self.party_polynomials.clear();
        self.dkg_wait_signer_ids = (0..self.config.num_signers).collect();
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```

**File:** src/state_machine/mod.rs (L48-55)
```rust
    /// DKG end failure
    #[error("DKG end failure")]
    DkgEndFailure {
        /// failures reported by signers during DkgEnd
        reported_failures: HashMap<u32, DkgFailure>,
        /// signers who were discovered to be malicious during this DKG round
        malicious_signers: HashSet<u32>,
    },
```
