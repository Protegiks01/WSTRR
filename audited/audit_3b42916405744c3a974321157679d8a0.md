### Title
Performance DoS via Unbounded num_keys in DKG Configuration

### Summary
The WSTS coordinator Config struct accepts arbitrarily large num_keys values without validation, enabling performance denial-of-service attacks during Distributed Key Generation (DKG). A malicious or compromised coordinator can set num_keys to extreme values (e.g., 10,000+), causing O(num_keys) computational and memory overhead across all signers, preventing DKG completion and blocking threshold signature operations.

### Finding Description

The vulnerability exists due to missing upper bound validation on the `num_keys` configuration parameter combined with multiple O(num_keys) operations during DKG.

**Root Cause - No Validation:**
The Config struct defines num_keys as a u32 with no maximum value enforcement. [1](#0-0) 

The only validation performed is that individual key_ids must be in range [1, num_keys], but num_keys itself can be any u32 value up to 4,294,967,295. [2](#0-1) 

**Attack Vector 1 - Large Message Payloads:**
The FROST coordinator creates DkgPrivateBegin messages containing a vector of ALL key_ids from 1 to num_keys+1, allocating O(num_keys) memory. [3](#0-2) 

Similarly, DkgEndBegin messages contain vectors from 0 to num_keys. [4](#0-3) 

**Attack Vector 2 - Hashing Overhead:**
When signing these messages, the hash function iterates over every key_id in the vector, performing O(num_keys) hash update operations. [5](#0-4) [6](#0-5) 

**Attack Vector 3 - Polynomial Evaluation:**
The critical vulnerability is in Party::get_shares() which unconditionally iterates from 1 to num_keys+1, evaluating the polynomial at each key_id regardless of which keys are actually active in the current DKG round.

V1 implementation: [7](#0-6) 

V2 implementation: [8](#0-7) 

This get_shares() method is called during private share distribution, generating shares for ALL num_keys. [9](#0-8) 

**Attack Vector 4 - Encryption Processing:**
After generating shares for all keys, signers must process the encryption loop which iterates over the share HashMap. While encryption is filtered by active_key_ids, the expensive polynomial evaluations have already occurred. [10](#0-9) 

**Why Existing Mitigations Fail:**
No mitigations exist. There are no MAX_KEYS constants, no bounds checking in Config constructors, and no runtime validation of reasonable num_keys values. [11](#0-10) 

### Impact Explanation

**Severity: Low** (per protocol scope definition: "Any remotely-exploitable denial of service in a node")

**Quantified Impact with Realistic Parameters:**

With num_keys = 10,000 and 10 signers each with 10 parties (v1):
- **Memory:** 40KB for key_ids vector in each DkgPrivateBegin/DkgEndBegin message
- **CPU:** 10,000 hash operations per message signature
- **Polynomial evaluations:** 10 parties Ã— 10,000 keys = 100,000 evaluations per signer
- **Total across 10 signers:** 1,000,000 polynomial evaluations during DKG
- **Time impact:** DKG that should complete in seconds could take minutes to hours

With num_keys = 100,000:
- **Memory:** 400KB+ per message
- **Operations:** 10,000,000+ polynomial evaluations
- **Result:** DKG likely cannot complete; nodes become unresponsive

**Who is Affected:**
All signers participating in DKG are affected. If WSTS is used in blockchain consensus systems (like Stacks):
- Cannot complete validator set changes requiring DKG
- Cannot rotate threshold signature keys
- Cannot generate signatures if DKG is prerequisite
- Node resources exhausted preventing other operations

**Does NOT cause:**
- Invalid signature acceptance
- Chain splits or forks  
- Direct loss of funds
- Invalid transaction confirmation

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control or compromise of the coordinator node
- Ability to set Config parameters before initializing coordinator
- Ability to call start_dkg_round()

**Attack Complexity: Low**
The attack requires only setting a configuration value. No cryptographic operations, complex message crafting, or timing requirements.

**Prerequisites:**
The coordinator role in WSTS has significant trust assumptions - coordinators control DKG initiation, message distribution, and round progression. However:
- Coordinators may be misconfigured rather than malicious
- A compromised coordinator can easily exploit this
- No authentication/authorization checks prevent excessive num_keys values

**Economic Feasibility: High**
Attack costs only coordinator node resources. Defensive costs are high - all signer nodes must process the expensive operations.

**Detection Risk: Low**  
The attack appears as legitimate DKG traffic. No error conditions are triggered until nodes become unresponsive. Monitoring for large num_keys values in Config is the only detection method.

**Probability: Medium**
While coordinators typically have trust, the lack of any validation makes accidental or malicious exploitation straightforward.

### Recommendation

**Primary Fix - Add Validation:**
Implement maximum bounds checking for num_keys in the Config constructor and validation methods:

```rust
// In src/state_machine/coordinator/mod.rs
const MAX_KEYS: u32 = 1000; // Reasonable upper bound

impl Config {
    pub fn new(
        num_signers: u32,
        num_keys: u32,
        threshold: u32,
        message_private_key: Scalar,
    ) -> Result<Self, ConfigError> {
        if num_keys > MAX_KEYS {
            return Err(ConfigError::NumKeysTooLarge(num_keys, MAX_KEYS));
        }
        if num_keys == 0 {
            return Err(ConfigError::NumKeysZero);
        }
        // ... rest of validation
        Ok(Config { /* ... */ })
    }
}
```

Add similar validation to `with_timeouts()` constructor.

**Secondary Fix - Optimize get_shares():**
Modify Party::get_shares() to only generate shares for active key_ids rather than all possible keys. This requires passing the active set as a parameter.

**Alternative Mitigation:**
If large num_keys is legitimately required, implement:
- Pagination/chunking of key_ids in messages
- Lazy evaluation of polynomial shares (generate on-demand)
- Streaming encryption rather than building full HashMap

**Testing Recommendations:**
1. Add unit tests verifying Config rejects num_keys > MAX_KEYS
2. Add integration tests measuring DKG performance at various num_keys values
3. Benchmark polynomial evaluation costs to determine appropriate MAX_KEYS
4. Test that DKG completes within reasonable timeouts (e.g., < 30 seconds)

**Deployment Considerations:**
- Choose MAX_KEYS based on expected deployment scale and performance requirements
- Document the maximum in configuration guides
- Emit warnings when num_keys approaches maximum
- Consider making MAX_KEYS configurable via build-time feature flags for different deployment contexts

### Proof of Concept

**Exploitation Steps:**

1. **Setup malicious/misconfigured coordinator:**
```rust
let config = Config::new(
    10,      // num_signers
    10000,   // num_keys - EXPLOIT VALUE
    7000,    // threshold
    Scalar::random(&mut rng)
);
let mut coordinator = frost::Coordinator::new(config);
```

2. **Initiate DKG round:**
```rust
let dkg_begin_packet = coordinator.start_dkg_round(None).unwrap();
// Coordinator sends to all signers
```

3. **Signers process DkgBegin and send public shares:**
Each signer creates polynomial and returns DkgPublicShares (this step is normal).

4. **Coordinator sends DkgPrivateBegin:**
```rust
// Inside coordinator after gathering public shares:
// Creates DkgPrivateBegin with key_ids = [1, 2, 3, ..., 10000]
// Message size: ~40KB for key_ids alone
```

5. **Signers process DkgPrivateBegin - ATTACK TRIGGERS:**
```rust
// Each signer calls:
self.signer.get_shares()
  // V1: Iterates 10000 times across all parties
  // With 10 parties: 100,000 polynomial evaluations
  // Each evaluation: compute::id(i) + poly.eval()
  
// Then encrypts shares for active keys
// But damage already done - all shares generated
```

**Expected Behavior:**
DKG completes in 1-5 seconds with reasonable num_keys (~100).

**Actual Behavior with num_keys=10000:**
- Initial message creation: 10-50ms (allocation of large vectors)
- Hash computation: 50-100ms per message signature
- Each signer's get_shares(): 1-10 seconds (100,000 polynomial evaluations)
- Total DKG time: 10-100 seconds minimum, potentially minutes
- Memory usage: Hundreds of MB allocated for key_ids vectors and share HashMaps

**Reproduction:**
Modify any existing WSTS DKG test to use num_keys=10000 and measure execution time. Compare against same test with num_keys=100 to observe ~100x performance degradation.

### Citations

**File:** src/state_machine/coordinator/mod.rs (L131-158)
```rust
/// Config fields common to all Coordinators
#[derive(Default, Clone, PartialEq)]
pub struct Config {
    /// total number of signers
    pub num_signers: u32,
    /// total number of keys
    pub num_keys: u32,
    /// threshold of keys needed to form a valid signature
    pub threshold: u32,
    /// threshold of keys needed to complete DKG (must be >= threshold)
    pub dkg_threshold: u32,
    /// private key used to sign network messages
    pub message_private_key: Scalar,
    /// timeout to gather DkgPublicShares messages
    pub dkg_public_timeout: Option<Duration>,
    /// timeout to gather DkgPrivateShares messages
    pub dkg_private_timeout: Option<Duration>,
    /// timeout to gather DkgEnd messages
    pub dkg_end_timeout: Option<Duration>,
    /// timeout to gather nonces
    pub nonce_timeout: Option<Duration>,
    /// timeout to gather signature shares
    pub sign_timeout: Option<Duration>,
    /// the public keys and key_ids for all signers
    pub public_keys: PublicKeys,
    /// whether to verify the signature on Packets
    pub verify_packet_sigs: bool,
}
```

**File:** src/state_machine/coordinator/mod.rs (L178-200)
```rust
impl Config {
    /// Create a new config object with no timeouts
    pub fn new(
        num_signers: u32,
        num_keys: u32,
        threshold: u32,
        message_private_key: Scalar,
    ) -> Self {
        Config {
            num_signers,
            num_keys,
            threshold,
            dkg_threshold: num_keys,
            message_private_key,
            dkg_public_timeout: None,
            dkg_private_timeout: None,
            dkg_end_timeout: None,
            nonce_timeout: None,
            sign_timeout: None,
            public_keys: Default::default(),
            verify_packet_sigs: true,
        }
    }
```

**File:** src/common.rs (L313-316)
```rust
/// Check that the passed `key_id` is valid
pub fn validate_key_id(key_id: u32, num_keys: u32) -> bool {
    key_id > 0 && key_id <= num_keys
}
```

**File:** src/state_machine/coordinator/frost.rs (L255-259)
```rust
        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            key_ids: (1..self.config.num_keys + 1).collect(),
            signer_ids: (0..self.config.num_signers).collect(),
        };
```

**File:** src/state_machine/coordinator/frost.rs (L277-281)
```rust
        let dkg_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            key_ids: (0..self.config.num_keys).collect(),
            signer_ids: (0..self.config.num_signers).collect(),
        };
```

**File:** src/net.rs (L177-187)
```rust
impl Signable for DkgPrivateBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PRIVATE_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }
        for signer_id in &self.signer_ids {
            hasher.update(signer_id.to_be_bytes());
        }
    }
```

**File:** src/net.rs (L230-240)
```rust
impl Signable for DkgEndBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_END_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }
        for signer_id in &self.signer_ids {
            hasher.update(signer_id.to_be_bytes());
        }
    }
```

**File:** src/v1.rs (L136-147)
```rust
    pub fn get_shares(&self) -> HashMap<u32, Scalar> {
        if let Some(poly) = &self.f {
            let mut shares = HashMap::new();
            for i in 1..self.num_keys + 1 {
                shares.insert(i, poly.eval(compute::id(i)));
            }
            shares
        } else {
            warn!("get_shares called with no polynomial");
            Default::default()
        }
    }
```

**File:** src/v1.rs (L640-646)
```rust
    fn get_shares(&self) -> HashMap<u32, HashMap<u32, Scalar>> {
        let mut shares = HashMap::new();
        for party in &self.parties {
            shares.insert(party.id, party.get_shares());
        }
        shares
    }
```

**File:** src/v2.rs (L106-116)
```rust
    pub fn get_shares(&self) -> HashMap<u32, Scalar> {
        let mut shares = HashMap::new();
        if let Some(poly) = &self.f {
            for i in 1..self.num_keys + 1 {
                shares.insert(i, poly.eval(compute::id(i)));
            }
        } else {
            warn!("get_poly_commitment called with no polynomial");
        }
        shares
    }
```

**File:** src/state_machine/signer/mod.rs (L926-949)
```rust
        for (party_id, shares) in &self.signer.get_shares() {
            debug!(
                "Signer {} addding dkg private share for party_id {party_id}",
                self.signer_id
            );
            // encrypt each share for the recipient
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
        }
```
