### Title
Memory Exhaustion via Unbounded PolyCommitment Vectors in DKG Public Shares

### Summary
A malicious DKG participant can cause memory and CPU exhaustion in all nodes (coordinator and signers) by sending DkgPublicShares messages containing arbitrarily large vectors of duplicate PolyCommitments, each containing an ID struct. No validation exists on the size or uniqueness of the `comms` vector before processing and storage, allowing an attacker to send millions of duplicate entries that consume hundreds of megabytes of memory per malicious signer.

### Finding Description

The ID struct is defined in `src/schnorr.rs` and contains three fields: `id: Scalar`, `kG: Point`, and `kca: Scalar`, totaling approximately 128 bytes per instance. [1](#0-0) 

Each ID struct is embedded within a PolyCommitment structure along with a polynomial vector. [2](#0-1) 

During DKG, signers send DkgPublicShares messages containing a vector of PolyCommitments (`comms: Vec<(u32, PolyCommitment)>`). [3](#0-2) 

**Root Cause - Coordinator Side:**

When the coordinator receives DkgPublicShares messages, it performs minimal validation and stores the entire message without checking the size of the `comms` vector. [4](#0-3) 

The coordinator blindly clones and stores the entire DkgPublicShares at line 506 without any limit on the number of entries in the `comms` vector.

**Root Cause - Signer Side:**

Similarly, signers validate each party_id in the `comms` vector but do not limit the vector size before iteration or storage. [5](#0-4) 

The validation loop at lines 993-1002 iterates through ALL entries in the `comms` vector, causing CPU exhaustion if the vector is large. If validation passes, the entire message is cloned and stored at line 1024.

**Why Existing Mitigations Fail:**

The validate_party_id check only validates that each party_id is owned by the signer, but does not prevent duplicate entries. For v2, where `signer_id == party_id`: [6](#0-5) 

A malicious signer can send millions of duplicate entries with the same valid party_id, all passing validation.

The duplicate detection that exists only rejects duplicate DkgPublicShares messages from the same signer_id, not duplicate entries within a single message. [7](#0-6) 

### Impact Explanation

**Specific Harm:**
- Coordinator node experiences memory exhaustion (hundreds of MB per malicious signer) and CPU exhaustion from iterating through large vectors
- All signer nodes experience the same memory/CPU exhaustion
- DKG process cannot complete, preventing new distributed key generation
- Nodes must be restarted and the malicious participant excluded from future rounds

**Quantified Impact:**
With a threshold of 3 and 1 million duplicate PolyCommitments:
- Memory per malicious signer: ~320 MB (ID struct ~128 bytes + poly vector ~192 bytes)
- CPU: Millions of validation iterations per receiving node
- Multiple malicious signers can amplify the attack linearly

**Who is Affected:**
All nodes participating in DKG (coordinator + all signers)

**Severity Justification:**
This maps to **Low severity** under the protocol scope: "Any remotely-exploitable denial of service in a node." While the attack can crash nodes and prevent DKG completion, it:
- Does not affect existing signing operations (only DKG)
- Does not cause fund loss or invalid signatures
- Requires being an authorized DKG participant
- Can be recovered by restarting nodes and excluding the attacker
- Does not permanently shut down the network

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be an authorized DKG participant with valid signer_id and public keys configured
- Must be able to construct and send network messages
- No cryptographic breaks required

**Attack Complexity:**
Low - The attack is straightforward:
1. Create a DkgPublicShares message
2. Populate `comms` with millions of duplicate (party_id, PolyCommitment) tuples using valid party_ids
3. Send to coordinator and other signers via normal network protocol

**Economic Feasibility:**
Trivial - The attacker only needs to generate and send one large message. The computational cost to the attacker is minimal compared to the resource consumption on victim nodes.

**Detection Risk:**
High - The attack is easily detectable through monitoring:
- Abnormally large network messages
- Sudden memory/CPU spikes during DKG
- Failed DKG rounds
- Malicious signer can be identified and excluded

**Probability of Success:**
High - If an authorized participant turns malicious, they can reliably execute this attack. However, the prerequisite of being an authorized participant significantly limits the attack surface.

### Recommendation

**Primary Fix:**
Add validation to limit the size of the `comms` vector before processing. The maximum valid size should equal the number of key_ids owned by the sending signer.

For coordinators (src/state_machine/coordinator/fire.rs, around line 492):
```rust
// Get expected number of key_ids for this signer
let expected_key_ids = match self.config.public_keys.signer_key_ids.get(&dkg_public_shares.signer_id) {
    Some(key_ids) => key_ids.len(),
    None => {
        warn!(signer_id = %dkg_public_shares.signer_id, "No key_ids in config");
        return Ok(());
    }
};

// Validate comms vector size
if dkg_public_shares.comms.len() > expected_key_ids {
    warn!(signer_id = %dkg_public_shares.signer_id, 
          expected = expected_key_ids,
          received = dkg_public_shares.comms.len(),
          "DkgPublicShares contains too many commitments");
    return Ok(());
}
```

For signers (src/state_machine/signer/mod.rs, around line 992):
```rust
let expected_key_ids = match self.public_keys.signer_key_ids.get(&signer_id) {
    Some(key_ids) => key_ids.len(),
    None => {
        warn!(%signer_id, "No key_ids configured");
        return Ok(vec![]);
    }
};

if dkg_public_shares.comms.len() > expected_key_ids {
    warn!(%signer_id, 
          expected = expected_key_ids,
          received = dkg_public_shares.comms.len(),
          "DkgPublicShares contains too many commitments");
    return Ok(vec![]);
}
```

**Additional Mitigation:**
Add duplicate detection within the `comms` vector using a HashSet to track seen party_ids during validation.

**Testing Recommendations:**
1. Unit test with oversized `comms` vectors (verify rejection)
2. Unit test with duplicate party_ids in `comms` (verify rejection)
3. Integration test with maximum valid size (verify acceptance)
4. Load test to confirm memory bounds with maximum valid participants

**Deployment Considerations:**
This is a breaking change that will reject previously valid (though malicious) messages. Deploy to all nodes simultaneously during a coordinated upgrade.

### Proof of Concept

**Exploitation Algorithm:**

1. Attacker is authorized DKG participant with signer_id = 5
2. For v2 deployment (signer_id == party_id):
   - Create PolyCommitment with valid ID proof for party_id = 5
   - Generate threshold-sized polynomial commitment
3. Construct DkgPublicShares:
   ```
   comms = Vec::new()
   for i in 0..1_000_000:
       comms.push((5, poly_commitment.clone()))
   ```
4. Send DkgPublicShares to coordinator and all signers
5. Each receiving node:
   - Iterates through 1M entries in validation (CPU spike)
   - All pass validation (party_id = 5 is valid)
   - Clones entire message with 1M PolyCommitments (~320 MB)
   - Stores in dkg_public_shares BTreeMap

**Expected Behavior:**
Message should be rejected due to excessive size

**Actual Behavior:**
Message is accepted, stored, and causes memory exhaustion

**Reproduction:**
Create a malicious signer that constructs DkgPublicShares with large duplicate `comms` vectors and observe memory consumption spike in receiving nodes during DKG public share gathering phase.

### Citations

**File:** src/schnorr.rs (L13-23)
```rust
#[allow(non_snake_case)]
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// ID type which encapsulates the ID and a schnorr proof of ownership of the polynomial
pub struct ID {
    /// The ID
    pub id: Scalar,
    /// The public schnorr response
    pub kG: Point,
    /// The aggregate of the schnorr committed values
    pub kca: Scalar,
}
```

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/signer/mod.rs (L973-1026)
```rust
    /// handle incoming DkgPublicShares
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/v2.rs (L644-650)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        _signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        signer_id == party_id
    }
```
