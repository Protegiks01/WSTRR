### Title
Missing Duplicate Party ID Validation in DKG Allows Silent Polynomial Commitment Overwrites

### Summary
The DKG process does not validate that party IDs are unique across different signers. When multiple signers claim the same party_id with different polynomials, HashMap insert operations silently overwrite earlier commitments in both coordinators and signers. This leads to inconsistent aggregate key computation where the coordinator's stored aggregate key includes all commitments but the aggregator's initialized polynomial is missing overwritten commitments, causing all subsequent signing operations to fail.

### Finding Description

The vulnerability exists at multiple locations where party polynomial commitments are stored without checking for duplicates:

**Configuration Validation** [1](#0-0) 
The `PublicKeys::validate()` method checks that signer_ids and key_ids are within valid ranges, but does NOT verify that party_ids (key_ids) are unique across different signers in the `signer_key_ids` mapping.

**Coordinator Overwrites (FIRE)** [2](#0-1) 
During `dkg_end_gathered()`, the coordinator populates `party_polynomials` by iterating through received commitments and inserting them into a HashMap. If two signers send commitments for the same party_id, the second insert silently overwrites the first.

**Coordinator Overwrites (FROST)** [3](#0-2) 
The FROST coordinator has the same issue in `gather_public_shares()`, inserting party commitments without duplicate detection.

**Signer Overwrites** [4](#0-3) 
Signers also populate their `commitments` HashMap during `dkg_ended()` with the same silent overwrite behavior.

**Aggregate Key Computation** [5](#0-4) 
The coordinator computes the aggregate public key by iterating through ALL commitments in `dkg_public_shares`, which correctly includes duplicate party_ids. However, this creates an inconsistency with `party_polynomials`.

**Aggregator Initialization** [6](#0-5) 
During signing, the aggregator is initialized with `party_polynomials`, which may be missing polynomial commitments due to overwrites.

**Incomplete Mitigation** [7](#0-6) 
The `set_key_and_party_polynomials()` method does check for duplicate party_ids by comparing HashMap length before and after conversion, but this method is only called when loading from saved state, NOT during the normal DKG flow.

**Root Cause**: The code assumes party_ids are unique per signer (as evidenced by test setup at [8](#0-7) ) but never validates this assumption. HashMap insert operations inherently overwrite duplicates without error.

### Impact Explanation

**Primary Impact - Signing Failure**: When duplicate party_ids exist, the coordinator's aggregate_public_key (computed from all commitments) will not match the aggregator's group polynomial (initialized from party_polynomials with missing commitments). This causes signature verification to fail at [9](#0-8) , preventing any valid signatures from being produced.

**Secondary Impact - Consensus Disruption**: If WSTS is used for blockchain consensus (as implied by the Stacks context), systematic signing failures prevent transaction confirmation. This maps to **Medium severity** (transient consensus failures) in the protocol scope. If the attack is sustained or affects critical operations, it could escalate to **High severity** (unintended chain split or network partition).

**Quantified Impact**: 
- With N total parties and D duplicate party_ids, the effective threshold becomes (N - D) 
- If D is large enough to reduce the effective threshold below the configured threshold, signatures may be accepted with fewer participants than intended
- All signers and coordinators are affected simultaneously once duplicate configuration is deployed

**Who is Affected**: All participants in the DKG round, including honest signers and coordinators, will have inconsistent state preventing signature generation.

### Likelihood Explanation

**Required Attacker Capabilities**:
1. Ability to influence or control the coordinator's configuration, specifically the `PublicKeys.signer_key_ids` mapping
2. Access to broadcast the malicious configuration to participants
3. No cryptographic breaks required

**Attack Prerequisites**:
- Attacker must be able to set up configuration where `signer_key_ids[A].contains(X)` and `signer_key_ids[B].contains(X)` for distinct signers A and B and party_id X
- All participants must accept this configuration (no independent validation prevents it)

**Attack Complexity**: Low to Medium
- Configuration setup is straightforward
- Attack is deterministic once configuration is accepted
- No timing dependencies or race conditions

**Detection Risk**: Medium
- DKG appears to complete successfully (no errors raised)
- Failure only manifests during first signing attempt
- Forensic analysis would reveal inconsistent party_polynomials

**Economic Feasibility**: High - requires only configuration control, no ongoing resources

**Estimated Probability**: Medium to High if attacker controls coordinator configuration; Low if configurations are independently validated by participants

### Recommendation

**Primary Fix - Add Duplicate Detection in PublicKeys::validate()**:
Modify the validation function to ensure party_ids are unique across all signers:

```rust
// In src/state_machine/mod.rs, PublicKeys::validate()
let mut all_key_ids = HashSet::new();
for (signer_id, key_ids) in &self.signer_key_ids {
    for key_id in key_ids {
        if !all_key_ids.insert(*key_id) {
            return Err(SignerError::Config(ConfigError::DuplicatePartyId(*key_id)));
        }
    }
}
```

**Secondary Fix - Add Runtime Checks in DKG Flow**:
Add explicit duplicate detection when populating party_polynomials in coordinators:

```rust
// In fire.rs dkg_end_gathered() and frost.rs gather_public_shares()
for (party_id, comm) in &commitments {
    if self.party_polynomials.contains_key(party_id) {
        return Err(Error::DuplicatePartyId);
    }
    self.party_polynomials.insert(*party_id, comm.clone());
}
```

**Tertiary Fix - Apply Same Checks to Signers**:
Add duplicate detection in signer's dkg_ended():

```rust
// In src/state_machine/signer/mod.rs
if self.commitments.contains_key(party_id) {
    return Err(Error::DuplicatePartyId);
}
self.commitments.insert(*party_id, comm.clone());
```

**Testing Recommendations**:
1. Add integration test with duplicate party_ids in configuration
2. Verify PublicKeys::validate() rejects duplicates
3. Test that DKG fails gracefully if duplicates bypass config validation
4. Verify error reporting to identify malicious/misconfigured participants

**Deployment Considerations**:
- This is a breaking change requiring configuration migration
- Existing configurations must be validated and regenerated if duplicates exist
- Consider adding diagnostic tools to detect this issue in production

### Proof of Concept

**Exploitation Steps**:

1. **Setup Malicious Configuration** (lines for illustration):
```
PublicKeys {
    signers: {0: pubkey_A, 1: pubkey_B},
    key_ids: {1: pubkey_1},  // party_id 1 will be claimed by both
    signer_key_ids: {
        0: [1],  // Signer 0 controls party_id 1
        1: [1],  // Signer 1 ALSO controls party_id 1 (DUPLICATE!)
    }
}
```

2. **DKG Execution**:
    - Signer 0 generates polynomial P0, computes commitment C0, creates ID proof for (id=1, P0[0])
    - Signer 1 generates polynomial P1, computes commitment C1, creates ID proof for (id=1, P1[0])  
    - Both send DkgPublicShares messages to coordinator

3. **Coordinator Processing** (fire.rs):
    - Line 797-799: Iterates through dkg_public_shares
  - `party_polynomials[1] = C0` (first insert)
  - `party_polynomials[1] = C1` (overwrites C0!)
    - Line 803-807: Computes aggregate_public_key = C0.poly[0] + C1.poly[0] + ... (includes BOTH)
    - Result: `party_polynomials.len() == 1` but should be 2

4. **Signing Attempt**:
    - Line 1145: `aggregator.init(&self.party_polynomials)` 
    - Aggregator computes: group_poly = C1.poly (C0 is missing!)
    - group_key = C1.poly[0] â‰  aggregate_public_key
    - Line 457-461: Signature verification fails because keys don't match

**Expected Behavior**: DKG should reject duplicate party_ids with Error::DuplicatePartyId

**Actual Behavior**: DKG completes successfully but all subsequent signing operations fail with signature verification errors

**Reproduction Parameters**:
- num_signers: 2
- keys_per_signer: 1 for signer 0, 1 for signer 1 (same party_id)
- threshold: 2
- Attack success rate: 100% once configuration is deployed

### Citations

**File:** src/state_machine/mod.rs (L106-136)
```rust
    pub fn validate(&self, num_signers: u32, num_keys: u32) -> Result<(), SignerError> {
        for (signer_id, _key) in &self.signers {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }
        }

        for (key_id, _key) in &self.key_ids {
            if !validate_key_id(*key_id, num_keys) {
                return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
            }
        }

        for (signer_id, key_ids) in &self.signer_key_ids {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }

            for key_id in key_ids {
                if !validate_key_id(*key_id, num_keys) {
                    return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
                }
            }
        }

        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L794-799)
```rust
    fn dkg_end_gathered(&mut self) -> Result<(), Error> {
        // Cache the polynomials used in DKG for the aggregator
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L802-810)
```rust
        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
```

**File:** src/state_machine/coordinator/fire.rs (L1145-1145)
```rust
            self.aggregator.init(&self.party_polynomials)?;
```

**File:** src/state_machine/coordinator/fire.rs (L1398-1402)
```rust
        let party_polynomials_len = party_polynomials.len();
        let party_polynomials = HashMap::from_iter(party_polynomials);
        if party_polynomials.len() != party_polynomials_len {
            return Err(Error::DuplicatePartyId);
        }
```

**File:** src/state_machine/coordinator/frost.rs (L319-321)
```rust
            for (party_id, comm) in &dkg_public_shares.comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
```

**File:** src/state_machine/signer/mod.rs (L556-561)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
```

**File:** src/state_machine/coordinator/mod.rs (L590-608)
```rust
        let mut key_id: u32 = 1;
        let mut signer_ids_map = HashMap::new();
        let mut signer_key_ids = HashMap::new();
        let mut signer_key_ids_set = HashMap::new();
        let mut signer_public_keys = HashMap::new();
        let mut key_ids_map = HashMap::new();
        for (i, (private_key, public_key)) in key_pairs.iter().enumerate() {
            let mut key_ids = Vec::new();
            let mut key_ids_set = HashSet::new();
            for _ in 0..keys_per_signer {
                key_ids_map.insert(key_id, *public_key);
                key_ids.push(key_id);
                key_ids_set.insert(key_id);
                key_id += 1;
            }
            signer_ids_map.insert(i as u32, *public_key);
            signer_key_ids.insert(i as u32, key_ids);
            signer_key_ids_set.insert(i as u32, key_ids_set);
            signer_public_keys.insert(i as u32, Point::from(private_key));
```

**File:** src/v2.rs (L457-461)
```rust
        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```
