### Title
Nonce Count Validation Bypass Enables Denial of Service in Signature Aggregation

### Summary
The coordinator state machines (fire.rs and frost.rs) fail to validate that the number of nonces in a `NonceResponse` matches the expected count for the signer's protocol version. A malicious signer can send an incorrect number of nonces, which passes initial validation but causes aggregation failure when the mismatch is detected during signature computation. This enables a single compromised signer to repeatedly halt signing rounds without detection.

### Finding Description

**Exact Location:** [1](#0-0) 

The coordinator validates individual nonces but never checks that `nonces.len()` matches the expected count. For v2, exactly 1 nonce per signer is required: [2](#0-1) 

For v1, `nonces.len()` should equal `key_ids.len()`: [3](#0-2) 

**Root Cause:**
The coordinator only validates that key_ids match the configuration and that individual nonces are valid points, but never enforces the protocol-specific nonce count requirement. The validation accepts any number of nonces (including zero) as long as each nonce passes `is_valid()`.

During aggregation, nonces are flattened across all signers: [4](#0-3) 

This creates a mismatch when passed to the aggregator, which expects `nonces.len() == sig_shares.len()`: [5](#0-4) 

**Why Existing Mitigations Fail:**
- Duplicate nonce detection (lines 922-929) only prevents the same signer from sending multiple `NonceResponse` messages, not incorrect nonce counts within a single response [6](#0-5) 

- The key_ids validation only checks set equality, not that nonces match: [7](#0-6) 

- Error handling treats aggregation failures as coordinator errors without identifying the malicious signer: [8](#0-7) 

The same vulnerability exists in frost.rs: [9](#0-8) 

### Impact Explanation

**Specific Harm:**
A single malicious signer can halt all signature generation indefinitely by sending malformed `NonceResponse` messages. When the coordinator attempts aggregation, it receives:
- `nonces.len()` = incorrect count (e.g., 0, 2, 5 instead of expected count)
- `sig_shares.len()` = correct count (one per signer for v2)
- The mismatch triggers `BadNonceLen` error, aborting the signing round

**Quantification:**
- 100% denial of service for any signing operation involving the malicious signer
- Attack repeatable indefinitely without detection or banning
- Affects all signature types (regular, Schnorr, Taproot)
- No signatures can be produced until the malicious signer is manually removed from the configuration

**Who Is Affected:**
All nodes using WSTS coordinators (fire.rs or frost.rs) with at least one compromised signer. In Stacks blockchain context, this prevents miners from producing valid blocks if threshold signatures are required for block signing.

**Severity:** **Low** per protocol scope - "Any remotely-exploitable denial of service in a node"

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control or compromise of a single valid signer in the threshold signature set
- Ability to send malformed `NonceResponse` messages on the network
- No cryptographic breaks required

**Attack Complexity:**
Trivial. The attacker simply modifies their `NonceResponse` to contain an incorrect number of nonces:
- v2 attack: Send 0 or 2+ nonces instead of 1
- v1 attack: Send nonces.len() != key_ids.len()

**Economic Feasibility:**
Minimal cost - only requires compromising one signer's communications or implementation. The attack is not rate-limited and causes no cost to the attacker.

**Detection Risk:**
The attack is not detected. The coordinator logs the error as a generic aggregation failure without identifying which signer sent malformed data. The malicious signer remains in good standing and can repeat the attack.

**Probability:** Very High - The attack is trivial to execute, undetectable, and repeatable if any signer is compromised.

### Recommendation

**Primary Fix:**
Add nonce count validation when receiving `NonceResponse` in both coordinators:

For v2 coordinators, enforce exactly 1 nonce per signer:
```rust
// After line 889 in fire.rs
if nonce_response.nonces.len() != 1 {
    warn!(
        signer_id = %nonce_response.signer_id, 
        "Expected 1 nonce for v2, got {}", 
        nonce_response.nonces.len()
    );
    return Ok(());
}
```

For v1 coordinators, enforce nonces.len() == key_ids.len():
```rust
// After line 889 in fire.rs
if nonce_response.nonces.len() != signer_key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id,
        "Expected {} nonces, got {}",
        signer_key_ids.len(),
        nonce_response.nonces.len()
    );
    return Ok(());
}
```

Apply the same fix to frost.rs after line 521.

**Alternative Mitigation:**
If runtime version detection is not feasible, add a configuration parameter specifying expected nonces per signer and validate against it.

**Testing:**
1. Create test case where malicious signer sends 0 nonces
2. Create test case where malicious signer sends 5 nonces (v2) or wrong count (v1)
3. Verify both are rejected with appropriate warning logs
4. Verify honest signers with correct nonce counts are still accepted

**Deployment:**
Deploy immediately as this is a simple validation check with no breaking changes to honest signers.

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:** Join a WSTS threshold signature group as a valid signer with configured key_ids
2. **Wait:** Receive `NonceRequest` from coordinator for a signing operation
3. **Attack:** Send malformed `NonceResponse`:
   ```
   NonceResponse {
       dkg_id: <valid>,
       sign_id: <valid>,
       sign_iter_id: <valid>,
       signer_id: <attacker_id>,
       key_ids: <configured_key_ids>,  // Correct
       nonces: vec![],                 // WRONG: empty instead of 1 (v2)
       message: <message>,
   }
   ```
4. **Pass Validation:** Coordinator validates key_ids (correct) and nonces (empty array passes loop check)
5. **Wait:** Coordinator reaches threshold with other honest signers
6. **Receive:** `SignatureShareRequest` is broadcast
7. **Optionally Send:** Valid signature share (or timeout)
8. **Aggregation Fails:** Coordinator flattens nonces from all signers:
   - Honest signers: N nonces total
   - Flattened array missing attacker's nonce(s)
   - `nonces.len() != sig_shares.len()` check fails
   - Returns `BadNonceLen` error
9. **Result:** Signing round aborted, no signature produced
10. **Repeat:** Attack repeatable for every subsequent signing attempt

**Expected vs Actual Behavior:**
- Expected: Malformed `NonceResponse` with wrong nonce count rejected during validation
- Actual: Malformed `NonceResponse` accepted, causes aggregation failure later

**Reproduction:**
1. Modify a v2 signer to send `nonces: vec![]` in `NonceResponse`
2. Run signing protocol with 3 signers (1 malicious, 2 honest)
3. Observe coordinator logs show aggregation failure with `BadNonceLen` error
4. Verify no signature was produced and malicious signer was not identified

### Citations

**File:** src/state_machine/coordinator/fire.rs (L328-333)
```rust
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L891-901)
```rust
            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L922-929)
```rust
            let have_nonces = nonce_info
                .public_nonces
                .contains_key(&nonce_response.signer_id);

            if have_nonces {
                info!(signer_id = %nonce_response.signer_id, "Received duplicate NonceResponse");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1121-1124)
```rust
            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();
```

**File:** src/v2.rs (L304-306)
```rust
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }
```

**File:** src/v2.rs (L627-633)
```rust
    fn gen_nonces<RNG: RngCore + CryptoRng>(
        &mut self,
        secret_key: &Scalar,
        rng: &mut RNG,
    ) -> Vec<PublicNonce> {
        vec![self.gen_nonce(secret_key, rng)]
    }
```

**File:** src/v1.rs (L676-685)
```rust
    fn gen_nonces<RNG: RngCore + CryptoRng>(
        &mut self,
        secret_key: &Scalar,
        rng: &mut RNG,
    ) -> Vec<PublicNonce> {
        self.parties
            .iter_mut()
            .map(|p| p.gen_nonce(secret_key, rng))
            .collect()
    }
```

**File:** src/state_machine/coordinator/frost.rs (L523-533)
```rust
            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }
```
