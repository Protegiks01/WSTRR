### Title
Missing Nonce Count Validation Allows Partial Nonce Set Acceptance Leading to Invalid Signature Generation

### Summary
The `sign_share_request()` function in the signer state machine fails to validate that each `NonceResponse` contains the expected number of nonces. A malicious coordinator can send a `SignatureShareRequest` containing `NonceResponse` messages with missing or empty nonce arrays, which passes validation because only the validity of present nonces is checked. This forces all signers to generate invalid signature shares based on incorrect aggregated nonce commitments, resulting in signature generation failure.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The validation logic collects all nonces via `flat_map` and only validates individual nonce validity using `is_valid()`. There is no check ensuring:
- Each `NonceResponse` contains the expected number of nonces (1 for v2, or `key_ids.len()` for v1)
- The total nonce count matches the number of participating signers/keys
- No `NonceResponse` has an empty nonces array [2](#0-1) 

The existing validation at lines 762-779 only checks for duplicate signer IDs and valid signer ID ranges, but does not validate nonce counts.

**Why Existing Mitigations Fail:**
The signer verifies the coordinator's signature on the `SignatureShareRequest` packet: [3](#0-2) 

However, this only confirms the coordinator signed the message. Critically, signers do NOT re-verify the embedded `NonceResponse` signatures that were originally created by individual signers. The coordinator can modify the `nonces` arrays within `NonceResponse` messages before including them in the `SignatureShareRequest`, and signers have no mechanism to detect this tampering. [4](#0-3) 

### Impact Explanation

**Specific Harm:**
When signers process a `SignatureShareRequest` with partial nonces, they call signing functions with mismatched array lengths. In `compute::intermediate()`, the nonces array is zipped with binding coefficients computed per signer: [5](#0-4) 

If nonces are missing (e.g., 2 nonces for 3 signers), the zip operation silently truncates to the minimum length, causing:
1. Incorrect aggregated nonce commitment `R` computed from partial nonce set
2. Wrong pairing between nonces and binding coefficients
3. All affected signers generate signature shares based on the incorrect `R`
4. Signature aggregation fails when the coordinator attempts to create the final signature

**Quantified Impact:**
A malicious coordinator controlling message distribution can:
- Force 100% of participating signers to generate invalid signature shares
- Prevent any valid threshold signatures from being produced
- Cause complete denial of service for signing operations

**Who is Affected:**
All WSTS-based systems relying on threshold signatures, including Stacks PoX and Bitcoin peg operations. If signature generation is blocked, critical transactions (e.g., Bitcoin withdrawals, block confirmations) cannot be signed.

**Severity Justification:**
This maps to **Low severity** per the defined scope: "Any remotely-exploitable denial of service in a node." The coordinator can force signing operations to fail, preventing transaction confirmation without shutting down the network entirely.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of the coordinator process OR ability to compromise the coordinator
- Network position to intercept and modify `NonceResponse` messages before they are included in `SignatureShareRequest`

**Attack Complexity:**
Low. The attack requires:
1. Coordinator receives genuine `NonceResponse` messages from threshold+ signers
2. Coordinator modifies one or more `NonceResponse` messages to have empty or partial nonce arrays
3. Coordinator creates and signs the `SignatureShareRequest` with modified messages
4. All signers accept it (validation passes)
5. All signers generate invalid signature shares

**Economic Feasibility:**
High. The coordinator is already a privileged component with message distribution control. No additional resources or cryptographic breaks required.

**Detection Risk:**
Medium. The attack appears as natural signature generation failure. Debugging would reveal mismatched array lengths, but determining whether the coordinator or signers caused the issue requires additional forensics.

**Probability of Success:**
Very high if the coordinator is malicious. The validation gaps ensure the attack succeeds with 100% reliability.

### Recommendation

**Proposed Code Changes:**

Add validation after line 795 in `sign_share_request()`:

```rust
// After existing nonce validation at line 795, add:

// For v2: each signer should provide exactly 1 nonce
// For v1: each signer should provide nonces.len() == key_ids.len()
let expected_nonce_count: usize = if SignerType::is_v2() {
    signer_id_set.len()
} else {
    sign_request.nonce_responses
        .iter()
        .map(|nr| nr.key_ids.len())
        .sum()
};

if nonces.len() != expected_nonce_count {
    warn!(
        signer_id = %self.signer_id,
        expected = expected_nonce_count,
        actual = nonces.len(),
        "SignatureShareRequest has incorrect nonce count"
    );
    return Err(Error::InvalidNonceResponse);
}

// Additionally, verify each NonceResponse individually
for nonce_response in &sign_request.nonce_responses {
    let expected_nonces_per_response = if SignerType::is_v2() {
        1
    } else {
        nonce_response.key_ids.len()
    };
    
    if nonce_response.nonces.len() != expected_nonces_per_response {
        warn!(
            signer_id = %self.signer_id,
            nonce_response_signer = nonce_response.signer_id,
            expected = expected_nonces_per_response,
            actual = nonce_response.nonces.len(),
            "NonceResponse has incorrect nonce count"
        );
        return Err(Error::InvalidNonceResponse);
    }
}
```

**Alternative Mitigation:**
Re-verify embedded `NonceResponse` signatures to detect coordinator tampering. However, this requires signers to have access to all signer public keys and adds significant verification overhead.

**Testing Recommendations:**
1. Test with empty nonces arrays in `NonceResponse`
2. Test with partial nonce sets (fewer nonces than expected)
3. Test with excess nonces (more nonces than expected)
4. Verify proper rejection in all cases

**Deployment Considerations:**
This is a backward-compatible fix that adds stricter validation. Deploy via standard update mechanisms.

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Standard WSTS signing scenario with 3 signers in v2 mode, threshold = 3
   - Signer 0 controls key_ids [0, 1]
   - Signer 1 controls key_ids [2, 3, 4]  
   - Signer 2 controls key_ids [5]

2. **Normal Flow**: Each signer responds to `NonceRequest` with valid `NonceResponse`:
   - Signer 0: `nonces = [nonce_0]` (1 nonce for v2)
   - Signer 1: `nonces = [nonce_1]` (1 nonce for v2)
   - Signer 2: `nonces = [nonce_2]` (1 nonce for v2)

3. **Attack**: Malicious coordinator modifies NonceResponse from Signer 1:
   - Changes `nonce_responses[1].nonces` from `[nonce_1]` to `[]` (empty array)
   - Creates `SignatureShareRequest` with modified nonce_responses
   - Signs with coordinator key

4. **Signer Processing** at lines 781-795:
   - Flattened nonces: `[nonce_0, nonce_2]` (length = 2, missing nonce_1)
   - Validation: Both nonce_0 and nonce_2 pass `is_valid()` ✓
   - No check that array length should be 3 ✗

5. **Signing Computation** in v2::Party::sign: [6](#0-5) 
   
   Calls `compute::intermediate(msg, signer_ids=[0,1,2], nonces=[nonce_0, nonce_2])`:
   - Computes rhos for 3 signers: `[rho_0, rho_1, rho_2]`
   - Zips with 2 nonces: `zip([nonce_0, nonce_2], [rho_0, rho_1, rho_2])`
   - Produces only 2 R values: `[(nonce_0, rho_0), (nonce_2, rho_1)]`
   - **Bug**: nonce_2 paired with rho_1 instead of rho_2!

6. **Expected vs Actual**:
   - Expected: R = R_0 + R_1 + R_2 (all three nonces)
   - Actual: R = R_0 + R_1' (only two, with wrong binding)

7. **Result**: All signers generate signature shares based on incorrect R, aggregation fails with invalid signature.

**Reproduction Instructions:**
Modify coordinator code to set `nonce_responses[1].nonces = vec![]` before creating `SignatureShareRequest`, then observe signature aggregation failure despite all signers participating.

### Citations

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L762-779)
```rust
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }
```

**File:** src/state_machine/signer/mod.rs (L781-795)
```rust
        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }
```

**File:** src/net.rs (L349-368)
```rust
impl Signable for NonceResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }

        for nonce in &self.nonces {
            hasher.update(nonce.D.compress().as_bytes());
            hasher.update(nonce.E.compress().as_bytes());
        }

        hasher.update(self.message.as_slice());
    }
}
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** src/v2.rs (L635-642)
```rust
    fn compute_intermediate(
        msg: &[u8],
        signer_ids: &[u32],
        _key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> (Vec<Point>, Point) {
        compute::intermediate(msg, signer_ids, nonces)
    }
```
