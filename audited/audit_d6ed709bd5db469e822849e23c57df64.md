### Title
Unvalidated Private Shares Included in DKG Key Derivation

### Summary
The `Party::compute_secret()` function in both v1 and v2 implementations fails to reject private shares that lack corresponding public commitments, instead only logging a warning and including these unvalidated shares in the final private key computation. This allows an attacker to contribute arbitrary private share values without providing verifiable public commitments, resulting in a group private key that is inconsistent with the group public key and produces invalid signatures.

### Finding Description

**Exact Code Location:**
- `src/v1.rs`, function `Party::compute_secret()`, lines 150-209, specifically line 197 (warning) and line 205 (summation) [1](#0-0) [2](#0-1) 

- `src/v2.rs`, function `Signer::compute_secret()`, lines 123-202, specifically line 174 (warning) and line 191 (summation) [3](#0-2) [4](#0-3) 

**Root Cause:**
The validation logic performs two checks:
1. Lines 172-180 (v1) / 146-163 (v2): Verify every public commitment has a corresponding private share
2. Lines 191-199 (v1) / 165-183 (v2): Verify every private share has a corresponding public commitment

However, when the second check fails (private share without public commitment), the code only logs a warning instead of returning an error or excluding the share from computation. [5](#0-4) 

Subsequently, ALL private shares are summed into the final private key, including those that were never validated against public commitments. [6](#0-5) 

**Attack Vector:**
The vulnerability is exploitable through the DKG state machine flow:

1. Attacker sends `DkgPrivateShares` messages directly to honest signers (peer-to-peer), which get decrypted and stored in `decrypted_shares` [7](#0-6) 

2. Attacker does NOT send `DkgPrivateShares` to the coordinator (or sends corrupted ones that are rejected)

3. Coordinator creates `DkgEndBegin` with `signer_ids` containing only signers that successfully sent shares to the coordinator (excluding attacker) [8](#0-7) 

4. In `dkg_ended()`, only signers in `signer_ids_set` (derived from `DkgEndBegin.signer_ids`) have their public commitments added to `self.commitments` [9](#0-8) 

5. `compute_secrets` is called with ALL `decrypted_shares` (including attacker's) but `commitments` excludes attacker's parties [10](#0-9) 

6. The attacker's private shares have no corresponding public commitments, triggering the warning but still being included in the final key

**Why Existing Mitigations Fail:**
The check for bad public shares only processes signers in `signer_ids_set`, so if an attacker is excluded from that set, their invalid or missing public shares never cause DKG failure. [11](#0-10) 

### Impact Explanation

**Specific Harm:**
The vulnerability breaks the fundamental VSS (Verifiable Secret Sharing) property of DKG, producing a group private key that includes unverified contributions. This creates an inconsistency where:
- Group public key = sum of valid polynomial constants (excluding attacker)
- Group private key = sum of all private shares (including attacker's unverified shares)

Since the private key doesn't correspond to the public key, all signatures produced will be INVALID and fail verification.

**Quantified Impact:**
- DKG round appears to succeed but produces unusable keys
- All subsequent signing attempts produce invalid signatures that are rejected
- Threshold signature scheme becomes non-functional until new DKG is performed
- Affects all honest parties that participated in the compromised DKG round

**Affected Parties:**
All honest signers in a DKG round where an attacker exploits this vulnerability.

**Severity Justification:**
This maps to **Medium** severity under the protocol scope: "Any transient consensus failures"
- The attack prevents honest parties from producing valid signatures
- This causes temporary inability to sign transactions/blocks
- However, it does not directly cause fund loss, chain splits, or permanent damage
- A new DKG round can restore functionality

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Network access to send `DkgPrivateShares` messages to honest signers via peer-to-peer channels
2. Ability to selectively NOT send messages to the coordinator (network partitioning or message filtering)
3. Knowledge of DKG protocol timing to send shares before coordinator decides final signer set

**Attack Complexity:** Medium
- Requires understanding of DKG protocol flow
- Requires ability to control message routing to different recipients
- In a decentralized P2P network, selective message delivery is feasible through network-level controls
- No cryptographic breaks or timing-sensitive races required

**Economic Feasibility:** High
- Attack costs are minimal (standard network participation)
- No economic stake or collateral required to launch attack
- Can repeatedly disrupt DKG rounds with low cost

**Detection Risk:** Low
- Attack is not detected during DKG (DKG succeeds with "Success" status)
- Only discovered when signatures fail verification in subsequent signing rounds
- Difficult to attribute blame since all parties believe DKG succeeded

**Estimated Probability:** Medium-High
- Prerequisites are reasonable for network-level attackers
- Attack is undetectable during DKG phase
- Can be executed repeatedly

### Recommendation

**Immediate Fix:**
Modify the validation logic to reject private shares without corresponding public commitments instead of just logging a warning. Change lines 191-199 in v1.rs and 165-183 in v2.rs to:

1. Track which private shares lack public commitments in a `missing_commitments` vector
2. Return `Err(DkgError::MissingPublicShares(missing_commitments))` if any are found
3. Alternatively, exclude such shares from the summation at line 205/191

**Complete Mitigation:**
Additionally, in `dkg_ended()` (src/state_machine/signer/mod.rs), filter `decrypted_shares` to only include parties from `signer_ids_set` before passing to `compute_secrets`:

```
let filtered_shares: HashMap<u32, HashMap<u32, Scalar>> = self.decrypted_shares
    .iter()
    .filter(|(party_id, _)| {
        // Only include shares from signers in signer_ids_set
        self.public_keys.signer_key_ids.iter()
            .any(|(signer_id, key_ids)| {
                signer_ids_set.contains(signer_id) && key_ids.contains(party_id)
            })
    })
    .map(|(k, v)| (*k, v.clone()))
    .collect();
```

**Testing Recommendations:**
1. Add test case where a signer sends `DkgPrivateShares` to other signers but not to coordinator
2. Verify that DKG fails with appropriate error instead of succeeding
3. Test that valid signature production works after fix
4. Add integration test simulating network partitioning scenarios

**Deployment Considerations:**
- This is a consensus-critical change affecting DKG key derivation
- All nodes must upgrade simultaneously to maintain consistent DKG behavior
- Coordinate upgrade with scheduled DKG rounds to avoid in-progress DKG failures

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:** Attacker is configured as legitimate signer in DKG round with network access

2. **Phase 1 - Public Shares:**
   - All parties (including attacker) send `DkgPublicShares` normally
   - Coordinator collects public shares from all parties

3. **Phase 2 - Private Shares (Attack):**
   - Coordinator sends `DkgPrivateBegin` to all signers
   - Honest signers encrypt and send `DkgPrivateShares` to all parties + coordinator
   - **Attacker sends `DkgPrivateShares` to honest signers only (not to coordinator)**
   - Attacker can use arbitrary malicious scalar values for shares

4. **Phase 3 - DKG End:**
   - Coordinator creates `DkgEndBegin` with `signer_ids` = signers that sent to coordinator (excludes attacker)
   - Honest signers receive `DkgEndBegin` and call `dkg_ended()`
   - `dkg_ended()` only adds public commitments from signers in `signer_ids` to `commitments` map
   - Attacker's public commitments are NOT in `commitments`
   - But attacker's private shares ARE in `decrypted_shares`

5. **Phase 4 - Secret Computation:**
   - `compute_secrets` called with `decrypted_shares` (includes attacker) and `commitments` (excludes attacker)
   - In `Party::compute_secret()`, iteration over attacker's private shares finds no public commitment
   - Warning logged at line 197: "unable to check private share from {attacker_party_id}"
   - Line 205 sums ALL shares including attacker's unvalidated malicious values

6. **Result:**
   - Group public key = sum of honest parties' polynomial constants
   - Group private key = sum of honest + attacker's arbitrary shares
   - Private key doesn't correspond to public key
   - All signatures will be invalid

**Expected vs Actual Behavior:**
- **Expected:** DKG should fail when private shares lack corresponding validated public commitments
- **Actual:** DKG succeeds with warning, produces inconsistent keys that generate invalid signatures

**Reproduction Steps:**
1. Set up DKG with 4 signers (3 honest, 1 attacker)
2. Configure network to allow attacker to send to honest signers but not coordinator
3. Execute DKG protocol
4. Observe warning in honest signer logs: "unable to check private share from {attacker_id}"
5. Observe DKG completes with Success status
6. Attempt to sign a message with resulting keys
7. Observe signature verification fails

### Citations

**File:** src/v1.rs (L191-199)
```rust
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
            } else {
                warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", i);
            }
        }
```

**File:** src/v1.rs (L205-206)
```rust
        self.private_key = private_shares.values().sum();
        self.public_key = self.private_key * G;
```

**File:** src/v2.rs (L174-174)
```rust
                        warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", sender);
```

**File:** src/v2.rs (L191-191)
```rust
                let secret = shares.values().sum();
```

**File:** src/state_machine/signer/mod.rs (L551-566)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L593-599)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L612-616)
```rust
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
```

**File:** src/state_machine/signer/mod.rs (L1099-1099)
```rust
            self.decrypted_shares.insert(*src_id, decrypted_shares);
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```
