### Title
Polynomial Secret Exposure Through Public Fields and Serialization

### Summary
The `random_poly()` function generates polynomials where the constant term is the party's secret share, but `PartyState` and `SignerState` expose this polynomial through public fields and derive `Serialize`, allowing trivial access to secret key material. While custom `Debug` implementations prevent direct logging, they provide false security as serialization or direct field access bypasses all protections, enabling complete private key reconstruction.

### Finding Description

**Exact Code Location:** [1](#0-0) [2](#0-1) [3](#0-2) 

**Root Cause:**

The polynomial generated by `random_poly()` contains the secret share in its constant term (coefficient at index 0). This is confirmed in the DKG flow: [4](#0-3) 

The constant term `poly.data()[0]` is used as the secret for ID creation. However, `PartyState` stores this polynomial in a **public field** that derives `Serialize`:

- Line 19 of traits.rs: `pub polynomial: Option<Polynomial<Scalar>>` - PUBLIC field containing the secret
- Line 21: `pub private_keys: Vec<(u32, Scalar)>` - PUBLIC field containing derived private keys  
- Line 15: `#[derive(Clone, Deserialize, Serialize, PartialEq)]` - Enables serialization

**Why Existing Mitigations Fail:**

The custom `Debug` implementation only prevents format printing: [5](#0-4) 

This protection is **completely bypassed** by:
1. **Direct field access**: `state.polynomial.as_ref().unwrap().data()[0]` - obtains the secret directly
2. **Serialization**: `serde_json::to_string(&state)` - serializes all polynomial coefficients including the secret
3. **Public API exposure**: Both `PartyState` and `SignerState` are public structs in the traits module

The `save()` method returns these vulnerable types: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Concrete Harm:**

If an attacker obtains a party's polynomial (through logging, serialization, or direct access):

1. **Secret share extraction**: The constant term `poly.data()[0]` is the party's secret contribution to the group key
2. **Share reconstruction**: All shares distributed by that party can be recomputed via `poly.eval(key_id)`
3. **Threshold compromise**: With `t` exposed polynomials (threshold number), the attacker reconstructs the complete group private key
4. **Signature forgery**: The attacker can sign arbitrary messages, creating invalid transactions

**Quantified Impact:**

- **Threshold t=7, parties=10**: Attacker needs 7 exposed polynomials (70% compromise rate)
- **Result**: Complete loss of group key control â†’ unlimited signature forgery
- **Chain impact**: Invalid transaction confirmation (Critical severity per scope)
- **Fund loss**: All funds controlled by the compromised group key (Critical severity per scope)

**Who is Affected:**

All WSTS users who persist state, implement debugging/monitoring, or use external serialization for the library's public types.

**Severity Justification:**

Maps to **Critical** scope: "Any causing the direct loss of funds" and "Any confirmation of an invalid transaction" - an attacker with exposed polynomials can forge signatures to spend funds or confirm invalid transactions.

### Likelihood Explanation

**Required Attacker Capabilities:**

1. **Access to serialized state**: Obtain logs, debug output, persisted state files, or crash dumps containing serialized `PartyState`/`SignerState`
2. **No cryptographic breaks required**: Direct field access or deserialization provides plaintext secrets
3. **Position**: Internal access (developer/operator logs) or compromised storage/monitoring systems

**Attack Complexity:** LOW

Common developer patterns that expose secrets:
```rust
// Pattern 1: Debugging/logging
let state = signer.save();
let json = serde_json::to_string(&state)?;
log::info!("State checkpoint: {}", json); // SECRET EXPOSED

// Pattern 2: Persistence
std::fs::write("state.json", serde_json::to_string(&state)?)?; // SECRET IN PLAINTEXT

// Pattern 3: Direct access
let secret = state.parties[0].1.polynomial.as_ref().unwrap().data()[0]; // SECRET EXTRACTED
```

**Economic Feasibility:** 

Highly feasible - no computational cost, only requires accessing log files or storage that developers routinely create for debugging/persistence.

**Detection Risk:**

Low - accessing logs or serialized state leaves no cryptographic traces. Legitimate operators regularly serialize state for backup/recovery.

**Estimated Probability:** HIGH

- Serialization for persistence is standard practice
- No documentation warns against it
- Custom Debug impl creates false sense of security
- Public fields make exploitation trivial

### Recommendation

**Immediate Fixes:**

1. **Remove Serialize/Deserialize from sensitive types:**

```rust
// Remove Serialize/Deserialize from PartyState
#[derive(Clone, PartialEq)]
pub struct PartyState {
    polynomial: Option<Polynomial<Scalar>>, // Make private
    private_keys: Vec<(u32, Scalar)>,       // Make private
    pub nonce: Nonce,
}
```

2. **Implement secure serialization wrapper:**

```rust
// Only serialize non-secret data, store secrets in encrypted form
pub struct SerializablePartyState {
    pub encrypted_secrets: Vec<u8>, // AES-GCM encrypted polynomial + keys
    pub nonce: Nonce,
}

impl PartyState {
    pub fn to_serializable(&self, encryption_key: &[u8]) -> SerializablePartyState {
        // Encrypt polynomial and private_keys before serialization
    }
}
```

3. **Make fields private:**

Change all secret fields from `pub` to private, provide only necessary accessors that don't expose raw secret material.

**Alternative Mitigations:**

- Use newtype wrappers with `#[serde(skip)]` for secret fields
- Implement custom Serialize that explicitly excludes secret fields
- Add compile-time warnings via deprecated attributes on `save()` methods

**Testing Recommendations:**

1. Add tests verifying secrets are NOT in serialized output
2. Test that direct field access is prevented (compilation failure)
3. Audit all existing code for accidental serialization

**Deployment Considerations:**

- **Breaking change**: Existing serialized state will be incompatible
- Migration path needed for users with persisted state
- Document secure state management patterns
- Audit all logs/storage for exposed secrets before deploying fix

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Create a standard WSTS signer during DKG

2. **Exploit via serialization**:
```rust
use wsts::traits::Signer;
use wsts::v2::Signer as V2Signer;

// Normal DKG setup
let mut rng = create_rng();
let signer = V2Signer::new(0, &[1, 2], 4, 10, 7, &mut rng);

// VULNERABILITY: Save and serialize state
let state = signer.save();
let json = serde_json::to_string(&state).unwrap();

// Attacker obtains json from logs
let recovered: SignerState = serde_json::from_str(&json).unwrap();

// Extract secret polynomial coefficients
if let Some(poly) = &recovered.parties[0].1.polynomial {
    let secret = poly.data()[0]; // THE SECRET SHARE
    println!("Stolen secret: {:?}", secret); // Now attacker has the secret
}
```

3. **Exploit via direct access**:
```rust
// Even simpler - direct field access
let state = signer.save();
let secret = state.parties[0].1.polynomial.as_ref().unwrap().data()[0];
// Attacker now has the secret share
```

**Expected vs Actual Behavior:**

- **Expected**: Secret polynomial should never be accessible or serializable
- **Actual**: Polynomial is in public field and serializes to JSON with all coefficients visible

**Reproduction:**

Run the above code in any WSTS project. The secret polynomial coefficients will be plaintext accessible through either serialization or direct field access, with no protection mechanism preventing it.

**Notes**

The vulnerability exists because the library conflates two different concerns: (1) internal state management that requires access to secrets, and (2) external state persistence that should never expose secrets. The custom `Debug` implementation suggests the developers were aware of the logging risk, but the public fields and `Serialize` derivation completely undermine that protection. This is particularly dangerous because it creates a false sense of security - developers see the custom `Debug` impl and assume secrets are protected, then proceed to serialize state for persistence without realizing they're exposing key material.

### Citations

**File:** src/vss.rs (L11-14)
```rust
    pub fn random_poly<RNG: RngCore + CryptoRng>(n: u32, rng: &mut RNG) -> Polynomial<Scalar> {
        let params: Vec<Scalar> = (0..n + 1).map(|_| Scalar::random(rng)).collect();
        Polynomial::new(params)
    }
```

**File:** src/traits.rs (L15-24)
```rust
#[derive(Clone, Deserialize, Serialize, PartialEq)]
/// The saved state required to reconstruct a party
pub struct PartyState {
    /// The party's private polynomial
    pub polynomial: Option<Polynomial<Scalar>>,
    /// The key IDS and associate private keys for this party
    pub private_keys: Vec<(u32, Scalar)>,
    /// The nonce being used by this party
    pub nonce: Nonce,
}
```

**File:** src/traits.rs (L26-30)
```rust
impl fmt::Debug for PartyState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PartyState").finish_non_exhaustive()
    }
}
```

**File:** src/traits.rs (L32-49)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// The saved state required to reconstruct a signer
pub struct SignerState {
    /// The signer ID
    pub id: u32,
    /// The key IDs this signer controls
    pub key_ids: Vec<u32>,
    /// The total number of keys
    pub num_keys: u32,
    /// The total number of parties
    pub num_parties: u32,
    /// The threshold for signing
    pub threshold: u32,
    /// The aggregate group public key
    pub group_key: Point,
    /// The party IDs and associated state for this signer
    pub parties: Vec<(u32, PartyState)>,
}
```

**File:** src/v1.rs (L86-93)
```rust
    /// Save the state required to reconstruct the party
    pub fn save(&self) -> traits::PartyState {
        traits::PartyState {
            private_keys: vec![(self.id, self.private_key)],
            polynomial: self.f.clone(),
            nonce: self.nonce.clone(),
        }
    }
```

**File:** src/v1.rs (L107-123)
```rust
    pub fn get_poly_commitment<RNG: RngCore + CryptoRng>(
        &self,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Option<PolyCommitment> {
        if let Some(poly) = &self.f {
            Some(PolyCommitment {
                id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
                poly: (0..poly.data().len())
                    .map(|i| &poly.data()[i] * G)
                    .collect(),
            })
        } else {
            warn!("get_poly_commitment called with no polynomial");
            None
        }
    }
```

**File:** src/v2.rs (L542-557)
```rust
    fn save(&self) -> traits::SignerState {
        let party_state = traits::PartyState {
            polynomial: self.f.clone(),
            private_keys: self.private_keys.iter().map(|(k, v)| (*k, *v)).collect(),
            nonce: self.nonce.clone(),
        };
        traits::SignerState {
            id: self.party_id,
            key_ids: self.key_ids.clone(),
            num_keys: self.num_keys,
            num_parties: self.num_parties,
            threshold: self.threshold,
            group_key: self.group_key,
            parties: vec![(self.party_id, party_state)],
        }
    }
```
