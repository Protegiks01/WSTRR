### Title
Unbounded Message Size Allows Memory Exhaustion in Coordinator

### Summary
The `start_signing_round()` function stores incoming messages without size validation, allowing malicious authorized signers to trigger memory exhaustion on the coordinator node. When a signing message is received, it is copied into memory via `.to_vec()` without checking its size, enabling a denial-of-service attack against the coordinator with messages as small as several hundred megabytes.

### Finding Description

**Location:**
- File: `src/state_machine/coordinator/fire.rs`
- Function: `start_signing_round()`
- Line: 1467
- Additional affected location: `gather_nonces()` line 919 (`message_nonces` map) [1](#0-0) 

**Root Cause:**

The coordinator stores the message parameter directly without any size validation. At line 1467, `self.message = message.to_vec()` unconditionally allocates heap memory proportional to the message size. The message originates from network packets in two ways:

1. Via `NonceRequest` messages processed in the Idle state [2](#0-1) 

2. Via `NonceResponse` messages stored in the `message_nonces` BTreeMap as keys [3](#0-2) 

The `NonceRequest` structure contains an unbounded `message: Vec<u8>` field with no size constraints: [4](#0-3) 

Similarly, `NonceResponse` contains an unbounded message field: [5](#0-4) 

**Why Existing Mitigations Fail:**

While the coordinator implements packet signature verification [6](#0-5) , this only authenticates the sender's identityâ€”it does not prevent malicious behavior by authorized participants. 

The default configuration enables signature verification [7](#0-6) , meaning `NonceRequest` must be signed by the coordinator and `NonceResponse` by valid signers [8](#0-7) . However, this provides no protection against:

1. A malicious authorized signer in the threshold group (Byzantine fault scenario)
2. Deployments that disable `verify_packet_sigs` for testing or trusted networks
3. Compromised signer private keys

The WSTS protocol is explicitly designed to handle Byzantine faults, as evidenced by the `malicious_signer_ids` tracking mechanism [9](#0-8) , making insider attacks part of the threat model.

### Impact Explanation

**Specific Harm:**
A malicious authorized signer can send a single `NonceResponse` message containing a multi-gigabyte payload, causing the coordinator to exhaust available memory and crash or become unresponsive. Multiple signers could coordinate to send different large messages that accumulate in the `message_nonces` BTreeMap during a signing round.

**Quantified Impact:**
- A single 1 GB message causes immediate memory allocation of 1 GB on the coordinator
- With 10 malicious signers, up to 10 GB could be allocated in `message_nonces` before the round completes
- Coordinator becomes unable to coordinate DKG or signing rounds
- Dependent blockchain systems cannot generate threshold signatures
- Service disruption until coordinator is restarted

**Affected Parties:**
- Coordinator nodes in any WSTS deployment
- Blockchain systems relying on WSTS for transaction signing
- All signers waiting for signature completion

**Severity Justification:**
This vulnerability maps to **Low severity** per the audit scope: "Any remotely-exploitable denial of service in a node." The attack causes coordinator unavailability but does not compromise cryptographic security, enable fund theft, or cause consensus failures.

### Likelihood Explanation

**Required Attacker Capabilities:**

Scenario 1 (Byzantine Fault - Default Config):
- Attacker controls at least one authorized signer's private key
- Can send network packets to the coordinator
- Access to standard WSTS client libraries

Scenario 2 (Disabled Signature Verification):
- Network access to coordinator
- Knowledge of coordinator endpoint
- No authentication required

**Attack Complexity:**
LOW - The attack requires only:
1. Crafting a `NonceResponse` message with a large byte array
2. Signing it with a valid signer key (Scenario 1) or skipping signature (Scenario 2)
3. Sending one network packet
4. Immediate memory exhaustion occurs upon processing

**Economic Feasibility:**
Trivial - Attack costs only network bandwidth to send 100MB-1GB packets. No computational work, staking, or economic resources required.

**Detection Risk:**
MEDIUM - The attack is detectable through:
- Abnormal memory usage spikes in monitoring
- Large packet sizes in network logs
- Coordinator becoming unresponsive

However, damage occurs immediately upon packet processing, before detection systems can respond.

**Probability of Success:**
- With Byzantine adversary: HIGH (95%+) - Authorized signers can always send messages
- With disabled signature verification: VERY HIGH (99%+) - No barriers to attack
- With all mitigations enabled and no compromised keys: LOW (but not zero - insider threat remains)

### Recommendation

**Primary Fix:**
Implement message size limits in the coordinator configuration:

1. Add a `max_message_size: usize` field to the `Config` struct (default: 1 MB)
2. Validate message size before allocation in `start_signing_round()`:
   ```rust
   if message.len() > self.config.max_message_size {
       return Err(Error::MessageTooLarge(message.len(), self.config.max_message_size));
   }
   self.message = message.to_vec();
   ```
3. Add similar validation in `gather_nonces()` before inserting into `message_nonces`
4. Define a new `Error::MessageTooLarge` variant

**Additional Mitigations:**
1. Implement a limit on the number of concurrent entries in `message_nonces` (e.g., 100 messages max)
2. Add rate limiting per signer for message submissions
3. Log warnings when messages exceed expected sizes (e.g., 100 KB)
4. Consider streaming/chunked processing for legitimately large messages if needed

**Testing Recommendations:**
1. Unit tests with messages at and above the size limit
2. Integration tests simulating malicious signers sending oversized messages
3. Memory profiling tests under attack conditions
4. Performance testing to ensure legitimate large messages (if needed) can be accommodated

**Deployment Considerations:**
- Choose `max_message_size` based on actual use case requirements (Bitcoin transactions are typically <1 MB)
- Document the limit in configuration guides
- Provide clear error messages when limit is exceeded
- Consider making this a runtime-configurable parameter

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup Phase:**
   - Obtain valid signer private key (either as authorized participant or through compromise)
   - Identify coordinator network endpoint

2. **Attack Execution:**
   ```
   a. Create NonceResponse message:
      - dkg_id: <current_dkg_id>
      - sign_id: <current_sign_id>
      - sign_iter_id: <current_sign_iter_id>
      - signer_id: <attacker_signer_id>
      - key_ids: <attacker_key_ids>
      - nonces: <valid_nonces>
      - message: vec![0u8; 1_000_000_000] // 1 GB payload
   
   b. Sign the message with attacker's signer private key
   
   c. Serialize to Packet and send to coordinator
   
   d. Coordinator processes in gather_nonces():
      - Line 919: message_nonces.entry(nonce_response.message.clone())
      - Allocates 1 GB for the cloned message
      - OOM or severe memory pressure
   ```

3. **Expected Behavior:**
   - Coordinator should reject messages exceeding reasonable size limits
   - Error logged and attacker marked as malicious

4. **Actual Behavior:**
   - Full 1 GB allocated without validation
   - Coordinator memory exhaustion
   - Crash or unresponsiveness

**Reproduction Steps:**
1. Set up WSTS coordinator with default configuration
2. Configure one signer as the attacker
3. Start a signing round with a legitimate message
4. Have attacker signer respond with `NonceResponse` containing 1 GB message
5. Observe coordinator memory usage spike and potential crash
6. Coordinator unable to complete signing round

**Parameter Values:**
- Message size: 1,000,000,000 bytes (1 GB) for guaranteed DoS
- Message size: 100,000,000 bytes (100 MB) for probable DoS on constrained systems
- Number of malicious signers: 1 sufficient, 3+ for guaranteed coordinator exhaustion

### Citations

**File:** src/state_machine/coordinator/fire.rs (L64-65)
```rust
    malicious_signer_ids: HashSet<u32>,
    malicious_dkg_signer_ids: HashSet<u32>,
```

**File:** src/state_machine/coordinator/fire.rs (L218-225)
```rust
        if self.config.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/coordinator/fire.rs (L238-250)
```rust
                    } else if let Message::NonceRequest(nonce_request) = &packet.msg {
                        if self.current_sign_id == nonce_request.sign_id {
                            // We have already processed this sign round
                            return Ok((None, None));
                        }
                        self.current_sign_iter_id = nonce_request.sign_iter_id.wrapping_sub(1);
                        // use sign_id from NonceRequest
                        let packet = self.start_signing_round(
                            nonce_request.message.as_slice(),
                            nonce_request.signature_type,
                            Some(nonce_request.sign_id),
                        )?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L916-920)
```rust

            let nonce_info = self
                .message_nonces
                .entry(nonce_response.message.clone())
                .or_default();
```

**File:** src/state_machine/coordinator/fire.rs (L1457-1476)
```rust
    fn start_signing_round(
        &mut self,
        message: &[u8],
        signature_type: SignatureType,
        sign_id: Option<u64>,
    ) -> Result<Packet, Error> {
        // We cannot sign if we haven't first set DKG (either manually or via DKG round).
        if self.aggregate_public_key.is_none() {
            return Err(Error::MissingAggregatePublicKey);
        }
        self.message = message.to_vec();
        if let Some(id) = sign_id {
            self.current_sign_id = id;
        } else {
            self.current_sign_id = self.current_sign_id.wrapping_add(1);
        }
        info!("Starting signing round {}", self.current_sign_id);
        self.move_to(State::NonceRequest(signature_type))?;
        self.request_nonces(signature_type)
    }
```

**File:** src/net.rs (L264-275)
```rust
pub struct NonceRequest {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// The message to sign
    pub message: Vec<u8>,
    /// What type of signature to create
    pub signature_type: SignatureType,
}
```

**File:** src/net.rs (L311-326)
```rust
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/net.rs (L557-576)
```rust
            Message::NonceRequest(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a NonceRequest message with an invalid signature.");
                    return false;
                }
            }
            Message::NonceResponse(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a NonceResponse message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a NonceResponse message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/coordinator/mod.rs (L186-199)
```rust
        Config {
            num_signers,
            num_keys,
            threshold,
            dkg_threshold: num_keys,
            message_private_key,
            dkg_public_timeout: None,
            dkg_private_timeout: None,
            dkg_end_timeout: None,
            nonce_timeout: None,
            sign_timeout: None,
            public_keys: Default::default(),
            verify_packet_sigs: true,
        }
```
