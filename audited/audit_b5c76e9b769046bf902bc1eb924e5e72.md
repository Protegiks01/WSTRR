# Audit Report

## Title
Incomplete DKG Private Share Validation Allows Undetected Malicious Signer Denial of Service (v1 Protocol)

## Summary
In WSTS v1, the `dkg_ended()` function fails to validate that all expected party_ids from each signer are present in received private shares. When `compute_secrets()` detects missing shares and returns `DkgError::MissingPrivateShares`, the error handler only processes `DkgError::BadPrivateShares`, resulting in an empty failure report that prevents the coordinator from identifying and excluding the malicious signer. This enables a persistent DKG denial-of-service attack.

## Finding Description

The vulnerability exists in the interaction between validation logic, error detection, and error handling in the DKG private shares phase.

**Validation Gap (Lines 567-582):**
The validation logic checks that received shares are non-empty and contain entries for all destination key_ids controlled by the receiving signer, but does NOT verify that shares.shares contains entries for ALL expected party_ids from the sender. [1](#0-0) 

In v1, a Signer contains multiple Party objects, each with its own party ID. When creating DkgPrivateShares, a signer should iterate through all its parties and create an entry for each: [2](#0-1) 

The structure shows shares is `Vec<(u32, HashMap<u32, Vec<u8>>)>` where the first u32 is the src_party_id: [3](#0-2) 

In v1, get_shares() returns entries for all parties controlled by the signer: [4](#0-3) 

**Detection But No Attribution:**
When compute_secrets() processes shares, it checks for ALL expected src_key_ids from public_shares.keys() and returns DkgError::MissingPrivateShares if any are missing: [5](#0-4) 

**Failed Error Handling:**
The error handler in dkg_ended() only processes DkgError::BadPrivateShares. When DkgError::MissingPrivateShares is returned, it hits the else branch which just logs a warning, then returns DkgFailure::BadPrivateShares with an empty HashMap: [6](#0-5) 

**Coordinator Cannot Identify Attacker:**
The coordinator processes BadPrivateShares by iterating over the HashMap. When it's empty, the loop doesn't execute and no malicious signer is identified: [7](#0-6) 

**Attack Scenario:**
1. Malicious v1 signer controls party_ids [10, 11, 12]
2. Sends valid DkgPublicShares for all three party_ids
3. In DkgPrivateShares, includes shares only from party_id 10, omitting 11 and 12
4. Validation at lines 567-582 passes (shares present for all dst_key_ids)
5. Other signers' compute_secrets() detect missing shares from party_ids 11, 12
6. Returns DkgError::MissingPrivateShares
7. Error handler creates empty bad_private_shares HashMap
8. Coordinator cannot identify which signer is malicious
9. DKG retry includes the same malicious signer, attack repeats indefinitely

## Impact Explanation

**Severity: Critical**

This vulnerability enables a persistent DKG denial-of-service that completely blocks threshold signature generation. The impact maps to "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

If WSTS DKG is required for blockchain consensus operations (e.g., Stacks block signing), inability to complete DKG prevents threshold signatures from being generated. Without these signatures, blocks cannot be produced or validated, causing the network to halt indefinitely.

The attack is particularly severe because:
- The malicious signer is never identified or excluded
- DKG retries perpetually fail with the same attacker
- Manual intervention is required to identify and remove the bad actor through log analysis
- All participants in the signing group are blocked from completing DKG

## Likelihood Explanation

**Likelihood: High**

**Required Capabilities:**
- Control of one v1 signer node with multiple parties
- Ability to send modified DkgPrivateShares messages
- No cryptographic breaks or secret knowledge required

**Attack Complexity: Low**
The attacker simply sends a DkgPrivateShares message with a subset of their party_ids. This requires minimal modification to the signer implementation.

**Detection Risk: Low**
The attack appears as a generic DKG failure. The only indication is a warning log "Got unexpected dkg_error" which requires manual inspection. The coordinator sees DkgFailure::BadPrivateShares with no specific attacker identification.

**Economic Feasibility: Trivial**
Once participating in the signing group, the attack costs nothing to execute and can be repeated indefinitely.

**Probability of Success: Near 100%**
If the attacker controls a v1 signer with multiple parties, the attack succeeds every time because the validation gap and error handling issues are deterministic.

**Note:** This vulnerability specifically affects v1 signers. In v2, signers only have a single party_id, making this attack vector non-applicable.

## Recommendation

**Fix 1: Add validation for expected party_ids**

In `dkg_ended()`, after line 582, add validation that all expected party_ids are present:

```rust
if let Some(shares) = self.dkg_private_shares.get(signer_id) {
    if shares.shares.is_empty() {
        missing_private_shares.insert(*signer_id);
    } else {
        // Existing validation for dst_key_ids
        for dst_key_id in self.signer.get_key_ids() {
            for (_src_key_id, shares) in &shares.shares {
                if shares.get(&dst_key_id).is_none() {
                    missing_private_shares.insert(*signer_id);
                }
            }
        }
        
        // NEW: Validate all expected src_party_ids are present
        if let Some(expected_key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
            let received_party_ids: HashSet<u32> = shares.shares.iter()
                .map(|(party_id, _)| *party_id)
                .collect();
            
            if !expected_key_ids.is_subset(&received_party_ids) {
                missing_private_shares.insert(*signer_id);
            }
        }
    }
}
```

**Fix 2: Handle DkgError::MissingPrivateShares**

In the error handler at line 626, add a case for MissingPrivateShares:

```rust
for (_my_party_id, dkg_error) in dkg_error_map {
    match dkg_error {
        DkgError::BadPrivateShares(party_ids) => {
            // existing handling
        }
        DkgError::MissingPrivateShares(missing_pairs) => {
            // Convert (dst_key_id, src_key_id) pairs to signer_ids
            for (_dst_key_id, src_party_id) in missing_pairs {
                if let Some((party_signer_id, _shared_key)) = 
                    &self.decryption_keys.get(&src_party_id)
                {
                    bad_private_shares.insert(
                        *party_signer_id,
                        self.make_bad_private_share(*party_signer_id, rng)?,
                    );
                }
            }
        }
        _ => {
            warn!("Got unexpected dkg_error {dkg_error:?}");
        }
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    fn test_missing_party_id_dos() {
        // Setup: Create v1 signer with 3 parties
        let mut rng = OsRng;
        let num_signers = 3;
        let num_keys = 9; // 3 signers * 3 parties each
        let threshold = 5;
        
        // Signer 0 has party_ids [0, 1, 2]
        let malicious_signer = v1::Signer::new(
            0, 
            &[0, 1, 2], 
            num_keys, 
            threshold, 
            &mut rng
        );
        
        // Create DkgPrivateShares with ONLY party_id 0, omitting 1 and 2
        let mut partial_shares = DkgPrivateShares {
            dkg_id: 1,
            signer_id: 0,
            shares: Vec::new(),
        };
        
        // Only include shares from party_id 0
        let shares_map = malicious_signer.get_shares();
        if let Some(party_0_shares) = shares_map.get(&0) {
            let mut encrypted = HashMap::new();
            for (dst_key_id, share) in party_0_shares {
                encrypted.insert(*dst_key_id, vec![0u8; 32]); // dummy encryption
            }
            partial_shares.shares.push((0, encrypted));
        }
        // Omit party_ids 1 and 2
        
        // Victim signer processes this
        // The validation at lines 567-582 should fail but doesn't
        // because it only checks dst_key_ids, not src_party_ids
        
        // When compute_secrets() runs, it will detect missing shares
        // from party_ids 1 and 2 and return DkgError::MissingPrivateShares
        // But the error handler won't identify signer 0 as malicious
        
        assert_eq!(partial_shares.shares.len(), 1); // Only 1 party instead of 3
    }
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L622-649)
```rust
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
```

**File:** src/state_machine/signer/mod.rs (L926-949)
```rust
        for (party_id, shares) in &self.signer.get_shares() {
            debug!(
                "Signer {} addding dkg private share for party_id {party_id}",
                self.signer_id
            );
            // encrypt each share for the recipient
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
        }
```

**File:** src/net.rs (L192-199)
```rust
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/v1.rs (L640-646)
```rust
    fn get_shares(&self) -> HashMap<u32, HashMap<u32, Scalar>> {
        let mut shares = HashMap::new();
        for party in &self.parties {
            shares.insert(party.id, party.get_shares());
        }
        shares
    }
```

**File:** src/v2.rs (L146-163)
```rust
        let mut missing_shares = Vec::new();
        for dst_key_id in &self.key_ids {
            for src_key_id in public_shares.keys() {
                match private_shares.get(dst_key_id) {
                    Some(shares) => {
                        if shares.get(src_key_id).is_none() {
                            missing_shares.push((*dst_key_id, *src_key_id));
                        }
                    }
                    None => {
                        missing_shares.push((*dst_key_id, *src_key_id));
                    }
                }
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```
