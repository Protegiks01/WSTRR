### Title
Missing Identity Point Validation in DKG Key Exchange Enables Private Share Decryption and Key Theft

### Summary
The DKG private share distribution phase fails to validate that ephemeral `kex_public_key` values are not the identity point (point at infinity). An attacker controlling a signer can broadcast the identity point as their ephemeral public key, causing all private shares encrypted for that signer to use a predictable, constant shared secret. Any network observer can decrypt these shares, and if the attacker controls threshold-many key IDs, the observer can reconstruct all honest signers' private polynomials and steal the group signing key.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The vulnerability exists in the `dkg_private_shares()` function where the shared key is computed without validating that `kex_public_key` is not the identity point: [1](#0-0) 

**Root Cause:**

When signers receive `DkgPublicShares` messages, the ephemeral `kex_public_key` field is stored without any point validation: [2](#0-1) 

The coordinator also stores these keys without validation: [3](#0-2) 

When computing the shared secret for encryption, if `kex_public_key` is the identity point, the result is:
- `shared_key = self.kex_private_key * identity = identity` (any scalar times identity equals identity)
- `shared_secret = make_shared_secret_from_key(&identity)` produces a constant, predictable value [4](#0-3) 

The shared secret derivation compresses the identity point to bytes and hashes it: [5](#0-4) 

Since the identity point has a fixed serialization in secp256k1 (typically `0x00`), the resulting shared secret is a publicly computable constant.

**Why Existing Mitigations Fail:**

The codebase correctly validates nonce points to prevent identity point usage: [6](#0-5) 

However, no equivalent validation exists for `kex_public_key` in either the signer or coordinator when processing `DkgPublicShares` messages. The `Point` type can represent the identity point, as evidenced by its use elsewhere in the code: [7](#0-6) 

### Impact Explanation

**Specific Harm:**

1. **Confidentiality Breach**: Private shares encrypted for the malicious signer become decryptable by any network observer using the constant shared secret `K = SHA256(serialize(identity) || counter || "DH_SHARED_SECRET_KEY/")`.

2. **Private Key Theft**: In WSTS configurations where a single signer controls multiple key IDs, if the attacker controls `k >= threshold` key IDs:
   - Each honest signer's polynomial has one share going to each of the attacker's `k` key IDs
   - All `k` shares are encrypted with the same constant key `K`
   - Any observer can decrypt all `k` shares and reconstruct the honest signer's entire polynomial using Lagrange interpolation
   - With all polynomials reconstructed, the observer learns the group private key

3. **Direct Loss of Funds**: With the stolen group private key, an attacker can:
   - Sign arbitrary transactions without authorization
   - Transfer funds from any addresses controlled by the compromised WSTS group
   - Create valid Schnorr signatures or taproot spends

**Quantified Impact:**

In a typical configuration from the test setup: [8](#0-7) 

- With `num_signers=5` and `keys_per_signer=2`: 10 total keys, threshold=7
- If one malicious signer controls 2 keys, the attack leaks 2 evaluations per polynomial (insufficient for reconstruction)
- However, in weighted configurations where a single signer controls 7+ keys (legitimately representing a major stakeholder), this becomes critical
- In multi-signature wallet deployments where high-weight signers exist, this vulnerability enables complete key compromise

**Who is Affected:**
- Any WSTS deployment where a single signer has >= threshold weight (key IDs)
- Stacks blockchain validators using WSTS for consensus signing
- Bitcoin layer-2 protocols using WSTS for multisig custody

**Severity Justification:**
This maps to **Critical** severity under the scope definition: "Any causing the direct loss of funds other than through any form of freezing." The vulnerability enables an attacker to steal private keys and sign unauthorized transactions, leading to direct, irreversible loss of funds.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Control of at least one legitimate signer in the WSTS group
2. Ability to send network messages during DKG
3. Sufficient key weight (>= threshold key IDs) for maximal impact

**Attack Complexity:**
- **Low**: The attack requires only modifying the `kex_public_key` field in `DkgPublicShares` to the identity point
- No cryptographic breaks required
- No timing or race condition dependencies
- The identity point is a well-defined constant in secp256k1

**Economic Feasibility:**
- **High**: In production deployments (Stacks consensus, Bitcoin custody), compromising a high-weight signer provides enormous financial incentive
- Attack cost is minimal (network message manipulation)
- Potential gains: theft of all funds controlled by the WSTS group

**Detection Risk:**
- **Low**: The malicious `kex_public_key` appears as a valid `Point` in network messages
- Without explicit validation, the attack is invisible until private shares are leaked
- Network observers can passively collect encrypted shares without active detection

**Estimated Probability:**
- In high-value deployments where single signers hold >= threshold weight: **High likelihood**
- Attacker only needs to compromise one high-weight signer
- The attack is deterministic once prerequisites are met

### Recommendation

**Immediate Fix:**

Add identity point validation in `dkg_public_share()` before storing `kex_public_key`:

```rust
// In src/state_machine/signer/mod.rs, around line 1018-1021
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!(%signer_id, "Invalid kex_public_key: identity point");
    return Ok(vec![]);
}

for key_id in signer_key_ids {
    self.kex_public_keys
        .insert(*key_id, dkg_public_shares.kex_public_key);
}
```

**Additional Validations:**

1. Add the same check in the coordinator's `gather_public_shares()`: [9](#0-8) 

2. Consider adding validation that `kex_public_key != G` (generator point) for defense in depth, similar to nonce validation: [10](#0-9) 

3. Add a validation method to the `DkgPublicShares` struct in `src/net.rs`:

```rust
impl DkgPublicShares {
    pub fn validate(&self) -> Result<(), Error> {
        if self.kex_public_key == Point::identity() || self.kex_public_key == G {
            return Err(Error::InvalidKexPublicKey);
        }
        Ok(())
    }
}
```

**Testing Recommendations:**

1. Add unit test attempting to use identity point as `kex_public_key` - should be rejected
2. Add integration test verifying DKG fails when a signer sends invalid `kex_public_key`
3. Add negative test confirming valid (non-identity) ephemeral keys still work
4. Fuzz test with various invalid point encodings

**Deployment Considerations:**

- This is a breaking change that must be deployed atomically across all signers and coordinators
- Requires network-wide upgrade before next DKG round
- Document the validation rules in protocol specification
- Consider backwards compatibility: reject invalid keys rather than cause protocol stall

### Proof of Concept

**Exploitation Algorithm:**

1. **Attacker Setup** (controls signer_id = 1 with key_ids = [1, 2, ..., k] where k >= threshold):
   ```
   malicious_kex_public_key = Point::identity()
   ```

2. **Broadcast Malicious DkgPublicShares**:
   ```
   DkgPublicShares {
       dkg_id: current_dkg_id,
       signer_id: 1,
       comms: [legitimate polynomial commitments],
       kex_public_key: Point::identity()  // ATTACK VECTOR
   }
   ```

3. **Honest Signers Encrypt Shares**:
   When honest signer Alice (signer_id = 2) encrypts private shares for attacker's key_id = 1: [11](#0-10) 
   
   This computes: `shared_secret = hash(Alice_kex_private * identity) = hash(identity)`

4. **Network Observer Decrypts**:
   Any passive observer computes the constant:
   ```
   K = SHA256(serialize(Point::identity()) || 0x00000001 || "DH_SHARED_SECRET_KEY/")
   ``` [12](#0-11) 
   
   Then decrypts all AES-GCM ciphertexts sent to attacker's key IDs using key `K`: [13](#0-12) 

5. **Polynomial Reconstruction**:
   Observer now has threshold-many shares `{(key_id, share_value)}` for each honest signer's polynomial. Using Lagrange interpolation, the observer reconstructs each polynomial's coefficients, including the private key (constant term).

**Expected vs Actual Behavior:**

- **Expected**: Private shares encrypted with unique, unpredictable DH shared secrets
- **Actual**: Private shares encrypted with constant, publicly computable key when attacker uses identity point

**Reproduction Steps:**

1. Set up WSTS with 5 signers, attacker controls signer 0 with 7 key IDs (>= threshold)
2. Modify signer 0's `dkg_public_begin()` to send `kex_public_key = Point::identity()`
3. Run DKG protocol
4. As network observer, compute `K = hash(identity_bytes || counter || DST)`
5. Decrypt all AES-GCM messages sent to key_ids [0..6]
6. Extract 7 polynomial evaluations for each honest signer
7. Run Lagrange interpolation to recover private keys
8. Verify recovered keys match the actual group private key

### Citations

**File:** src/state_machine/signer/mod.rs (L941-942)
```rust
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L55-60)
```rust
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/util.rs (L64-77)
```rust
pub fn ansi_x963_derive_key(shared_key: &[u8], shared_info: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    let counter = 1u32;

    hasher.update(shared_key);
    hasher.update(counter.to_be_bytes());
    hasher.update(shared_info);

    let hash = hasher.finalize();
    let mut bytes = [0u8; 32];

    bytes.clone_from_slice(hash.as_slice());
    bytes
}
```

**File:** src/util.rs (L102-115)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L206-208)
```rust
    fn is_zero(&self) -> bool {
        self.D == Point::identity() && self.E == Point::identity()
    }
```

**File:** src/state_machine/coordinator/mod.rs (L580-582)
```rust
        let num_keys = num_signers * keys_per_signer;
        let threshold = (num_keys * 7) / 10;
        let dkg_threshold = (num_keys * 9) / 10;
```
