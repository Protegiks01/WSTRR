### Title
Critical: DkgPublicShares Message Authentication Bypass Enables Private Share Interception and Secret Key Theft

### Summary
The `DkgPublicShares::hash()` function omits critical fields (`kex_public_key` and `comm.id`) from message authentication, allowing attackers to modify these fields without invalidating signatures. An attacker can substitute the ephemeral public key used for Diffie-Hellman key exchange, intercept all encrypted private shares intended for a victim signer, and reconstruct the distributed secret key to forge threshold signatures unilaterally.

### Finding Description

**Location:** `src/net.rs`, lines 152-164, `DkgPublicShares::hash()` implementation [1](#0-0) 

**Root Cause:** The hash function only includes `dkg_id`, `signer_id`, `party_id`, and polynomial points (`comm.poly`), but critically omits:
1. `kex_public_key` (line 149) - the ephemeral public key for DH key exchange
2. `comm.id` - the Schnorr ID proof binding polynomials to party IDs [2](#0-1) 

The `PolyCommitment` structure contains an `ID` field with a Schnorr proof: [3](#0-2) 

This Schnorr proof cryptographically binds the polynomial constant to a specific party ID: [4](#0-3) 

**Why Existing Mitigations Fail:** 

The signature verification uses the hash function to authenticate messages: [5](#0-4) 

Since `kex_public_key` and `comm.id` are not in the hash, modifying them produces the same hash and thus passes signature verification. The state machine stores the unauthenticated `kex_public_key`: [6](#0-5) 

This key is later used to encrypt private shares: [7](#0-6) 

### Impact Explanation

**Critical Impact - Complete Threshold Signature Compromise:**

1. **Secret Key Theft:** An attacker who intercepts private shares can reconstruct the distributed secret key once they obtain threshold-many shares. With a threshold of t out of n signers, stealing private shares for one signer across t key IDs allows full key reconstruction.

2. **Unilateral Signature Forgery:** With the secret key, the attacker can forge threshold signatures without any honest signer participation, completely bypassing the threshold security assumption.

3. **Direct Loss of Funds:** In the Stacks blockchain context, forged signatures enable unauthorized Bitcoin transactions, spending from multisig wallets without proper authorization. This directly maps to: "Any causing the direct loss of funds other than through any form of freezing."

4. **Chain-Level Impact:** Forged signatures can confirm invalid transactions with incorrect nonces, mapping to: "Any confirmation of an invalid transaction, such as with an incorrect nonce."

**Quantified Impact:** In a 7-of-10 threshold configuration controlling a treasury wallet:
- Attacker intercepts private shares for any 7 key IDs (potentially from just 1-2 compromised signers in weighted threshold)
- Complete control over the wallet is achieved
- All funds in the wallet are at risk

### Likelihood Explanation

**Attack Prerequisites:**
- Network-level message interception capability (man-in-the-middle position on any network path)
- No cryptographic secrets required
- Standard network attacker capabilities

**Attack Complexity: LOW**

Step-by-step exploitation:
1. Attacker monitors network for `DkgPublicShares` broadcasts during DKG
2. Intercepts victim signer's authenticated packet
3. Deserializes the message, replaces `kex_public_key` with attacker's public key
4. Re-serializes and forwards modified packet with original signature
5. Signature verification passes (hash unchanged)
6. Other signers encrypt private shares using attacker's key
7. Attacker decrypts intercepted `DkgPrivateShares` messages
8. After collecting threshold shares, reconstructs secret key

**Economic Feasibility:** Trivial - requires only basic network interception, no computational costs

**Detection Risk:** Low - the attack leaves no cryptographic traces since the signature remains valid. The only detection would be if the victim notices their node didn't receive expected encrypted shares, but this appears as a normal network issue.

**Success Probability:** Near 100% if attacker can intercept the initial `DkgPublicShares` broadcast. Network position requirements are minimal (any path between victim and other signers).

### Recommendation

**Immediate Fix - Include All Security-Critical Fields in Hash:**

Modify `DkgPublicShares::hash()` in `src/net.rs` to include both `kex_public_key` and the Schnorr ID proofs:

```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        hasher.update(self.kex_public_key.compress().as_bytes());  // ADD THIS
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            hasher.update(comm.id.id.to_bytes());  // ADD THIS
            hasher.update(comm.id.kG.compress().as_bytes());  // ADD THIS
            hasher.update(comm.id.kca.to_bytes());  // ADD THIS
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**Additional Validation:**

Add explicit validation that `party_id` matches the Schnorr ID proof:

```rust
for (party_id, comm) in &dkg_public_shares.comms {
    if *party_id != comm.id.id.get_u32() {
        warn!("party_id mismatch with commitment ID proof");
        return Ok(vec![]);
    }
    // ... existing validation
}
```

**Testing Recommendations:**
1. Create unit test attempting KEX key substitution attack - should fail after fix
2. Create test for commitment ID mismatch - should be rejected
3. Verify backward compatibility is broken (intentional) - old signatures must be invalid
4. Test all DKG scenarios (v1/v2, different thresholds) with new authentication

**Deployment Considerations:**
- This is a breaking protocol change requiring coordinated upgrade
- All nodes must upgrade simultaneously for DKG to function
- Consider this a critical security patch requiring immediate deployment

### Proof of Concept

**Attack Algorithm:**

```
ATTACKER_SETUP:
  Generate attacker_kex_private_key
  Compute attacker_kex_public_key = attacker_kex_private_key * G

INTERCEPT_PHASE (during DKG):
  1. Monitor network for DkgPublicShares packets
  2. For target victim_signer_id:
     a. Capture Packet { msg: DkgPublicShares, sig: victim_signature }
     b. Extract original_kex_key = msg.kex_public_key
     c. Create modified_msg = msg with kex_public_key = attacker_kex_public_key
     d. Forward Packet { msg: modified_msg, sig: victim_signature }
     e. Signature verification passes (hash unchanged)

PRIVATE_SHARE_COLLECTION:
  3. Other signers encrypt private shares for victim using attacker_kex_public_key
  4. Monitor network for DkgPrivateShares packets destined for victim
  5. For each intercepted encrypted_share:
     a. Compute shared_secret = attacker_kex_private_key * sender_kex_public_key
     b. Decrypt private_share = decrypt(shared_secret, encrypted_share)
     c. Store private_share indexed by (src_key_id, dst_key_id)

KEY_RECONSTRUCTION:
  6. Once threshold private shares collected:
     a. For each dst_key_id in victim's key_ids:
        secret[dst_key_id] = sum(private_shares[*, dst_key_id])
  7. Compute group_key from all commitments
  8. Attacker now controls sufficient key shares to forge signatures

EXPECTED_BEHAVIOR: Victim receives invalid/missing shares, DKG fails for them
ACTUAL_BEHAVIOR: Attack succeeds, victim's shares intercepted, attacker learns secret
```

**Reproduction Steps:**
1. Set up WSTS DKG with 3 signers (threshold 2)
2. Position attacker to intercept network traffic for Signer 1
3. Signer 1 broadcasts DkgPublicShares
4. Attacker intercepts, modifies kex_public_key, forwards with original signature
5. Signers 2 and 3 receive modified message, verification passes
6. Signers 2 and 3 encrypt shares using attacker's key
7. Attacker decrypts intercepted shares
8. Verify: Attacker has obtained Signer 1's secret key shares
9. Verify: Attacker can forge threshold signatures without Signer 1

### Citations

**File:** src/net.rs (L32-45)
```rust
    /// Verify a hash of this object using the passed public key
    fn verify(&self, signature: &[u8], public_key: &ecdsa::PublicKey) -> bool {
        let mut hasher = Sha256::new();

        self.hash(&mut hasher);

        let hash = hasher.finalize();
        let sig = match ecdsa::Signature::try_from(signature) {
            Ok(sig) => sig,
            Err(_) => return false,
        };

        sig.verify(hash.as_slice(), public_key)
    }
```

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/common.rs (L26-40)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}

impl PolyCommitment {
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
}
```

**File:** src/schnorr.rs (L13-66)
```rust
#[allow(non_snake_case)]
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// ID type which encapsulates the ID and a schnorr proof of ownership of the polynomial
pub struct ID {
    /// The ID
    pub id: Scalar,
    /// The public schnorr response
    pub kG: Point,
    /// The aggregate of the schnorr committed values
    pub kca: Scalar,
}

#[allow(non_snake_case)]
impl ID {
    /// Construct a new schnorr ID which binds the passed `Scalar` `id` and `Scalar` `a`, with a
    /// zero-knowledge proof of ownership of `a`.  The `ctx` is a common reference string used to
    /// prevent replay attacks; it can be any length, but will typically be a `u64` value in
    /// big endian format.
    pub fn new<RNG: RngCore + CryptoRng>(
        id: &Scalar,
        a: &Scalar,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Self {
        let k = Scalar::random(rng);
        let c = Self::challenge(id, &(&k * &G), &(a * &G), ctx);

        Self {
            id: *id,
            kG: &k * G,
            kca: &k + c * a,
        }
    }

    /// Compute the schnorr challenge
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }

    /// Verify the proof
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
}
```

**File:** src/state_machine/signer/mod.rs (L934-944)
```rust
            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```
