### Title
Duplicate SignatureShare IDs in SignatureShareResponse Enable Undetectable DoS via Aggregation Double-Counting

### Summary
A malicious signer can include duplicate `SignatureShare` entries with the same party ID in their `SignatureShareResponse`, causing the aggregator to double-count their contribution during aggregation. This results in persistent signature aggregation failure (Denial of Service) that cannot be attributed or mitigated by the current protocol logic.

### Finding Description
- **Exact code location:**  
  - `src/net.rs`, struct `SignatureShareResponse` holds a `Vec<SignatureShare>` with no duplicate check for IDs in `signature_shares`  
  - `src/state_machine/coordinator/fire.rs`, function `gather_sig_shares` (lines 998–1174): valid responses can include duplicate `SignatureShare`s with identical IDs; only key ID set equality is checked, but not unique signature share IDs [1](#0-0)   
  - `src/v2.rs`, in `Aggregator::sign_with_tweak` (lines 296–340): all signature shares are summed unconditionally, so duplicates inflate the aggregate signature value [2](#0-1)   
  - `src/v2.rs`, in `Aggregator::check_signature_shares` (lines 347–417): after aggregate signature verification fails, individual shares are verified, but duplicates (being well-formed) pass, resulting in an undiagnosed group signature failure [3](#0-2) 

- **Root cause explanation:**  
  There is no explicit requirement or enforcement that `SignatureShareResponse.signature_shares` contains at most one `SignatureShare` per unique `id`. The coordinator's response processing and the aggregation engine both fail to deduplicate or reject these, enabling a malicious party to send their share multiple times, bloating the group signature and causing permanent failure.

- **Why existing mitigations fail:**  
  - Only the *set* of key IDs (across the response) is checked, not uniqueness of signature share party IDs (lines 1067–1076), so duplicates are accepted as long as all key IDs are present [4](#0-3)   
  - The aggregation logic simply sums all `z_i`, regardless of uniqueness, so duplicate shares result in double-counting [5](#0-4)   
  - Verification after failure (AggregatorError::BadGroupSig) cannot identify the dishonest party, as every individual `SignatureShare` still passes local verification [6](#0-5) 

### Impact Explanation
- **What specific harm occurs:**  
  Any participant can cause the signature protocol to fail persistently for all future signing rounds simply by sending duplicated `SignatureShare`s in their response.
- **Quantify the impact:**  
  No threshold signature can be completed as long as the attack is sustained; recovery is only possible by manual reconfiguration or restart.
- **Who is affected:**  
  All users and dependent systems relying on the affected signing group.
- **Severity:**  
  This is a Critical vulnerability aligned with "remotely-exploitable denial of service in a node" (protocol-wide signing paralysis).

### Likelihood Explanation
- **Required attacker capabilities:**  
  Any protocol participant able to send a `SignatureShareResponse`.
- **Attack complexity:**  
  Trivial: duplicate their existing valid signature share in the response vector.
- **Economic feasibility:**  
  Free; no extra computation, no cryptographic compromise required.
- **Detection risk:**  
  None; protocol misattributes the failure as a group anomaly, not an individual attack. Repeated offending parties are not excluded.
- **Estimated probability of success:**  
  100% when conducted as described.

### Recommendation
- The coordinator, upon receiving a `SignatureShareResponse`, *must* validate that all `SignatureShare.id` values are unique within each response. If duplicates are found, the response should be rejected and the participant flagged.
- Additional aggregation-level checks (e.g., ensure no duplicate party IDs in the full share set before aggregation) should be added for defense-in-depth.
- Add property-based and unit tests to guarantee only one share per party is processed per signing round.
- Consider enhanced logging and exclusion mechanisms for repeat offenders.

### Proof of Concept

**Exploit Steps:**
1. Malicious signer chooses a valid signature share:  
   `let share = SignatureShare { id: 3, ... };`
2. Sends the following response:  
   `SignatureShareResponse { signature_shares: vec![share.clone(), share.clone()] }`
3. Coordinator checks key ID set (passes, because duplicates are ignored via set logic).
4. Coordinator collects all `signature_shares` (both copies included).
5. Aggregator sums both `z_i` (doubles the contribution of this party).
6. Group signature verification fails, but check_signature_shares cannot attribute blame since all shares are individually valid.
7. Group stays in failed state, with no party to penalize, indefinitely.

**Expected vs. actual behavior:**
- *Expected*: Invalid SignatureShareResponse rejected, malicious participant flagged.
- *Actual*: Invalid SignatureShareResponse accepted, group enters unrecoverable failure state. [7](#0-6) [1](#0-0) [2](#0-1) [3](#0-2) [8](#0-7)

### Citations

**File:** src/state_machine/coordinator/fire.rs (L998-1174)
```rust
    fn gather_sig_shares(
        &mut self,
        packet: &Packet,
        signature_type: SignatureType,
    ) -> Result<(), Error> {
        let Message::SignatureShareResponse(sig_share_response) = &packet.msg else {
            return Ok(());
        };

        let Some(response_info) = self.message_nonces.get_mut(&self.message) else {
            warn!(
                "Sign round {} SignatureShareResponse for round {} from signer {} no message nonces entry",
                self.current_sign_id, sig_share_response.sign_id, sig_share_response.signer_id,
            );
            return Ok(());
        };

        let waiting = response_info
            .sign_wait_signer_ids
            .contains(&sig_share_response.signer_id);

        if !waiting {
            warn!(
                "Sign round {} SignatureShareResponse for round {} from signer {} not in the wait list",
                self.current_sign_id, sig_share_response.sign_id, sig_share_response.signer_id,
            );
            return Ok(());
        }

        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }

        // we were waiting on you, and you sent a packet for this sign round, so we won't take
        // another packet from you
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);

        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };

        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }

        let have_shares = self
            .signature_shares
            .contains_key(&sig_share_response.signer_id);

        if have_shares {
            info!(signer_id = %sig_share_response.signer_id, "received duplicate SignatureShareResponse");
            // XXX should this be an error?  We should have already removed signer from wait set
            return Ok(());
        }

        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );

        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                response_info.sign_recv_key_ids.insert(*key_id);
            }
        }

        debug!(
            "Sign round {} SignatureShareResponse for round {} from signer {} ({}/{} key_ids). Waiting on {:?}",
            self.current_sign_id,
            sig_share_response.sign_id,
            sig_share_response.signer_id,
            response_info.sign_recv_key_ids.len(),
            response_info.nonce_recv_key_ids.len(),
            response_info.sign_wait_signer_ids
        );

        let message_nonce = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?;
        if message_nonce.sign_wait_signer_ids.is_empty() {
            // Calculate the aggregate signature
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();

            debug!(
                "aggregator.sign({}, {:?}, {:?}, {})",
                bs58::encode(&self.message).into_string(),
                nonces.len(),
                shares.len(),
                self.party_polynomials.len(),
            );

            self.aggregator.init(&self.party_polynomials)?;

            if let SignatureType::Taproot(merkle_root) = signature_type {
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    &shares,
                    &key_ids,
                    merkle_root,
                )?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else if let SignatureType::Schnorr = signature_type {
                let schnorr_proof =
                    self.aggregator
                        .sign_schnorr(&self.message, &nonces, &shares, &key_ids)?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else {
                let signature = self
                    .aggregator
                    .sign(&self.message, &nonces, &shares, &key_ids)?;
                debug!("Signature ({}, {})", signature.R, signature.z);
                self.signature = Some(signature);
            }

            self.move_to(State::Idle)?;
        }
        Ok(())
    }
```

**File:** src/v2.rs (L296-340)
```rust
    pub fn sign_with_tweak(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        _key_ids: &[u32],
        tweak: Option<Scalar>,
    ) -> Result<(Point, Signature), AggregatorError> {
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }

        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &party_ids, nonces);
        let mut z = Scalar::zero();
        let mut cx_sign = Scalar::one();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                let key = compute::tweaked_public_key_from_tweak(&aggregate_public_key, t);
                if !key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                key
            } else {
                aggregate_public_key
            }
        } else {
            aggregate_public_key
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        // optimistically try to create the aggregate signature without checking for bad keys or sig shares
        for sig_share in sig_shares {
            z += sig_share.z_i;
        }

        // The signature shares have already incorporated the private key adjustments, so we just have to add the tweak.  But the tweak itself needs to be adjusted if the tweaked public key is odd
        if let Some(t) = tweak {
            z += cx_sign * c * t;
        }

        let sig = Signature { R, z };

        Ok((tweaked_public_key, sig))
    }
```

**File:** src/v2.rs (L347-417)
```rust
    pub fn check_signature_shares(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
        tweak: Option<Scalar>,
    ) -> AggregatorError {
        if nonces.len() != sig_shares.len() {
            return AggregatorError::BadNonceLen(nonces.len(), sig_shares.len());
        }

        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (Rs, R) = compute::intermediate(msg, &party_ids, nonces);
        let mut bad_party_keys = Vec::new();
        let mut bad_party_sigs = Vec::new();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                compute::tweaked_public_key_from_tweak(&aggregate_public_key, t)
            } else {
                aggregate_public_key
            }
        } else {
            aggregate_public_key
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r_sign = Scalar::one();
        let mut cx_sign = Scalar::one();
        if let Some(t) = tweak {
            if !R.has_even_y() {
                r_sign = -Scalar::one();
            }
            if t != Scalar::zero() {
                if !tweaked_public_key.has_even_y() ^ !aggregate_public_key.has_even_y() {
                    cx_sign = -Scalar::one();
                }
            } else if !aggregate_public_key.has_even_y() {
                cx_sign = -Scalar::one();
            }
        }

        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
        } else {
            AggregatorError::BadGroupSig
        }
    }
```

**File:** src/net.rs (L437-448)
```rust
pub struct SignatureShareResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Signature shares from this Signer
    pub signature_shares: Vec<SignatureShare>,
}
```
