### Title
Incomplete Party ID Validation in DKG Private Shares Allows Undetected Malicious Signer Attacks

### Summary
The `can_dkg_end()` function only checks for existence of a signer_id entry in `dkg_private_shares`, not whether all required party_ids from that signer are present. [1](#0-0)  Additionally, error handling in `dkg_ended()` fails to process `DkgError::MissingPrivateShares` from `compute_secrets`, only handling `DkgError::BadPrivateShares`. [2](#0-1)  This allows malicious signers to send incomplete DKG shares without being identified, enabling repeated denial-of-service attacks on the DKG protocol.

### Finding Description

**Exact Code Location:**
- Primary check: [1](#0-0) 
- Secondary validation: [3](#0-2) 
- Broken error handling: [2](#0-1) 

**Root Cause:**
The DKG validation has a three-stage check that fails to properly validate completeness of party_ids:

1. In `can_dkg_end()`, the check only verifies that `self.dkg_private_shares.contains_key(signer_id)` exists, without checking that the `DkgPrivateShares` message contains shares from all expected party_ids for that signer.

2. In `dkg_ended()`, the validation at lines 567-582 iterates through party_ids that ARE present in the received shares and verifies they have shares for all required destination key_ids, but does NOT verify that ALL expected party_ids from the sender are present in the first place.

3. The `compute_secrets` function properly detects missing party_ids [4](#0-3)  and returns `DkgError::MissingPrivateShares`, but the error handling only processes `DkgError::BadPrivateShares` (line 626). Any other error type including `DkgError::MissingPrivateShares` is logged as "Got unexpected dkg_error" (line 640) but NOT included in the `bad_private_shares` map.

4. This results in a `DkgEnd` message with `DkgFailure::BadPrivateShares(empty_map)` being sent to the coordinator. [5](#0-4) 

5. The coordinator processes this failure [6](#0-5)  but with an empty map, the loop at line 654 doesn't execute, so no malicious signer is identified or marked. [7](#0-6) 

**Why Existing Mitigations Fail:**
The `DkgPrivateShares` structure includes a `shares` field of type `Vec<(u32, HashMap<u32, Vec<u8>>)>` where the first element is the source party_id. [8](#0-7)  When processing incoming shares, validation occurs via `validate_party_id` to ensure each party_id belongs to the sender [9](#0-8) , but there's no check that ALL expected party_ids from `signer_key_ids[signer_id]` are present in the vector.

### Impact Explanation

**Specific Harm:**
A malicious signer can repeatedly cause DKG to fail without being detected and marked as malicious, breaking the Byzantine fault tolerance mechanism.

**Attack Flow:**
1. Malicious signer with party_ids {1, 2, 3} sends valid `DkgPublicShares` with commitments for all three parties
2. Malicious signer sends `DkgPrivateShares` containing shares only from party_ids {1, 2}, deliberately omitting party_id 3
3. Honest signers receive incomplete shares but early validation passes
4. When `compute_secrets` executes, it detects missing party_id 3 in commitments vs private_shares
5. The error is mishandled, resulting in `DkgEnd` with empty `BadPrivateShares` map
6. Coordinator sees a failure but cannot identify which signer was malicious
7. Malicious signer remains unmarked and can repeat the attack indefinitely

**Quantified Impact:**
- DKG fails to complete, preventing signature generation
- Malicious signer is never added to `malicious_dkg_signer_ids` [10](#0-9) 
- Attack can be repeated every DKG round
- Impacts all participants attempting to generate a distributed key

**Severity Justification:**
This maps to **Medium** severity per the protocol scope definition of "transient consensus failures." While DKG failures don't directly cause invalid signatures or chain splits, they prevent the system from establishing the cryptographic keys needed for signature generation, effectively causing a transient denial of service on the signing functionality.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be an authorized participant in the DKG protocol
- Must be able to construct and send malformed `DkgPrivateShares` messages
- No special cryptographic capabilities required

**Attack Complexity:**
Low. The attacker simply needs to:
1. Generate valid `DkgPublicShares` (normal protocol behavior)
2. Generate `DkgPrivateShares` but include only a subset of their party_ids in the shares vector
3. Send both messages normally

**Economic Feasibility:**
High. The attack is nearly free to execute - it requires no additional computational resources beyond normal DKG participation. The attacker pays no penalty since they're not detected.

**Detection Risk:**
Very low. The malicious signer is never identified by the coordinator. The only evidence is logged warnings about "unexpected dkg_error" in the honest signer's logs, which don't identify the attacker.

**Estimated Probability:**
Near certain (>95%). Any malicious DKG participant can execute this attack successfully. The only failure mode would be if the implementation is in v2 mode where `party_id == signer_id` (one party per signer), in which case the attack surface is reduced but the error handling bug still exists.

### Recommendation

**Primary Fix - Add Proper Error Handling:**
In `dkg_ended()` function, extend the error handling to properly process `DkgError::MissingPrivateShares`: [11](#0-10) 

The handler should:
1. Check for both `DkgError::MissingPrivateShares` and `DkgError::BadPrivateShares`
2. For `MissingPrivateShares`, extract the source party_ids from the error's `Vec<(u32, u32)>` where the tuple is (dst_key_id, src_party_id)
3. Look up the signer_id for each missing src_party_id using `self.decryption_keys`
4. Add each malicious signer_id to the `bad_private_shares` map with proof

**Secondary Fix - Add Early Validation:**
In `dkg_ended()` before the existing checks, add validation that all expected party_ids are present: [3](#0-2) 

After retrieving shares for a signer_id, verify that `shares.shares` contains entries for ALL party_ids that signer should control (from `self.public_keys.signer_key_ids.get(signer_id)`).

**Testing Recommendations:**
1. Add integration test for malicious signer sending incomplete party_ids in DkgPrivateShares
2. Verify proper error type propagation from compute_secrets through dkg_ended
3. Test coordinator properly marks malicious signer after receiving corrected DkgEnd message
4. Add test coverage for both v1 (multiple parties per signer) and v2 (one party per signer) scenarios

**Deployment Considerations:**
This is a consensus-critical fix. All nodes must upgrade simultaneously to maintain consistent malicious signer detection. Consider:
- Versioning the DKG protocol to coordinate upgrade
- Testing with mixed versions to verify backward compatibility or graceful degradation
- Documenting the change in security model

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Configure DKG with malicious signer controlling party_ids {10, 11, 12} (in v1 mode where signer_id maps to multiple party_ids)

2. **Step 1 - Send Valid Public Shares**: Malicious signer generates and sends `DkgPublicShares` containing polynomial commitments for all three party_ids {10, 11, 12}. This passes all validation. [12](#0-11) 

3. **Step 2 - Send Incomplete Private Shares**: Malicious signer constructs `DkgPrivateShares` with:
   - `signer_id`: their signer_id  
   - `shares`: Vector containing only `(10, shares_map)` and `(11, shares_map)`, deliberately omitting party_id 12 [13](#0-12) 

4. **Step 3 - Validation Passes Early Checks**: When honest signers receive this:
   - `dkg_private_shares()` stores it successfully [14](#0-13) 
   - `can_dkg_end()` check passes (signer_id key exists) [1](#0-0) 
   - `dkg_ended()` validation at lines 567-582 passes (party_ids 10 and 11 have shares for all dst_key_ids)

5. **Step 4 - Compute Secrets Fails**: When `compute_secrets` executes, commitments include party_ids {10, 11, 12} but private_shares only has {10, 11}. The check detects missing party_id 12. [4](#0-3) 

6. **Step 5 - Error Mishandled**: The `Err(dkg_error_map)` is received with `DkgError::MissingPrivateShares`, but line 640 logs it as unexpected, and the `bad_private_shares` map remains empty. [15](#0-14) 

7. **Step 6 - Empty Failure Reported**: Honest signer sends `DkgEnd` with `DkgFailure::BadPrivateShares(HashMap::new())`.

8. **Step 7 - No Malicious Detection**: Coordinator processes the failure but the loop over `bad_shares` doesn't execute (empty map), so no signer is marked malicious. [16](#0-15) 

**Expected vs Actual Behavior:**
- **Expected**: Malicious signer who sends incomplete party_ids should be identified and marked in `malicious_dkg_signer_ids`
- **Actual**: Honest signer reports failure with empty map, no signer marked malicious, attack can repeat indefinitely

**Reproduction Instructions:**
1. Set up v1 WSTS DKG with at least one signer controlling multiple party_ids
2. Modify one signer to send incomplete `DkgPrivateShares` (omit one party_id from shares vector)
3. Run DKG protocol to completion
4. Observe honest signer logs show "Got unexpected dkg_error" with `MissingPrivateShares`
5. Verify coordinator receives `DkgFailure::BadPrivateShares` with empty map
6. Check that `malicious_dkg_signer_ids` does not contain the malicious signer
7. Repeat DKG - malicious signer can participate again

### Notes

This vulnerability specifically affects v1 implementations where signers control multiple party_ids. In v2, `party_id == signer_id` so each signer has only one party, reducing but not eliminating the attack surface (the error handling bug still exists). The severity is mitigated by the fact that DKG must eventually succeed with honest participants, but repeated failures cause significant operational disruption and undermine the Byzantine fault tolerance guarantees of the protocol.

### Citations

**File:** src/state_machine/signer/mod.rs (L551-566)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L622-650)
```rust
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L705-710)
```rust
                    for signer_id in &dkg_end_begin.signer_ids {
                        if !self.dkg_private_shares.contains_key(signer_id) {
                            debug!("can_dkg_end: false, missing private shares from signer {signer_id}");
                            return false;
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L892-956)
```rust
    fn dkg_private_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_begin: &DkgPrivateBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let mut private_shares = DkgPrivateShares {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            shares: Vec::new(),
        };
        let mut active_key_ids = HashSet::new();
        for signer_id in &dkg_private_begin.signer_ids {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
                for key_id in key_ids {
                    active_key_ids.insert(*key_id);
                }
            }
        }

        self.dkg_private_begin_msg = Some(dkg_private_begin.clone());
        self.move_to(State::DkgPrivateDistribute)?;

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            "sending DkgPrivateShares"
        );

        trace!(
            "Signer {} shares {:?}",
            self.signer_id,
            &self.signer.get_shares()
        );
        for (party_id, shares) in &self.signer.get_shares() {
            debug!(
                "Signer {} addding dkg private share for party_id {party_id}",
                self.signer_id
            );
            // encrypt each share for the recipient
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
        }

        let private_shares = Message::DkgPrivateShares(private_shares);
        msgs.push(private_shares);

        self.move_to(State::DkgPrivateGather)?;
        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L1028-1110)
```rust
    /// handle incoming DkgPrivateShares
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/v1.rs (L172-180)
```rust
        let mut missing_shares = Vec::new();
        for i in public_shares.keys() {
            if private_shares.get(i).is_none() {
                missing_shares.push((self.id, *i));
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L607-610)
```rust
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```
