### Title
Missing Identity Element Validation in KEX Public Key Allows Confidentiality Breach of DKG Private Shares

### Summary
The `make_bad_private_share()` function computes `K = a * B` without validating that `B` (the KEX public key) is not the identity element. This allows a malicious signer to broadcast the identity element as their KEX public key, causing all honest signers to encrypt their DKG private shares with a predictable, publicly-computable key. Any network observer can then decrypt these shares, completely breaking the confidentiality of the DKG protocol.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `make_bad_private_share()` function retrieves the KEX public key `B` at line 1139 and computes `K = a * B` at line 1140 without any validation that `B` is not the identity element.

**Root Cause:**

When a signer receives DKG public shares containing a KEX public key, the key is stored without validation: [2](#0-1) 

The `get_kex_public_key()` method only validates existence, not the point's validity: [3](#0-2) 

When encrypting private shares for transmission, the shared secret is computed from this potentially-identity KEX public key: [4](#0-3) 

The `make_shared_secret()` function performs Diffie-Hellman key exchange without validating the input point: [5](#0-4) 

If the KEX public key is the identity element, then `private_key * identity = identity`, resulting in a fixed, predictable shared secret that any observer can compute: [6](#0-5) 

**Why Existing Mitigations Fail:**

The codebase correctly validates nonces against the identity element: [7](#0-6) 

However, no equivalent validation exists for KEX public keys. The TupleProof verification in `make_bad_private_share()` will still succeed when `B` is the identity element because the mathematical relationship `K = a * identity = identity` is valid: [8](#0-7) 

The coordinator's verification logic also accepts identity-based proofs: [9](#0-8) 

### Impact Explanation

**Specific Harm:**
A malicious participant can force all honest signers to encrypt their DKG private shares using a publicly-computable encryption key. Any passive network observer can then:
1. Identify that the malicious signer used `identity` as their KEX public key
2. Compute the predictable shared secret: `make_shared_secret_from_key(&Point::identity())`
3. Decrypt all private shares encrypted for that malicious signer
4. Learn polynomial evaluations that should remain confidential

**Quantified Impact:**
- Complete loss of confidentiality for DKG shares sent to the malicious signer
- With threshold T, if the attacker controls or observes shares from T honest signers, they can reconstruct the group private key
- This undermines the fundamental security assumption that private shares remain confidential during DKG

**Affected Parties:**
All honest signers participating in a DKG round with a malicious signer who exploits this vulnerability.

**Severity Justification:**
This maps to **Medium** severity under the protocol scope definition: "Any transient consensus failures." The compromised DKG could lead to:
- Invalid key material being used for subsequent signing operations
- Potential for unauthorized signatures if enough shares are compromised
- Need to restart DKG with the malicious signer excluded

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a registered signer participant in the DKG protocol
- Must be able to send DkgPublicShares messages
- No cryptographic breaks required

**Attack Complexity:**
Very low. The attacker simply needs to:
1. Set their `kex_public_key` field to `Point::identity()` when constructing DkgPublicShares
2. Wait for honest signers to encrypt and broadcast their private shares
3. Decrypt the shares using the predictable key

**Economic Feasibility:**
Trivial. The attack requires no computational resources beyond normal protocol participation.

**Detection Risk:**
Very low. The attack is completely undetectable because:
- No validation rejects the identity element
- TupleProof verification passes correctly
- The coordinator's checks accept the identity-based shared keys
- No error conditions are triggered

**Probability of Success:**
100% if the attacker is a protocol participant. The vulnerability is deterministic.

### Recommendation

**Primary Fix:**
Add identity element validation when receiving KEX public keys in `dkg_public_share()`:

```rust
// Before line 1018
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!(%signer_id, "Received identity element as kex_public_key");
    return Ok(vec![]);
}
```

**Secondary Fix:**
Add defensive validation in `make_bad_private_share()` before computing K:

```rust
// Before line 1140
let B = self.get_kex_public_key(signer_id)?;
if B == Point::identity() {
    return Err(Error::Point(PointError::InvalidPublicKey));
}
```

**Alternative Mitigation:**
Add validation in `make_shared_secret()` to reject identity element inputs:

```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> Result<[u8; 32], Error> {
    if *public_key == Point::identity() {
        return Err(Error::InvalidPublicKey);
    }
    // existing code...
}
```

**Testing Recommendations:**
1. Add unit test attempting to use identity element as KEX public key
2. Verify the test fails before the fix and passes after
3. Add integration test for full DKG flow with malicious identity-element attack
4. Test that valid KEX public keys still work correctly

**Deployment Considerations:**
- This is a breaking change that will reject previously-accepted (but insecure) messages
- Deploy to all signers and coordinators simultaneously
- Consider adding telemetry to detect if any existing deployments are affected

### Proof of Concept

**Exploitation Algorithm:**

1. **Attacker Setup (Malicious Signer M):**
   - Join DKG round as legitimate participant
   - Generate normal polynomial commitments
   - Set `kex_public_key = Point::identity()` in DkgPublicShares message
   - Broadcast DkgPublicShares

2. **Honest Signer Processing:**
   - Receive M's DkgPublicShares containing `identity` as kex_public_key
   - Store it without validation (line 1019-1020)
   - When sending DkgPrivateShares, compute:
     - `shared_secret = make_shared_secret(&self.kex_private_key, &identity)`
     - This equals `make_shared_secret_from_key(&identity)` (independent of private key)
   - Encrypt private shares: `encrypt(&shared_secret, &share_bytes, rng)`

3. **Attacker Decryption:**
   - Compute predictable key: `key = make_shared_secret_from_key(&Point::identity())`
   - For each received encrypted share from honest signer H:
     - `decrypt(&key, encrypted_share)` succeeds
     - Parse decrypted bytes as `Scalar`
   - Attacker now knows all private polynomial evaluations sent to them

4. **Expected vs Actual Behavior:**
   - **Expected:** Encryption uses DH shared secret known only to sender and receiver
   - **Actual:** Encryption uses publicly-computable key; anyone can decrypt

**Reproduction Steps:**
1. Modify test signer to use `Point::identity()` as KEX public key
2. Run DKG protocol with at least 2 signers (1 malicious, 1+ honest)
3. Capture encrypted DkgPrivateShares messages
4. Decrypt using `make_shared_secret_from_key(&Point::identity())`
5. Verify decrypted shares match expected polynomial evaluations

**Parameter Values:**
- KEX public key: `Point::identity()` (point at infinity)
- Shared secret: 32-byte output of SHA-256 over compressed identity point
- All honest signers will use identical encryption key when sending to malicious signer

### Citations

**File:** src/state_machine/signer/mod.rs (L941-942)
```rust
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1112-1129)
```rust
    fn get_kex_public_key(&self, signer_id: u32) -> Result<Point, Error> {
        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(signer_key_id) = signer_key_ids.iter().next() else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(kex_public_key) = self.kex_public_keys.get(signer_key_id) else {
            warn!(%signer_id, %signer_key_id, "No KEX public key configured");
            return Err(Error::MissingKexPublicKey(*signer_key_id));
        };

        Ok(*kex_public_key)
    }
```

**File:** src/state_machine/signer/mod.rs (L1131-1147)
```rust
    #[allow(non_snake_case)]
    fn make_bad_private_share<R: RngCore + CryptoRng>(
        &self,
        signer_id: u32,
        rng: &mut R,
    ) -> Result<BadPrivateShare, Error> {
        let a = self.kex_private_key;
        let A = a * G;
        let B = self.get_kex_public_key(signer_id)?;
        let K = a * B;
        let tuple_proof = TupleProof::new(&a, &A, &B, &K, rng);

        Ok(BadPrivateShare {
            shared_key: K,
            tuple_proof,
        })
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L55-60)
```rust
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L287-292)
```rust
    /// Verify the proof using the transcript and public parameters
    pub fn verify(&self, A: &Point, B: &Point, K: &Point) -> bool {
        let s = Self::challenge(A, B, K, &self.R);

        (self.z * G == self.R + s * A) && (self.z * B == self.rB + s * K)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L681-688)
```rust
                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);
```
