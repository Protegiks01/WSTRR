### Title
Unbounded NonceResponse Vectors Enable Coordinator Denial of Service

### Summary
The `NonceResponse` struct contains unbounded vectors (`key_ids` and `nonces`) that are processed through expensive cryptographic operations during packet signature verification before any size validation occurs. A malicious or compromised signer can send `NonceResponse` messages with thousands of entries, forcing the coordinator to perform excessive point compressions and hash computations, leading to CPU exhaustion and denial of service.

### Finding Description

**Exact Code Location:**

The vulnerability exists in multiple locations: [1](#0-0) [2](#0-1) [3](#0-2) 

**Root Cause:**

The `NonceResponse` struct defines `key_ids` and `nonces` as unbounded `Vec` types. When a packet containing `NonceResponse` is received, the coordinator performs signature verification by calling `Packet.verify()`, which invokes `NonceResponse.hash()`. This hash function iterates through ALL key_ids and nonces, performing expensive elliptic curve point compression operations on each nonce's D and E points before any bounds checking occurs.

The validation that `key_ids` match the configured signer's key IDs happens later in `gather_nonces()`, but by that point the expensive cryptographic operations have already been executed.

**Why Existing Mitigations Fail:**

The `verify_packet_sigs` configuration defaults to `true` and authenticates packet senders: [4](#0-3) 

However, this only prevents unauthorized parties from sending packets. It does not prevent legitimate signers (who possess valid signing keys) from sending oversized messages. The signature verification itself becomes part of the attack surface, as it requires hashing the entire oversized message before validation can reject it.

### Impact Explanation

**Specific Harm:**
A malicious or compromised signer can send `NonceResponse` packets with thousands of key_ids and nonces (e.g., 10,000 entries). Each `PublicNonce` contains two elliptic curve points (D and E) that must be compressed during hashing. This results in:
- 20,000 point compression operations per oversized packet
- Excessive CPU consumption on the coordinator
- Memory allocation for large vectors
- Repeated attacks can sustain coordinator DoS

**Impact Quantification:**
- Single oversized packet: 10,000 nonces × 2 points × point compression cost
- Multiple packets can exhaust coordinator resources
- Coordinator becomes unresponsive to legitimate signing requests
- In blockchain context: prevents signature aggregation, blocks cannot be signed

**Who is Affected:**
- Coordinator nodes processing NonceResponse messages
- Entire signing protocol halts when coordinator is DoSed
- Dependent blockchain systems cannot produce signatures for transactions/blocks

**Severity Justification:**
This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." The attack is network-based and can disable coordinator functionality, though it requires insider access (legitimate signer) or key compromise.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. **Primary path:** Attacker must be a legitimate signer with a valid private key for signing packets
2. **Alternative path:** Attacker compromises a signer's private key
3. **Edge case:** System configured with `verify_packet_sigs=false` (non-default, allows unauthenticated packets)

**Attack Complexity:**
Low complexity once prerequisites are met:
1. Construct `NonceResponse` with Vec of 10,000+ key_ids and nonces
2. Sign packet with legitimate signer key
3. Send to coordinator over network
4. Repeat to sustain DoS

**Economic Feasibility:**
- Minimal cost for attacker (network bandwidth only)
- High cost for defender (CPU exhaustion)
- Asymmetric attack where small attacker effort causes disproportionate defender cost

**Detection Risk:**
- Oversized packets should be detectable via network monitoring
- Abnormal CPU usage patterns on coordinator
- However, attack may appear as legitimate signer behavior initially

**Estimated Probability:**
- Moderate likelihood given insider threat model required
- High impact if signer key is compromised
- Particularly concerning in deployment scenarios with untrusted or partially trusted signers

### Recommendation

**Primary Fix - Add Bounds Checking:**

Add size limits to `NonceResponse` before expensive operations. Implement early validation in `Packet.verify()` or create a separate pre-validation step:

1. Define maximum allowable sizes (e.g., `MAX_NONCES_PER_RESPONSE = config.num_keys`)
2. Check vector sizes before calling `hash()` during signature verification
3. Reject oversized messages immediately with minimal processing

**Specific Implementation:**

In `src/state_machine/coordinator/fire.rs`, add validation at the start of `gather_nonces()` before signature verification:

```rust
// Add after line 846 (after extracting NonceResponse from packet.msg)
if nonce_response.key_ids.len() > self.config.num_keys as usize {
    warn!("NonceResponse key_ids exceeds maximum: {}", nonce_response.key_ids.len());
    return Ok(());
}
if nonce_response.nonces.len() > self.config.num_keys as usize {
    warn!("NonceResponse nonces exceeds maximum: {}", nonce_response.nonces.len());
    return Ok(());
}
```

**Alternative Mitigation:**

Implement a custom deserializer that enforces size limits during packet deserialization, preventing oversized vectors from ever being constructed.

**Testing Recommendations:**
1. Unit test with NonceResponse containing 1000+ entries, verify rejection
2. Performance test measuring CPU/memory impact of oversized packets
3. Integration test ensuring legitimate multi-key signers still function correctly

**Deployment Considerations:**
- This fix should be applied to both FireCoordinator and FrostCoordinator
- Similar bounds checking should be added for other message types with unbounded vectors
- Consider adding rate limiting for repeated oversized packet attempts

### Proof of Concept

**Exploitation Algorithm:**

```
1. Prerequisites:
   - Obtain valid signer private key (signer_private_key)
   - Know coordinator network address
   - System has verify_packet_sigs=true (default)

2. Construct malicious NonceResponse:
   nonce_response = NonceResponse {
       dkg_id: <current_dkg_id>,
       sign_id: <current_sign_id>,
       sign_iter_id: <current_sign_iter_id>,
       signer_id: <attacker_signer_id>,
       key_ids: vec![1, 2, 3, ..., 10000],  // 10,000 entries
       nonces: vec![PublicNonce { D: <random_point>, E: <random_point> }; 10000],
       message: <current_message>
   }

3. Sign and send packet:
   packet = Packet {
       msg: Message::NonceResponse(nonce_response),
       sig: nonce_response.sign(&signer_private_key)
   }
   send(packet, coordinator_address)

4. Coordinator processing:
   - Calls Packet.verify()
   - Invokes NonceResponse.hash()
   - Iterates through 10,000 key_ids: O(n) hash updates
   - Iterates through 10,000 nonces: O(n) point compressions
     * Each nonce has 2 points (D, E)
     * Total: 20,000 point compression operations
   - Performs ECDSA signature verification
   - Finally reaches gather_nonces() validation that rejects it

5. Impact:
   - CPU spikes to 100% for extended period
   - Coordinator cannot process legitimate requests
   - Repeat attack sustains DoS
```

**Expected Behavior:**
Coordinator should reject oversized NonceResponse before expensive cryptographic operations.

**Actual Behavior:**
Coordinator performs 20,000+ point compressions and full ECDSA verification before rejecting the message, allowing resource exhaustion attack.

**Reproduction:**
Modify existing test in `src/state_machine/coordinator/mod.rs` to create NonceResponse with 10,000 entries and measure processing time compared to legitimate response with ~10 entries.

### Citations

**File:** src/net.rs (L310-326)
```rust
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/net.rs (L349-368)
```rust
impl Signable for NonceResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }

        for nonce in &self.nonces {
            hasher.update(nonce.D.compress().as_bytes());
            hasher.update(nonce.E.compress().as_bytes());
        }

        hasher.update(self.message.as_slice());
    }
}
```

**File:** src/state_machine/coordinator/fire.rs (L841-962)
```rust
    fn gather_nonces(
        &mut self,
        packet: &Packet,
        signature_type: SignatureType,
    ) -> Result<(), Error> {
        if let Message::NonceResponse(nonce_response) = &packet.msg {
            if nonce_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(nonce_response.dkg_id, self.current_dkg_id));
            }
            if nonce_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    nonce_response.sign_id,
                    self.current_sign_id,
                ));
            }
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&nonce_response.signer_id) {
                warn!(signer_id = %nonce_response.signer_id, "No public key in config");
                return Ok(());
            };

            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }

            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
            }

            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }

            let nonce_info = self
                .message_nonces
                .entry(nonce_response.message.clone())
                .or_default();

            let have_nonces = nonce_info
                .public_nonces
                .contains_key(&nonce_response.signer_id);

            if have_nonces {
                info!(signer_id = %nonce_response.signer_id, "Received duplicate NonceResponse");
                return Ok(());
            }

            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());

            // ignore the passed key_ids
            for key_id in signer_key_ids {
                nonce_info.nonce_recv_key_ids.insert(*key_id);
            }

            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
            // Because of entry call, it is safe to unwrap here
            info!(
                sign_id = %nonce_response.sign_id,
                sign_iter_id = %nonce_response.sign_iter_id,
                signer_id = %nonce_response.signer_id,
                recv_keys = %nonce_info.nonce_recv_key_ids.len(),
                threshold = %self.config.threshold,
                "Received NonceResponse"
            );
            if nonce_info.nonce_recv_key_ids.len() >= self.config.threshold as usize {
                // We have a winning message!
                self.message.clone_from(&nonce_response.message);
                let aggregate_nonce = self.compute_aggregate_nonce();
                info!("Aggregate nonce: {aggregate_nonce}");

                self.move_to(State::SigShareRequest(signature_type))?;
            }
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/mod.rs (L186-199)
```rust
        Config {
            num_signers,
            num_keys,
            threshold,
            dkg_threshold: num_keys,
            message_private_key,
            dkg_public_timeout: None,
            dkg_private_timeout: None,
            dkg_end_timeout: None,
            nonce_timeout: None,
            sign_timeout: None,
            public_keys: Default::default(),
            verify_packet_sigs: true,
        }
```
