### Title
Unbounded Message Serialization Sizes Enable Memory Exhaustion DoS

### Summary
Network message structures contain unbounded vectors that are stored and processed without size validation, allowing malicious signers to send extremely large messages that cause memory and CPU exhaustion. A malicious signer can craft DkgPublicShares messages with arbitrarily large polynomial commitment vectors, causing coordinators and signers to allocate excessive memory and consume significant CPU resources during deserialization, storage, and signature verification.

### Finding Description

Multiple network message structures in WSTS contain unbounded vector fields that are serialized and transmitted without size limits: [1](#0-0) 

The `DkgPublicShares` message contains a `comms` field as `Vec<(u32, PolyCommitment)>` with no bounds on vector size. Each `PolyCommitment` itself contains an unbounded `poly` field: [2](#0-1) 

The `poly` field is defined as `Vec<Point>` without any maximum size constraint. Additional unbounded vectors exist in other message types including `DkgPrivateShares.shares`, `NonceResponse.nonces`, `SignatureShareRequest.nonce_responses`, and `SignatureShareResponse.signature_shares`. [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

The root cause is that messages are stored immediately upon receipt without size validation. In the coordinator's `gather_public_shares` function, messages are inserted into state storage without checking vector bounds: [7](#0-6) 

Size validation via `check_public_shares` only occurs later during the DkgEnd phase, and only validates that the polynomial length matches the threshold - not that it's within reasonable bounds before storage: [8](#0-7) [9](#0-8) 

No size limits are enforced at the transport layer, during deserialization, or before message storage. Messages are accepted and stored in their entirety before any validation occurs.

### Impact Explanation

A malicious signer can craft a `DkgPublicShares` message containing 10,000 polynomial commitments, each with 10,000 Points in the `poly` vector. Since each compressed Point is 33 bytes, this results in a ~33 MB message (10,000 × 10,000 × 33 bytes).

When such a message is received:
1. **Memory exhaustion**: Deserialization allocates ~33 MB for the message structure
2. **Memory retention**: The coordinator stores the entire message in `dkg_public_shares` state
3. **CPU exhaustion**: Signature verification requires hashing the entire message content
4. **Network amplification**: If forwarded, consumes bandwidth proportional to message size

This affects all coordinators and signers in the WSTS network. Since DKG must complete for the network to generate signatures, preventing DKG completion prevents the generation of any threshold signatures. This maps to **"Low: Any remotely-exploitable denial of service in a node"** in the protocol scope, as it can render nodes unresponsive and prevent signature generation without fully shutting down the network.

In resource-constrained environments (embedded systems, mobile devices), even smaller malicious messages (1 MB - 10 MB) could cause significant degradation or crashes. Multiple concurrent malicious messages from different signers could compound the impact.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a registered signer with valid credentials (private key and signer_id in coordinator's public_keys configuration)
- Ability to send network messages to coordinators and other signers

**Attack Complexity:** Very Low
- Attacker simply constructs a malicious message by populating vectors with excessive elements
- No cryptographic operations needed beyond normal message signing
- Can be executed with a simple script modifying legitimate client code

**Economic Feasibility:** High
- Minimal computational cost to generate large messages (just memory allocation)
- No ongoing costs once message is sent
- Single message can impact multiple nodes simultaneously

**Detection Risk:** Low
- No size limit checks exist to reject oversized messages before processing
- Messages appear structurally valid until validation occurs later
- Coordinator logs show normal message receipt, making detection difficult

**Probability of Success:** High
- Attack succeeds immediately upon message receipt
- No race conditions or timing dependencies
- Works against all coordinator and signer implementations
- Can be repeated across multiple DKG rounds

### Recommendation

Implement maximum size bounds for all network message vector fields:

1. **Add message size constants** in `src/net.rs`:
   ```rust
   const MAX_COMMS_PER_MESSAGE: usize = 1000;  // Reasonable upper bound
   const MAX_POLY_COEFFICIENTS: usize = 1000;  // Based on practical threshold
   const MAX_NONCES_PER_RESPONSE: usize = 1000;
   const MAX_SIGNATURE_SHARES: usize = 1000;
   ```

2. **Validate sizes before storage** in coordinator and signer message handlers:
   - In `gather_public_shares`: Check `dkg_public_shares.comms.len() <= MAX_COMMS_PER_MESSAGE`
   - For each commitment: Check `comm.poly.len() <= MAX_POLY_COEFFICIENTS`
   - Reject messages exceeding limits with `Err(Error::MessageTooLarge)`

3. **Implement custom deserializers** with size limits using serde's `deserialize_with` attribute to enforce bounds during deserialization, preventing memory allocation for oversized messages.

4. **Add integration tests** that verify:
   - Legitimate messages within bounds are accepted
   - Messages exceeding bounds are rejected
   - Memory usage remains bounded under attack

5. **Consider transport-layer limits** if using a custom network protocol, implement maximum packet size limits (e.g., 10 MB) at the transport layer as defense-in-depth.

### Proof of Concept

**Exploitation Algorithm:**

1. Register as a legitimate signer with valid credentials
2. Wait for coordinator to initiate DKG round with `DkgBegin` message
3. Construct malicious `DkgPublicShares` message:
   ```
   malicious_message = DkgPublicShares {
       dkg_id: <current_dkg_id>,
       signer_id: <attacker_signer_id>,
       comms: Vec with 10,000 entries of (party_id, PolyCommitment {
           id: <valid_schnorr_id>,
           poly: Vec with 10,000 Points (each 33 bytes)
       }),
       kex_public_key: <valid_point>
   }
   ```
4. Sign message with attacker's private key
5. Send to coordinator
6. Monitor coordinator resource usage

**Expected Behavior:**
- Legitimate messages have ~10 commitments with ~10 Points each (~3.3 KB)
- Message validation accepts and stores message
- Processing completes in milliseconds

**Actual Malicious Behavior:**
- Malicious message has 10,000 commitments with 10,000 Points each (~33 MB)
- Coordinator allocates 33 MB memory during deserialization
- Message stored in coordinator state (33 MB retained)
- Signature verification hashes 33 MB of data (seconds of CPU time)
- Repeated attacks exhaust available memory
- Coordinator becomes unresponsive or crashes

**Reproduction Steps:**
1. Set up WSTS network with coordinator and signers
2. Modify signer code to generate oversized `comms` vector in `dkg_public_begin()`
3. Initiate DKG round
4. Observe coordinator memory usage spike to >100 MB (depending on message size)
5. Observe coordinator CPU usage spike during signature verification
6. Send multiple malicious messages to exhaust resources completely

### Citations

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L309-326)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/net.rs (L381-396)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Signature share request message from coordinator to signers
pub struct SignatureShareRequest {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Nonces responses used for this signature
    pub nonce_responses: Vec<NonceResponse>,
    /// Bytes to sign
    pub message: Vec<u8>,
    /// What type of signature to create
    pub signature_type: SignatureType,
}
```

**File:** src/net.rs (L435-448)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// Signature share response message from signers to coordinator
pub struct SignatureShareResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Signature shares from this Signer
    pub signature_shares: Vec<SignatureShare>,
}
```

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```
