### Title
Denial of Service via Duplicate Key IDs in SignatureShare

### Summary
A malicious signer can craft SignatureShare messages with thousands of duplicate key_ids that pass coordinator validation but cause severe performance degradation during signature verification. The coordinator's validation logic checks only the set equality of key_ids (allowing duplicates), while the aggregator's check_signature_shares function iterates through every key_id including duplicates with O(n×m) complexity, enabling CPU exhaustion and signing round disruption.

### Finding Description

The SignatureShare struct contains an unbounded Vec<u32> for key_ids with no deduplication: [1](#0-0) 

During signature share validation in the FROST coordinator, the code collects all key_ids into a HashSet to check against configured keys: [2](#0-1) 

This validation compares only the SET of key_ids, not the underlying array. An attacker can send `[1,1,1,...,2,2,2,...,3,3,3,...]` with thousands of duplicates, and the HashSet will deduplicate to `{1,2,3}`, passing validation if that matches the configured set.

The validated SignatureShare is stored and later passed to the aggregator. When signature verification fails (which the attacker can force by providing an incorrect z_i value), the aggregator calls check_signature_shares: [3](#0-2) 

This function iterates through ALL key_ids in the SignatureShare, including duplicates. For each key_id, it:
1. Calls compute::poly which performs polynomial evaluation
2. Calls compute::lambda which itself loops through all key_ids in the signing round: [4](#0-3) 

The total complexity is O(num_duplicates × total_signing_keys). With 100,000 duplicate key_ids and 1,000 total keys, this results in 100 million operations involving expensive scalar arithmetic and point operations.

The FIRE coordinator has identical vulnerable validation logic: [5](#0-4) 

### Impact Explanation

**Specific Harm:**
- Coordinator CPU exhaustion processing malicious signature shares
- Memory pressure from storing large key_ids arrays (400KB+ per malicious share)
- Signing rounds delayed or failed due to coordinator overload
- Multiple coordinators affected if attacker sends to all

**Quantified Impact:**
With realistic parameters (100,000 duplicate key_ids, 1,000 total signing keys):
- 100+ million scalar/point operations per malicious signature share
- 1+ seconds of CPU time per verification attempt on modern hardware
- Memory allocation of ~400KB for the Vec<u32> alone
- Repeated every signing round = sustained DoS

**Who is Affected:**
- All coordinators receiving the malicious signature share
- Legitimate signers waiting for signing round completion
- Dependent systems requiring signatures for transaction confirmation

**Severity Justification:**
This maps to **Medium** severity under the protocol scope: "Any transient consensus failures". The attack causes transient failures in the signing protocol, preventing signature aggregation and delaying transaction confirmation. While it doesn't cause permanent damage or invalid signatures, it disrupts the signing process which could impact dependent blockchain operations requiring threshold signatures.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Valid signer credentials (legitimate signer or compromised signer key)
- Ability to send messages on the coordinator network
- Access to sign messages with their private key

**Attack Complexity:**
Low. The attacker simply needs to:
1. Craft a SignatureShareResponse with inflated key_ids arrays
2. Sign it with their valid signer key
3. Send it to coordinators during a signing round

**Economic Feasibility:**
High. The attack requires:
- No additional infrastructure beyond normal signer participation
- Minimal bandwidth (few hundred KB per malicious message)
- No continuous resource expenditure by attacker

**Detection Risk:**
Medium. The attack would be visible in:
- Coordinator logs showing validation warnings for failed signatures
- Performance monitoring showing CPU spikes during signature verification
- But the malicious signer is identified in check_signature_shares, allowing exclusion

**Estimated Probability:**
High once attacker has signer credentials. The attack is straightforward to execute and difficult to prevent at the protocol level without adding bounds checking.

### Recommendation

**Primary Fix: Add key_ids bounds checking and deduplication**

Add validation in gather_sig_shares before the HashSet check:

```rust
// In frost.rs and fire.rs gather_sig_shares, before line 631/1066:
const MAX_KEY_IDS_PER_SHARE: usize = 10000; // Reasonable upper bound

for sig_share in &sig_share_response.signature_shares {
    if sig_share.key_ids.len() > MAX_KEY_IDS_PER_SHARE {
        warn!(signer_id = %sig_share_response.signer_id, 
              key_ids_len = %sig_share.key_ids.len(),
              "SignatureShare exceeds maximum key_ids length");
        return Ok(()); // or return Err(Error::MaliciousSigner(...))
    }
    
    // Check for duplicates within a single SignatureShare
    let mut seen = HashSet::new();
    for key_id in &sig_share.key_ids {
        if !seen.insert(*key_id) {
            warn!(signer_id = %sig_share_response.signer_id,
                  "SignatureShare contains duplicate key_id {}", key_id);
            return Ok(()); // or return Err(Error::MaliciousSigner(...))
        }
    }
}
```

**Alternative Mitigation: Deduplicate before aggregation**

In the aggregator sign functions, deduplicate key_ids from each SignatureShare before processing:

```rust
// In v2.rs check_signature_shares before line 393:
let deduplicated_key_ids: Vec<u32> = sig_shares[i].key_ids.iter()
    .copied()
    .collect::<HashSet<_>>()
    .into_iter()
    .collect();
```

**Testing Recommendations:**
1. Add unit test with SignatureShare containing 100,000 duplicate key_ids
2. Verify validation rejects messages exceeding MAX_KEY_IDS_PER_SHARE
3. Add integration test measuring coordinator performance with malicious shares
4. Test that legitimate signers with many keys (e.g., 100+) still function correctly

**Deployment Considerations:**
- Set MAX_KEY_IDS_PER_SHARE based on largest legitimate configuration
- Consider rate limiting per signer_id to prevent repeated attacks
- Add metrics for key_ids array sizes to detect attacks in production
- Document the bounds in coordinator configuration

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:** Attacker is legitimate signer with configured key_ids = {1, 2, 3}

2. **Craft Malicious Message:**
```rust
let mut malicious_key_ids = Vec::new();
for &key_id in &[1u32, 2, 3] {
    // Add each key_id 50,000 times
    for _ in 0..50_000 {
        malicious_key_ids.push(key_id);
    }
}
// Total: 150,000 key_ids, but HashSet is {1, 2, 3}

let sig_share = SignatureShare {
    id: attacker_signer_id,
    z_i: Scalar::random(&mut rng), // Incorrect value to force verification failure
    key_ids: malicious_key_ids,
};

let response = SignatureShareResponse {
    dkg_id: current_dkg_id,
    sign_id: current_sign_id,
    sign_iter_id: current_sign_iter_id,
    signer_id: attacker_signer_id,
    signature_shares: vec![sig_share],
};
```

3. **Send to Coordinator:** Sign and send the crafted response during a signing round

4. **Expected Behavior:** 
   - Coordinator validation passes (HashSet {1,2,3} matches config)
   - Signature aggregation fails (incorrect z_i)
   - check_signature_shares called with 150,000 key_ids
   - For each of 150,000 iterations, lambda computes over ~1,000 total keys
   - Result: 150M+ operations, 1+ seconds CPU time, signing round delayed

5. **Actual Behavior:** Same as expected - no bounds checking prevents the attack

**Reproduction Instructions:**
1. Set up FROST coordinator with v2::Aggregator
2. Configure signer with key_ids {1, 2, 3}
3. During signing round, send SignatureShareResponse with 150,000 duplicate key_ids
4. Observe coordinator CPU spike and delayed signature aggregation
5. Check logs for signature verification failure and bad signer identification
6. Repeat to sustain DoS across multiple signing rounds

### Citations

**File:** src/common.rs (L211-220)
```rust
#[derive(Clone, Deserialize, Serialize, PartialEq)]
/// A share of the party signature with related values
pub struct SignatureShare {
    /// The ID of the party
    pub id: u32,
    /// The party signature
    pub z_i: Scalar,
    /// The key IDs of the party
    pub key_ids: Vec<u32>,
}
```

**File:** src/state_machine/coordinator/frost.rs (L631-641)
```rust
            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/v2.rs (L389-409)
```rust
        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
```

**File:** src/compute.rs (L69-80)
```rust
/// Compute the Lagrange interpolation value
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```
