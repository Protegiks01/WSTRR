Audit Report

## Title
Missing sign_iter_id Validation in Signature Share Collection Allows Cross-Iteration Replay Attacks

## Summary
Both FROST and FIRE coordinators fail to validate the `sign_iter_id` field when receiving `SignatureShareResponse` messages, despite validating it for `NonceResponse` messages. This inconsistency allows a malicious signer to replay signature shares from previous signing iterations, causing signing rounds to fail and requiring retries, resulting in denial of service.

## Finding Description

The WSTS protocol uses three identifiers to track signing rounds: `dkg_id`, `sign_id`, and `sign_iter_id`. When timeout-based retries occur, the coordinator increments `sign_iter_id` and requests new nonces for a fresh iteration of the same signing round. This security guarantee—that signature shares must match the nonces from the same iteration—is broken by inconsistent validation.

**Missing Validation in FROST Coordinator:**

The FROST coordinator's `gather_sig_shares` function validates `dkg_id` and `sign_id` but omits the `sign_iter_id` check: [1](#0-0) 

In contrast, the FROST coordinator's `gather_nonces` function correctly validates all three identifiers including `sign_iter_id`: [2](#0-1) 

**Missing Validation in FIRE Coordinator:**

The same inconsistency exists in the FIRE coordinator's `gather_sig_shares` function: [3](#0-2) 

While the FIRE coordinator's `gather_nonces` function correctly validates `sign_iter_id`: [4](#0-3) 

**Root Cause Analysis:**

The `SignatureShareResponse` struct contains a `sign_iter_id` field that is intended to correlate responses with specific iterations: [5](#0-4) 

However, the `SignatureShareResponse.hash()` implementation does not include `sign_iter_id` in the cryptographic hash used for packet signatures: [6](#0-5) 

This means even with packet signature verification enabled, the `sign_iter_id` field is not cryptographically authenticated and can be modified without detection.

**Attack Mechanism:**

When a timeout occurs during signature share gathering, the FIRE coordinator transitions back to the nonce request state and increments `sign_iter_id`: [7](#0-6) 

The `request_nonces` function increments the iteration counter: [8](#0-7) 

Subsequently, `request_sig_shares` clears old signature shares before requesting new ones: [9](#0-8) 

However, because `gather_sig_shares` doesn't validate `sign_iter_id`, a malicious signer can replay a signature share from the previous iteration (computed with old nonces) during the new iteration (which uses new nonces).

**Why Aggregation Fails:**

When the coordinator aggregates signatures, it uses the current iteration's nonces to verify signature shares: [10](#0-9) 

The aggregator's verification checks that each signature share was computed correctly using the provided nonces: [11](#0-10) 

When a signature share from iteration N (computed with nonces_N) is verified against nonces from iteration N+1 (nonces_N+1), the verification equation `z_i * G == r_sign * Rs[i] + cx_sign * cx` fails because Rs[i] is derived from the wrong nonce set. This causes aggregation to fail and identifies the malicious party.

## Impact Explanation

**Severity: Low** - This vulnerability maps to "Any remotely-exploitable denial of service in a node" per the defined scope.

**Specific Harm:**
- Signing rounds fail to produce valid signatures when replayed shares are mixed with current shares
- The coordinator must retry the signing process, causing delays
- Network throughput is reduced as signing operations are disrupted
- Malicious signers can repeatedly trigger this by deliberately timing out and replaying old responses

**Quantified Impact:**
- No fund loss occurs (invalid signatures are rejected before transaction confirmation)
- No invalid transactions are confirmed (cryptographic validation catches bad shares)
- No consensus failures result (only signing delays)
- The malicious signer is eventually detected through the `check_signature_shares` validation in the aggregator

**Affected Deployments:**
- FIRE coordinator deployments are most vulnerable due to built-in timeout-based retry logic
- FROST coordinator deployments are affected if external coordination triggers `sign_iter_id` changes
- All protocol participants experience signing delays during attacks

## Likelihood Explanation

**Attacker Requirements:**
- Must be a participating signer in the threshold signature scheme (within protocol threat model)
- Requires standard network access to send messages to the coordinator
- No cryptographic primitives need to be broken
- No privileged access or key compromise required

**Attack Complexity:**
The attack is straightforward to execute:
1. Participate normally in signing iteration N
2. Receive `SignatureShareRequest` and compute valid signature shares
3. Save the `SignatureShareResponse` without sending it (or delay transmission)
4. Wait for or deliberately cause a timeout
5. Coordinator increments to iteration N+1 and requests new nonces
6. Replay the saved `SignatureShareResponse` from iteration N
7. Coordinator accepts it due to missing validation
8. Aggregation fails, causing retry

**Triggering Conditions:**
- In FIRE: Timeouts occur naturally in distributed systems due to network delays, node issues, or deliberate delays by the attacker
- In FROST: Less common but possible if external systems modify `sign_iter_id`
- The attacker can reliably trigger timeouts by simply not responding promptly

**Economic Feasibility:**
- No additional costs beyond normal protocol participation
- Can cause repeated disruptions with minimal effort
- Detection occurs eventually but after signing delays

**Detection Risk:**
- The malicious signer is identified through signature share validation failures
- Repeated failures from the same signer would be logged
- Monitoring systems could detect patterns of signing failures

**Probability Assessment:**
- **High** for FIRE coordinators with timeout configurations (timeouts are expected in production distributed systems)
- **Medium** for FROST coordinators (depends on external orchestration)
- Easily reproducible by any malicious signer within the threshold

## Recommendation

Add `sign_iter_id` validation in both coordinators' `gather_sig_shares` functions, mirroring the validation already present in `gather_nonces`:

**For FROST Coordinator** (after line 610 in `src/state_machine/coordinator/frost.rs`):
```rust
if sig_share_response.sign_iter_id != self.current_sign_iter_id {
    return Err(Error::BadSignIterId(
        sig_share_response.sign_iter_id,
        self.current_sign_iter_id,
    ));
}
```

**For FIRE Coordinator** (after line 1037 in `src/state_machine/coordinator/fire.rs`):
```rust
if sig_share_response.sign_iter_id != self.current_sign_iter_id {
    return Err(Error::BadSignIterId(
        sig_share_response.sign_iter_id,
        self.current_sign_iter_id,
    ));
}
```

**Additional Hardening (Optional but Recommended):**

Include `sign_iter_id` in the `SignatureShareResponse.hash()` implementation for defense-in-depth:
```rust
impl Signable for SignatureShareResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("SIGNATURE_SHARE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());  // Add this line
        hasher.update(self.signer_id.to_be_bytes());
        // ... rest of implementation
    }
}
```

This ensures packet signatures cryptographically bind all round identifiers, preventing any possibility of field manipulation.

## Proof of Concept

A test demonstrating this vulnerability would involve:

1. Starting a FIRE or FROST coordinator in signing mode
2. Completing nonce gathering for iteration N
3. Receiving a valid `SignatureShareResponse` from a signer for iteration N
4. Triggering a timeout to increment to iteration N+1
5. Gathering new nonces for iteration N+1
6. Replaying the saved `SignatureShareResponse` from iteration N
7. Observing that the coordinator accepts it (doesn't reject with `BadSignIterId`)
8. Observing that aggregation fails with `BadPartySigs` error

The test would assert that:
- The replayed response with mismatched `sign_iter_id` is accepted by `gather_sig_shares`
- The final signature aggregation fails
- The malicious signer is identified in the error

**Note:** The existing test infrastructure in `src/state_machine/coordinator/mod.rs` provides the `check_signature_shares` helper function that demonstrates signature validation failures. A similar test structure should be created specifically for cross-iteration replay scenarios.

### Citations

**File:** src/state_machine/coordinator/frost.rs (L488-492)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/frost.rs (L600-610)
```rust
            if sig_share_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    sig_share_response.dkg_id,
                    self.current_dkg_id,
                ));
            }
            if sig_share_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    sig_share_response.sign_id,
                    self.current_sign_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L202-203)
```rust
                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
```

**File:** src/state_machine/coordinator/fire.rs (L816-816)
```rust
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
```

**File:** src/state_machine/coordinator/fire.rs (L856-860)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L965-965)
```rust
        self.signature_shares.clear();
```

**File:** src/state_machine/coordinator/fire.rs (L1027-1037)
```rust
        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
```

**File:** src/state_machine/coordinator/fire.rs (L1115-1169)
```rust
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();

            debug!(
                "aggregator.sign({}, {:?}, {:?}, {})",
                bs58::encode(&self.message).into_string(),
                nonces.len(),
                shares.len(),
                self.party_polynomials.len(),
            );

            self.aggregator.init(&self.party_polynomials)?;

            if let SignatureType::Taproot(merkle_root) = signature_type {
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    &shares,
                    &key_ids,
                    merkle_root,
                )?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else if let SignatureType::Schnorr = signature_type {
                let schnorr_proof =
                    self.aggregator
                        .sign_schnorr(&self.message, &nonces, &shares, &key_ids)?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else {
                let signature = self
                    .aggregator
                    .sign(&self.message, &nonces, &shares, &key_ids)?;
                debug!("Signature ({}, {})", signature.R, signature.z);
                self.signature = Some(signature);
            }
```

**File:** src/net.rs (L437-448)
```rust
pub struct SignatureShareResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Signature shares from this Signer
    pub signature_shares: Vec<SignatureShare>,
}
```

**File:** src/net.rs (L451-464)
```rust
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("SIGNATURE_SHARE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for signature_share in &self.signature_shares {
            hasher.update(signature_share.id.to_be_bytes());
            hasher.update(signature_share.z_i.to_bytes());
            for key_id in &signature_share.key_ids {
                hasher.update(key_id.to_be_bytes());
            }
        }
    }
```

**File:** src/v2.rs (L406-408)
```rust
            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
```
