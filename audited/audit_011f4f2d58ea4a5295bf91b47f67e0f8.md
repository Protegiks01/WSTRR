### Title
Incomplete Malicious Party Detection in Signature Share Verification

### Summary
The `check_signature_shares` function in both v1 and v2 aggregators fails to report all malicious parties when there is a mix of parties with invalid key IDs and parties with bad signatures. The function returns only `BadPartyKeys` or `BadPartySigs`, never both, meaning parties with bad signatures go unreported if any party has an invalid key ID. The test does not verify this mixed scenario. [1](#0-0) 

### Finding Description

The vulnerability exists in the aggregator implementations in both v1 and v2:

In v2, the `check_signature_shares` function collects bad parties into two separate vectors during its validation loop: `bad_party_keys` for parties with invalid key IDs and `bad_party_sigs` for parties with invalid signature shares. [2](#0-1) 

However, the function only returns ONE type of error at the end, prioritizing bad keys over bad signatures: [3](#0-2) 

This means if Party A provides an invalid key ID and Party B provides a bad signature, only Party A will be reported in the error, and Party B will go undetected. The v1 implementation has the same flaw: [4](#0-3) 

Additionally, in v2, when a party controls multiple key IDs and multiple IDs fail the polynomial lookup, the party ID is added to `bad_party_keys` multiple times (once per bad key), creating duplicates in the result: [5](#0-4) 

The test function only verifies detection of a single malicious party by mutating signatures from signer 0: [6](#0-5) 

The test never checks mixed scenarios with multiple types of malicious behavior, nor does it verify that all bad parties are reported when both bad keys and bad signatures exist.

### Impact Explanation

This vulnerability allows malicious signers to evade detection and identification. In a signing round where multiple malicious parties are present:
- If one malicious party provides invalid key IDs, all other malicious parties with bad signatures will not be reported
- The coordinator cannot properly identify and exclude all malicious parties
- Undetected malicious parties can continue disrupting subsequent signing rounds
- This leads to repeated signing failures and potential denial of service

In a production blockchain system using WSTS for threshold signatures, this could prevent the network from confirming valid transactions if malicious signers coordinate their attacks. If malicious Party A always sends invalid keys while Parties B, C, D send bad signatures, only Party A would be detected and excluded, while B, C, D remain in the signer set and continue disrupting operations.

This maps to **Low severity** per the protocol scope: "remotely-exploitable denial of service in a node" or "network denial of service impacting more than 10 percent of miners that does not shut down the network."

### Likelihood Explanation

**Required attacker capabilities:**
- Control of at least two malicious signers in the threshold signing set
- Ability to coordinate attacks between malicious signers
- One signer must provide invalid key IDs while others provide bad signatures

**Attack complexity:**
Medium. The attacker needs multiple compromised signers but the exploitation is straightforward:
1. Malicious Signer A claims invalid key IDs in its signature share
2. Malicious Signers B, C, etc. provide valid key IDs but corrupted signature shares
3. The coordinator's `check_signature_shares` detects Signer A and returns `BadPartyKeys([A])`
4. Signers B, C remain undetected and can disrupt future rounds

**Economic feasibility:**
The attack requires compromising multiple signers, which depends on the system's signer selection and security model. In systems with economic incentives for correct behavior, the cost of compromising multiple signers may be high.

**Detection risk:**
The attack is partially detectable (Signer A is identified), but the incomplete detection is the vulnerability itself. Over multiple rounds, patterns might emerge, but undetected malicious signers can continue operations.

**Estimated probability:**
Medium-High if an attacker controls multiple signers. The coordination is trivial once signers are compromised.

### Recommendation

**Primary fix:** Modify `check_signature_shares` to return all malicious parties regardless of error type.

In both `src/v1.rs` and `src/v2.rs`, change the return logic to:

```rust
if !bad_party_keys.is_empty() || !bad_party_sigs.is_empty() {
    // Combine and deduplicate
    let mut all_bad_parties: HashSet<u32> = bad_party_keys.into_iter().collect();
    all_bad_parties.extend(bad_party_sigs);
    let bad_parties: Vec<u32> = all_bad_parties.into_iter().collect();
    
    if bad_parties.len() > 0 {
        AggregatorError::BadPartySigs(bad_parties)
    } else {
        AggregatorError::BadGroupSig
    }
} else {
    AggregatorError::BadGroupSig
}
```

Or create a new error variant that can carry both types of information.

**Additional fix:** In v2, ensure party IDs are added to `bad_party_keys` at most once per signature share (move the check outside the inner loop or use a HashSet).

**Testing recommendations:**
1. Add test cases that mix multiple types of malicious behavior
2. Test with multiple malicious signers (not just one)
3. Test with parties controlling multiple key IDs where some keys fail lookup
4. Verify no duplicate party IDs in results
5. Verify all malicious parties are reported in mixed scenarios

**Deployment considerations:**
This is a breaking change to the error type API. Coordinate with all consumers of this interface.

### Proof of Concept

The following test case would expose the vulnerability:

**Setup:**
- 5 signers, 2 keys per signer (10 total keys)
- Signer 0 provides invalid key IDs (triggers `bad_party_keys`)
- Signer 1 provides bad signatures (triggers `bad_party_sigs`)

**Exploitation steps:**
1. Run DKG successfully with all 5 signers
2. Start a signing round
3. When responding with signature shares:
   - Signer 0: Mutate its `key_ids` field to include non-existent key ID 999
   - Signer 1: Mutate its `z_i` value by adding Scalar::from(1)
4. Coordinator calls `check_signature_shares`

**Expected behavior:**
Function should return an error listing both Party 0 and Party 1 as malicious

**Actual behavior:**
Function returns `BadPartyKeys([0])`, and Party 1 is never reported

**Reproduction:**
Modify the test at line 1257 to mutate signatures from TWO signers in different ways, then verify both are reported in the error result. The test will fail with current implementation.

### Citations

**File:** src/state_machine/coordinator/mod.rs (L1257-1349)
```rust
    /// Run DKG then sign a message, but alter the signature shares for signer 0.  This should trigger the aggregator internal check_signature_shares function to run and determine which parties signatures were bad.
    /// Because of the differences between how parties are represented in v1 and v2, we need to pass in a vector of the expected bad parties.
    pub fn check_signature_shares<Coordinator: CoordinatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
        signature_type: SignatureType,
        bad_parties: Vec<u32>,
    ) {
        let (mut coordinators, mut signers) =
            run_dkg::<Coordinator, SignerType>(num_signers, keys_per_signer);

        let msg = "It was many and many a year ago, in a kingdom by the sea"
            .as_bytes()
            .to_vec();
        // Start a signing round
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_signing_round(&msg, signature_type, None)
            .unwrap();
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::NonceGather(signature_type)
        );

        // Send the message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::SigShareGather(signature_type)
        );

        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::SignatureShareRequest(_)),
            "Expected SignatureShareRequest message"
        );

        // Send the SignatureShareRequest message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) = feedback_mutated_messages(
            &mut coordinators,
            &mut signers,
            &outbound_messages,
            |signer, packets| {
                if signer.signer_id != 0 {
                    return packets.clone();
                }
                packets
                    .iter()
                    .map(|packet| {
                        let Message::SignatureShareResponse(response) = &packet.msg else {
                            return packet.clone();
                        };
                        // mutate one of the shares
                        let sshares: Vec<SignatureShare> = response
                            .signature_shares
                            .iter()
                            .map(|share| SignatureShare {
                                id: share.id,
                                key_ids: share.key_ids.clone(),
                                z_i: share.z_i + Scalar::from(1),
                            })
                            .collect();
                        Packet {
                            msg: Message::SignatureShareResponse(SignatureShareResponse {
                                dkg_id: response.dkg_id,
                                sign_id: response.sign_id,
                                sign_iter_id: response.sign_iter_id,
                                signer_id: response.signer_id,
                                signature_shares: sshares,
                            }),
                            sig: vec![],
                        }
                    })
                    .collect()
            },
        );
        assert!(outbound_messages.is_empty());
        assert_eq!(operation_results.len(), 1);
        let OperationResult::SignError(SignError::Coordinator(Error::Aggregator(
            AggregatorError::BadPartySigs(parties),
        ))) = &operation_results[0]
        else {
            panic!("Expected OperationResult::SignError(SignError::Coordinator(Error::Aggregator(AggregatorError::BadPartySigs(parties))))");
        };
        assert_eq!(
            parties, &bad_parties,
            "Expected BadPartySigs from {bad_parties:?}, got {:?}",
            &operation_results[0]
        );
    }
```

**File:** src/v2.rs (L389-409)
```rust
        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
```

**File:** src/v2.rs (L410-416)
```rust
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
        } else {
            AggregatorError::BadGroupSig
        }
```

**File:** src/v1.rs (L419-425)
```rust
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
        } else {
            AggregatorError::BadGroupSig
        }
```
