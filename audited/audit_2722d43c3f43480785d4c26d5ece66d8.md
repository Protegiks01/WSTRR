### Title
Missing Point Validation in DH Key Exchange Allows Private Share Decryption by Network Eavesdroppers

### Summary
The DH key exchange used for encrypting DKG private shares does not validate that `kex_public_key` is not the point-at-infinity (identity element) or a low-order point. A malicious signer can set their `kex_public_key` to `Point::identity()`, causing all other signers to derive a predictable, constant shared secret when encrypting private shares for that signer. This allows external network eavesdroppers to decrypt the private shares, potentially leading to reconstruction of the group private key and direct loss of funds.

### Finding Description

**Location:** The vulnerability spans multiple locations:
- [1](#0-0) 
- [2](#0-1) 
- [3](#0-2) 

**Root Cause:** When a signer receives a `DkgPublicShares` message, the `kex_public_key` field is stored directly without validation. [1](#0-0) 

The codebase demonstrates awareness of this threat - `PublicNonce` has explicit validation to reject the identity point: [4](#0-3) 

However, this validation is not applied to `kex_public_key`. When `make_shared_secret()` is called with an identity point, the scalar multiplication produces identity: `shared_key = private_key * identity = identity`. [2](#0-1) 

The resulting `shared_secret` becomes a predictable constant derived from hashing the compressed identity point. [5](#0-4) 

**Test Coverage:** The unit test only validates correct DH exchange with random points. [6](#0-5) 

No integration tests cover invalid points, point-at-infinity, or low-order point cases. My search found zero tests matching these patterns across the entire codebase.

**Why Existing Mitigations Fail:** While `DkgPublicShares` messages are authenticated with ECDSA signatures, this only proves the message came from the claimed signer - it does not validate the content of `kex_public_key`. A malicious but legitimate signer can publish `Point::identity()` as their own `kex_public_key` and the signature verification will pass.

### Impact Explanation

**Specific Harm:** When a malicious signer sets `kex_public_key = Point::identity()`:

1. All honest signers encrypting private shares for the malicious signer compute:
   - `shared_key = honest_kex_private * identity = identity`
   - `shared_secret = SHA256(compress(identity) || 1 || "DH_SHARED_SECRET_KEY/")` (predictable constant)
   
2. An external network eavesdropper who observes the malicious `DkgPublicShares` message can:
   - Compute the same predictable `shared_secret`
   - Intercept encrypted `DkgPrivateShares` messages destined for the malicious signer
   - Decrypt all private shares using AES-GCM with the predictable key [7](#0-6) 

3. The eavesdropper learns polynomial evaluations (private shares) that should remain confidential

**Quantified Impact:** In an n-of-n or t-of-n threshold scheme where t ≤ n-1:
- Eavesdropper learns (n-1) shares (one from each honest signer to the malicious signer)
- If t ≤ n-1, eavesdropper can reconstruct the group private key using Lagrange interpolation
- With the group private key, attacker can sign arbitrary transactions
- This enables **direct loss of funds** without any authorization

**Affected Parties:** All WSTS deployments using DKG where:
- Any signer is malicious or compromised
- Network traffic is observable (unencrypted channels, compromised infrastructure)
- Threshold t ≤ n-1 (common configurations)

**Severity Justification:** This maps to **Critical** severity under the protocol scope: "Any causing the direct loss of funds other than through any form of freezing." The vulnerability enables unauthorized transaction signing leading to theft.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. **Malicious Signer:** Attacker must control at least one legitimate signer identity (insider threat)
2. **Network Eavesdropping:** Attacker must observe network traffic containing DKG messages (passive attack)
3. **No Cryptographic Breaks:** Exploit requires no breaks of secp256k1, SHA-256, or AES-GCM

**Attack Complexity:**
- Low to Medium complexity
- Malicious signer publishes `Point::identity()` as `kex_public_key` in their `DkgPublicShares` message
- Standard network sniffing tools capture encrypted private share messages
- Simple computation of predictable shared secret (hash of known constant)
- Standard AES-GCM decryption with known key and nonce

**Economic Feasibility:**
- Zero additional cost beyond controlling one signer identity
- No specialized hardware or resources required
- Attack succeeds in single DKG round

**Detection Risk:**
- Low: Identity point appears as valid 33-byte compressed point encoding
- No cryptographic validation detects this in current code
- Only detectable through protocol-level monitoring of point values

**Estimated Probability:** High in deployments with:
- Malicious/compromised signers (insider threat scenarios)
- Observable network traffic (enterprise networks, cloud deployments)
- Common threshold configurations (t ≤ n-1)

### Recommendation

**Primary Fix:** Add validation to reject invalid points in `kex_public_key`:

In `src/state_machine/signer/mod.rs`, before line 1021, add:
```rust
// Validate kex_public_key is not identity or low-order point
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!(%signer_id, "Received identity point as kex_public_key");
    return Err(Error::InvalidDkgPublicShares);
}
// Additional check for low-order points if library provides is_torsion_free()
```

**Alternative Mitigations:**
1. Require authenticated encryption channels (TLS/noise protocol) for DKG messages to prevent eavesdropping
2. Add coordinator-side validation in `gather_public_shares()` to reject invalid `kex_public_key` values
3. Implement point validation in `make_shared_secret()` itself as defense-in-depth

**Testing Recommendations:**
1. Add unit tests in `src/util.rs` for invalid points:
   - Test `make_shared_secret()` with `Point::identity()` → should reject or detect
   - Test with known low-order points on secp256k1 curve
   
2. Add integration tests in state machine tests:
   - Malicious signer sends `kex_public_key = Point::identity()` in `DkgPublicShares`
   - Verify message is rejected or signer is marked malicious
   - Verify DKG fails safely without leaking shares

3. Add property-based tests validating all `Point` inputs to DH key exchange

**Deployment Considerations:**
- Breaking change: existing deployments accepting identity points will fail
- Coordinate upgrade across all signer implementations
- Consider adding configuration flag for validation strictness during migration

### Proof of Concept

**Exploitation Steps:**

1. **Malicious Signer Setup:** Attacker controls signer ID `S` with valid ECDSA key
   
2. **DKG Initiation:** Coordinator broadcasts `DkgBegin` message

3. **Malicious Public Share:** Signer `S` constructs `DkgPublicShares`:
   ```
   kex_public_key = Point::identity()  // 33-byte compressed: 0x00 + 32 zero bytes
   comms = [legitimate polynomial commitments]
   ```
   Signs message with legitimate ECDSA key and broadcasts

4. **Honest Signers Process:** Other signers accept the message (passes signature verification) and store `kex_public_key = identity` at [8](#0-7) 

5. **Private Share Encryption:** Each honest signer computes at [9](#0-8) :
   ```
   shared_secret = make_shared_secret(honest_kex_private, identity)
                 = SHA256(compress(identity) || 0x00000001 || "DH_SHARED_SECRET_KEY/")
                 = <predictable 32-byte value>
   encrypted_share = AES_GCM_encrypt(shared_secret, private_share, random_nonce)
   ```

6. **Eavesdropper Attack:** External attacker with network access:
   - Observes `DkgPublicShares` from signer `S` containing `identity` point
   - Computes same predictable `shared_secret` value
   - Intercepts `DkgPrivateShares` messages sent to `S`
   - Extracts nonce (first 12 bytes) from each encrypted share
   - Decrypts: `private_share = AES_GCM_decrypt(shared_secret, encrypted_bytes, nonce)`

7. **Key Reconstruction:** With `t` or more decrypted private shares:
   - Apply Lagrange interpolation over decrypted share values
   - Reconstruct group private key scalar
   - Derive group public key and verify match
   - Sign arbitrary transactions using reconstructed key

**Expected vs Actual Behavior:**
- **Expected:** `kex_public_key` validation rejects identity point, DKG fails safely
- **Actual:** Identity point accepted, all private shares encrypted with predictable key, eavesdropper decrypts shares

**Reproduction:** Deploy test WSTS network with 3 signers (threshold=2), make one signer malicious with identity `kex_public_key`, run packet capture, demonstrate private share decryption.

### Citations

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L54-60)
```rust
/// Create a shared secret from the passed Diffie-Hellman shared key
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/util.rs (L101-116)
```rust
/// Decrypt the passed data using the key
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/util.rs (L130-143)
```rust
    fn test_shared_secret() {
        let mut rng = create_rng();

        let x = Scalar::random(&mut rng);
        let y = Scalar::random(&mut rng);

        let X = Point::from(x);
        let Y = Point::from(y);

        let xy = make_shared_secret(&x, &Y);
        let yx = make_shared_secret(&y, &X);

        assert_eq!(xy, yx);
    }
```

**File:** src/common.rs (L161-162)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
```
