### Title
Taproot Merkle Root Substitution Attack - Coordinator Can Change Merkle Root Between Nonce Request and Signature Share Request

### Summary
A malicious coordinator can send a `NonceRequest` with one merkle root (or none), collect nonce responses from signers, then send a `SignatureShareRequest` with a different merkle root. Signers do not validate that the merkle root in `SignatureShareRequest` matches what was in `NonceRequest`, allowing the coordinator to trick signers into creating signatures for a different Taproot script tree than intended. This violates the FROST security model and can lead to unauthorized spending of Taproot outputs in Bitcoin/Stacks transactions.

### Finding Description

The vulnerability exists in the signing protocol flow between `NonceRequest` and `SignatureShareRequest` messages.

**Location 1: NonceRequest processing** - When signers receive a `NonceRequest`, they generate nonces and respond with a `NonceResponse`, but they do not store the `signature_type` (including the merkle_root for Taproot signatures) from the request: [1](#0-0) 

The `NonceResponse` struct does not include the `signature_type` field, only the message: [2](#0-1) 

**Location 2: SignatureShareRequest processing** - When signers receive a `SignatureShareRequest`, they use whatever merkle_root is provided in that message to compute signature shares, without validating it matches the original `NonceRequest`: [3](#0-2) 

Specifically, at line 809, the signer extracts the merkle_root from `sign_request.signature_type` and passes it directly to `sign_taproot` without any validation.

**Location 3: Taproot tweak computation** - The merkle_root directly affects the BIP-341 tweak computation, which modifies the public key being signed for: [4](#0-3) 

The tweak is computed by hashing the public key's x-coordinate with the merkle_root (line 160-161). Different merkle roots produce different tweaks, resulting in signatures for different tweaked public keys.

**Location 4: Signer's sign_taproot implementation** - The signer computes the tweak using the merkle_root from the `SignatureShareRequest`: [5](#0-4) 

**Root Cause:** The protocol does not cryptographically bind the nonces to the signature_type parameters. The `NonceResponse` should include the signature_type (or at minimum, a hash commitment to it) so that:
1. The coordinator cannot change it later
2. The signer can validate consistency when processing `SignatureShareRequest`

**Why Existing Mitigations Fail:**
- Packet signatures only verify that the coordinator sent the message, not that it's consistent with prior requests [6](#0-5) 
- The honest coordinator implementation flows signature_type through state correctly, but this is not enforced cryptographically [7](#0-6) 
- There is no validation in the signer that checks merkle_root consistency

### Impact Explanation

**Specific Harm:**
In Bitcoin and Stacks Taproot transactions, the merkle root represents a Merkle tree of alternative spending scripts. Different merkle roots represent completely different sets of spending conditions. A malicious coordinator can:

1. Request nonces for Taproot output with merkle_root_A (legitimate script tree with proper spending conditions)
2. Collect nonce responses from all signers
3. Request signature shares with merkle_root_B (malicious script tree with backdoor or weaker conditions)
4. Signers unknowingly create signature shares for merkle_root_B
5. Coordinator aggregates a valid signature for the wrong Taproot output

**Quantified Impact:**
- **Direct Loss of Funds:** If the malicious merkle root represents a script tree with a backdoor allowing the coordinator to spend funds unilaterally, the entire UTXO value is at risk
- **Invalid Transaction Confirmation:** The signature is valid for a different Taproot output than intended, potentially confirming transactions that should not be authorized
- **Violation of Multi-Signature Security:** Defeats the purpose of threshold signatures by allowing a single party (coordinator) to control what is actually being signed

**Who Is Affected:**
- Any Bitcoin or Stacks users relying on WSTS for Taproot multisig wallets
- Protocols using WSTS for Taproot-based smart contracts
- All participants in a signing group when the coordinator is compromised

**Severity Justification:** **HIGH** 
Maps to the "High" category in protocol scope: "Any causing the direct loss of funds other than through any form of freezing." This vulnerability allows a malicious coordinator to manipulate signatures to spend funds from unintended Taproot outputs, leading to potential fund loss.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Compromised or malicious coordinator with ability to send protocol messages
- No cryptographic breaks required
- No access to private keys needed
- No network-level attacks required

**Attack Complexity:**
Low - The attack is straightforward:
1. Coordinator sends `NonceRequest` with merkle_root_A
2. Waits for all `NonceResponse` messages
3. Sends `SignatureShareRequest` with merkle_root_B
4. Collects signature shares and aggregates

**Economic Feasibility:**
Highly feasible - requires only compromising the coordinator node, which is a single point of failure in the current architecture.

**Detection Risk:**
Low - Signers have no way to detect the attack since they don't store or validate the original merkle_root. The attack leaves no trace in the protocol messages visible to signers.

**Estimated Probability:**
High probability if coordinator is compromised. The attack is deterministic and requires no special timing or luck.

### Recommendation

**Primary Fix:** Add merkle_root binding to NonceResponse and validation to SignatureShareRequest processing.

**Proposed Code Changes:**

1. Modify `NonceResponse` to include `signature_type`:
   - Add `signature_type: SignatureType` field to `NonceResponse` struct in `src/net.rs`
   - Update hash implementation to include signature_type
   - Update signer's `nonce_request` method to include signature_type in response

2. Store the signature_type from NonceRequest in signer state:
   - Add field to store the current signing round's signature_type
   - Set it when processing NonceRequest
   - Clear it after signature share is sent

3. Add validation in `sign_share_request` method (`src/state_machine/signer/mod.rs`):
   - Compare stored signature_type against `sign_request.signature_type`
   - Reject if they don't match with error
   - Also validate that all nonce_responses in the request have matching signature_type

**Alternative Mitigation:**
If modifying NonceResponse is not feasible, add a hash commitment:
- Include `commitment: [u8; 32]` in NonceResponse as hash of (nonces || signature_type)
- Signers verify this commitment in SignatureShareRequest

**Testing Recommendations:**
1. Unit test: Create test that sends NonceRequest with one merkle_root, then SignatureShareRequest with different merkle_root - should be rejected
2. Integration test: Verify honest coordinator flow still works
3. Test edge cases: None merkle_root vs Some(_), switching between Taproot/Schnorr/Frost types

**Deployment Considerations:**
This is a protocol-breaking change requiring coordination:
- All signers and coordinators must upgrade simultaneously
- Old and new versions cannot interoperate
- Requires protocol version bump

### Proof of Concept

**Exploitation Algorithm:**

```
1. Setup:
   - Attacker controls coordinator
   - Honest signers participate in threshold signing
   - Target: Create signature for Taproot output with malicious script tree

2. Execution:
   - merkle_root_honest = compute_merkle_root(legitimate_script_tree)
   - merkle_root_malicious = compute_merkle_root(backdoor_script_tree)
   
   - coordinator.send(NonceRequest {
       signature_type: Taproot(Some(merkle_root_honest)),
       message: transaction_hash,
       ...
   })
   
   - nonce_responses = coordinator.collect_all_nonce_responses()
   
   - coordinator.send(SignatureShareRequest {
       signature_type: Taproot(Some(merkle_root_malicious)),
       message: transaction_hash,
       nonce_responses: nonce_responses,
       ...
   })
   
   - sig_shares = coordinator.collect_all_signature_shares()
   - signature = coordinator.aggregate(sig_shares)

3. Result:
   - signature is valid for Taproot output with merkle_root_malicious
   - Signers believe they signed for merkle_root_honest
   - Attacker can spend from malicious script tree
```

**Reproduction Steps:**
1. Set up WSTS coordinator and 2+ signers with threshold 2
2. Initiate signing round with `start_signing_round(msg, SignatureType::Taproot(Some(merkle_A)), ...)`
3. After receiving all NonceResponses, manually modify coordinator state: `coordinator.state = State::SigShareRequest(SignatureType::Taproot(Some(merkle_B)))` where `merkle_B != merkle_A`
4. Call `coordinator.request_sig_shares(SignatureType::Taproot(Some(merkle_B)))`
5. Observe that signers accept and process the request, computing shares for merkle_B
6. Aggregate the signature - it will be valid for a Taproot output with merkle_B, not merkle_A

**Expected vs Actual Behavior:**
- Expected: Signers should reject SignatureShareRequest when merkle_root doesn't match NonceRequest
- Actual: Signers accept any merkle_root in SignatureShareRequest and compute shares accordingly

### Citations

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L757-842)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };

            self.signer.gen_nonces(&self.network_private_key, rng);

            let response = SignatureShareResponse {
                dkg_id: sign_request.dkg_id,
                sign_id: sign_request.sign_id,
                sign_iter_id: sign_request.sign_iter_id,
                signer_id: self.signer_id,
                signature_shares,
            };
            info!(
                signer_id = %self.signer_id,
                dkg_id = %sign_request.dkg_id,
                sign_id = %sign_request.sign_id,
                sign_iter_id = %sign_request.sign_iter_id,
                "sending SignatureShareResponse"
            );

            Ok(vec![Message::SignatureShareResponse(response)])
        } else {
            debug!(signer_id = %self.signer_id, "signer not included in SignatureShareRequest");
            Ok(Vec::new())
        }
    }
```

**File:** src/net.rs (L309-326)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/net.rs (L577-581)
```rust
            Message::SignatureShareRequest(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a SignatureShareRequest message with an invalid signature.");
                    return false;
                }
```

**File:** src/compute.rs (L155-165)
```rust
/// Create a BIP341 compliant taproot tweak from a public key and merkle root
pub fn tweak(public_key: &Point, merkle_root: Option<[u8; 32]>) -> Scalar {
    let mut hasher = tagged_hash("TapTweak");

    hasher.update(public_key.x().to_bytes());
    if let Some(root) = merkle_root {
        hasher.update(root);
    }

    hash_to_scalar(&mut hasher)
}
```

**File:** src/v2.rs (L672-681)
```rust
    fn sign_taproot(
        &self,
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
        merkle_root: Option<[u8; 32]>,
    ) -> Vec<SignatureShare> {
        let tweak = compute::tweak(&self.group_key, merkle_root);
        vec![self.sign_with_tweak(msg, signer_ids, key_ids, nonces, Some(tweak))]
```

**File:** src/state_machine/coordinator/frost.rs (L157-171)
```rust
                State::NonceRequest(signature_type) => {
                    let packet = self.request_nonces(signature_type)?;
                    return Ok((Some(packet), None));
                }
                State::NonceGather(signature_type) => {
                    self.gather_nonces(packet, signature_type)?;
                    if self.state == State::NonceGather(signature_type) {
                        // We need more data
                        return Ok((None, None));
                    }
                }
                State::SigShareRequest(signature_type) => {
                    let packet = self.request_sig_shares(signature_type)?;
                    return Ok((Some(packet), None));
                }
```
