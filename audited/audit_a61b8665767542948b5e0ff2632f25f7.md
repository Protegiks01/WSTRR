# Audit Report

## Title
Missing sign_iter_id Validation in FIRE Coordinator Allows Stale Signature Shares After Timeout Retry

## Summary
The FIRE coordinator's `gather_sig_shares()` function fails to validate the `sign_iter_id` field in `SignatureShareResponse` messages, despite correctly incrementing this field during timeout retries. This allows malicious signers to submit signature shares from previous signing iterations, causing signature verification failures and denial of service.

## Finding Description

The FIRE coordinator implements timeout retry logic for signature gathering operations. When a timeout occurs, the coordinator increments `sign_iter_id` and restarts the signing process from the nonce request phase. [1](#0-0) 

The `gather_nonces()` function correctly validates that incoming `NonceResponse` messages match the current `sign_iter_id`, rejecting responses from previous iterations. [2](#0-1) 

However, the `gather_sig_shares()` function only validates `dkg_id` and `sign_id` fields but completely omits validation of the `sign_iter_id` field. [3](#0-2) 

This inconsistency breaks the protocol's security guarantee that signature shares must be computed using the nonces from the current signing iteration. In FROST, signature shares are computed using binding values that are cryptographically derived from the complete set of nonces. [4](#0-3) 

**Attack Scenario:**
1. Initial signing iteration N: All signers submit nonces. Coordinator requests signature shares with `sign_iter_id` = N.
2. Malicious Signer A computes their signature share correctly for iteration N but withholds it, causing a timeout.
3. Retry iteration N+1: Coordinator increments `sign_iter_id` to N+1 via timeout handler. [5](#0-4) 
4. Signer A (if not excluded or if a different signer behaves maliciously) sends nonces for iteration N+1 and gets added to the wait list.
5. When coordinator requests signature shares for iteration N+1, Signer A maliciously sends their OLD signature share from iteration N.
6. The coordinator accepts this stale signature share because `gather_sig_shares()` doesn't validate `sign_iter_id`.
7. The aggregator attempts to verify using nonces from iteration N+1, but the signature share contains binding values from iteration N, causing verification to fail.

The FROST coordinator is not vulnerable because it lacks timeout retry logic entirely and never increments `sign_iter_id` after the initial signing round.

## Impact Explanation

This vulnerability causes **transient consensus failures** (Medium severity per the defined scope). When triggered, signing rounds fail despite having sufficient honest signers, because the aggregated signature cannot be verified.

In the Stacks blockchain context, this could prevent block signing or transaction confirmation until the issue is detected and the malicious signer is excluded. The disruption is temporary rather than permanent because:
- No funds are directly lost
- No permanent chain splits occur
- No cryptographic keys are compromised
- The system can recover by identifying and excluding the malicious signer

However, the attack can repeatedly disrupt operations if the malicious signer continues to participate, potentially affecting multiple blocks before detection.

## Likelihood Explanation

**High likelihood when conditions are met:**

1. **Required Attacker Capabilities**: A malicious signer within the threshold (explicitly allowed by the threat model). The attacker only needs to:
   - Participate legitimately in the signing protocol
   - Store signature share responses from previous iterations
   - Send stale messages during retry attempts

2. **Attack Complexity**: Low. The attack is a simple message replay that requires no cryptographic expertise or significant computation. Any signer can save their old `SignatureShareResponse` and resend it with the same `dkg_id` and `sign_id` but outdated `sign_iter_id`.

3. **Preconditions**: The coordinator must have `sign_timeout` configured and timeout retries must be triggered. This is common in real-world deployments where network latency or temporary unavailability can cause timeouts.

4. **Detection Difficulty**: Low detection risk for the attacker. Failed signature verifications appear identical to legitimate failures caused by network issues or honest mistakes, making it difficult to distinguish malicious behavior without detailed `sign_iter_id` logging.

5. **Economic Feasibility**: Highly feasible. No additional resources required beyond normal protocol participation. The attacker causes disruption without extracting value, making it suitable for griefing attacks.

## Recommendation

Add `sign_iter_id` validation in `gather_sig_shares()` to match the validation pattern used in `gather_nonces()`:

```rust
fn gather_sig_shares(
    &mut self,
    packet: &Packet,
    signature_type: SignatureType,
) -> Result<(), Error> {
    let Message::SignatureShareResponse(sig_share_response) = &packet.msg else {
        return Ok(());
    };
    
    // ... existing code ...
    
    if sig_share_response.dkg_id != self.current_dkg_id {
        return Err(Error::BadDkgId(
            sig_share_response.dkg_id,
            self.current_dkg_id,
        ));
    }
    if sig_share_response.sign_id != self.current_sign_id {
        return Err(Error::BadSignId(
            sig_share_response.sign_id,
            self.current_sign_id,
        ));
    }
    // ADD THIS VALIDATION:
    if sig_share_response.sign_iter_id != self.current_sign_iter_id {
        return Err(Error::BadSignIterId(
            sig_share_response.sign_iter_id,
            self.current_sign_iter_id,
        ));
    }
    
    // ... rest of function ...
}
```

This ensures that only signature shares computed with nonces from the current signing iteration are accepted, maintaining the cryptographic binding between nonces and signature shares.

## Proof of Concept

```rust
#[test]
fn test_stale_signature_share_after_retry() {
    use rand_core::OsRng;
    
    // Setup coordinator with timeout enabled
    let mut coordinator = setup_fire_coordinator_with_timeout();
    
    // Iteration N: Collect nonces, request signature shares
    coordinator.start_signing_round(&message, SignatureType::Frost, None).unwrap();
    let nonce_responses = collect_nonces_from_signers();
    for nonce in nonce_responses {
        coordinator.process_message(&nonce).unwrap();
    }
    
    // Signer A computes signature share for iteration N
    let stale_share = signer_a.compute_signature_share(iteration_n_nonces);
    
    // Trigger timeout (don't send signature shares)
    coordinator.process_timeout(Instant::now()).unwrap();
    
    // Iteration N+1: Collect new nonces
    assert_eq!(coordinator.current_sign_iter_id, 1); // Incremented
    let new_nonce_responses = collect_nonces_from_signers();
    for nonce in new_nonce_responses {
        coordinator.process_message(&nonce).unwrap();
    }
    
    // Malicious Signer A sends STALE signature share from iteration N
    let result = coordinator.process_message(&stale_share);
    
    // BUG: Coordinator accepts stale share (should reject)
    assert!(result.is_ok()); // Current behavior (vulnerable)
    // Should be: assert!(matches!(result, Err(Error::BadSignIterId(..))));
    
    // When aggregating, verification fails due to mismatched binding values
    let aggregate_result = coordinator.aggregate_signatures();
    assert!(aggregate_result.is_err()); // Verification failure
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L173-204)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L816-816)
```rust
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
```

**File:** src/state_machine/coordinator/fire.rs (L856-860)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L1027-1038)
```rust
        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }
```

**File:** src/compute.rs (L17-33)
```rust
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```
