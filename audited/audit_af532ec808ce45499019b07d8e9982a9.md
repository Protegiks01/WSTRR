### Title
Missing Identity Element Validation in KEX Public Key Allows Trivial Shared Secret Computation and DKG Private Share Decryption

### Summary
The `get_kex_public_key()` function and the code that stores KEX public keys do not validate that the returned point is not the identity element. A malicious signer can send `Point::identity()` as their KEX public key, causing all honest signers to compute a trivial, predictable shared secret when encrypting DKG private shares. This allows the attacker to decrypt all private polynomial shares intended for them, breaking the confidentiality of the DKG protocol.

### Finding Description

**Exact Code Location:**

The vulnerability exists in multiple locations:

1. **KEX Public Key Storage (No Validation):** When receiving `DkgPublicShares` messages, the signer stores the `kex_public_key` directly into `self.kex_public_keys` without any validation that it is not the identity element. [1](#0-0) 

2. **KEX Public Key Retrieval:** The `get_kex_public_key()` function simply retrieves the stored key without validation. [2](#0-1) 

3. **Vulnerable Usage in dkg_private_shares():** The retrieved KEX public key is used at line 1043 and then directly used to compute a shared secret. [3](#0-2) 

4. **Shared Secret Computation:** The `make_shared_secret()` function performs scalar-point multiplication without validating the point. [4](#0-3) 

5. **Encryption of Private Shares:** During `dkg_private_begin()`, honest signers encrypt private shares for recipients using the unvalidated KEX public keys. [5](#0-4) 

**Root Cause:**

The root cause is the absence of point validation to ensure KEX public keys are not the identity element. The codebase demonstrates awareness of this attack class—`PublicNonce::is_valid()` explicitly checks that nonce points are not the identity element. [6](#0-5) 

However, this validation pattern was not applied to KEX public keys during DKG.

**Why Existing Mitigations Fail:**

There are no mitigations for this vulnerability. The coordinator also stores KEX public keys without validation. [7](#0-6) 

Point deserialization from network messages does not automatically reject identity elements, and no explicit validation is performed at the application layer.

### Impact Explanation

**Specific Harm:**

When a malicious signer sends `Point::identity()` as their `kex_public_key`:

1. For any scalar `a` (honest signer's private KEX key): `a * Point::identity() = Point::identity()`
2. All honest signers compute the same trivial shared secret derived from the identity point
3. The attacker knows this shared secret is deterministic and can compute it independently
4. The attacker decrypts all DKG private shares that honest signers encrypted for them

**Quantified Impact:**

- **Confidentiality Breach:** Private polynomial evaluations `f_i(party_id)` from all honest signers are exposed to the attacker
- **DKG Compromise:** The attacker learns secret shares they should never possess, potentially allowing manipulation of the distributed key generation
- **Threshold Signature Failure:** Compromised DKG can prevent valid threshold signatures from being generated
- **Transaction Confirmation Failure:** In the Stacks context, inability to generate valid threshold signatures prevents Bitcoin transactions from being signed and confirmed

**Who is Affected:**

All honest signers who encrypt private shares for the malicious signer, and the entire DKG round is compromised.

**Severity Justification:**

This maps to **Critical** severity under the protocol scope: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks." A compromised DKG prevents the threshold signature system from functioning, which in turn prevents valid transactions from being confirmed on the blockchain.

### Likelihood Explanation

**Required Attacker Capabilities:**

- Attacker must be a registered signer in the DKG round
- Attacker needs to send a `DkgPublicShares` message with `kex_public_key` set to `Point::identity()`
- No special cryptographic knowledge or computational resources required

**Attack Complexity:**

Extremely low. The attack requires only:
1. Serialize `Point::identity()` in a `DkgPublicShares` message
2. Send the message during the DKG public shares phase
3. Receive and decrypt private shares using the known trivial shared secret

**Economic Feasibility:**

Negligible cost. The attack uses standard protocol messages and requires no additional resources beyond being a registered signer.

**Detection Risk:**

Low detection risk. Without explicit validation, the identity element appears as a valid serialized point. The attack leaves no obvious traces unless specific monitoring for identity elements is implemented.

**Estimated Probability of Success:**

Near 100% if the attacker is a registered signer. The vulnerability is deterministic—there are no random factors or race conditions involved.

### Recommendation

**Proposed Code Changes:**

1. Add validation in `dkg_public_shares()` before storing KEX public keys:

```rust
// In src/state_machine/signer/mod.rs, around line 1017
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!(%signer_id, "Signer sent identity element as KEX public key");
    return Ok(vec![]);
}

for key_id in signer_key_ids {
    self.kex_public_keys
        .insert(*key_id, dkg_public_shares.kex_public_key);
}
```

2. Add validation in coordinator's `gather_public_shares()`:

```rust
// In src/state_machine/coordinator/fire.rs, around line 492
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!(signer_id = %dkg_public_shares.signer_id, "Signer sent identity element as KEX public key");
    return Ok(());
}
```

3. Add defensive validation in `get_kex_public_key()`:

```rust
// In src/state_machine/signer/mod.rs, in get_kex_public_key()
let kex_public_key = *kex_public_key;
if kex_public_key == Point::identity() {
    return Err(Error::Config(ConfigError::InvalidKexPublicKey(*signer_key_id)));
}
Ok(kex_public_key)
```

**Alternative Mitigations:**

Consider adding a general `Point::is_valid_kex_key()` method that checks for identity element and potentially other invalid curve points.

**Testing Recommendations:**

1. Unit test: Verify that `DkgPublicShares` with identity element KEX key is rejected
2. Integration test: Attempt a full DKG round where a malicious signer sends identity element
3. Fuzzing: Test point validation with various edge case curve points

**Deployment Considerations:**

- This is a breaking protocol change requiring all signers and coordinators to upgrade
- Existing DKG sessions in progress should be aborted and restarted after the fix
- Consider a coordinated deployment to prevent partial upgrades

### Proof of Concept

**Exploitation Algorithm:**

```
1. Attacker Setup:
   - Register as a valid signer in DKG round
   - Prepare DkgPublicShares message with kex_public_key = Point::identity()

2. DKG Public Shares Phase:
   - Attacker sends malicious DkgPublicShares message
   - Honest signers store identity element as attacker's KEX public key
   - No validation occurs; message is accepted

3. DKG Private Shares Phase:
   - Honest signers execute dkg_private_begin()
   - For each share destined to attacker's key_ids:
     * Honest signer retrieves kex_public_key (identity element)
     * Computes: shared_secret = make_shared_secret(honest_private_key, identity)
     * Result: shared_key = honest_private_key * identity = identity (always)
     * Encrypts private share with shared_secret derived from identity
   - Honest signers broadcast DkgPrivateShares messages

4. Attacker Decryption:
   - Attacker computes same trivial shared_secret from identity element
   - Attacker decrypts all private shares: decrypt(shared_secret, encrypted_share)
   - Attacker obtains f_i(party_id) for all honest signers i

5. Impact Realization:
   - Attacker possesses private polynomial evaluations
   - DKG confidentiality is broken
   - Attacker can manipulate or abort DKG
```

**Expected vs Actual Behavior:**

- **Expected:** KEX public keys should be validated to ensure they are valid curve points that are not the identity element, generator point, or other special values
- **Actual:** No validation occurs; identity element is accepted and used, resulting in trivial shared secrets

**Reproduction Instructions:**

1. Set up a WSTS DKG round with multiple signers
2. Modify one signer to send `Point::identity()` as `kex_public_key` in `DkgPublicShares`
3. Observe that honest signers accept the message without error
4. During private share distribution, intercept encrypted shares
5. Decrypt using the trivial shared secret derived from `Point::identity()`
6. Verify successful decryption of private polynomial shares

### Citations

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1043-1070)
```rust
        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/state_machine/signer/mod.rs (L1112-1129)
```rust
    fn get_kex_public_key(&self, signer_id: u32) -> Result<Point, Error> {
        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(signer_key_id) = signer_key_ids.iter().next() else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(kex_public_key) = self.kex_public_keys.get(signer_key_id) else {
            warn!(%signer_id, %signer_key_id, "No KEX public key configured");
            return Err(Error::MissingKexPublicKey(*signer_key_id));
        };

        Ok(*kex_public_key)
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```
