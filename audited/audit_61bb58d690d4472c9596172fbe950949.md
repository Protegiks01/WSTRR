> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4)

### Citations

**File:** src/compute.rs (L155-165)
```rust
/// Create a BIP341 compliant taproot tweak from a public key and merkle root
pub fn tweak(public_key: &Point, merkle_root: Option<[u8; 32]>) -> Scalar {
    let mut hasher = tagged_hash("TapTweak");

    hasher.update(public_key.x().to_bytes());
    if let Some(root) = merkle_root {
        hasher.update(root);
    }

    hash_to_scalar(&mut hasher)
}
```

**File:** src/v2.rs (L465-501)
```rust
    fn sign_schnorr(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
    ) -> Result<SchnorrProof, AggregatorError> {
        let tweak = Scalar::from(0);
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, key_ids, Some(tweak))?;
        let proof = SchnorrProof::new(&sig);

        if proof.verify(&key.x(), msg) {
            Ok(proof)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, Some(tweak)))
        }
    }

    /// Check and aggregate the party signatures
    fn sign_taproot(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
        merkle_root: Option<[u8; 32]>,
    ) -> Result<SchnorrProof, AggregatorError> {
        let tweak = compute::tweak(&self.poly[0], merkle_root);
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, key_ids, Some(tweak))?;
        let proof = SchnorrProof::new(&sig);

        if proof.verify(&key.x(), msg) {
            Ok(proof)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, Some(tweak)))
        }
    }
```

**File:** src/v2.rs (L662-683)
```rust
    fn sign_schnorr(
        &self,
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
    ) -> Vec<SignatureShare> {
        vec![self.sign_with_tweak(msg, signer_ids, key_ids, nonces, Some(Scalar::from(0)))]
    }

    fn sign_taproot(
        &self,
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
        merkle_root: Option<[u8; 32]>,
    ) -> Vec<SignatureShare> {
        let tweak = compute::tweak(&self.group_key, merkle_root);
        vec![self.sign_with_tweak(msg, signer_ids, key_ids, nonces, Some(tweak))]
    }
}
```

**File:** src/taproot.rs (L314-316)
```rust
    fn taproot_sign_verify_v1_no_merkle_root() {
        taproot_sign_verify_v1(None);
    }
```

**File:** src/taproot.rs (L320-374)
```rust
    fn taproot_sign_verify_v1(merkle_root: Option<[u8; 32]>) {
        let mut rng = create_rng();

        // First create and verify a frost signature
        let msg = "It was many and many a year ago".as_bytes();
        let N: u32 = 10;
        let T: u32 = 7;
        let signer_ids: Vec<Vec<u32>> = [
            [1, 2, 3].to_vec(),
            [4, 5].to_vec(),
            [6, 7, 8].to_vec(),
            [9, 10].to_vec(),
        ]
        .to_vec();
        let mut signers: Vec<v1::Signer> = signer_ids
            .iter()
            .enumerate()
            .map(|(id, ids)| v1::Signer::new(id.try_into().unwrap(), ids, N, T, &mut rng))
            .collect();

        let polys = match test_helpers::dkg(&mut signers, &mut rng) {
            Ok(polys) => polys,
            Err(secret_errors) => {
                panic!("Got secret errors from DKG: {secret_errors:?}");
            }
        };

        let mut S = [signers[0].clone(), signers[1].clone(), signers[3].clone()].to_vec();
        let mut sig_agg = v1::Aggregator::new(N, T);
        sig_agg.init(&polys).expect("aggregator init failed");
        let aggregate_public_key = sig_agg.poly[0];
        println!(
            "sign_verify:  agg_pubkey    {}",
            &hex::encode(sig_agg.poly[0].compress().as_bytes())
        );
        println!("sign_verify:  agg_pubkey.x  {}", &sig_agg.poly[0].x());
        let tweaked_public_key = compute::tweaked_public_key(&aggregate_public_key, merkle_root);
        println!(
            "sign_verify: tweaked_key    {}",
            &hex::encode(tweaked_public_key.compress().as_bytes())
        );
        println!("sign_verify: tweaked_key.x  {}", &tweaked_public_key.x());
        let (nonces, sig_shares) = test_helpers::sign(msg, &mut S, &mut rng, merkle_root);
        let proof = match sig_agg.sign_taproot(msg, &nonces, &sig_shares, &[], merkle_root) {
            Err(e) => panic!("Aggregator sign failed: {e:?}"),
            Ok(proof) => proof,
        };

        // now ser/de the proof
        let proof_bytes = proof.to_bytes();
        let proof_deser = SchnorrProof::from(proof_bytes);

        assert_eq!(proof, proof_deser);
        assert!(proof_deser.verify(&tweaked_public_key.x(), msg));
    }
```
