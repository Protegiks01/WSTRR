### Title
Nonce Reuse Vulnerability Through State Persistence Enables Private Key Extraction

### Summary
The WSTS implementation stores private nonces in `PartyState` and persists them through save/load operations without any mechanism to track nonce usage or prevent reuse. An attacker who can control state persistence timing or trigger multiple signing operations with a loaded state can cause the same nonce to be used across different messages, enabling mathematical extraction of the private key through standard Schnorr nonce reuse attacks.

### Finding Description

**Exact Code Locations:**

The vulnerability exists across multiple components:

1. **Nonce Storage in PartyState:** [1](#0-0) 

2. **Nonce Persistence in Party::save():** [2](#0-1) 

3. **Nonce Restoration in Party::load():** [3](#0-2) 

4. **Nonce Usage in Signing (immutable reference, cannot clear):** [4](#0-3) 

5. **State Machine Save/Load:** [5](#0-4) 

6. **Nonce Regeneration After Signing:** [6](#0-5) 

**Root Cause:**

The root cause is architectural: nonces are treated as persistent state that can be saved and restored, but there is no mechanism to track whether a nonce has been used or to prevent loading a state with a previously-used nonce. The signing methods take `&self` (immutable reference), meaning they cannot clear nonces after use. While the state machine attempts to regenerate nonces after signing (line 820), this protection is insufficient because:

1. State can be saved between signing and nonce regeneration
2. The `Signer` trait can be used directly, bypassing the state machine's automatic regeneration
3. There is no version control or nonce usage tracking in saved states
4. No validation exists to detect and reject reused nonces

**Why Existing Mitigations Fail:**

The state machine's post-signing nonce regeneration [7](#0-6)  is insufficient because:
- It only protects sequential operations within a single state machine session
- It cannot prevent state rollback attacks where an old saved state is reloaded
- It doesn't help if state is persisted before the regeneration occurs
- It provides no protection when the `Signer` trait is used directly

### Impact Explanation

**Specific Harm:**

This vulnerability enables complete private key compromise through mathematical extraction. When a signer uses the same nonce `(d, e)` to sign two different messages, an attacker obtains two signature shares with the form:
- `z1 = d + e*ρ1 + c1*x*λ`
- `z2 = d + e*ρ2 + c2*x*λ`

Where `ρ1, ρ2` are binding values (different for different messages), `c1, c2` are challenges, `x` is the private key, and `λ` is the Lagrange coefficient. Since all values except `d`, `e`, and `x` are public or computable from public information, the attacker can solve for the private key.

**Quantified Impact:**

- **Critical Severity**: Maps to "Any causing the direct loss of funds other than through any form of freezing"
- **Scope**: Affects all WSTS signers that persist state across signing sessions
- **Consequence**: Complete compromise of signer's private key share, enabling:
  - Unauthorized transaction signing
  - Theft of all funds controlled by compromised key shares
  - If threshold signers are compromised, total loss of group funds
  - Invalid signatures could be confirmed, violating protocol integrity

**Who is Affected:**

Any system using WSTS for threshold signatures where:
- Signer states are persisted to disk or other storage
- Applications manage state save/load operations
- The `Signer` trait is used directly without the state machine wrapper
- State backups or snapshots are taken and later restored

This includes blockchain wallets, custody solutions, and distributed signing services using WSTS.

### Likelihood Explanation

**Required Attacker Capabilities:**

**Scenario 1 - State Rollback Attack:**
- Attacker needs ability to trigger state save operations (e.g., through application crashes, backups, or normal persistence)
- Attacker needs ability to restore old saved states (e.g., database rollback, file system manipulation, or legitimate state recovery)
- Attacker needs ability to trigger signing of two different messages with the same key

**Scenario 2 - Direct Signer Usage:**
- Application uses `Signer` trait directly instead of through state machine
- Attacker triggers two signing operations without intermediate nonce regeneration
- No special access required if application incorrectly manages nonce lifecycle

**Scenario 3 - Race Condition:**
- Attacker triggers state save between signing and nonce regeneration (narrow window but possible)
- Later triggers state load and another signing operation

**Attack Complexity:**

- **Low to Medium**: Does not require cryptographic breaks
- No need to compromise secp256k1, SHA-256, or other primitives
- Attack relies on state management issues, not cryptographic weaknesses
- Exploitation is deterministic once conditions are met

**Economic Feasibility:**

- **High**: Attack cost is minimal (state manipulation, API calls)
- **High Return**: Can steal all funds controlled by compromised threshold keys
- **Detection Risk**: Low - appears as legitimate signing operations

**Estimated Probability:**

- **Medium-High** for applications that:
  - Persist state to disk regularly
  - Have backup/restore functionality
  - Use direct `Signer` trait without state machine
  - Have error recovery that reloads states
- **Low** for applications that:
  - Only use state machine with proper lifecycle management
  - Never persist intermediate states
  - Have no backup/restore capability (impractical for production)

### Recommendation

**Immediate Mitigations:**

1. **Add Nonce Usage Tracking:**
   - Add a `nonce_used: bool` field to `PartyState`
   - Set to `true` after signing, check before signing
   - Reject any signing attempt with a used nonce
   - Clear the flag only when `gen_nonces()` generates new nonces

2. **Add Nonce Version/ID:**
   - Include a unique nonce generation ID or timestamp in `PartyState`
   - Track the last used nonce ID separately
   - Reject signing if current nonce ID has been used before

3. **Clear Nonces After Use:**
   - Make signing methods take `&mut self` instead of `&self`
   - Zero out nonces immediately after computing signature share
   - Force nonce regeneration before next signing operation

4. **State Version Control:**
   - Add state version counter that increments with each signing operation
   - Reject loading states with version numbers earlier than last known version
   - Persist "high water mark" of state versions separately from main state

**Proposed Code Changes:**

Modify `PartyState`:
```rust
pub struct PartyState {
    pub polynomial: Option<Polynomial<Scalar>>,
    pub private_keys: Vec<(u32, Scalar)>,
    pub nonce: Nonce,
    pub nonce_used: bool,        // NEW
    pub nonce_generation_id: u64, // NEW
}
```

Modify `Party::sign()` to take `&mut self` and clear nonce after use, or add explicit validation.

Add validation in `Signer::sign()` methods to check nonce usage status before signing.

**Alternative Mitigation:**

Implement a "nonce commitment" system where:
- Nonces are generated and committed to (hash stored) before use
- After use, the commitment is marked as consumed
- Attempting to use a nonce with an existing commitment fails

**Testing Recommendations:**

1. Unit test: Save state after signing, load state, attempt to sign again - should fail
2. Integration test: Simulate state rollback and verify signing is rejected
3. Fuzzing: Random state save/load patterns to find edge cases
4. Regression test: Verify nonce uniqueness across all signing operations

**Deployment Considerations:**

- Breaking change to serialization format (requires migration)
- Existing saved states must be invalidated or migrated with fresh nonces
- Documentation must warn against using `Signer` trait directly without proper nonce management
- Consider deprecating direct `Signer` usage in favor of state machine

### Proof of Concept

**Attack Algorithm:**

1. **Setup Phase:**
   - Initialize WSTS signer with DKG
   - Generate nonces via `gen_nonces()`
   
2. **First Signature:**
   - Sign message M1, obtain signature share `z1`
   - Record public nonce commitments and binding value `ρ1`
   - Call `save()` to persist state (including used nonce)

3. **Second Signature (with loaded state):**
   - Call `load()` to restore saved state (with same nonce)
   - Sign different message M2, obtain signature share `z2`
   - Record binding value `ρ2` for M2

4. **Private Key Extraction:**
   - Compute: `e = (z1 - z2) / (ρ1 - ρ2)` (nonce component)
   - Substitute back: `d = z1 - e*ρ1 - c1*x*λ`
   - Solve for private key `x` using known values

**Concrete Steps:**

```
# Pseudocode for exploitation

# Step 1: Initial setup
signer = Signer::new(params)
signer.gen_nonces(&secret_key, &mut rng)

# Step 2: First signing operation
sig_share_1 = signer.sign(message_1, signers, key_ids, nonces)
z1 = sig_share_1.z_i
rho1 = compute::binding(signer_id, nonces, message_1)
c1 = compute::challenge(group_key, aggregate_nonce, message_1)

# Step 3: Save state with used nonce
saved_state = signer.save()
# At this point, saved_state contains the used nonce

# Step 4: Load saved state (simulating rollback or restore)
signer_restored = Signer::load(&saved_state)

# Step 5: Sign different message with SAME nonce
sig_share_2 = signer_restored.sign(message_2, signers, key_ids, nonces)
z2 = sig_share_2.z_i
rho2 = compute::binding(signer_id, nonces, message_2)
c2 = compute::challenge(group_key, aggregate_nonce, message_2)

# Step 6: Extract private key (if rho1 != rho2)
if rho1 != rho2:
    e = (z1 - z2) / (rho1 - rho2)  # Extract nonce component
    # Now solve for private key x using either equation
    # z1 = d + e*rho1 + c1*x*lambda
    # x = (z1 - d - e*rho1) / (c1*lambda)
```

**Expected vs Actual Behavior:**

- **Expected:** System should detect nonce reuse and reject the second signing operation
- **Actual:** System allows signing with reused nonce, enabling private key extraction

**Reproduction Instructions:**

1. Run DKG with test signers
2. Generate nonces and sign a test message
3. Save signer state immediately after signing
4. Load the saved state into a new signer instance
5. Attempt to sign a different message
6. Verify that both signatures use the same nonce by checking public nonce commitments
7. Apply mathematical extraction as shown above to recover private key

### Citations

**File:** src/traits.rs (L15-24)
```rust
#[derive(Clone, Deserialize, Serialize, PartialEq)]
/// The saved state required to reconstruct a party
pub struct PartyState {
    /// The party's private polynomial
    pub polynomial: Option<Polynomial<Scalar>>,
    /// The key IDS and associate private keys for this party
    pub private_keys: Vec<(u32, Scalar)>,
    /// The nonce being used by this party
    pub nonce: Nonce,
}
```

**File:** src/v1.rs (L67-84)
```rust
    /// Load a party from `state`
    pub fn load(id: u32, n: u32, t: u32, group_key: &Point, state: &traits::PartyState) -> Self {
        assert_eq!(state.private_keys.len(), 1);
        assert_eq!(state.private_keys[0].0, id);

        let private_key = state.private_keys[0].1;

        Self {
            id,
            num_keys: n,
            threshold: t,
            f: state.polynomial.clone(),
            public_key: private_key * G,
            private_key,
            group_key: *group_key,
            nonce: state.nonce.clone(),
        }
    }
```

**File:** src/v1.rs (L86-93)
```rust
    /// Save the state required to reconstruct the party
    pub fn save(&self) -> traits::PartyState {
        traits::PartyState {
            private_keys: vec![(self.id, self.private_key)],
            polynomial: self.f.clone(),
            nonce: self.nonce.clone(),
        }
    }
```

**File:** src/v1.rs (L216-229)
```rust
    /// Sign `msg` with this party's share of the group private key, using the set of `signers` and corresponding `nonces`
    pub fn sign(&self, msg: &[u8], signers: &[u32], nonces: &[PublicNonce]) -> SignatureShare {
        let (_, aggregate_nonce) = compute::intermediate(msg, signers, nonces);
        let mut z = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
        z += compute::challenge(&self.group_key, &aggregate_nonce, msg)
            * &self.private_key
            * compute::lambda(self.id, signers);

        SignatureShare {
            id: self.id,
            z_i: z,
            key_ids: vec![self.id],
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L385-414)
```rust
    /// Save the state required to reconstruct the coordinator
    pub fn save(&self) -> SavedState {
        SavedState {
            dkg_id: self.dkg_id,
            sign_id: self.sign_id,
            sign_iter_id: self.sign_iter_id,
            threshold: self.threshold,
            dkg_threshold: self.dkg_threshold,
            total_signers: self.total_signers,
            total_keys: self.total_keys,
            signer: self.signer.save(),
            signer_id: self.signer_id,
            state: self.state.clone(),
            commitments: self.commitments.clone(),
            decrypted_shares: self.decrypted_shares.clone(),
            decryption_keys: self.decryption_keys.clone(),
            invalid_private_shares: self.invalid_private_shares.clone(),
            public_nonces: self.public_nonces.clone(),
            network_private_key: self.network_private_key,
            public_keys: self.public_keys.clone(),
            dkg_public_shares: self.dkg_public_shares.clone(),
            dkg_private_shares: self.dkg_private_shares.clone(),
            dkg_private_begin_msg: self.dkg_private_begin_msg.clone(),
            dkg_end_begin_msg: self.dkg_end_begin_msg.clone(),
            verify_packet_sigs: self.verify_packet_sigs,
            coordinator_public_key: self.coordinator_public_key,
            kex_private_key: self.kex_private_key,
            kex_public_keys: self.kex_public_keys.clone(),
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L757-842)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };

            self.signer.gen_nonces(&self.network_private_key, rng);

            let response = SignatureShareResponse {
                dkg_id: sign_request.dkg_id,
                sign_id: sign_request.sign_id,
                sign_iter_id: sign_request.sign_iter_id,
                signer_id: self.signer_id,
                signature_shares,
            };
            info!(
                signer_id = %self.signer_id,
                dkg_id = %sign_request.dkg_id,
                sign_id = %sign_request.sign_id,
                sign_iter_id = %sign_request.sign_iter_id,
                "sending SignatureShareResponse"
            );

            Ok(vec![Message::SignatureShareResponse(response)])
        } else {
            debug!(signer_id = %self.signer_id, "signer not included in SignatureShareRequest");
            Ok(Vec::new())
        }
    }
```
