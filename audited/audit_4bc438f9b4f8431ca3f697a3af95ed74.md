### Title
Malicious Coordinator Can Frame Honest Parties via Lagrange Coefficient Mismatch in SignatureShareRequest

### Summary
A malicious coordinator can modify the `key_ids` field in `SignatureShareRequest` messages to cause honest signers to compute signature shares using incorrect Lagrange coefficients. When the coordinator later validates these shares using the original (correct) `key_ids`, the validation fails and honest parties are incorrectly identified via `BadPartySigs` error. This breaks accountability and can lead to denial of service by excluding honest signers from future rounds.

### Finding Description

**Exact Code Locations:**

The vulnerability spans multiple files in the signature share creation and validation flow:

1. **Signer signature share creation** [1](#0-0) 
   - Signers compute `z_i` using `compute::lambda(*key_id, key_ids)` where `key_ids` parameter comes from `SignatureShareRequest`

2. **Lagrange coefficient computation** [2](#0-1) 
   - Lagrange coefficients are computed based on the exact set of `key_ids` provided
   - Different key sets produce different coefficients

3. **SignatureShareRequest creation by coordinator** [3](#0-2) 
   - Coordinator collects `nonce_responses` from `self.public_nonces` and includes them in request

4. **Signer extracts key_ids from request** [4](#0-3) 
   - Signers flatten `key_ids` from the received `nonce_responses` in `SignatureShareRequest`

5. **Insufficient validation at signer** [5](#0-4) 
   - Signers only validate signer IDs are valid and nonces are non-zero
   - No validation that `key_ids` in request match what signers originally sent

6. **Coordinator validation using different key_ids** [6](#0-5) 
   - Coordinator extracts `key_ids` from its own `self.public_nonces` (original, unmodified)

7. **Validation in check_signature_shares** [7](#0-6) 
   - Uses coordinator's `key_ids` parameter to compute expected Lagrange coefficients
   - Mismatch causes `BadPartySigs` error [8](#0-7) 

**Root Cause:**

The root cause is a protocol-level design flaw where:
1. Signers trust the coordinator to accurately relay `key_ids` from all parties' `NonceResponse` messages
2. The coordinator creates and signs `SignatureShareRequest`, giving it control over the `nonce_responses` content
3. Signers compute signature shares using `key_ids` from the request
4. Coordinator validates using `key_ids` from its own internal state
5. There is no cryptographic binding or validation ensuring these two `key_ids` sets are identical

**Why Existing Mitigations Fail:**

- **Message authentication**: The coordinator legitimately signs the `SignatureShareRequest`, so signature verification passes [9](#0-8) 

- **Key ID validation against config**: Only checks that signature share responses contain expected key IDs [10](#0-9) , not that the request contained correct key IDs

- **Nonce validation**: Only validates nonces are valid points, not that accompanying key IDs are correct [11](#0-10) 

### Impact Explanation

**Specific Harm:**

A malicious coordinator can:
1. Frame any honest signer by modifying their `key_ids` in `SignatureShareRequest` (e.g., changing `[1,2,3]` to `[1,2]`)
2. Cause honest signers to compute signature shares with incorrect Lagrange coefficients
3. Trigger `BadPartySigs` errors identifying innocent parties as malicious
4. Systematically exclude all honest signers from signing rounds

**Quantified Impact:**

- **Denial of Service (Critical)**: If a malicious coordinator frames all honest signers (e.g., 7 out of 10 signers in a threshold setup), no valid signatures can be produced. This maps to "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

- **Consensus Failures (Critical)**: If multiple coordinators have different views of which parties are malicious, they will exclude different signers and potentially produce conflicting signatures or fail to reach consensus. This maps to "chain split caused by different nodes processing the same block or transaction and yielding different results."

- **Accountability Breakdown**: Honest parties appear malicious in error logs, breaking forensic analysis and incident response.

**Affected Parties:**
- Honest signers: falsely blamed for bad signatures
- Network operators: unable to produce valid signatures
- Users: transactions cannot be confirmed

**Severity Justification:**
**Critical** - A single malicious coordinator with standard network access can prevent signature generation across the entire network by systematically framing all honest signers. This directly causes "network to shut down or otherwise not confirm new valid transactions for multiple blocks" per the scope definition.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Attacker must control a coordinator node
- No cryptographic secrets needed beyond coordinator's legitimate signing key
- Standard network access to communicate with signers

**Attack Complexity:**
Low - The attack requires only:
1. Collecting legitimate `NonceResponse` messages from signers
2. Modifying the `key_ids` field in one or more `NonceResponse` entries
3. Creating a `SignatureShareRequest` with modified `nonce_responses`
4. Signing and sending the malicious request

**Economic Feasibility:**
Highly feasible - requires no special resources beyond running a coordinator node. In production deployments, coordinators are typically required infrastructure, so the attacker position is realistic.

**Detection Risk:**
Low to Medium:
- Attack leaves no cryptographic evidence (coordinator legitimately signs the message)
- Honest signers cannot detect the modification without out-of-band validation
- Error logs show honest parties as malicious, potentially obscuring the real attacker
- Only detectable through careful comparison of sent vs. received `key_ids` if signers log extensively

**Estimated Probability:**
High (>80%) if deployed with malicious coordinator. The attack has no cryptographic requirements and exploits a fundamental protocol design issue.

### Recommendation

**Primary Fix - Add Cryptographic Binding:**

Modify signers to include a hash or signature of their `NonceResponse` in the signature share response, allowing the coordinator (or other signers in broadcast scenarios) to verify consistency:

1. When creating `NonceResponse`, signer computes and stores `nonce_response_hash = Hash(signer_id || key_ids || nonces)`

2. Include this hash in `SignatureShareResponse` structure

3. Coordinator validates that each `SignatureShareResponse.nonce_response_hash` matches the hash of the corresponding entry in the `SignatureShareRequest.nonce_responses` that was sent

4. Reject signature shares where hashes don't match

**Alternative Mitigation - Signer-Side Validation:**

Have signers store their sent `NonceResponse` and validate the received `SignatureShareRequest` contains matching data for their signer ID:

1. After sending `NonceResponse`, store it in signer state
2. When receiving `SignatureShareRequest`, locate own `NonceResponse` in the request
3. Validate `key_ids` and `nonces` match what was originally sent
4. Reject the request if mismatch detected

**Testing Recommendations:**

1. Unit test: Modify `key_ids` in `SignatureShareRequest` and verify signers detect the modification
2. Integration test: Run full signing round with malicious coordinator that modifies `key_ids`
3. Negative test: Verify legitimate requests continue to work

**Deployment Considerations:**

- Requires protocol version bump due to signature share format change
- Backward compatibility: Old signers won't validate hashes, but new signers can validate when communicating with each other
- Consider adding a protocol version field to negotiate validation requirements

### Proof of Concept

**Exploitation Algorithm:**

```
1. Setup:
   - Honest Party A controls key_ids = [1, 2, 3]
   - Honest Party B controls key_ids = [4, 5]
   - Threshold = 5 (requires all keys)
   - Attacker controls coordinator

2. Normal NonceResponse Collection:
   - Party A sends NonceResponse{signer_id: 0, key_ids: [1,2,3], nonces: [D_0, E_0]}
   - Party B sends NonceResponse{signer_id: 1, key_ids: [4,5], nonces: [D_1, E_1]}
   - Coordinator stores both in self.public_nonces

3. Attack - Malicious SignatureShareRequest:
   - Coordinator creates modified nonce_responses:
     * Modified: NonceResponse{signer_id: 0, key_ids: [1,2], nonces: [D_0, E_0]}  // Missing key 3!
     * Unchanged: NonceResponse{signer_id: 1, key_ids: [4,5], nonces: [D_1, E_1]}
   - Creates SignatureShareRequest with modified nonce_responses
   - Signs and broadcasts request

4. Party A Computes Signature Share:
   - Extracts key_ids = [1, 2, 4, 5] from modified request (missing 3)
   - Iterates over self.key_ids = [1, 2, 3]
   - Computes z_A = r + c * (priv[1]*λ(1,[1,2,4,5]) + priv[2]*λ(2,[1,2,4,5]) + priv[3]*λ(3,[1,2,4,5]))
   - Note: λ(3,[1,2,4,5]) is computed with key 3 not in the interpolation set
   - Returns SignatureShare{id: 0, z_i: z_A, key_ids: [1,2,3]}

5. Party B Computes Normally:
   - Uses key_ids = [1, 2, 4, 5]
   - Computes z_B correctly for this set

6. Coordinator Validation:
   - Extracts key_ids = [1, 2, 3, 4, 5] from self.public_nonces (original, unmodified)
   - Calls sign_with_tweak, verification fails
   - Calls check_signature_shares with key_ids = [1, 2, 3, 4, 5]
   - For Party A: computes expected_cx = sum over [1,2,3] of (λ(k,[1,2,3,4,5]) * c * pub[k])
   - Lagrange coefficients differ:
     * λ(1,[1,2,4,5]) ≠ λ(1,[1,2,3,4,5])
     * λ(2,[1,2,4,5]) ≠ λ(2,[1,2,3,4,5])
     * λ(3,[1,2,4,5]) ≠ λ(3,[1,2,3,4,5])
   - Validation check fails: z_A * G ≠ expected
   - Returns AggregatorError::BadPartySigs([0])

7. Result:
   - Honest Party A (signer_id: 0) incorrectly identified as malicious
   - Coordinator can repeat for all honest parties
   - Network cannot produce valid signatures
```

**Expected vs Actual Behavior:**

- Expected: Honest signers' signature shares validate correctly
- Actual: Honest signers' signature shares fail validation due to Lagrange coefficient mismatch
- Root cause: Different `key_ids` sets used for signing vs. validation

**Reproduction Instructions:**

1. Set up 2 signers in test environment with key distribution [1,2,3] and [4,5]
2. Modify coordinator code to alter Party 0's `key_ids` from `[1,2,3]` to `[1,2]` in `SignatureShareRequest`
3. Run signing round
4. Observe `BadPartySigs([0])` error despite Party 0 being honest
5. Verify Party 0's signature share fails check_signature_shares validation due to Lagrange coefficient mismatch

### Citations

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L393-407)
```rust
            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
```

**File:** src/compute.rs (L69-80)
```rust
/// Compute the Lagrange interpolation value
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/coordinator/frost.rs (L571-578)
```rust
        let nonce_responses = (0..self.config.num_signers)
            .map(|i| self.public_nonces[&i].clone())
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
```

**File:** src/state_machine/coordinator/frost.rs (L582-586)
```rust
        let sig_share_request_msg = Packet {
            sig: sig_share_request
                .sign(&self.config.message_private_key)
                .expect(""),
            msg: Message::SignatureShareRequest(sig_share_request),
```

**File:** src/state_machine/coordinator/frost.rs (L631-640)
```rust
            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
```

**File:** src/state_machine/coordinator/frost.rs (L675-678)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L762-795)
```rust
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/errors.rs (L50-52)
```rust
    #[error("bad party sigs from {0:?}")]
    /// The party signatures which failed to verify
    BadPartySigs(Vec<u32>),
```
