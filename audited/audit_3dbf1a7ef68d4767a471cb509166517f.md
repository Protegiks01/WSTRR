### Title
DKG State Rollback Vulnerability Due to Missing Monotonicity Validation

### Summary
The `dkg_begin()` function accepts DKG round IDs without validating that the new `dkg_id` is greater than the current one, allowing state rollback to previous DKG rounds. This enables an attacker with coordinator access to force signers to revert to old DKG rounds, potentially re-establishing previously compromised group keys or causing state confusion across signers.

### Finding Description

**Exact Code Location:**
The vulnerability exists in `src/state_machine/signer/mod.rs` in the `dkg_begin()` function at line 849, where `reset()` is called without validation. [1](#0-0) 

The `reset()` function at line 417 simply overwrites the current `dkg_id` with the provided value without any validation: [2](#0-1) 

**Root Cause:**
The `dkg_begin()` function receives a `DkgBegin` message containing a `dkg_id` field and immediately calls `reset()` with this value, unconditionally setting `self.dkg_id = dkg_id` and clearing all DKG state (commitments, shares, keys). There is no check that the new `dkg_id` is greater than `self.dkg_id`, violating the state machine invariant that "Round IDs must match expected values."

**Why Existing Mitigations Fail:**
1. **Packet signature verification**: While the `process()` function verifies packet signatures when `verify_packet_sigs` is enabled, this only authenticates that the message came from the coordinator, not that the `dkg_id` is valid. [3](#0-2) 

2. **Coordinator-side validation**: The coordinator implementations (both FROST and FIRE) only check for equality with the current `dkg_id` to prevent duplicate processing, but do not prevent rollback to lower values: [4](#0-3) [5](#0-4) 

3. **No per-message dkg_id validation**: Other DKG message handlers (e.g., `dkg_public_share()`) do not validate that incoming messages match the current `dkg_id`: [6](#0-5) 

### Impact Explanation

**Specific Harm:**
1. **State Confusion and Chain Split**: If a rollback message is sent to only some signers, different signers will have different `dkg_id` values and potentially different group keys, causing inability to reach consensus on signatures. This maps to **HIGH** severity: "Any unintended chain split or network partition."

2. **Compromised Key Re-establishment**: If an attacker compromised threshold signers in an old DKG round (e.g., round 50) but not in the current round (e.g., round 100), they can force rollback to round 50 and replay saved messages to re-establish the old group key. With control of threshold signers in the old round, the attacker gains full signing authority. This maps to **CRITICAL** severity: "Any causing the direct loss of funds" through unauthorized signatures.

3. **Invalid Transaction Confirmation**: Using a rolled-back compromised key, an attacker can create valid signatures for invalid transactions. This maps to **CRITICAL** severity: "Any confirmation of an invalid transaction."

**Quantified Impact:**
- With threshold t=3 and n=5 signers, if an attacker controls 3 signers' keys from round 50 but only 1 from round 100, rollback to round 50 gives complete signing control
- All signers accepting the rollback message will lose their current DKG state and cannot participate in the legitimate round 100 signing operations
- Partial rollback (some signers accept, others reject) causes permanent state divergence requiring manual intervention

**Who is Affected:**
All signers and any system relying on WSTS signatures (e.g., Stacks blockchain) are affected.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. **Coordinator Compromise (Primary Path)**: If `verify_packet_sigs` is enabled (recommended configuration), the attacker must compromise the coordinator's private key to sign a valid `DkgBegin` message with a lower `dkg_id`.

2. **Network Access (Secondary Path)**: If `verify_packet_sigs` is disabled, any network attacker can send malicious `DkgBegin` messages directly to signers.

3. **Message Replay Data**: For full exploitation, the attacker needs saved messages from the target old DKG round to replay the complete protocol.

**Attack Complexity:**
- **Low Complexity**: Once coordinator access is obtained, the attack is trivial - simply send `DkgBegin{dkg_id: old_value}` to all signers
- **No Cryptographic Breaks**: Does not require breaking secp256k1, SHA-256, or any cryptographic primitives
- **Immediate Effect**: State rollback occurs immediately upon message processing

**Economic Feasibility:**
- Compromising a coordinator is a significant but realistic threat (server vulnerabilities, insider threat, key theft)
- No ongoing costs once initial access is gained
- High reward if old DKG rounds had weaker security

**Detection Risk:**
- Low detection risk if done during legitimate DKG operations
- May be noticed if signers are monitoring their `dkg_id` values, but no automated detection exists
- Logs would show the `dkg_id` decrease, but might be dismissed as coordinator restart

**Estimated Probability:**
- **If coordinator is secure and verify_packet_sigs enabled**: Low (requires coordinator compromise)
- **If verify_packet_sigs disabled**: High (any network attacker)
- **Overall Assessment**: Medium to High given the severe impact and relatively simple exploit path if prerequisites are met

### Recommendation

**Primary Fix: Add Monotonicity Validation**

Add validation in the `dkg_begin()` function to reject `dkg_id` values that are not strictly greater than the current value (unless current is 0 for initial DKG):

```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Validate monotonicity: new dkg_id must be greater than current
    // Exception: allow first DKG when self.dkg_id == 0
    if self.dkg_id != 0 && dkg_begin.dkg_id <= self.dkg_id {
        warn!(
            signer_id = %self.signer_id,
            current_dkg_id = %self.dkg_id,
            received_dkg_id = %dkg_begin.dkg_id,
            "Rejecting DkgBegin with non-increasing dkg_id"
        );
        return Err(Error::BadStateChange(format!(
            "DKG ID must increase: current={}, received={}",
            self.dkg_id, dkg_begin.dkg_id
        )));
    }
    
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Secondary Fix: Add dkg_id Validation to Message Handlers**

Add validation to other DKG message handlers to reject messages with mismatched `dkg_id`:

```rust
fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Validate dkg_id matches current round
    if dkg_public_shares.dkg_id != self.dkg_id {
        warn!(
            "Received DkgPublicShares with mismatched dkg_id: expected {}, got {}",
            self.dkg_id, dkg_public_shares.dkg_id
        );
        return Ok(vec![]);
    }
    // ... rest of function
}
```

Apply similar validation to `dkg_private_shares()`, `dkg_private_begin()`, and `dkg_end_begin()`.

**Alternative Mitigation:**

Implement a "high water mark" that tracks the maximum `dkg_id` ever seen and never allow processing messages with lower values, even across resets.

**Testing Recommendations:**
1. Add unit test that attempts to send `DkgBegin` with decreasing `dkg_id` and verifies rejection
2. Add integration test that verifies state remains unchanged after rejected rollback attempt
3. Test edge cases: dkg_id=0 (initial), dkg_id overflow, concurrent DKG attempts
4. Add monitoring/alerting for `dkg_id` decreases in production

**Deployment Considerations:**
- This is a breaking change that will reject previously-accepted messages
- Coordinate deployment across all signers simultaneously
- Consider versioning the protocol to handle mixed deployments
- Ensure `verify_packet_sigs` is enabled in all production configurations

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: System completes DKG round with `dkg_id = 100`, establishing group key K₁₀₀
   
2. **Attacker Action**: Compromised coordinator sends malicious message:
   ```
   DkgBegin { dkg_id: 50 }
   ```

3. **Signer Processing**: Each signer receives the message and processes it:
   - `process()` verifies signature (passes if coordinator key is compromised)
   - Routes to `dkg_begin(&DkgBegin{dkg_id: 50}, rng)`
   - Calls `reset(50, rng)` without validation
   - Sets `self.dkg_id = 50`
   - Clears all state: `commitments`, `decrypted_shares`, `public_nonces`, etc.
   - Moves to `State::DkgPublicDistribute`

4. **State Rollback Result**:
   - All signers now have `dkg_id = 50` instead of 100
   - Current group key K₁₀₀ is lost
   - Signers are waiting for DKG round 50 messages

5. **Message Replay** (if attacker saved round 50 messages):
   - Attacker replays `DkgPublicShares` from original round 50
   - Replays `DkgPrivateShares` from original round 50
   - Group key K₅₀ is re-established

**Expected vs Actual Behavior:**

**Expected**: Signer rejects `DkgBegin{dkg_id: 50}` with error:
```
Error: DKG ID must increase: current=100, received=50
```

**Actual**: Signer accepts the message and resets to `dkg_id = 50`:
```
INFO signer_id=1 dkg_id=50 "sending DkgPublicShares"
```

**Reproduction Instructions:**

```rust
#[test]
fn test_dkg_id_rollback_vulnerability() {
    let mut rng = OsRng;
    let mut signer = create_test_signer(&mut rng);
    
    // Complete DKG round 100
    let dkg_begin_100 = DkgBegin { dkg_id: 100 };
    signer.dkg_begin(&dkg_begin_100, &mut rng).unwrap();
    assert_eq!(signer.dkg_id, 100);
    
    // Attempt rollback to round 50
    let dkg_begin_50 = DkgBegin { dkg_id: 50 };
    let result = signer.dkg_begin(&dkg_begin_50, &mut rng);
    
    // VULNERABILITY: This should fail but currently succeeds
    assert!(result.is_err()); // This assertion will FAIL
    assert_eq!(signer.dkg_id, 50); // This shows the rollback occurred
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L463-472)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/frost.rs (L76-82)
```rust
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L231-237)
```rust
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```
