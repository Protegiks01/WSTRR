### Title
Missing Validation of KEX Public Keys in DKG Allows Predictable Shared Secrets

### Summary
The DKG phase does not validate key exchange (KEX) public keys received in `DkgPublicShares` messages, allowing malicious signers to force the use of invalid elliptic curve points (point-at-infinity, low-order points). This enables attackers to break the confidentiality of encrypted private polynomial shares, potentially leading to group private key reconstruction and signature forgery.

### Finding Description

**Exact Code Location:**
- `src/state_machine/signer/mod.rs` line 1020: KEX public key stored without validation [1](#0-0) 

- `src/state_machine/signer/mod.rs` line 941: Unvalidated key used in DH exchange [2](#0-1) 

- `src/util.rs` lines 48-52: DH exchange with no point validation [3](#0-2) 

- `src/state_machine/coordinator/frost.rs` lines 317-318: Coordinator stores without validation [4](#0-3) 

**Root Cause:**
When signers process `DkgPublicShares` messages containing KEX public keys for encrypting private polynomial shares, neither signers nor coordinators validate whether the received `kex_public_key` is a valid elliptic curve point. Unlike signing nonces which are validated via `PublicNonce::is_valid()` (checking for identity point and generator G), KEX public keys have no equivalent validation. [5](#0-4) 

**Why Existing Mitigations Fail:**
- Test coverage exists for invalid nonces in signing (lines 1588-1632 of coordinator/mod.rs) but NOT for invalid KEX keys in DKG [6](#0-5) 

- Unit tests in `src/util.rs` lines 130-143 only test valid DH exchange scenarios [7](#0-6) 

- While a test in fire.rs uses `Point::new()` as kex_public_key, it's testing polynomial validation, not KEX key validation [8](#0-7) 

### Impact Explanation

**Specific Harm:**
When a malicious signer broadcasts `kex_public_key = Point::identity()` in their `DkgPublicShares`:
1. All honest signers compute `shared_secret = their_private_key * Point::identity() = Point::identity()`
2. The shared secret becomes a known constant (compressed representation of identity point)
3. Network eavesdroppers can decrypt ALL private polynomial shares encrypted for the malicious signer
4. With threshold number of shares decrypted, attackers reconstruct the group secret polynomial
5. Group private key is compromised, enabling signature forgery

**Quantified Impact:**
- In a 5-of-7 threshold setup, if 1 malicious signer collects shares from 5+ honest parties, complete key compromise occurs
- Every encrypted share transmission becomes readable by passive network observers
- All future signatures can be forged, invalidating transaction authenticity

**Affected Parties:**
All participants in any DKG round containing a malicious signer, and downstream systems relying on signature validity.

**Severity Justification:**
**CRITICAL** - Maps to "confirmation of an invalid transaction" and "direct loss of funds" from protocol scope. Compromised group keys enable transaction forgery in dependent blockchain systems.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Attacker must be a legitimate signer participating in DKG setup
- Ability to send modified `DkgPublicShares` messages with invalid `kex_public_key`
- Network position to observe encrypted share transmissions (or be the intended recipient)

**Attack Complexity:**
LOW - Attack requires only:
1. Modify single field: `kex_public_key: Point::identity()` in outgoing message
2. No cryptographic breaks required
3. No timing constraints or race conditions

**Economic Feasibility:**
HIGH - If attacker controls just 1 signer slot in initial DKG:
- Zero additional resources needed beyond signer participation
- Passive eavesdropping captures all shares encrypted for attacker
- With sufficient key_ids controlled, threshold reached trivially

**Detection Risk:**
LOW - Invalid KEX keys not validated anywhere; appears as normal DKG participation until key compromise is exploited for forged signatures.

**Estimated Probability:**
HIGH if any signer is compromised during DKG; GUARANTEED if attacker controls threshold number of key_ids.

### Recommendation

**Proposed Code Changes:**

Add validation in `src/state_machine/signer/mod.rs` before storing KEX public key:
```rust
// After line 1016, before line 1018:
// Validate kex_public_key is not identity, generator, or low-order
if dkg_public_shares.kex_public_key == Point::identity() 
   || dkg_public_shares.kex_public_key == G {
    warn!(%signer_id, "Invalid KEX public key (identity or generator)");
    return Ok(vec![]);
}
```

**Alternative Mitigations:**
1. Add similar validation in coordinator `gather_public_shares` (frost.rs line 317, fire.rs line 505)
2. Implement `validate_kex_public_key()` helper similar to `PublicNonce::is_valid()`
3. Extend validation to check for all low-order points on secp256k1

**Testing Recommendations:**
1. Add unit test in `src/util.rs` testing DH exchange with `Point::identity()` - expect failure/detection
2. Add integration test sending `DkgPublicShares` with invalid `kex_public_key` - expect rejection
3. Test with low-order points beyond just identity and generator
4. Verify encrypted shares cannot be decrypted when KEX key validation triggers

**Deployment Considerations:**
- Breaking change: existing deployments must coordinate upgrade
- All nodes must upgrade before next DKG round
- Consider migrating existing keys if any DKG rounds occurred with unvalidated KEX keys

### Proof of Concept

**Exploitation Steps:**

1. **Malicious Signer Setup:** Compromise or control signer with ID `m` in DKG with threshold `t`

2. **Send Invalid KEX Key:**
```rust
let malicious_shares = DkgPublicShares {
    dkg_id: current_dkg_id,
    signer_id: m,
    comms: legitimate_polynomial_commitments,
    kex_public_key: Point::identity(), // Invalid!
};
broadcast(malicious_shares);
```

3. **Honest Signers Encrypt Shares:**
Each honest signer `i` computes:
```rust
let shared_secret = make_shared_secret(&honest_private_key_i, &Point::identity());
// Result: shared_secret = derive_from(Point::identity())
// This is a CONSTANT known to attacker
```

4. **Attacker Decrypts All Shares:**
```rust
// Known constant from Point::identity().compress()
let known_secret = make_shared_secret_from_key(&Point::identity());
for intercepted_ciphertext in network_traffic {
    let share = decrypt(&known_secret, &intercepted_ciphertext);
    polynomial_shares.push(share);
}
```

5. **Reconstruct Group Secret:**
With `t` shares from different parties:
```rust
// Lagrange interpolation over collected shares
let group_private_key = reconstruct_secret(polynomial_shares);
// Attacker now has full signing capability
```

**Expected vs Actual Behavior:**
- **Expected:** Invalid KEX public keys rejected, DKG fails safely
- **Actual:** Invalid keys accepted, predictable encryption used, shares compromised

**Reproduction Instructions:**
1. Set up WSTS DKG with 3 signers, threshold 2
2. Modify signer 0 to send `kex_public_key: Point::identity()` in `DkgPublicShares`
3. Observe encrypted shares sent to signer 0 use constant shared_secret
4. Decrypt shares using `make_shared_secret_from_key(&Point::identity())`
5. Verify polynomial shares are readable without signer 0's private KEX key

### Citations

**File:** src/state_machine/signer/mod.rs (L936-942)
```rust
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L130-143)
```rust
    fn test_shared_secret() {
        let mut rng = create_rng();

        let x = Scalar::random(&mut rng);
        let y = Scalar::random(&mut rng);

        let X = Point::from(x);
        let Y = Point::from(y);

        let xy = make_shared_secret(&x, &Y);
        let yx = make_shared_secret(&y, &X);

        assert_eq!(xy, yx);
    }
```

**File:** src/state_machine/coordinator/frost.rs (L317-318)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/state_machine/coordinator/mod.rs (L1594-1596)
```rust
            for nonce in &mut nonce_response.nonces {
                nonce.D = Point::new();
                nonce.E = Point::new();
```

**File:** src/state_machine/coordinator/fire.rs (L2646-2646)
```rust
                                kex_public_key: Point::new(),
```
