Audit Report

## Title
Duplicate Key IDs in NonceResponse Bypass Validation and Corrupt Lagrange Coefficient Computation

## Summary
A malicious signer can send NonceResponse messages with duplicate key_ids that pass coordinator validation but cause incorrect Lagrange coefficient computation during signature aggregation. The validation logic converts the key_ids vector to a HashSet before comparison, masking duplicates, while the original vector with duplicates is stored and later used for cryptographic operations. This results in signature verification failure and prevents successful signing rounds.

## Finding Description

The vulnerability exists in both FROST and FIRE coordinator implementations where NonceResponse validation converts the `key_ids` vector to a HashSet before comparing against the configured signer_key_ids. [1](#0-0) [2](#0-1) 

The NonceResponse struct stores key_ids as a Vec<u32>, not a HashSet. [3](#0-2) 

**Root Cause**: When a malicious signer sends key_ids `[1, 1, 2]` and the configuration expects `{1, 2}`, the validation passes because `HashSet::from([1, 1, 2])` equals `{1, 2}`. However, the original NonceResponse with duplicate key_ids is stored unchanged. [4](#0-3) 

**Propagation**: When collecting key_ids for signature aggregation, the coordinator uses flat_map on the stored NonceResponses, preserving all duplicates from the original vectors. [5](#0-4) 

**Cryptographic Impact**: These duplicate key_ids are passed to the Lagrange coefficient computation function. [6](#0-5)  While the `if i != *j` check prevents division by zero, duplicate values cause the coefficient to be computed incorrectly. For example, `lambda(2, [1, 1, 2])` multiplies by `(1/(1-2))` twice, yielding 1, whereas the correct `lambda(2, [1, 2])` yields -1.

The aggregator's check_signature_shares function uses these corrupted key_ids for verification. [7](#0-6)  Specifically, it computes Lagrange coefficients using the duplicate-containing key_ids list at line 403.

**Complete Attack Flow**:
1. Malicious signer sends NonceResponse with duplicate key_ids [1, 1, 2]
2. Coordinator validates: {1, 1, 2} → {1, 2} matches config ✓
3. Original NonceResponse with [1, 1, 2] is stored
4. Coordinator sends SignatureShareRequest containing all NonceResponses
5. All signers extract key_ids using flat_map, getting duplicates. [8](#0-7) 
6. Signers compute shares with incorrect Lagrange coefficients. [9](#0-8) 
7. Coordinator aggregates and verifies signature - fails due to incorrect interpolation

**Why No Existing Validation Catches This**: The coordinator validates that key_ids match the configuration but performs this check after HashSet conversion. There is no validation for uniqueness within the key_ids vector, nor any check that the number of key_ids matches the number of nonces.

## Impact Explanation

This vulnerability enables a single malicious signer to execute a denial-of-service attack against the WSTS signing protocol. When duplicate key_ids corrupt the Lagrange coefficient computation, the mathematical foundation of threshold signature reconstruction breaks. The Lagrange interpolation formula requires `sum(lambda_i * x_i) = x` where x is the aggregate secret. Incorrect lambda values violate this equation, causing signature verification to fail consistently.

**Quantified Impact**: Any signing round where a single signer includes duplicate key_ids will fail to produce a valid signature. In a system with threshold T out of N signers, one malicious signer can block all signing operations indefinitely.

**Severity Justification**: This maps to **Low** severity under the scope definition: "Any remotely-exploitable denial of service in a node." The attack prevents signing operations from succeeding but does not cause fund loss, chain splits, or acceptance of invalid transactions. The DoS is remotely exploitable by any protocol participant.

## Likelihood Explanation

**Attacker Requirements**: The attacker must be a legitimate signer in the WSTS protocol with the ability to send network messages to the coordinator. They must modify their client code to construct NonceResponse messages with duplicate key_ids.

**Attack Complexity**: Low. The attacker only needs to craft a NonceResponse with duplicate key_ids that, when deduplicated, match their configured key set. No cryptographic operations, timing attacks, or complex state manipulation is required.

**Economic Feasibility**: Trivial. The attack requires no special resources beyond being a protocol participant.

**Detection**: The attack manifests as signature verification failure, but the coordinator's check_signature_shares diagnostic function uses the same corrupted key_ids list, potentially misidentifying which parties provided bad signatures.

**Probability**: High if any signer is malicious or misconfigured. The vulnerability is deterministic and requires no special conditions beyond a single malformed NonceResponse.

## Recommendation

Add validation to ensure key_ids uniqueness in NonceResponse messages before storing them. The fix should be applied in both coordinators:

```rust
// After line 517 in frost.rs and line 885 in fire.rs
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response contains duplicate key_ids");
    return Ok(());
}
```

Additionally, validate that the number of nonces matches the number of unique key_ids:

```rust
if nonce_response.nonces.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce count doesn't match key_id count");
    return Ok(());
}
```

## Proof of Concept

The vulnerability can be demonstrated by constructing a NonceResponse with duplicate key_ids and tracing its path through the coordinator:

1. Create a NonceResponse with key_ids = [1, 1, 2] where the signer's configured keys are {1, 2}
2. Submit to coordinator's gather_nonces function
3. Observe validation passes (HashSet comparison succeeds)
4. Observe stored NonceResponse retains duplicates
5. Trigger signature aggregation
6. Extract key_ids via flat_map - duplicates preserved
7. Compute lambda(2, [1, 1, 2]) - returns 1 instead of correct -1
8. Signature verification fails

The code path is deterministic and does not require runtime execution to verify. The mathematical error in Lagrange coefficient computation with duplicates is provable: for `lambda(i, L)` where L contains duplicates of j ≠ i, the product multiplies `j/(j-i)` multiple times instead of once, producing an incorrect coefficient that breaks polynomial interpolation.

### Citations

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L542-543)
```rust
            self.public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/frost.rs (L675-678)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/net.rs (L309-327)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}

```

**File:** src/compute.rs (L69-80)
```rust
/// Compute the Lagrange interpolation value
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L347-417)
```rust
    pub fn check_signature_shares(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
        tweak: Option<Scalar>,
    ) -> AggregatorError {
        if nonces.len() != sig_shares.len() {
            return AggregatorError::BadNonceLen(nonces.len(), sig_shares.len());
        }

        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (Rs, R) = compute::intermediate(msg, &party_ids, nonces);
        let mut bad_party_keys = Vec::new();
        let mut bad_party_sigs = Vec::new();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                compute::tweaked_public_key_from_tweak(&aggregate_public_key, t)
            } else {
                aggregate_public_key
            }
        } else {
            aggregate_public_key
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r_sign = Scalar::one();
        let mut cx_sign = Scalar::one();
        if let Some(t) = tweak {
            if !R.has_even_y() {
                r_sign = -Scalar::one();
            }
            if t != Scalar::zero() {
                if !tweaked_public_key.has_even_y() ^ !aggregate_public_key.has_even_y() {
                    cx_sign = -Scalar::one();
                }
            } else if !aggregate_public_key.has_even_y() {
                cx_sign = -Scalar::one();
            }
        }

        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
        } else {
            AggregatorError::BadGroupSig
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```
