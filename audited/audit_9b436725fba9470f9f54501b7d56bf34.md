### Title
DKG Round ID Not Validated in Signer's dkg_public_share() Enabling Replay/Framing Attacks

### Summary
The signer's `dkg_public_share()` function fails to validate that incoming `DkgPublicShares` messages have a `dkg_id` matching the current DKG round. This allows attackers to replay legitimately-signed public shares from previous DKG rounds, causing them to be stored and preventing legitimate current-round shares from the same signer (due to first-come-first-served duplicate detection). When the replayed shares inevitably fail ID proof verification, the innocent original sender is blamed for providing bad shares, causing DKG failure.

### Finding Description

**Location:** [1](#0-0) 

The `dkg_public_share()` function accepts and stores `DkgPublicShares` messages without validating that `dkg_public_shares.dkg_id` equals `self.dkg_id`. In contrast, the coordinator implementations properly validate this field: [2](#0-1) [3](#0-2) 

**Root Cause:** The signer validates signer ID, party ID ownership, and duplicate detection, but never checks if the message belongs to the current DKG round. The function stores shares in a BTreeMap keyed only by `signer_id` with first-come-first-served semantics: [4](#0-3) [5](#0-4) 

**Why Existing Mitigations Fail:**

1. **Packet signature verification** validates the sender's identity but not the round ID. The signature computation includes `dkg_id` in the signed data, meaning old messages remain validly signed: [6](#0-5) 

2. **ID proof verification** occurs much later during `dkg_ended()` and validates the polynomial commitment against the current `dkg_id` as context. This will detect the mismatch, but the damage is already done: [7](#0-6) 

The ID proof verification uses the current round's `dkg_id` as context: [8](#0-7) 

When shares from a different round are validated against the wrong context, the Schnorr ID proof fails because the challenge computation includes the context: [9](#0-8) [10](#0-9) 

3. **Application-level verification** is documented as the responsibility of applications, but only covers signature verification, not round ID validation: [11](#0-10) 

### Impact Explanation

**Concrete Harm:**
- **DKG Failure:** The replayed shares fail ID proof verification, causing the signer to report `DkgFailure::BadPublicShares` and aborting the DKG round [12](#0-11) 

- **Framing Attack:** The innocent signer whose old message was replayed is blamed for providing bad shares, potentially leading to their exclusion from future rounds or reputation damage

- **Persistent Denial of Service:** An attacker can repeat this attack for every DKG round by replaying saved messages, preventing the system from ever completing DKG successfully

- **Chain-Level Impact:** In systems like Stacks blockchain that depend on WSTS for threshold signing, inability to complete DKG means inability to generate signatures for transactions, potentially halting block production or transaction confirmation

**Affected Parties:** All honest signers participating in DKG, and any blockchain or system depending on WSTS for distributed key generation.

**Severity Justification:** This maps to **Low severity** under "Any remotely-exploitable denial of service in a node" or potentially **Low severity** under "Any network denial of service impacting more than 10 percent of miners that does not shut down the network" if multiple nodes are affected by coordinated attacks.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Network-level access to inject messages to signers (achievable in most distributed systems)
- Ability to capture legitimate `DkgPublicShares` messages from previous DKG rounds (trivial if attacker participates or observes network traffic)
- Timing advantage to deliver replayed message before legitimate current-round message (feasible with network positioning, packet delays, or DoS on legitimate sender)

**Attack Complexity:** Low. The attacker simply:
1. Saves valid `DkgPublicShares` messages during any successful DKG round
2. During subsequent rounds, replays these messages to victim signers
3. No cryptographic breaks, signature forgery, or private key access required

**Economic Feasibility:** Very low cost. Storage and replay of small messages requires minimal resources.

**Detection Risk:** Low. The attack uses legitimately-signed messages, making it indistinguishable from network delays or message reordering until validation fails.

**Estimated Probability:** High. An attacker with network access can reliably execute this attack with minimal technical sophistication.

### Recommendation

**Primary Fix:** Add `dkg_id` validation at the start of `dkg_public_share()`:

```rust
pub fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Validate dkg_id matches current round
    if dkg_public_shares.dkg_id != self.dkg_id {
        warn!(
            expected_dkg_id = %self.dkg_id,
            received_dkg_id = %dkg_public_shares.dkg_id,
            signer_id = %dkg_public_shares.signer_id,
            "Received DkgPublicShares with mismatched dkg_id"
        );
        return Err(Error::BadDkgId(dkg_public_shares.dkg_id, self.dkg_id));
    }
    
    // ... rest of existing validation
}
```

Note: This requires defining `Error::BadDkgId` similar to the coordinator's error type, or reusing an existing error variant.

**Apply Same Fix to `dkg_private_shares()`:** The same vulnerability likely exists in the private shares handler: [13](#0-12) 

**Testing Recommendations:**
1. Add test case that sends `DkgPublicShares` with `dkg_id = current_dkg_id - 1` and verify rejection
2. Add test case that sends `DkgPublicShares` with `dkg_id = current_dkg_id + 1` and verify rejection
3. Verify legitimate shares with correct `dkg_id` are still accepted
4. Test that the error is properly logged and returned

**Deployment Considerations:** This is a breaking change that will reject previously-accepted messages. Deploy in coordination with all nodes to prevent temporary incompatibilities.

### Proof of Concept

**Exploitation Algorithm:**

1. **Capture Phase (DKG Round N):**
   - Attacker observes network traffic during a successful DKG round N
   - Captures valid `DkgPublicShares` message from victim signer (signer_id=1) with `dkg_id=N`
   - Message is legitimately signed by signer 1

2. **Attack Phase (DKG Round N+1):**
   - DKG round N+1 begins with `dkg_id=N+1`
   - All signers enter `DkgPublicGather` state
   - Attacker replays captured message (with `dkg_id=N`) to target signer (signer_id=2)
   - Target signer's `dkg_public_share()` executes:
     - Validates signer_id=1 exists in config ✓
     - Validates party IDs belong to signer 1 ✓
     - Checks for duplicate: none yet ✓
     - **Missing: dkg_id validation** ✗
     - Stores replayed shares in `dkg_public_shares[1]`
   - Legitimate signer 1 sends real shares for round N+1
   - Target signer receives legitimate shares:
     - Duplicate check finds `dkg_public_shares[1]` already exists
     - Returns early without storing
   - During `dkg_ended()`, target signer validates shares:
     - Calls `check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes())`
     - `self.dkg_id` is N+1, but commitment's ID proof was created with context N
     - `poly_comm.verify(&[N+1])` fails because `ID::verify()` recomputes challenge with wrong context
     - Target signer marks signer 1 as having bad public shares
   - Target signer returns `DkgEnd` with `DkgFailure::BadPublicShares({1})`
   - DKG round fails, signer 1 blamed

**Expected vs Actual Behavior:**
- **Expected:** Replayed message with wrong `dkg_id` should be rejected immediately with error
- **Actual:** Replayed message is accepted, stored, and causes DKG failure with innocent party blamed

**Reproduction Instructions:**
1. Run DKG round with 3 signers
2. Capture `DkgPublicShares` from signer 1
3. Start new DKG round with incremented `dkg_id`
4. Inject captured message to signer 2 before signer 1's legitimate message arrives
5. Observe: DKG fails with signer 1 reported as having bad shares

### Citations

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L593-599)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/signer/mod.rs (L1029-1033)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
```

**File:** src/state_machine/coordinator/fire.rs (L479-483)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
```

**File:** src/state_machine/coordinator/frost.rs (L292-296)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
```

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/schnorr.rs (L47-59)
```rust
    /// Compute the schnorr challenge
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }
```

**File:** src/schnorr.rs (L62-65)
```rust
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```

**File:** USAGE.md (L3-3)
```markdown
Applications which use `WSTS` will typically run both `Signer` and `Coordinator` state machines, in order to be able to handle all parts of the protocol. Because of this, these state machines do not verify packets as they come in; this would lead to duplicate work, and require the state machines to have all keys in their configs, including knowing who is the active coordinator. This is out of scope for the library. Thus applications `must` verify packets before calling `process_message` on them.
```
