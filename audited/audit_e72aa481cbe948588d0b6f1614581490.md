# Audit Report

## Title
Incomplete DKG Private Share Validation Allows Undetected Malicious Signer Denial of Service

## Summary
The `dkg_ended()` function in the signer state machine contains a critical validation flaw that fails to verify all expected party_ids from each signer are present in received private shares. When combined with incomplete error handling for `DkgError::MissingPrivateShares`, this enables a malicious signer to cause persistent DKG failures without being identified or excluded, resulting in indefinite network unavailability.

## Finding Description

The vulnerability exists in the DKG private share validation logic where signers can control multiple key_ids (weighted threshold scheme). The validation at lines 567-582 only checks that shares are non-empty and that each share entry contains all destination key_ids, but fails to verify that the shares vector contains entries for ALL party_ids the sending signer controls. [1](#0-0) 

When a signer controls multiple party_ids (e.g., [10, 11, 12]), the shares structure should contain one entry per party_id: [2](#0-1) 

During share creation, each party_id gets its own entry: [3](#0-2) 

The expected party_ids are tracked in `public_keys.signer_key_ids`: [4](#0-3) 

**Attack Execution:**

1. Malicious signer sends complete public shares (commitments) for all party_ids during DKG public phase
2. During private phase, sends shares for only a subset of party_ids (e.g., only party_id 10, omitting 11 and 12)
3. Validation passes because it only checks destination key_ids within present shares, not the completeness of source party_ids
4. When `compute_secrets()` executes, it detects missing shares and returns `DkgError::MissingPrivateShares`: [5](#0-4) 

5. However, the error handler only processes `DkgError::BadPrivateShares`, leaving `MissingPrivateShares` unhandled: [6](#0-5) 

6. This results in `DkgFailure::BadPrivateShares` with an empty HashMap being returned to the coordinator
7. The coordinator's processing loop cannot identify the malicious signer when the HashMap is empty: [7](#0-6) 

The weighted threshold functionality is confirmed in production code: [8](#0-7) 

## Impact Explanation

This vulnerability enables a **Critical** severity denial-of-service attack that maps directly to "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

**Specific Impact Chain:**
- DKG cannot complete because the malicious signer causes failures without being identified
- Without successful DKG, the distributed signing key cannot be generated
- Without the signing key, threshold signatures required for block production cannot be created
- The blockchain network cannot progress, preventing all transaction confirmations
- The attack is persistent because the malicious signer is never excluded from retry attempts

**Affected Systems:**
- All signers in the WSTS signing group experience repeated DKG failures
- Downstream systems depending on WSTS threshold signatures (e.g., Stacks blockchain) cannot produce blocks
- End users cannot confirm transactions indefinitely

The severity is Critical because a single malicious signer with multiple key_ids can permanently halt network operation with no recovery path, as the system has no mechanism to identify and exclude the attacker.

## Likelihood Explanation

The likelihood of exploitation is **HIGH** with near-certainty of success:

**Attacker Requirements:**
- Control of one signer node participating in DKG (within protocol threat model)
- No cryptographic breaks or special privileges required
- Simply requires sending protocol-compliant messages

**Attack Simplicity:**
1. Generate valid public shares for all controlled party_ids (standard protocol behavior)
2. Send private shares for only a subset of party_ids (trivial omission)
3. Repeat on each DKG retry attempt

**Economic Considerations:**
- Zero incremental cost once admitted to signing group
- Signing group membership may have barriers, but attack itself is free
- No resource expenditure beyond normal message transmission

**Detection Difficulty:**
- Attack manifests as generic "DKG failure" without specific attribution
- Only visible in logs as "Got unexpected dkg_error" requiring manual inspection
- No automated detection or response mechanism exists

**Success Rate:**
- Near 100% for any signer controlling multiple key_ids (weighted threshold scenario)
- Attack succeeds every time until code is patched

## Recommendation

Implement validation to ensure all expected party_ids are present in private shares:

```rust
// In dkg_ended() after line 566, add:
if let Some(shares) = self.dkg_private_shares.get(signer_id) {
    // Get expected party_ids for this signer
    if let Some(expected_key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
        // Check that shares.shares contains all expected party_ids
        let received_party_ids: HashSet<u32> = shares.shares.iter()
            .map(|(party_id, _)| *party_id)
            .collect();
        
        if expected_key_ids != &received_party_ids {
            missing_private_shares.insert(*signer_id);
        }
    }
    
    // Existing validation continues...
}
```

Additionally, update error handling to process `DkgError::MissingPrivateShares`:

```rust
// In dkg_ended() error handler around line 625, add:
for (_my_party_id, dkg_error) in dkg_error_map {
    match dkg_error {
        DkgError::BadPrivateShares(party_ids) => {
            // existing handling
        }
        DkgError::MissingPrivateShares(missing_pairs) => {
            for (_receiver_id, sender_party_id) in missing_pairs {
                if let Some((sender_signer_id, shared_key)) = 
                    self.decryption_keys.get(&sender_party_id) 
                {
                    bad_private_shares.insert(
                        *sender_signer_id,
                        self.make_bad_private_share(*sender_signer_id, rng)?
                    );
                }
            }
        }
        _ => {
            warn!("Got unexpected dkg_error {dkg_error:?}");
        }
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated with this test that shows a signer with multiple party_ids sending incomplete shares:

```rust
#[test]
fn test_incomplete_party_shares_dos() {
    let mut rng = rand::thread_rng();
    
    // Setup: Signer 0 controls party_ids [1, 2, 3]
    let signer_ids: Vec<Vec<u32>> = vec![vec![1, 2, 3], vec![4, 5]];
    let mut signers: Vec<v1::Signer> = signer_ids
        .iter()
        .enumerate()
        .map(|(id, ids)| v1::Signer::new(id as u32, ids, 5, 2, 3, &mut rng))
        .collect();
    
    // Malicious signer 0 sends public shares for all party_ids [1,2,3]
    let ctx = 0u64.to_be_bytes();
    let polys: HashMap<u32, PolyCommitment> = signers[0]
        .get_poly_commitments(&ctx, &mut rng)
        .into_iter()
        .map(|comm| (comm.id.id.get_u32(), comm))
        .collect();
    
    // But sends private shares for only party_id 1 (omitting 2 and 3)
    let mut incomplete_shares = HashMap::new();
    let full_shares = signers[0].get_shares();
    
    // Only include shares from party_id 1
    if let Some(shares_from_1) = full_shares.get(&1) {
        incomplete_shares.insert(1, shares_from_1.clone());
    }
    // Omit party_ids 2 and 3
    
    // Attempt compute_secrets with incomplete shares
    match signers[1].compute_secrets(&incomplete_shares, &polys, &ctx) {
        Ok(_) => panic!("Should have detected missing shares"),
        Err(errors) => {
            // Verify MissingPrivateShares error is returned
            assert!(!errors.is_empty());
            for (_, error) in errors {
                assert!(matches!(error, DkgError::MissingPrivateShares(_)));
            }
            // But in actual protocol, this error is not handled properly,
            // allowing malicious signer to avoid detection
        }
    }
}
```

This test demonstrates that `compute_secrets()` correctly detects missing party_ids and returns `MissingPrivateShares`, but the error handling in `dkg_ended()` fails to process it, confirming the vulnerability.

### Citations

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L622-650)
```rust
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L926-949)
```rust
        for (party_id, shares) in &self.signer.get_shares() {
            debug!(
                "Signer {} addding dkg private share for party_id {party_id}",
                self.signer_id
            );
            // encrypt each share for the recipient
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
        }
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/state_machine/mod.rs (L93-102)
```rust
#[derive(Clone, Default, PartialEq, Eq)]
/// Map of signer_id and key_id to the relevant ecdsa public keys
pub struct PublicKeys {
    /// signer_id -> public key
    pub signers: HashMap<u32, ecdsa::PublicKey>,
    /// key_id -> public key
    pub key_ids: HashMap<u32, ecdsa::PublicKey>,
    /// map of signer_id to controlled key_ids
    pub signer_key_ids: HashMap<u32, HashSet<u32>>,
}
```

**File:** src/v1.rs (L172-179)
```rust
        let mut missing_shares = Vec::new();
        for i in public_shares.keys() {
            if private_shares.get(i).is_none() {
                missing_shares.push((self.id, *i));
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
```

**File:** src/v1.rs (L929-935)
```rust
        let signer_ids: Vec<Vec<u32>> = [
            [1, 2, 3].to_vec(),
            [4, 5].to_vec(),
            [6, 7, 8].to_vec(),
            [9, 10].to_vec(),
        ]
        .to_vec();
```

**File:** src/state_machine/coordinator/fire.rs (L652-764)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
                        }
```
