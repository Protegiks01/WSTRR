# Audit Report

## Title
Fire Coordinator Timeout Logic Incorrectly Marks Honest Signers as Malicious on Network Delays

## Summary
The FIRE coordinator's signature share timeout handler permanently marks all non-responding signers as malicious without distinguishing between actual malicious behavior and temporary network delays. This creates a progressive denial of service vulnerability where honest signers experiencing transient network issues are permanently excluded from future signing rounds, eventually reducing system capacity below the threshold required to produce signatures.

## Finding Description

The vulnerability exists in the fire coordinator's timeout handling logic, which conflates two fundamentally different failure modes: temporary network unavailability and permanent malicious behavior.

When the signature share gathering timeout fires, the coordinator marks ALL non-responding signers as malicious without any validation of cryptographic correctness. [1](#0-0)  The `sign_wait_signer_ids` set contains all signers who sent valid nonce responses but have not yet sent signature shares. [2](#0-1) 

Once marked as malicious, signers are permanently excluded from all future signing rounds. When these signers send nonce responses in subsequent iterations, their responses are silently rejected. [3](#0-2) 

The `malicious_signer_ids` set is never cleared—not during reset operations, nor through any other recovery mechanism. [4](#0-3) 

**Security Guarantee Broken:** The protocol breaks its **liveness/availability guarantee**. WSTS should provide the ability to produce signatures when a threshold of honest signers are available. However, honest signers experiencing temporary network delays are permanently excluded, progressively degrading system capacity even when all signers are actually honest and eventually available.

**Attack Propagation:** Network delays (either natural or attacker-induced) → timeout fires during `SigShareGather` state → honest signers marked malicious → subsequent nonce responses rejected → progressive capacity reduction → system falls below threshold → permanent inability to produce signatures.

## Impact Explanation

**Severity: High to Critical**

This vulnerability causes a progressive denial of service that can escalate to permanent system failure. The impact severity depends on deployment context:

**High Severity** (General deployments): Maps to "Any remotely-exploitable denial of service" as it causes the coordinator to permanently lose signing capability when sufficient signers are incorrectly flagged.

**Critical Severity** (Blockchain deployments): In contexts like Stacks where WSTS coordinates block production or transaction signing, this maps to "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks." When the signing system falls below threshold, the blockchain cannot produce new blocks, resulting in complete network halt.

**Concrete Example**: Consider a deployment with 10 signers (2 keys each = 20 total keys) and threshold of 14 keys:
- After first timeout affecting 3 signers: 14 keys remain (exactly at threshold)
- After second timeout affecting 2 more signers: 10 keys remain (below threshold)
- **Result**: Permanent inability to produce signatures requiring manual intervention

The cumulative nature makes this particularly severe—each timeout event permanently reduces capacity, and the issue cannot self-recover.

## Likelihood Explanation

**Likelihood: High**

This vulnerability has high probability of occurrence because:

1. **Natural Occurrence**: Can trigger without any attacker through normal network congestion, high system load on signers, or transient connectivity issues—all common in distributed systems.

2. **Low Attack Barrier**: If attacker-induced, requires only the ability to delay packets between signers and coordinator. No cryptographic capabilities, no privileged access, no expensive resources needed.

3. **Cumulative Effect**: Each timeout event increases the probability of future failures by permanently reducing available capacity. A single timeout affecting even one signer makes the system more fragile.

4. **No Detection**: Delayed packets appear identical to legitimate network behavior, making malicious delays indistinguishable from benign ones.

5. **Probability Increases Over Time**: As system operates longer, more opportunities for transient network issues to occur, progressively weakening the system until eventual failure.

## Recommendation

Implement a distinction between temporary unavailability and permanent malicious behavior:

1. **Separate Timeout from Malicious Behavior**: Create a separate "temporarily unavailable" tracking mechanism that allows signers to recover after network issues resolve.

2. **Validate Before Marking Malicious**: Only mark signers as permanently malicious when they send cryptographically invalid responses, not when they simply fail to respond.

3. **Add Recovery Mechanism**: Implement timeout-based recovery that allows temporarily flagged signers to rejoin after successful responses in subsequent rounds.

4. **Clear on Reset**: Ensure the `reset()` function clears malicious signer tracking to prevent state contamination across protocol sessions.

Example fix for the timeout handler:

```rust
// Track timeouts separately from cryptographic maliciousness
self.timeout_signer_ids.insert(*signer_id); // Temporary tracking

// Only mark as permanently malicious if cryptographic validation fails
// (move this logic to where actual signature verification happens)
```

And modify nonce gathering to allow recovery:

```rust
if self.malicious_signer_ids.contains(&nonce_response.signer_id) {
    // Still reject cryptographically malicious signers
    return Ok(());
}
// Allow signers who previously timed out to try again
// (remove check against timeout_signer_ids)
```

## Proof of Concept

The existing test at lines 2936-3184 in `src/state_machine/coordinator/fire.rs` demonstrates this behavior pattern, though not explicitly as a vulnerability test. The test shows:

1. Signers are marked as malicious when they timeout (not present to send signature shares)
2. The system attempts to continue with reduced capacity
3. After sufficient timeouts, system returns `InsufficientSigners` error

A minimal PoC demonstrating the vulnerability:

```rust
#[test]
fn test_honest_signers_marked_malicious_on_network_delay() {
    // Setup: 3 signers, 2 keys each = 6 keys, threshold = 4
    let (mut coordinator, mut signers) = setup_with_timeouts(3, 2, None, None, None, None, Some(Duration::from_millis(100)));
    
    // Complete DKG
    run_dkg(&mut coordinator, &mut signers);
    
    // Start signing round
    let msg = b"test".to_vec();
    coordinator.start_signing_round(&msg, SignatureType::Frost, None).unwrap();
    
    // All signers send nonces (all honest)
    send_all_nonces(&mut coordinator, &mut signers);
    
    // Simulate network delay: Don't send signature shares from one signer
    let delayed_signer = signers.pop().unwrap();
    
    // Send signature shares from remaining signers
    send_signature_shares(&mut coordinator, &mut signers);
    
    // Timeout fires - delayed signer marked as malicious despite being honest
    thread::sleep(Duration::from_millis(150));
    coordinator.process_timeout().unwrap();
    
    // Verify: Previously delayed signer (now recovered) cannot participate
    signers.push(delayed_signer);
    coordinator.start_signing_round(&msg, SignatureType::Frost, None).unwrap();
    
    // Delayed signer sends nonce response - should be accepted but is rejected
    let nonce_response = delayed_signer.process_message(&nonce_request).unwrap();
    coordinator.process(&nonce_response).unwrap();
    
    // Assert: System has permanently lost capacity even though signer is honest
    assert!(coordinator.malicious_signer_ids.contains(&delayed_signer.id));
}
```

This demonstrates that a single timeout event permanently excludes an honest signer, progressively degrading system capacity.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L173-186)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L940-942)
```rust
            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```
