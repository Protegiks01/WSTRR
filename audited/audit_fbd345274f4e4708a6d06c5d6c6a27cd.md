### Title
Missing Validation Allows Duplicate Key IDs Across Signers, Causing Invalid Signatures Through Incorrect Lagrange Coefficient Computation

### Summary
The `sign_share_request()` function collects key IDs from all participating signers without deduplication, allowing duplicate key IDs across signers to corrupt Lagrange coefficient calculations. The `PublicKeys::validate()` method fails to enforce uniqueness of key IDs across signers, enabling misconfiguration that causes all signatures to fail verification. This violates the critical signing invariant "Lagrange interpolation must use the correct key set with no duplicates" and can render the signing system completely non-functional.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:** The signer's `sign_share_request()` function aggregates key IDs from all `NonceResponse` messages using `flat_map` without deduplication. When the coordinator's `PublicKeys` configuration contains overlapping key IDs across different signers (e.g., Signer 0 controls [1,2] and Signer 1 controls [2,3]), the resulting `key_ids` vector contains duplicates [1,2,2,3].

These duplicate-containing key ID lists are then passed to signing functions [2](#0-1)  which use them to compute Lagrange coefficients via `compute::lambda()` [3](#0-2) .

The Lagrange coefficient computation [4](#0-3)  multiplies by `(j/(j-i))` for each `j` in the key IDs list where `j != i`. When duplicates exist, non-duplicated key IDs incorrectly multiply by duplicate values multiple times, exponentially inflating their coefficients.

**Example:** For `key_ids = [1,2,2,3]` and computing `lambda(1, key_ids)`:
- Multiplies by `(2/(2-1)) = 2` twice (once for each duplicate 2)
- Multiplies by `(3/(3-1)) = 1.5` once
- Result: `2 × 2 × 1.5 = 6`
- Correct value for `lambda(1, [1,2,3])`: `2 × 1.5 = 3`

**Why Existing Mitigations Fail:** The `PublicKeys::validate()` method [5](#0-4)  only validates that signer IDs and key IDs are within range. It does NOT check for duplicate key IDs across the `signer_key_ids` mapping, allowing configurations where multiple signers claim control of the same key ID.

Both coordinator implementations (FROST [6](#0-5)  and FIRE [7](#0-6) ) validate that each signer's reported key IDs match the configuration, but neither checks for overlap across signers.

### Impact Explanation

**Specific Harm:** All signatures generated with duplicate key IDs will have mathematically incorrect Lagrange coefficients in their signature shares. When the coordinator aggregates these shares, the resulting group signature will fail cryptographic verification because the interpolation is computed over an incorrect set of points.

**Quantified Impact:** 
- 100% of signatures fail verification when any signer pair has overlapping key IDs
- Complete denial of service for the threshold signature system
- In blockchain integration: no transactions can be signed or confirmed
- Maps to **CRITICAL** severity: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks"

**Who Is Affected:** Any deployment where the coordinator's `PublicKeys` configuration contains duplicate key IDs across signers, whether through:
1. Malicious configuration by an attacker who controls coordinator setup
2. Software bugs in configuration generation code
3. Human error during manual configuration

### Likelihood Explanation

**Required Attacker Capabilities:**
- Ability to configure the coordinator's `PublicKeys` mapping during system initialization, OR
- Ability to inject a malicious configuration file/parameters
- No cryptographic breaks or key compromise required

**Attack Complexity:** Low
1. Create `PublicKeys` with overlapping `signer_key_ids` entries (e.g., two signers both control key_id=5)
2. Initialize coordinator with this configuration
3. The configuration passes `validate()` checks
4. Any signing round produces invalid signatures

**Economic Feasibility:** Minimal resources required. Attack is effective at configuration time before any cryptographic operations occur.

**Detection Risk:** Low for attacker. The misconfiguration passes all validation checks. Invalid signatures appear as signing failures, not as obvious malicious activity.

**Estimated Probability:** 
- **Malicious:** Medium (requires coordinator initialization access)
- **Accidental:** Medium-High (no validation prevents this common configuration error)

The test setup code [8](#0-7)  intentionally generates sequential unique key IDs, demonstrating the intended design. However, this pattern is not enforced, making misconfiguration likely.

### Recommendation

**Primary Fix:** Add duplicate key ID validation to `PublicKeys::validate()`:

```rust
// In src/state_machine/mod.rs, PublicKeys::validate()
let mut all_key_ids = HashSet::new();
for (signer_id, key_ids) in &self.signer_key_ids {
    for key_id in key_ids {
        if !all_key_ids.insert(*key_id) {
            return Err(SignerError::Config(ConfigError::DuplicateKeyId(*key_id)));
        }
    }
}
```

**Secondary Fix:** Add defensive deduplication in signers:

```rust
// In src/state_machine/signer/mod.rs, sign_share_request()
let key_ids: Vec<u32> = sign_request
    .nonce_responses
    .iter()
    .flat_map(|nr| nr.key_ids.iter().copied())
    .collect::<HashSet<u32>>()  // Deduplicate
    .into_iter()
    .collect();
```

**Testing Recommendations:**
1. Add unit test attempting to create `PublicKeys` with duplicate key IDs across signers
2. Add integration test showing signature failure with duplicate configuration
3. Verify existing tests still pass with validation added

**Deployment Considerations:** 
- Review all production configurations for duplicate key IDs
- Add migration check to detect and reject duplicate configurations
- Document that key IDs must be globally unique across all signers

### Proof of Concept

**Exploitation Steps:**

1. Configure coordinator with overlapping key IDs:
   - Signer 0: `signer_key_ids[0] = {1, 2}`
   - Signer 1: `signer_key_ids[1] = {2, 3}`

2. Configuration passes validation (no duplicate check exists)

3. During signing round, coordinator collects `NonceResponse` messages:
   - From Signer 0: `key_ids = [1, 2]`
   - From Signer 1: `key_ids = [2, 3]`

4. Signer processes `SignatureShareRequest`:
   - Flat-maps to `key_ids = [1, 2, 2, 3]` (duplicate 2)

5. Signer 0 computes signature share:
   - For key_id=1: `lambda(1, [1,2,2,3]) = (2/1) * (2/1) * (3/2) = 6` (should be 3)
   - For key_id=2: `lambda(2, [1,2,2,3]) = (1/-1) * (3/1) = -3` (correct by chance)
   - Signature share uses inflated coefficient for key_id=1

6. Coordinator aggregates signature shares with incorrect coefficients

7. **Expected behavior:** Signature verifies correctly
   **Actual behavior:** Signature verification fails due to incorrect Lagrange interpolation

**Reproduction:** Create test with `PublicKeys` containing duplicate key IDs across signers, run through DKG and signing round, observe signature verification failure.

### Citations

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L808-818)
```rust
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/compute.rs (L69-80)
```rust
/// Compute the Lagrange interpolation value
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/mod.rs (L106-136)
```rust
    pub fn validate(&self, num_signers: u32, num_keys: u32) -> Result<(), SignerError> {
        for (signer_id, _key) in &self.signers {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }
        }

        for (key_id, _key) in &self.key_ids {
            if !validate_key_id(*key_id, num_keys) {
                return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
            }
        }

        for (signer_id, key_ids) in &self.signer_key_ids {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }

            for key_id in key_ids {
                if !validate_key_id(*key_id, num_keys) {
                    return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
                }
            }
        }

        Ok(())
    }
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/mod.rs (L590-609)
```rust
        let mut key_id: u32 = 1;
        let mut signer_ids_map = HashMap::new();
        let mut signer_key_ids = HashMap::new();
        let mut signer_key_ids_set = HashMap::new();
        let mut signer_public_keys = HashMap::new();
        let mut key_ids_map = HashMap::new();
        for (i, (private_key, public_key)) in key_pairs.iter().enumerate() {
            let mut key_ids = Vec::new();
            let mut key_ids_set = HashSet::new();
            for _ in 0..keys_per_signer {
                key_ids_map.insert(key_id, *public_key);
                key_ids.push(key_id);
                key_ids_set.insert(key_id);
                key_id += 1;
            }
            signer_ids_map.insert(i as u32, *public_key);
            signer_key_ids.insert(i as u32, key_ids);
            signer_key_ids_set.insert(i as u32, key_ids_set);
            signer_public_keys.insert(i as u32, Point::from(private_key));
        }
```
