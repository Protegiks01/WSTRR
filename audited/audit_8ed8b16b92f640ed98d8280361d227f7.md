### Title
Malicious Signer Memory Loss Enables Persistent DKG Denial of Service

### Summary
The `reset()` function clears `invalid_private_shares`, erasing signers' memory of previously detected malicious actors. Combined with the coordinator's failure to exclude tracked malicious signers from new DKG rounds, a single compromised signer can indefinitely prevent DKG completion, blocking all transaction signing and effectively shutting down the network.

### Finding Description

The vulnerability exists at the intersection of two components:

**Primary Issue - Signer Memory Loss:**
The `reset()` function unconditionally clears `invalid_private_shares` when starting a new DKG round. [1](#0-0) 

This field tracks signers who sent invalid private shares during decryption or verification. [2](#0-1) 

When invalid shares are detected, signers report them in their `DkgEnd` messages. [3](#0-2) 

**Secondary Issue - Coordinator Fails to Exclude Malicious Signers:**
The coordinator tracks malicious signers in `malicious_dkg_signer_ids`. [4](#0-3) 

However, when starting a new DKG round, `start_public_shares()` includes ALL signers without filtering. [5](#0-4) 

Additionally, when any DKG failures are reported, the coordinator immediately returns an error instead of checking if sufficient honest signers remain. This behavior is explicitly acknowledged as incomplete. [6](#0-5) 

The coordinator validates bad private share reports and correctly identifies malicious signers. [7](#0-6) 

But this validation occurs AFTER the DKG round has already failed, and the identified malicious signers are not excluded from the next round attempt.

**Why Existing Mitigations Fail:**
- The `malicious_dkg_signer_ids` tracking exists but is never enforced during signer selection
- The `dkg_threshold` mechanism could allow DKG to succeed with a subset of honest signers, but the coordinator exits immediately on any failure without checking threshold viability
- Timeout mechanisms only exclude non-responsive signers; malicious signers can remain active while sending invalid data
- Signers lose all memory of malicious actors when `reset()` is called, requiring re-detection each round

### Impact Explanation

**Specific Harm:**
A single compromised signer node can prevent DKG from ever completing successfully. Without a completed DKG, the signing group cannot generate any signatures. This directly prevents transaction confirmation.

**Quantified Impact:**
- **Round 1:** Malicious signer sends invalid private shares → DKG fails
- **Round 2:** Same signer participates again (not excluded) → Signers forget previous failures (`reset()`) → Attack repeats → DKG fails
- **Round N:** Attack continues indefinitely with zero cost to attacker
- **Result:** Network cannot produce signatures for ANY transactions

**Who is Affected:**
All network participants relying on this WSTS signing group for transaction validation. In a blockchain context where WSTS is used for consensus or transaction signing, this affects the entire network.

**Severity Justification:**
This maps directly to **CRITICAL** severity per the protocol scope: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks." The attack causes complete signing failure, not transient delays. The network cannot recover without manual intervention to exclude the malicious signer at the configuration level.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of a single signer node in the signing group
- Network access to participate in DKG protocol
- No special privileges or cryptographic material needed beyond being a configured signer

**Attack Complexity:**
- **Technical Difficulty:** Low - attacker simply sends random bytes as encrypted private shares or valid encryption of invalid scalar values
- **Resources Required:** Minimal - just CPU time to participate in protocol
- **Persistence:** Attack can repeat indefinitely with no additional cost
- **Detection:** Coordinator detects malicious behavior but fails to act on it

**Economic Feasibility:**
The attack costs essentially nothing to execute. Even if the attacker's signer node is detected, they can continue the attack since exclusion is not enforced.

**Detection Risk:**
The attack IS detected (malicious signer identified and logged), but detection doesn't prevent continuation. The coordinator logs warnings but takes no enforcement action.

**Estimated Probability:**
- If attacker has signer access: 100% success rate
- Attack will succeed on every DKG round attempt
- No randomness or timing dependencies
- No mitigation exists in the current codebase

### Recommendation

**Primary Fix - Coordinator Must Exclude Malicious Signers:**

1. Modify `start_public_shares()` to filter out previously identified malicious signers:
```rust
// In src/state_machine/coordinator/fire.rs, line 399
self.dkg_wait_signer_ids = (0..self.config.num_signers)
    .filter(|id| !self.malicious_dkg_signer_ids.contains(id))
    .collect();
```

2. Implement the TODO at line 783 - check if remaining honest signers meet `dkg_threshold` before failing:
```rust
// Calculate total key weight of non-malicious signers who succeeded
let honest_key_count = calculate_honest_key_weight(&non_malicious_signers);
if honest_key_count >= self.config.dkg_threshold {
    // Continue DKG with honest subset
    self.dkg_end_gathered()?;
} else {
    // Insufficient honest signers to meet threshold
    return Err(Error::DkgFailure { ... });
}
```

**Alternative Mitigation:**
Signers could maintain a persistent blacklist that survives `reset()`, but this is inferior because:
- It requires coordination between signers
- Coordinator is the authoritative source of truth and should enforce exclusions
- Distributed blacklist maintenance is more complex and error-prone

**Testing Recommendations:**
1. Add integration test with one malicious signer sending invalid shares across multiple DKG rounds
2. Verify malicious signer is excluded from round 2 onwards
3. Test that DKG succeeds with honest signers meeting `dkg_threshold`
4. Test that DKG properly fails when honest signers below `dkg_threshold` after exclusions

**Deployment Considerations:**
- This is a protocol-level change requiring coordinated deployment
- Existing `malicious_dkg_signer_ids` field provides backward-compatible state for tracking
- No breaking changes to message formats required
- Operators should review `malicious_dkg_signer_ids` before deployment and clear any false positives

### Proof of Concept

**Attack Algorithm:**

```
Setup:
- Network with N signers (e.g., N=10)
- dkg_threshold = 7 keys
- Attacker controls signer_id = 3 with 1 key

Attack Steps:

Round 1:
1. Coordinator broadcasts DkgBegin(dkg_id=1)
2. All signers (including attacker) respond with DkgPublicShares
   - Attacker sends valid public polynomial commitments
3. Coordinator broadcasts DkgPrivateBegin
4. Attacker sends DkgPrivateShares with encrypted random bytes:
   encrypted_share = encrypt(shared_secret, random_32_bytes())
5. Honest signers attempt to decrypt:
   - Decryption succeeds but Scalar::try_from() fails (line 1077-1082)
   - OR shares don't verify against commitments (in compute_secrets)
6. Honest signers populate invalid_private_shares.insert(3, bad_share)
7. Honest signers send DkgEnd(status=Failure(BadPrivateShares({3: proof})))
8. Coordinator validates proof (lines 681-761)
9. Coordinator adds signer 3 to malicious_dkg_signer_ids
10. Coordinator returns Error::DkgFailure
    → DKG Round 1 FAILS

Round 2:
1. System retries: start_dkg_round(dkg_id=2)
2. start_public_shares() includes ALL signers (line 399):
   dkg_wait_signer_ids = {0,1,2,3,4,5,6,7,8,9}  // attacker INCLUDED
3. All signers call reset(dkg_id=2, rng)
4. reset() clears invalid_private_shares (line 422)
   → Signers FORGET signer 3 was malicious
5. Coordinator broadcasts DkgBegin(dkg_id=2)
6. GOTO Round 1, step 2 (attack repeats)

Round N:
... identical pattern, loops indefinitely ...

Result:
- DKG never completes
- No signatures can be generated
- Network halted
```

**Expected vs Actual Behavior:**

*Expected:* After detecting malicious signer in Round 1, coordinator should exclude them from Round 2, allowing DKG to succeed with honest signers (7/9 remaining keys ≥ threshold).

*Actual:* Coordinator includes malicious signer in every round, and signers forget previous detections. Attack succeeds indefinitely with no recovery mechanism.

**Reproduction Instructions:**
1. Deploy WSTS network with 10 signers, dkg_threshold=7
2. Compromise signer 3
3. Modify signer 3 to send random bytes in DkgPrivateShares
4. Observe DKG fails in round 1 with signer 3 marked malicious
5. Retry DKG round 2
6. Observe signer 3 is included again and attack repeats
7. Confirm DKG never completes despite 9 honest signers exceeding threshold

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L611-660)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };
```

**File:** src/state_machine/signer/mod.rs (L1076-1096)
```rust
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L396-417)
```rust
    pub fn start_public_shares(&mut self) -> Result<Packet, Error> {
        self.dkg_public_shares.clear();
        self.party_polynomials.clear();
        self.dkg_wait_signer_ids = (0..self.config.num_signers).collect();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting Public Share Distribution"
        );
        let dkg_begin = DkgBegin {
            dkg_id: self.current_dkg_id,
        };
        let dkg_begin_packet = Packet {
            sig: dkg_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgBegin"),
            msg: Message::DkgBegin(dkg_begin),
        };

        self.move_to(State::DkgPublicGather)?;
        self.dkg_public_start = Some(Instant::now());
        Ok(dkg_begin_packet)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```
