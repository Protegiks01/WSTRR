### Title
Schnorr ID Proof Forgery via Weak RNG and Context Reuse in DKG

### Summary
The Schnorr ID proof mechanism in `Party::get_poly_commitment()` is vulnerable to forgery when both a weak RNG and context reuse occur. An attacker can extract the secret polynomial constant from observed proofs when the RNG is predictable, then forge new proofs in subsequent DKG rounds that reuse the same `dkg_id` context value. This allows party impersonation and DKG manipulation, potentially leading to invalid signature acceptance and chain-level consensus failures.

### Finding Description

The vulnerability exists in the Schnorr ID proof construction used during DKG polynomial commitment: [1](#0-0) 

The proof is created via: [2](#0-1) 

**Root Cause:**

The Schnorr proof relies on a random scalar `k` for security. The proof structure is:
- Commitment: `K = k*G`  
- Challenge: `c = H(id || K || A || ctx)` where `A = a*G`
- Response: `kca = k + c*a`

If an attacker can predict `k` (due to weak RNG), they can extract the secret polynomial constant `a`:

Since all values `(id, K, kca, A, ctx)` are public or observable, and the attacker knows `k`, they compute:
- `c = H(id || K || A || ctx)` using public values
- `a = (kca - k) / c` extracting the secret

The `ctx` parameter is derived from `dkg_id`: [3](#0-2) [4](#0-3) [5](#0-4) 

The coordinator accepts external `dkg_id` values from `DkgBegin` messages: [6](#0-5) [7](#0-6) 

The check at line 231 only prevents reprocessing in the *current session*. After system restart or with different coordinator instances, `dkg_id` values can be reused, causing context reuse.

**Why Existing Mitigations Fail:**

1. **CryptoRng Requirement**: The `RngCore + CryptoRng` trait bound is documented but `CryptoRng` is only a marker trait with no runtime enforcement. Callers can provide weak RNGs that still satisfy the trait. [8](#0-7) 

2. **Auto-incrementing dkg_id**: While the coordinator attempts to increment `dkg_id`, it accepts external values without global uniqueness validation, allowing reuse across sessions or coordinator instances.

3. **Message Authentication**: USAGE.md states applications "must" verify packets, but this is not enforced by the library and doesn't prevent the cryptographic proof forgery itself. [9](#0-8) 

### Impact Explanation

**Specific Harm:**

Once an attacker extracts a party's polynomial constant `a` and the context is reused:

1. **Proof Forgery**: Attacker generates their own random `k'`, computes `K' = k'*G`, `c' = H(id || K' || A || ctx)`, and `kca' = k' + c'*a`, creating a valid forged proof.

2. **Party Impersonation**: Attacker submits fake `DkgPublicShares` with forged Schnorr ID proofs passing verification: [10](#0-9) 

3. **DKG Manipulation**: Attacker controls the polynomial coefficients (except the extracted constant term) and distributes attacker-chosen private shares to other parties.

4. **Group Key Compromise**: With control over shares from forged parties, attacker can manipulate the resulting group key and signature shares.

**Quantified Impact:**

- If attacker controls â‰¥ threshold parties through forgery: Complete group key control, arbitrary signature generation
- If attacker controls < threshold but > 0 parties: Partial influence over signatures, potential signature malleability
- Chain-level impact: Invalid signatures accepted, different DKG outcomes across nodes causing chain splits

**Severity Justification:**

This maps to **Critical** severity under the protocol scope:
- "Any confirmation of an invalid transaction" - manipulated DKG leads to invalid signature acceptance
- "Any chain split caused by different nodes...yielding different results" - nodes with different DKG outcomes diverge
- "Any causing the direct loss of funds" - compromised threshold enables unauthorized fund movements

### Likelihood Explanation

**Required Attacker Capabilities:**

1. **Passive Observation**: Monitor DKG messages containing Schnorr ID proofs
2. **RNG Prediction**: Ability to predict random scalars from the weak RNG (requires knowledge of RNG implementation/seed)
3. **Context Knowledge**: Awareness of when `dkg_id` values are reused
4. **Network Access**: Submit forged `DkgPublicShares` messages

**Attack Complexity:**

- **Cryptographic**: Low - standard algebraic extraction, no hash/curve breaks
- **Implementation**: Medium - requires understanding DKG flow and message formats
- **Detection**: Low - forged proofs verify correctly, indistinguishable from legitimate

**Prerequisites Feasibility:**

1. **Weak RNG** (Likelihood: Low-Medium):
   - Violations occur in testing/development environments using deterministic RNGs
   - Misconfigured production deployments with poor entropy
   - Embedded systems or restricted environments with limited randomness
   - Realistic in practice despite documented requirements

2. **Context Reuse** (Likelihood: Low):
   - System restarts resetting `current_dkg_id` to 0 or low values
   - Distributed coordinator deployments without shared state
   - Application bugs in `dkg_id` management
   - Intentional malicious coordinator behavior
   - `dkg_id` integer overflow after 2^64 rounds (essentially impossible)

3. **Both Conditions** (Combined Likelihood: Low):
   - Requires both violations simultaneously
   - More likely in development/testing environments
   - Possible in production with configuration errors

**Economic Feasibility:**

High-value targets (securing significant funds) justify sophisticated attacks. Development of RNG prediction capabilities and monitoring infrastructure is economically viable for motivated attackers.

**Estimated Probability:** Low but non-negligible in misconfigured or development deployments; very low in properly configured production systems.

### Recommendation

**Primary Fix - Enforce RNG Quality:**

Add runtime RNG quality checks by requiring additional entropy validation:

```rust
pub fn get_poly_commitment<RNG: RngCore + CryptoRng>(
    &self,
    ctx: &[u8],
    rng: &mut RNG,
) -> Option<PolyCommitment> {
    if let Some(poly) = &self.f {
        // Validate RNG quality by testing entropy
        let mut test_bytes = [0u8; 32];
        rng.fill_bytes(&mut test_bytes);
        if test_bytes.iter().all(|&b| b == 0) {
            panic!("RNG appears to be weak or deterministic");
        }
        
        Some(PolyCommitment {
            id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
            ...
        })
    } else {
        None
    }
}
```

**Secondary Fix - Enforce Context Uniqueness:**

Bind `ctx` to additional unique values to prevent reuse:

```rust
// In state machine, include timestamp or monotonic counter
let ctx_bytes = [
    self.dkg_id.to_be_bytes(),
    system_time_nanos().to_be_bytes(),
    monotonic_counter.to_be_bytes()
].concat();

self.signer.get_poly_commitments(&ctx_bytes, rng);
```

**Tertiary Fix - Add Nonce Commitment:**

Include additional randomness in the challenge computation:

```rust
pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
    let mut hasher = Sha256::new();
    hasher.update("WSTS/polynomial-constant");
    hasher.update(id.to_bytes());
    hasher.update(K.compress().as_bytes());
    hasher.update(A.compress().as_bytes());
    hasher.update(ctx);
    // Add commitment to additional random value to prevent extraction
    // even if k is known
    hasher.update(additional_random_bytes);
    hash_to_scalar(&mut hasher)
}
```

**Documentation Updates:**

Update USAGE.md to explicitly warn about:
- RNG quality requirements with concrete examples of acceptable RNGs
- `dkg_id` uniqueness requirements across system restarts
- Security implications of weak RNG or context reuse

**Testing Recommendations:**

1. Add tests verifying RNG entropy requirements
2. Add tests detecting `dkg_id` reuse attempts
3. Fuzz test with intentionally weak RNGs to detect vulnerabilities
4. Integration tests covering system restart scenarios

**Deployment Considerations:**

- Audit existing deployments for RNG implementation
- Implement monotonic `dkg_id` storage persisting across restarts
- Add runtime monitoring for `dkg_id` anomalies
- Consider migration path for already-deployed systems

### Proof of Concept

**Extraction Algorithm:**

Given observed proof from Round 1:
```
Input: (id, K, kca, A, ctx) from legitimate party's PolyCommitment
Input: k (predicted from weak RNG)

Step 1: Compute challenge
c = H("WSTS/polynomial-constant" || id || K || A || ctx)

Step 2: Extract secret polynomial constant
a = (kca - k) / c

Output: Secret polynomial constant a
```

**Forgery Algorithm:**

Given extracted `a` and reused `ctx` in Round 2:
```
Input: Extracted polynomial constant a
Input: Previously-used ctx (same dkg_id)
Input: Party id to impersonate

Step 1: Generate new random scalar (attacker's RNG)
k' = random()

Step 2: Compute new commitment
K' = k' * G

Step 3: Compute challenge with reused context
c' = H("WSTS/polynomial-constant" || id || K' || a*G || ctx)

Step 4: Compute forged response
kca' = k' + c'*a

Step 5: Create forged proof
forged_proof = ID {
    id: id,
    kG: K',
    kca: kca'
}

Output: Forged Schnorr ID proof that verifies correctly
```

**Verification:**

The forged proof verifies because:
```
kca' * G = (k' + c'*a) * G
        = k'*G + c'*a*G
        = K' + c'*A
```

Which matches the verification equation.

**Reproduction Steps:**

1. Deploy WSTS with deterministic RNG (e.g., seeded ChaCha20Rng with fixed seed)
2. Run DKG round with `dkg_id = 5`, observe party's PolyCommitment
3. Predict/extract the `k` value used (possible with deterministic RNG)
4. Compute `a = (kca - k) / c` using observed values
5. Restart system or use different coordinator instance
6. Initiate new DKG with `dkg_id = 5` (reused)
7. Submit forged DkgPublicShares with proof constructed using extracted `a`
8. Observe that `check_public_shares` accepts the forged proof
9. Attacker successfully participates as forged party in DKG

**Expected vs Actual Behavior:**

- **Expected**: Schnorr ID proofs should be unforgeable without knowledge of the secret `a`, and should bind uniquely to each DKG round
- **Actual**: With weak RNG and context reuse, attacker can extract `a` and forge proofs, impersonating parties in subsequent rounds

### Citations

**File:** src/v1.rs (L107-123)
```rust
    pub fn get_poly_commitment<RNG: RngCore + CryptoRng>(
        &self,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Option<PolyCommitment> {
        if let Some(poly) = &self.f {
            Some(PolyCommitment {
                id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
                poly: (0..poly.data().len())
                    .map(|i| &poly.data()[i] * G)
                    .collect(),
            })
        } else {
            warn!("get_poly_commitment called with no polynomial");
            None
        }
    }
```

**File:** src/schnorr.rs (L31-45)
```rust
    pub fn new<RNG: RngCore + CryptoRng>(
        id: &Scalar,
        a: &Scalar,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Self {
        let k = Scalar::random(rng);
        let c = Self::challenge(id, &(&k * &G), &(a * &G), ctx);

        Self {
            id: *id,
            kG: &k * G,
            kca: &k + c * a,
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L557-557)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
```

**File:** src/state_machine/signer/mod.rs (L615-615)
```rust
                &self.dkg_id.to_be_bytes(),
```

**File:** src/state_machine/signer/mod.rs (L864-864)
```rust
            .get_poly_commitments(&self.dkg_id.to_be_bytes(), rng);
```

**File:** src/state_machine/coordinator/fire.rs (L230-236)
```rust
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
```

**File:** src/state_machine/coordinator/fire.rs (L1429-1434)
```rust
    fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }
```

**File:** USAGE.md (L3-5)
```markdown
Applications which use `WSTS` will typically run both `Signer` and `Coordinator` state machines, in order to be able to handle all parts of the protocol. Because of this, these state machines do not verify packets as they come in; this would lead to duplicate work, and require the state machines to have all keys in their configs, including knowing who is the active coordinator. This is out of scope for the library. Thus applications `must` verify packets before calling `process_message` on them.

This addresses the audit critical issues [CR-01](https://github.com/Trust-Machines/wsts/issues/66) and [CR-02](https://github.com/Trust-Machines/wsts/issues/67).
```

**File:** USAGE.md (L7-8)
```markdown

To ensure flexibility, these state machines require the user to provide a random number generator (RNG) that implements the `RngCore` and `CryptoRng` traits.
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```
