# Audit Report

## Title
Unbounded NonceResponse Vectors Enable Coordinator Denial of Service

## Summary
The `NonceResponse` message structure contains unbounded vectors (`key_ids` and `nonces`) that undergo expensive elliptic curve point compression operations during ECDSA signature verification, before any size validation occurs. A malicious signer can exploit this by sending `NonceResponse` packets with thousands of entries, causing coordinator CPU exhaustion and denial of service.

## Finding Description

The vulnerability exists in the `NonceResponse` struct which defines `key_ids` and `nonces` as unbounded `Vec` types with no maximum size constraints. [1](#0-0) 

When a coordinator receives a `NonceResponse` packet, it must verify the packet signature before processing. The `process_message()` method calls `packet.verify()` when `verify_packet_sigs` is enabled (which defaults to `true`): [2](#0-1) 

The verification process calls the `Signable` trait's `verify()` method, which invokes `self.hash()` to compute the message digest: [3](#0-2) 

The `NonceResponse.hash()` implementation iterates through **ALL** key_ids and nonces, performing expensive elliptic curve point compression on each nonce's D and E points: [4](#0-3) 

Critically, the point compression operations at lines 362-363 are cryptographically expensive, as `Point` is a secp256k1 elliptic curve point type requiring coordinate calculations for compression.

Only **after** this expensive signature verification completes does the coordinator validate that the `key_ids` match the configured signer's key IDs in `gather_nonces()`: [5](#0-4) 

By this point, the coordinator has already expended significant CPU resources on point compressions for potentially thousands of malicious entries.

**Attack Flow:**
1. Malicious signer constructs `NonceResponse` with 10,000 nonces (each with D and E points)
2. Signs packet with legitimate signer private key
3. Sends to coordinator
4. Coordinator calls `packet.verify()` which hashes entire message (20,000 point compressions)
5. Even after validation rejects the oversized response, CPU resources have been exhausted
6. Repeated packets sustain coordinator DoS

The `verify_packet_sigs` configuration defaults to `true`, confirming this is the standard code path: [6](#0-5) 

## Impact Explanation

This vulnerability maps to **Low** severity under the defined scope: "Any remotely-exploitable denial of service in a node."

**Specific Harm:**
- A single oversized packet with 10,000 nonces requires 20,000 elliptic curve point compression operations
- Coordinator CPU becomes saturated processing malicious packets
- Memory allocation for large vectors adds additional resource pressure
- Coordinator becomes unresponsive to legitimate signing requests
- In blockchain integration contexts, this prevents signature aggregation and block signing

**Affected Components:**
- Coordinator nodes processing `NonceResponse` messages during signing rounds
- Any WSTS deployment where signers may be partially trusted or compromised
- Blockchain systems depending on WSTS for threshold signatures

The attack is asymmetric: minimal cost for the attacker (network bandwidth only) versus high cost for the defender (CPU exhaustion), making it economically feasible to sustain.

## Likelihood Explanation

**Required Attacker Capabilities:**
1. **Primary attack path:** Attacker must be a legitimate signer with a valid ECDSA private key for packet signing
2. **Alternative path:** Attacker compromises a signer's private key
3. **Edge case:** System misconfigured with `verify_packet_sigs=false` (allows unauthenticated packets)

This aligns with the WSTS threat model documented in the Security Model wiki, which states: "WSTS is designed to operate in a partially-trusted distributed environment where up to `t-1` parties (where `t` is the threshold) may behave maliciously." A malicious signer within the threshold is an expected adversary.

**Attack Complexity:**
Once the attacker has signer credentials, the attack is straightforward:
1. Construct `NonceResponse` with oversized vectors (no serialization limits exist)
2. Sign with legitimate signer key
3. Transmit over network to coordinator
4. Repeat to sustain DoS

**Detection and Mitigation Challenges:**
- Attack appears as legitimate protocol traffic initially
- No bounds checking before expensive operations
- Network-level monitoring could detect oversized packets, but requires external tooling
- Coordinator CPU spikes would be observable but may occur too late

**Probability Assessment:**
Moderate likelihood given that:
- Insider threat (malicious signer) is within protocol threat model
- Key compromise scenarios are realistic security concerns
- No cryptographic primitives need to be broken
- Attack has low technical complexity once prerequisites are met

## Recommendation

Implement bounds checking on `NonceResponse` vector sizes **before** signature verification:

1. **Add maximum size constants** for `key_ids` and `nonces` vectors based on protocol parameters (e.g., `num_keys` from coordinator config)

2. **Validate vector sizes in `Packet::verify()`** before calling `msg.verify()`:

```rust
// In Packet::verify(), before line 565:
Message::NonceResponse(msg) => {
    // Validate vector sizes before expensive hashing
    if msg.key_ids.len() > MAX_KEY_IDS || msg.nonces.len() > MAX_NONCES {
        warn!("NonceResponse exceeded maximum vector sizes");
        return false;
    }
    // ... existing verification logic
}
```

3. **Alternative: Validate during deserialization** by implementing custom `Deserialize` with bounds checking, rejecting oversized messages before they reach the state machine

4. **Defense in depth:** Implement rate limiting on `NonceResponse` messages per signer to prevent repeated attack attempts

5. **Monitoring:** Log vector sizes for anomaly detection and alerting on suspicious patterns

The fix should validate sizes against the coordinator's configured `signer_key_ids` for each signer, ensuring responses cannot exceed legitimate bounds.

## Proof of Concept

```rust
#[test]
fn test_oversized_nonce_response_dos() {
    use crate::net::*;
    use crate::common::PublicNonce;
    use crate::curve::point::{Point, G};
    use crate::util::create_rng;
    use std::time::Instant;
    
    let mut rng = create_rng();
    let test_config = TestConfig::default();
    
    // Create oversized NonceResponse with 10,000 nonces
    let mut oversized_nonces = Vec::new();
    for _ in 0..10_000 {
        let d = Point::from(Scalar::random(&mut rng) * G);
        let e = Point::from(Scalar::random(&mut rng) * G);
        oversized_nonces.push(PublicNonce { D: d, E: e });
    }
    
    let oversized_response = NonceResponse {
        dkg_id: 0,
        sign_id: 0,
        sign_iter_id: 0,
        signer_id: 0,
        key_ids: vec![1; 10_000], // 10,000 key_ids
        nonces: oversized_nonces,
        message: vec![0u8; 32],
    };
    
    // Sign with legitimate signer key
    let sig = oversized_response
        .sign(&test_config.signer_private_key)
        .expect("Failed to sign");
    
    let packet = Packet {
        msg: Message::NonceResponse(oversized_response),
        sig,
    };
    
    // Measure verification time - this will be expensive
    let start = Instant::now();
    let verified = packet.verify(
        &test_config.public_keys,
        &test_config.coordinator_public_key
    );
    let duration = start.elapsed();
    
    println!("Verification of 10,000 nonces took: {:?}", duration);
    println!("Verified: {}", verified);
    
    // Demonstrates excessive CPU time for verification
    // Expected: >100ms for 20,000 point compressions
    // Normal response: <1ms for ~10 nonces
    assert!(duration.as_millis() > 50, "DoS attack demonstrated");
}
```

This test demonstrates that a malicious signer can force the coordinator to perform expensive cryptographic operations by sending oversized `NonceResponse` packets, resulting in denial of service through CPU exhaustion.

### Citations

**File:** src/net.rs (L33-45)
```rust
    fn verify(&self, signature: &[u8], public_key: &ecdsa::PublicKey) -> bool {
        let mut hasher = Sha256::new();

        self.hash(&mut hasher);

        let hash = hasher.finalize();
        let sig = match ecdsa::Signature::try_from(signature) {
            Ok(sig) => sig,
            Err(_) => return false,
        };

        sig.verify(hash.as_slice(), public_key)
    }
```

**File:** src/net.rs (L311-326)
```rust
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/net.rs (L350-367)
```rust
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }

        for nonce in &self.nonces {
            hasher.update(nonce.D.compress().as_bytes());
            hasher.update(nonce.E.compress().as_bytes());
        }

        hasher.update(self.message.as_slice());
    }
```

**File:** src/state_machine/coordinator/frost.rs (L63-70)
```rust
        if self.config.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.config.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/mod.rs (L217-230)
```rust
        Config {
            num_signers,
            num_keys,
            threshold,
            dkg_threshold,
            message_private_key,
            dkg_public_timeout,
            dkg_private_timeout,
            dkg_end_timeout,
            nonce_timeout,
            sign_timeout,
            public_keys,
            verify_packet_sigs: true,
        }
```
