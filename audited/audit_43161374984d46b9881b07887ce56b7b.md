# Audit Report

## Title
Non-Participating Signers Can Abort DKG Through Invalid Private Shares

## Summary
The `dkg_ended()` function in the signer state machine fails the entire DKG round if `invalid_private_shares` contains any entries, even when those invalid shares originate from signers not included in the final participating set defined by `DkgEndBegin.signer_ids`. This allows a single malicious signer to deny service by sending corrupted private shares while avoiding inclusion in the coordinator's final participant list, preventing honest signers from completing DKG despite having sufficient valid shares.

## Finding Description

The vulnerability exists in the signer's `dkg_ended()` function where the decision to compute secrets is based on checking if `invalid_private_shares` is completely empty, without filtering by the final participating signer set. [1](#0-0) 

This check evaluates the entire `invalid_private_shares` map across ALL signers who sent private shares during any point in the DKG round, not just those in the coordinator-defined final participating set received in `DkgEndBegin.signer_ids`.

The attack flow works as follows:

1. **Signer exclusion from participating set**: When a signer doesn't send `DkgPublicShares` (or sends invalid/late shares), the FIRE coordinator's `start_private_shares()` only includes signers who successfully provided public shares in the `DkgPrivateBegin.signer_ids` list: [2](#0-1) [3](#0-2) 

2. **Unrestricted private share acceptance**: The signer's `dkg_private_shares()` handler accepts and processes private shares from ANY configured signer, with no validation against the expected participating set from `DkgPrivateBegin.signer_ids`: [4](#0-3) 

3. **Invalid share tracking**: When decryption fails (due to corrupted data from the malicious signer), the sender is added to `invalid_private_shares`: [5](#0-4) [6](#0-5) 

4. **Final participant set determination**: The coordinator's `start_dkg_end()` sends `DkgEndBegin` with `signer_ids` derived from `dkg_private_shares.keys()`, which may not include the malicious signer if their message didn't reach the coordinator or arrived after state transition: [7](#0-6) [8](#0-7) 

5. **Inconsistent validation**: In `dkg_ended()`, the validation loop correctly checks only signers in the coordinator-provided `signer_ids_set`: [9](#0-8) [10](#0-9) 

These validations pass for all honest participating signers. However, the subsequent check at line 611 uses the unfiltered `invalid_private_shares` map, causing failure even when the invalid shares are from non-participating signers: [11](#0-10) 

This breaks the security guarantee that DKG should complete successfully when sufficient honest signers (meeting the threshold) have valid shares, even in the presence of non-participating malicious signers.

## Impact Explanation

**Severity: Low** - This vulnerability maps to "Any remotely-exploitable denial of service in a node" from the severity criteria.

**Concrete Impact:**
- DKG cannot complete, preventing establishment of threshold signing keys
- All honest signers report `DkgStatus::Failure`, causing the coordinator to abort with `Error::DkgFailure`
- The system cannot proceed to the signing phase without valid threshold keys
- Affects all DKG participants in the round

**Scenario**: With 10 signers (threshold=7, dkg_threshold=7):
1. Attacker controls Signer A
2. Signer A doesn't send `DkgPublicShares` (excluded from participating set)
3. Signer A sends corrupted `DkgPrivateShares` to other signers
4. All 9 honest signers add Signer A to `invalid_private_shares`
5. Coordinator sends `DkgEndBegin` with only the 9 honest signers
6. Despite having 9 valid participating signers (exceeding threshold of 7), all report failure
7. DKG aborts, must be restarted

While the coordinator's `gather_dkg_end()` does identify and track malicious signers for reporting purposes, this detection occurs after the DKG round has already failed: [12](#0-11) 

The severity is Limited to Low (not High) because:
- No cryptographic security compromise occurs
- No funds are at risk
- System can recover by retrying DKG
- Attack is detectable and malicious signers are identified

## Likelihood Explanation

**Likelihood: High**

**Attacker Capabilities Required:**
- Control of a single configured signer (within threshold-1, part of normal threat model)
- Ability to send network messages during DKG private share phase
- No cryptographic capabilities or key compromise needed

**Attack Complexity: Low**
- Send corrupted `DkgPrivateShares` with malformed ciphertext (random bytes)
- Optionally avoid sending `DkgPublicShares` to ensure exclusion from participating set
- No deep protocol understanding required beyond message timing

**Economic Feasibility:**
- Minimal cost: only network bandwidth for malformed messages
- No computational resources beyond normal signer operation
- Attack repeatable at negligible cost

**Detection vs. Prevention:**
- Attack is detectable through decryption failure logs and coordinator reporting
- However, detection doesn't prevent the DoS from succeeding in the current round
- Malicious signer identified only after damage is done

**Success Probability:**
- 100% success rate if attacker controls any configured signer
- Honest signers cannot distinguish between participating vs non-participating signers until processing shares
- No existing mitigation prevents the attack

## Recommendation

Filter `invalid_private_shares` by the final participating signer set (`signer_ids_set`) before checking if DKG should proceed:

```rust
// After line 609, before line 611:
// Only consider invalid shares from signers in the final participating set
let invalid_participating_shares: HashMap<u32, BadPrivateShare> = self
    .invalid_private_shares
    .iter()
    .filter(|(signer_id, _)| signer_ids_set.contains(signer_id))
    .map(|(k, v)| (*k, v.clone()))
    .collect();

let dkg_end = if invalid_participating_shares.is_empty() {
    match self.signer.compute_secrets(
        &self.decrypted_shares,
        &self.commitments,
        &self.dkg_id.to_be_bytes(),
    ) {
        Ok(()) => DkgEnd {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            status: DkgStatus::Success,
        },
        Err(dkg_error_map) => {
            // Handle errors...
        }
    }
} else {
    DkgEnd {
        dkg_id: self.dkg_id,
        signer_id: self.signer_id,
        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
            invalid_participating_shares,
        )),
    }
};
```

Additionally, consider adding validation in `dkg_private_shares()` to check if the sender is in the expected participating set from `dkg_private_begin_msg.signer_ids` before processing their shares.

## Proof of Concept

```rust
#[test]
fn test_non_participating_signer_aborts_dkg() {
    use rand_core::OsRng;
    
    // Setup: 5 signers, threshold 3, dkg_threshold 3
    let mut rng = OsRng;
    let config = Config::new(5, 3, 3, /*...*/);
    
    // Initialize coordinator and 5 signers
    let mut coordinator = Coordinator::new(config.clone());
    let mut signers: Vec<Signer> = (0..5)
        .map(|i| Signer::new(i, /*...*/, &mut rng))
        .collect();
    
    // Phase 1: Public shares - only signers 0-3 send shares
    coordinator.start_public_shares().unwrap();
    for i in 0..4 {
        let msg = signers[i].dkg_public_begin(&mut rng).unwrap();
        coordinator.process_message(&msg).unwrap();
    }
    // Signer 4 (malicious) does NOT send public shares
    
    // Phase 2: Private shares
    let dkg_private_begin = coordinator.start_private_shares().unwrap();
    // dkg_private_begin.signer_ids contains only [0,1,2,3]
    
    for signer in &mut signers[0..4] {
        signer.dkg_private_begin(&dkg_private_begin, &mut rng).unwrap();
    }
    
    // Malicious signer 4 crafts corrupted private shares
    let corrupted_shares = DkgPrivateShares {
        dkg_id: dkg_private_begin.dkg_id,
        signer_id: 4,
        shares: vec![(0, vec![0u8; 100])], // Invalid encrypted data
    };
    
    // Send corrupted shares to honest signers 0-3
    for signer in &mut signers[0..4] {
        signer.dkg_private_shares(&corrupted_shares, &mut rng).unwrap();
        // Decryption fails, signer 4 added to invalid_private_shares
        assert!(signer.invalid_private_shares.contains_key(&4));
    }
    
    // Phase 3: DKG End
    let dkg_end_begin = coordinator.start_dkg_end().unwrap();
    // dkg_end_begin.signer_ids = [0,1,2,3] (excludes signer 4)
    
    // Honest signers call dkg_ended()
    for signer in &mut signers[0..4] {
        let result = signer.dkg_ended(&mut rng).unwrap();
        
        // VULNERABILITY: All honest signers report failure
        // even though they have 4 valid participating signers (exceeds threshold of 3)
        // and signer 4 is NOT in the final participating set
        assert_matches!(
            result,
            Message::DkgEnd(DkgEnd {
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(_)),
                ..
            })
        );
    }
    
    // Expected behavior: Signers 0-3 should succeed since they form a valid
    // participating set meeting the threshold, and signer 4's invalid shares
    // should be ignored as signer 4 is not in signer_ids
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L529-534)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L551-551)
```rust
        for signer_id in &signer_ids_set {
```

**File:** src/state_machine/signer/mod.rs (L611-660)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };
```

**File:** src/state_machine/signer/mod.rs (L1038-1041)
```rust
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };
```

**File:** src/state_machine/signer/mod.rs (L1082-1086)
```rust
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
```

**File:** src/state_machine/signer/mod.rs (L1089-1094)
```rust
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
```

**File:** src/state_machine/coordinator/fire.rs (L422-426)
```rust
        self.dkg_wait_signer_ids = self
            .dkg_public_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/coordinator/fire.rs (L434-434)
```rust
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
```

**File:** src/state_machine/coordinator/fire.rs (L451-455)
```rust
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/coordinator/fire.rs (L463-463)
```rust
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
```

**File:** src/state_machine/coordinator/fire.rs (L775-788)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }

            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```
