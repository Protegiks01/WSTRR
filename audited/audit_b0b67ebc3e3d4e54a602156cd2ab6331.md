### Title
FIRE Coordinator Returns Incorrect Aggregate Public Key Due to Duplicate Party ID Summation

### Summary
The FIRE coordinator's `dkg_end_gathered()` function computes the aggregate public key by flat-mapping over `dkg_public_shares.comms` without deduplicating party IDs, allowing a malicious signer to inflate the aggregate key by including duplicate party IDs in their DkgPublicShares message. This causes the coordinator to return an incorrect aggregate public key to users, breaking external signature verification and potentially causing consensus failures or loss of funds in blockchain integrations.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The vulnerability exists in the `dkg_end_gathered()` function where the aggregate public key is calculated by directly flat-mapping over all `comms` vectors and summing polynomial constants without deduplication.

**Root Cause:**
The FIRE coordinator computes the aggregate public key differently from how it populates `party_polynomials`. Lines 796-800 insert commitments into a HashMap (which deduplicates), while lines 803-807 flat-map and sum all commitments including duplicates. [2](#0-1) 

**Missing Validation:**
The `gather_public_shares()` function accepts DkgPublicShares messages without validating that the `comms` vector contains unique party IDs or that party IDs match the signer's configured key IDs. [3](#0-2) 

**Data Structure:**
DkgPublicShares contains a `comms` field of type `Vec<(u32, PolyCommitment)>` which can contain duplicate party IDs without restriction. [4](#0-3) 

**Comparison with FROST:**
The FROST coordinator correctly computes the aggregate key from the deduplicated `party_polynomials` HashMap, avoiding this vulnerability. [5](#0-4) 

### Impact Explanation

**Direct Impact:**
A malicious signer can cause the FIRE coordinator to return an incorrect aggregate public key via `OperationResult::Dkg`. This key would be stored by users and blockchain systems for address derivation and signature verification. [6](#0-5) 

**Signature Verification Mismatch:**
Signatures produced by the protocol would be cryptographically valid (they verify against the correct deduplicated key used by the aggregator), but users cannot verify them using the incorrect published key. The aggregator uses `party_polynomials` which is deduplicated. [7](#0-6) 

**Blockchain Integration Impact:**
In Stacks/Bitcoin integration, this maps to **High severity** under the protocol scope:
- **Chain split**: Different nodes may derive different addresses from different DKG results, causing transaction validation disagreements
- **Loss of funds**: If the incorrect aggregate key is used to derive addresses, funds sent to those addresses may be unspendable since the protocol cannot produce valid signatures for external verification
- **Consensus failure**: Different coordinator instances could return different aggregate keys from the same DKG messages if duplicate handling is non-deterministic

**Quantified Impact:**
With a single duplicate party ID (e.g., party_id=1 appears twice), the aggregate key becomes `K_agg = K_correct + K_party1` where `K_party1` is the duplicated commitment. For n duplicates of weight w, the error scales as `(n-1) * w * G`, making the key completely unusable for signature verification.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Position: Any single signer participating in DKG
- Access: Ability to send DkgPublicShares messages to coordinator
- Secrets: None beyond normal signer credentials
- Resources: Trivial computational cost

**Attack Complexity:**
The attack is straightforward:
1. Signer creates DkgPublicShares with valid commitments
2. Duplicates entries in the `comms` vector (e.g., adds party_id=1 twice)
3. Signs the message normally (packet signature covers message content, doesn't prevent duplicates)
4. Sends to coordinator

**Economic Feasibility:**
Zero additional cost beyond normal protocol participation. No cryptographic breaks required. Single malicious signer sufficient (no coordination needed).

**Detection:**
No detection mechanism exists. The coordinator accepts the message, honest signers deduplicate in their HashMap conversion (lines 556-561 in signer/mod.rs), and the protocol appears to complete successfully until external verification fails. [8](#0-7) 

**Success Probability:**
Near 100% - the coordinator has no validation to prevent this attack and will deterministically compute the wrong aggregate key.

### Recommendation

**Primary Fix:**
Change line 806 in `fire.rs` to compute the aggregate public key from `party_polynomials` instead of flat-mapping `comms`, matching the FROST coordinator implementation:

```rust
let key = self
    .party_polynomials
    .iter()
    .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```

**Additional Validation:**
Add validation in `gather_public_shares()` to check for duplicate party IDs within each signer's `comms` vector:

```rust
// After line 491, add:
let party_ids: HashSet<u32> = dkg_public_shares.comms.iter().map(|(id, _)| *id).collect();
if party_ids.len() != dkg_public_shares.comms.len() {
    warn!(signer_id = %dkg_public_shares.signer_id, "DkgPublicShares contains duplicate party_ids");
    return Ok(());
}
```

**Validation Against Config:**
Add validation that party IDs in `comms` match the signer's configured key IDs:

```rust
let Some(expected_key_ids) = self.config.public_keys.signer_key_ids.get(&dkg_public_shares.signer_id) else {
    warn!(signer_id = %dkg_public_shares.signer_id, "No key IDs configured");
    return Ok(());
};
if party_ids != *expected_key_ids {
    warn!(signer_id = %dkg_public_shares.signer_id, "Party IDs don't match configured key IDs");
    return Ok(());
}
```

**Testing:**
1. Add unit test with malicious signer sending duplicate party IDs
2. Verify coordinator rejects the message or deduplicates correctly
3. Verify aggregate key matches honest signer group keys
4. Add integration test comparing FIRE and FROST aggregate key computation

### Proof of Concept

**Exploitation Algorithm:**

1. **Malicious Signer Creates DkgPublicShares:**
   - Generate valid polynomial commitments for assigned key IDs
   - Duplicate one entry in comms: `[(1, comm1), (1, comm1), (2, comm2)]`
   - Sign the message and send to coordinator

2. **Coordinator Processing:**
   - `gather_public_shares()` accepts message (no duplicate check)
   - Stores in `dkg_public_shares[signer_id]`
   
3. **DKG Completion:**
   - Line 798: `party_polynomials.insert(1, comm1)` called twice (last wins, deduplicated)
   - Line 806: `flat_map` yields `[(1, comm1), (1, comm1), (2, comm2)]`
   - Line 807: Sums `comm1.poly[0] + comm1.poly[0] + comm2.poly[0]` (duplicate counted)
   - Returns `aggregate_public_key = P_correct + comm1.poly[0]` (incorrect)

4. **Signing Phase:**
   - Aggregator initialized with deduplicated `party_polynomials`
   - Signatures computed against correct key `P_correct`
   - Signatures valid under `P_correct`

5. **External Verification:**
   - User has incorrect `aggregate_public_key = P_correct + comm1.poly[0]`
   - Attempts to verify signature: `verify(signature, message, aggregate_public_key)`
   - **Verification fails** because signature is valid under `P_correct`, not the inflated key

**Expected vs Actual:**
- Expected: `aggregate_public_key` equals sum of unique party commitments
- Actual: `aggregate_public_key` includes duplicate commitments multiple times

**Reproduction:**
Create test with 3 signers (IDs 0,1,2), each with 1 key. Make signer 0 send `comms = [(0, C0), (0, C0)]`. Observer coordinator returns `K_agg = 2*C0[0] + C1[0] + C2[0]` instead of `C0[0] + C1[0] + C2[0]`.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L303-309)
```rust
                        return Ok((
                            None,
                            Some(OperationResult::Dkg(
                                self.aggregate_public_key
                                    .ok_or(Error::MissingAggregatePublicKey)?,
                            )),
                        ));
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L796-800)
```rust
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
        }
```

**File:** src/state_machine/coordinator/fire.rs (L803-807)
```rust
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/state_machine/coordinator/frost.rs (L434-438)
```rust
        // Calculate the aggregate public key
        let key = self
            .party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```

**File:** src/v1.rs (L329-329)
```rust
        let aggregate_public_key = self.poly[0];
```

**File:** src/state_machine/signer/mod.rs (L556-561)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
```
