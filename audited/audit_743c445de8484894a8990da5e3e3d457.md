### Title
Missing sign_iter_id Validation in FIRE Coordinator Allows Stale Signature Shares After Timeout Retry

### Summary
The FIRE coordinator's `gather_sig_shares()` function fails to validate the `sign_iter_id` field in `SignatureShareResponse` messages, while correctly incrementing `sign_iter_id` during timeout retries. This allows malicious or delayed signers to submit signature shares from previous signing iterations, causing signature verification failures and denial of service. The FROST coordinator is not affected as it lacks timeout retry logic.

### Finding Description

The vulnerability exists in the FIRE coordinator implementation at [1](#0-0) .

The `gather_sig_shares()` function validates `dkg_id` and `sign_id` fields but completely omits validation of the `sign_iter_id` field, despite this field being present in the `SignatureShareResponse` structure [2](#0-1) .

When a timeout occurs during signature share gathering, the coordinator's `process_timeout()` function correctly handles the retry [3](#0-2) . The coordinator moves back to `NonceRequest` state and calls `request_nonces()`, which properly increments `sign_iter_id` [4](#0-3) .

In contrast, the coordinator's `gather_nonces()` function correctly validates `sign_iter_id` [5](#0-4) , demonstrating that the validation should also be present in `gather_sig_shares()`.

The FROST coordinator implementation does not have this issue because it lacks timeout retry logic and never increments `sign_iter_id` after the initial signing round [6](#0-5) .

### Impact Explanation

**Specific Harm:** When a timeout occurs and the coordinator retries with an incremented `sign_iter_id`, old signature shares from the previous iteration can be accepted and mixed with nonces from the new iteration. Since signature shares are computed using a binding value derived from specific nonces, mixing signature shares from iteration N with nonces from iteration N+1 produces an invalid aggregated signature that fails verification.

**Quantified Impact:** This creates a transient consensus failure where signing rounds fail despite having sufficient honest signers. In a Stacks blockchain context, this could prevent block signing or transaction confirmation until the issue is detected and corrected, potentially affecting multiple blocks but not causing permanent chain splits.

**Who is Affected:** Any system using the FIRE coordinator implementation with timeout configurations (`sign_timeout` set). The FROST coordinator is not vulnerable.

**Severity Justification:** This is a **Medium severity** issue per the protocol scope, as it causes "transient consensus failures." It does not lead to direct fund loss, permanent chain splits, or key compromise, but can disrupt normal operations.

### Likelihood Explanation

**Required Attacker Capabilities:** A malicious signer participating in the threshold signature protocol, or a network-level attacker who can delay messages. The attacker must be able to:
1. Participate in signing rounds (legitimate protocol participant)
2. Delay or withhold signature share responses to trigger timeouts
3. Send old signature shares after timeout retry

**Attack Complexity:** Low to Medium. The attack requires:
1. Forcing a timeout by not responding promptly (trivial for a participant)
2. Submitting a delayed signature share from the previous iteration (straightforward message replay)
3. The coordinator's timeout configuration must be enabled

**Economic Feasibility:** Highly feasible. No significant resources required beyond normal protocol participation. The attack only causes temporary disruption rather than value extraction.

**Detection Risk:** Low. The failed signatures appear as normal verification failures. Without detailed logging of `sign_iter_id` values, distinguishing this attack from legitimate failures is difficult.

**Estimated Probability:** High if timeout retries are frequently triggered (network instability, malicious participants). The missing validation is systematic and will accept any signature share with matching `dkg_id` and `sign_id` regardless of `sign_iter_id`.

### Recommendation

**Primary Fix:** Add `sign_iter_id` validation in the `gather_sig_shares()` function, immediately after the existing `sign_id` validation:

```rust
if sig_share_response.sign_iter_id != self.current_sign_iter_id {
    return Err(Error::BadSignIterId(
        sig_share_response.sign_iter_id,
        self.current_sign_iter_id,
    ));
}
```

This validation should be added at [7](#0-6)  to mirror the validation pattern used in `gather_nonces()`.

**Testing Recommendations:**
1. Add unit tests simulating timeout retries with delayed signature shares from previous iterations
2. Verify that signature shares with incorrect `sign_iter_id` are rejected with `BadSignIterId` error
3. Test that legitimate retries with correct `sign_iter_id` succeed

**Deployment Considerations:** This is a backwards-compatible fix that strengthens validation. Deploy with the next security update. Monitor for increased `BadSignIterId` errors which may indicate attempted attacks or legitimate timing issues requiring timeout adjustment.

### Proof of Concept

**Attack Algorithm:**

1. **Setup:** Coordinator starts signing round with `sign_iter_id=1`, message M
   - Coordinator sends `NonceRequest(sign_iter_id=1, message=M)` to signers A, B, C

2. **Iteration 1:**
   - Signers A, B, C respond with `NonceResponse(sign_iter_id=1)` with fresh nonces
   - Coordinator sends `SignatureShareRequest(sign_iter_id=1)` with nonces from iteration 1
   - Signer A computes signature share z1_A using binding value e1 (derived from iteration 1 nonces)
   - Signer A delays sending `SignatureShareResponse(sign_iter_id=1, signature_share=z1_A)`
   - Signers B and C also don't respond
   - Timeout occurs at [8](#0-7) 

3. **Retry - Iteration 2:**
   - Coordinator increments `sign_iter_id=2` at [9](#0-8) 
   - Coordinator sends `NonceRequest(sign_iter_id=2, message=M)` to signers
   - Signers generate NEW fresh nonces [10](#0-9) 
   - Signers A and B respond with `NonceResponse(sign_iter_id=2)` with new nonces
   - Coordinator sends `SignatureShareRequest(sign_iter_id=2)` with nonces from iteration 2

4. **Attack Execution:**
   - Signer A now sends its delayed `SignatureShareResponse(sign_iter_id=1, signature_share=z1_A)` from iteration 1
   - Coordinator's `gather_sig_shares()` checks at [11](#0-10)  pass (only validates `dkg_id` and `sign_id`, not `sign_iter_id`)
   - Old signature share z1_A (computed with binding value e1) is accepted
   - Signer B sends `SignatureShareResponse(sign_iter_id=2, signature_share=z2_B)` from iteration 2

5. **Expected Behavior:** Coordinator should reject the response with `Error::BadSignIterId(1, 2)`

6. **Actual Behavior:** Coordinator accepts z1_A and attempts signature aggregation mixing shares from iterations 1 and 2, producing an invalid signature that fails verification

**Reproduction:** Configure FIRE coordinator with `sign_timeout`, trigger timeout by having signers delay responses, submit old signature share from previous iteration, observe invalid aggregated signature despite sufficient participants.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L173-204)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/fire.rs (L814-816)
```rust
    fn request_nonces(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.message_nonces.clear();
        self.current_sign_iter_id = self.current_sign_iter_id.wrapping_add(1);
```

**File:** src/state_machine/coordinator/fire.rs (L856-860)
```rust
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L998-1038)
```rust
    fn gather_sig_shares(
        &mut self,
        packet: &Packet,
        signature_type: SignatureType,
    ) -> Result<(), Error> {
        let Message::SignatureShareResponse(sig_share_response) = &packet.msg else {
            return Ok(());
        };

        let Some(response_info) = self.message_nonces.get_mut(&self.message) else {
            warn!(
                "Sign round {} SignatureShareResponse for round {} from signer {} no message nonces entry",
                self.current_sign_id, sig_share_response.sign_id, sig_share_response.signer_id,
            );
            return Ok(());
        };

        let waiting = response_info
            .sign_wait_signer_ids
            .contains(&sig_share_response.signer_id);

        if !waiting {
            warn!(
                "Sign round {} SignatureShareResponse for round {} from signer {} not in the wait list",
                self.current_sign_id, sig_share_response.sign_id, sig_share_response.signer_id,
            );
            return Ok(());
        }

        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }
```

**File:** src/net.rs (L437-448)
```rust
pub struct SignatureShareResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Signature shares from this Signer
    pub signature_shares: Vec<SignatureShare>,
}
```

**File:** src/state_machine/coordinator/frost.rs (L594-611)
```rust
    fn gather_sig_shares(
        &mut self,
        packet: &Packet,
        signature_type: SignatureType,
    ) -> Result<(), Error> {
        if let Message::SignatureShareResponse(sig_share_response) = &packet.msg {
            if sig_share_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    sig_share_response.dkg_id,
                    self.current_dkg_id,
                ));
            }
            if sig_share_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    sig_share_response.sign_id,
                    self.current_sign_id,
                ));
            }
```

**File:** src/state_machine/signer/mod.rs (L731-731)
```rust
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);
```
