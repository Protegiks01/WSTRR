# Audit Report

## Title
Unbounded Encrypted Share Size Enables Memory Exhaustion DoS During DKG

## Summary
A malicious signer can send DKG private shares with arbitrarily large encrypted payloads, causing memory and CPU exhaustion in honest signers during decryption. The `decrypt()` function has no size limits, the `DkgPrivateShares` message structure allows unbounded `Vec<u8>` values, and no validation occurs before attempting decryption. This enables a node-level denial-of-service attack that can prevent DKG completion.

## Finding Description

The vulnerability stems from three interconnected weaknesses in the DKG private share processing flow:

**1. Unbounded decrypt() function:**
The `decrypt()` function accepts arbitrary-size input data with no validation. [1](#0-0) 

The function extracts a 12-byte nonce and passes the remainder to AES-GCM decryption via `cipher.decrypt(nonce, cipher_data)?`, which allocates an output buffer proportional to the ciphertext size and processes all data regardless of size.

**2. Unbounded encrypted shares in network messages:**
The `DkgPrivateShares` struct contains `shares: Vec<(u32, HashMap<u32, Vec<u8>>)>` with no size constraints. [2](#0-1) 

Serde deserialization will allocate memory for arbitrarily large `Vec<u8>` values without any limits, as confirmed by the absence of size validation constants in the codebase.

**3. Unvalidated decryption during message processing:**
When processing incoming `DkgPrivateShares` messages, signers call `decrypt(&shared_secret, bytes)` directly on network-received data. [3](#0-2) 

The decryption occurs without prior size validation, and error handling only catches failures after resource consumption has already occurred.

**Attack Flow:**
1. Malicious signer (within threshold-1 limit) constructs a `DkgPrivateShares` message with gigabyte-sized `Vec<u8>` values
2. Signs the message with their valid ECDSA key
3. Message passes signature verification (authenticity check doesn't validate size) [4](#0-3) 
4. Honest signers deserialize the packet, allocating memory for large vectors
5. `decrypt()` attempts to process the gigabyte payload
6. Memory allocation for output buffer or CPU processing causes resource exhaustion
7. Signer node becomes unresponsive or crashes

**Why existing protections fail:**
- Signature verification validates authenticity but not content size
- No maximum message or field size limits exist anywhere in the codebase
- Error handling happens post-decryption, after resources are consumed
- Serde deserialization allocates memory before any validation occurs

This breaks the security guarantee that honest signers can complete DKG rounds when sufficient participants (threshold) are honest.

## Impact Explanation

**Severity: Low** - Maps to "Any remotely-exploitable denial of service in a node" per the defined scope.

**Specific harm:**
- Individual signer nodes experience memory exhaustion (allocation of gigabyte-sized buffers) or CPU exhaustion (processing large ciphertexts through AES-GCM)
- Targeted signers become unresponsive or crash during DKG
- If enough signers are affected, the DKG round cannot reach threshold and fails to complete
- Group key generation is blocked until the malicious signer is excluded or the attack is mitigated

**Quantified impact:**
In a DKG round with N parties and M key IDs per party, a malicious signer can send NÃ—M encrypted shares to each victim. With 1 GB payloads, this can exceed typical signer node memory limits (4-8 GB), causing immediate failure. Multiple victims can be targeted simultaneously, preventing threshold from being met.

**Scope alignment:**
This is a node-level DoS attack against individual signers during DKG. It does not:
- Directly impact the blockchain or consensus
- Cause loss of funds
- Enable persistent code execution
- Affect network-wide operations

The attack is limited to preventing DKG completion, which classifies it as Low severity per the defined impact scope.

## Likelihood Explanation

**Probability: Medium to High**

**Required capabilities:**
- Valid signer credentials (ECDSA signing key) - the attacker must be a registered signer
- Network access to send messages to other signers
- Knowledge of DKG round parameters (dkg_id)

These capabilities are within the protocol's threat model, which assumes up to threshold-1 signers may be malicious.

**Attack complexity: Low**
The attack requires only:
1. Constructing a `DkgPrivateShares` message with large `Vec<u8>` values (trivial to generate random bytes)
2. Signing with valid ECDSA key (standard protocol operation)
3. Broadcasting during DKG private share phase (normal protocol flow)

No cryptographic breaking, race conditions, or complex timing requirements exist.

**Economic feasibility: High**
- Network bandwidth cost: One-time transmission of large messages
- Computational cost: Minimal (just message signing)
- Can target multiple victims with a single malicious message
- No ongoing resource requirements

**Detection risk: Moderate**
The attack produces observable anomalies (abnormally large messages, resource exhaustion in victims) and the attacker is identifiable via their signer_id in the message. However, damage occurs before detection can prevent it.

**Overall likelihood:** High if an attacker is a registered signer (insider or compromised credentials), Medium when accounting for the prerequisite of having signer status.

## Recommendation

Implement size validation at multiple layers:

**1. Add maximum encrypted share size constant:**
```rust
// In src/util.rs or src/constants.rs
pub const MAX_ENCRYPTED_SHARE_SIZE: usize = 128; // 32-byte scalar + 12-byte nonce + 16-byte tag + overhead

pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    if data.len() > MAX_ENCRYPTED_SHARE_SIZE {
        return Err(EncryptionError::DataTooLarge);
    }
    // ... existing code
}
```

**2. Validate encrypted share sizes before processing:**
```rust
// In src/state_machine/signer/mod.rs, before line 1076
for (dst_key_id, bytes) in shares {
    if bytes.len() > MAX_ENCRYPTED_SHARE_SIZE {
        warn!("Encrypted share from signer {src_signer_id} exceeds maximum size: {} bytes", bytes.len());
        self.invalid_private_shares.insert(
            src_signer_id,
            self.make_bad_private_share(src_signer_id, rng)?,
        );
        continue;
    }
    // ... existing decryption code
}
```

**3. Add message-level size limit:**
Consider implementing a maximum total message size at the network packet level to prevent resource exhaustion during deserialization itself.

**4. Add runtime monitoring:**
Log warnings when receiving unusually large messages to detect potential attacks early.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::util::{decrypt, encrypt, make_shared_secret, create_rng};
    use crate::curve::{scalar::Scalar, point::Point};
    
    #[test]
    fn test_large_encrypted_share_causes_resource_exhaustion() {
        let mut rng = create_rng();
        
        // Setup: Create shared secret as in DKG
        let private_key = Scalar::random(&mut rng);
        let public_key = Point::from(Scalar::random(&mut rng));
        let shared_secret = make_shared_secret(&private_key, &public_key);
        
        // Attack: Create a gigantic encrypted payload
        let large_payload = vec![0u8; 100_000_000]; // 100 MB payload
        let encrypted = encrypt(&shared_secret, &large_payload, &mut rng)
            .expect("encryption should succeed");
        
        // Vulnerability: decrypt() will attempt to allocate 100 MB output buffer
        // and process all data through AES-GCM without size validation
        let start = std::time::Instant::now();
        let result = decrypt(&shared_secret, &encrypted);
        let elapsed = start.elapsed();
        
        // This demonstrates resource exhaustion:
        // - Large memory allocation (100 MB)
        // - Significant CPU time processing large ciphertext
        assert!(result.is_ok());
        assert!(elapsed.as_millis() > 10); // Processing time indicates resource usage
        println!("Decryption of 100 MB took {:?}", elapsed);
        
        // In a real attack, payloads would be gigabytes, causing:
        // - Out-of-memory errors
        // - Node unresponsiveness
        // - DKG failure
    }
}
```

This test demonstrates that arbitrarily large encrypted payloads can be processed without size validation, proving the vulnerability. In production, a malicious signer would send gigabyte-sized payloads within `DkgPrivateShares` messages to exhaust victim node resources.

### Citations

**File:** src/util.rs (L102-116)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L1076-1096)
```rust
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
```
