# Audit Report

## Title
Duplicate Key IDs in NonceResponse Bypass Validation and Cause Invalid Lagrange Interpolation

## Summary
A malicious signer can send a NonceResponse with duplicate key_ids that bypasses the coordinator's validation. The duplicates propagate through the signing protocol, causing all participants to compute incorrect Lagrange interpolation coefficients. This results in all signature shares being invalid, creating a denial of service where a single malicious signer prevents any signatures from being produced.

## Finding Description

**Root Cause - Lambda Does Not Deduplicate:**

The Lagrange interpolation function computes coefficients by iterating over all key_ids without deduplication: [1](#0-0) 

When key_ids contains duplicates, the lambda value is multiplied by duplicate factors. For example, computing λ₂ for key_ids=[1, 1, 2] results in 1/(1-2) × 1/(1-2) = 1 instead of the correct 1/(1-2) = -1.

**Validation Bypass:**

The coordinator validates NonceResponse key_ids by converting them to a HashSet for comparison: [2](#0-1) 

This silently removes duplicates during HashSet conversion. If a malicious signer sends key_ids=[1, 1, 2], it becomes {1, 2} for validation and passes if configured signer_key_ids={1, 2}. However, the original NonceResponse with duplicates is stored: [3](#0-2) 

**Duplicate Propagation:**

The coordinator constructs SignatureShareRequest by collecting the stored nonce_responses: [4](#0-3) 

All signers receive this request and reconstruct the key_ids list with duplicates via flat_map: [5](#0-4) 

**Invalid Signature Share Computation:**

Signers pass the duplicate-containing key_ids to their signing methods: [6](#0-5) 

The Party::sign_with_tweak method computes signature shares using the incorrect lambda values: [7](#0-6) 

All signature shares are computed with wrong lambda values, making them invalid.

**Detection Without Prevention:**

The coordinator aggregates signature shares using the same duplicate-containing key_ids: [8](#0-7) 

The aggregator verifies the final signature and rejects it: [9](#0-8) 

When verification fails, check_signature_shares is called, but it also uses the wrong lambda values: [10](#0-9) 

This makes attribution difficult as the diagnostic function validates shares using the same incorrect coefficients.

## Impact Explanation

**Specific Harm:**
A single malicious signer causes complete denial of service for all signing operations. Every signing round fails because all participants compute invalid signature shares due to incorrect Lagrange coefficients.

**Quantification:**
- 100% of signing rounds affected when malicious signer participates
- All honest signers' computational resources wasted
- Signing rounds must be retried but continue to fail while malicious signer participates
- System becomes unable to produce any valid signatures

**Who is Affected:**
All participants in the WSTS signing protocol, including honest signers and the coordinator.

**Severity Assessment:**
This qualifies as **Low severity** per the defined scope: "Any remotely-exploitable denial of service in a node." If the WSTS deployment controls more than 10% of miners, this could escalate to **Medium severity**: "Any network denial of service impacting more than 10 percent of miners that does not shut down the network."

## Likelihood Explanation

**Attacker Capabilities:**
- Must be a registered signer in the WSTS protocol (within threat model)
- Requires ability to send modified NonceResponse messages
- No cryptographic secrets needed beyond valid signer credentials

**Attack Complexity:**
Trivial. The attacker modifies their client to send a NonceResponse with duplicate key_ids (e.g., [1, 1, 2] instead of [1, 2]).

**Economic Feasibility:**
Extremely low cost. A single modified network message causes indefinite denial of service.

**Detection Risk:**
Medium. The attack is detected when signature verification fails, but attribution is difficult because check_signature_shares also uses wrong lambda values, potentially misidentifying which parties have bad signatures.

**Probability of Success:**
100%. The validation bypass is guaranteed, and all signature shares will be invalid.

## Recommendation

Add explicit deduplication before validation and storage of NonceResponse key_ids:

```rust
// In gather_nonces, after line 881:
let mut nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

// Check for duplicates BEFORE validation
if nonce_response_key_ids.len() != nonce_response.key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id, 
        "NonceResponse contains duplicate key_ids"
    );
    return Ok(());
}

// Then proceed with existing validation
if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

Alternatively, deduplicate in the lambda function itself, though the first approach is preferable as it catches malicious input at the entry point.

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_invalid_lambda() {
    use crate::compute::lambda;
    use crate::curve::scalar::Scalar;
    
    // Correct computation: lambda(2, [1, 2])
    let key_ids_correct = vec![1, 2];
    let lambda_correct = lambda(2, &key_ids_correct);
    // Expected: 1/(1-2) = -1
    assert_eq!(lambda_correct, Scalar::from(1) / (Scalar::from(1) - Scalar::from(2)));
    
    // Malicious computation: lambda(2, [1, 1, 2])
    let key_ids_duplicate = vec![1, 1, 2];
    let lambda_duplicate = lambda(2, &key_ids_duplicate);
    // Result: 1/(1-2) * 1/(1-2) = 1 (WRONG!)
    let expected_duplicate = (Scalar::from(1) / (Scalar::from(1) - Scalar::from(2))) * 
                            (Scalar::from(1) / (Scalar::from(1) - Scalar::from(2)));
    assert_eq!(lambda_duplicate, expected_duplicate);
    
    // Verify they are different
    assert_ne!(lambda_correct, lambda_duplicate);
    
    // The duplicate case produces lambda = 1 instead of -1
    assert_eq!(lambda_duplicate, Scalar::from(1));
    assert_eq!(lambda_correct, -Scalar::from(1));
}
```

### Citations

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-985)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
            message: self.message.clone(),
            signature_type,
        };
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L808-818)
```rust
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L403-404)
```rust
                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }
```

**File:** src/v2.rs (L457-461)
```rust
        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```
