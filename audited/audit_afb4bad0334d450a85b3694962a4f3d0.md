### Title
Key ID Collision in v1 DKG Allows Silent Polynomial Commitment Loss

### Summary
The protocol layer does not enforce uniqueness of key_ids across signers in the v1 implementation. When multiple signers claim the same key_id (party_id), their polynomial commitments pass validation but one is silently overwritten during DKG aggregation, breaking the cryptographic security guarantees and causing signature verification failures or protocol inconsistencies.

### Finding Description

The vulnerability exists in the v1 implementation's DKG flow due to missing uniqueness validation for key_ids across different signers.

**Root Cause:**

The `PublicKeys::validate()` method only validates that key_ids are within valid ranges but does NOT enforce that key_ids are disjoint across different signers: [1](#0-0) 

In v1, each signer can control multiple parties where `party_id == key_id`. The `validate_party_id` function only checks if a party_id belongs to that specific signer's key set, not global uniqueness: [2](#0-1) 

During DKG, signers send polynomial commitments for their party_ids, and the state machine validates them using this non-unique check: [3](#0-2) 

**The Critical Flaw:**

When the coordinator processes DKG completion in `dkg_end_gathered()`, it iterates through all signers' commitments and inserts them into a HashMap by party_id. If two signers both sent commitments for the same party_id, the HashMap silently overwrites the first with the second: [4](#0-3) 

This creates an inconsistent state where:
1. The aggregate public key calculation uses ALL commitments from `dkg_public_shares` (including both duplicates)
2. But `party_polynomials` only stores ONE of the duplicate commitments (the last inserted)
3. During signature verification, the aggregator uses `party_polynomials` which has the wrong/missing polynomial for that party_id

**Why Existing Mitigations Fail:**

The `set_key_and_party_polynomials` function has duplicate detection, but it's only called when initializing from saved state, not during normal DKG flow: [5](#0-4) 

Note: v2 is NOT vulnerable because it enforces `party_id == signer_id`, making party_ids inherently unique: [6](#0-5) 

### Impact Explanation

**Specific Harm:**
- One signer's polynomial commitment is silently dropped from `party_polynomials`
- The aggregate public key includes both commitments (correct) but the stored polynomials only have one (incorrect)
- Signature share verification will fail or use wrong polynomial coefficients
- Protocol cannot produce valid signatures or produces signatures that fail verification
- Breaks the fundamental FROST/WSTS security property that the group key equals the sum of all valid party commitments

**Quantified Impact:**
In a configuration with:
- Signer A controls key_ids [1, 2]
- Signer B maliciously configured to control key_ids [2, 3]
- Both participate in DKG

Result:
- Aggregate key = comm_1[0] + comm_A_2[0] + comm_B_2[0] + comm_3[0] (4 commitments)
- Stored polynomials = {1: comm_1, 2: comm_B_2, 3: comm_3} (3 polynomials, missing comm_A_2)
- Signer A's contribution for party_id 2 is lost
- Subsequent signature operations will fail or be invalid

**Severity Justification:**
This maps to **High** severity per the protocol scope:
- Causes "confirmation of an invalid transaction" if corrupted signatures are accepted (Critical scope item)
- Causes "unintended chain split" if different nodes have different DKG configurations (High scope item)
- Protocol cannot produce valid signatures, causing transaction confirmation failures
- Dependent blockchain systems would experience consensus failures

### Likelihood Explanation

**Required Attacker Capabilities:**
- Ability to influence or set the `PublicKeys` configuration
- Specifically, control over `signer_key_ids` mapping
- This typically requires:
  - Compromised coordinator setup process
  - Malicious system administrator
  - Exploited configuration injection vulnerability

**Attack Complexity:**
- LOW: Simply configure two signers with overlapping key_ids
- No cryptographic breaks required
- No special timing or network conditions needed
- The vulnerability is deterministic once the configuration exists

**Exploitation Path:**
1. Attacker configures or influences `PublicKeys.signer_key_ids` to assign the same key_id to multiple signers
2. Both signers participate normally in DKG
3. Both send valid polynomial commitments for the shared party_id
4. Coordinator accepts both (validation passes for each)
5. During `dkg_end_gathered()`, HashMap overwrites one commitment
6. Protocol reaches inconsistent state
7. Subsequent signature operations fail or produce invalid results

**Detection Risk:**
- HIGH detection difficulty: The overwrite is silent with no error or warning
- Configuration errors may appear as "normal" DKG or signing failures
- Requires code inspection to identify the root cause

**Probability Assessment:**
- Configuration mishaps: MEDIUM (human error in complex multi-signer setups)
- Deliberate exploitation: LOW (requires insider access or compromised setup process)
- Overall likelihood: MEDIUM with HIGH impact

### Recommendation

**Primary Fix:**
Add uniqueness validation to `PublicKeys::validate()` to enforce that no key_id appears in multiple signers' sets:

```rust
// In src/state_machine/mod.rs, PublicKeys::validate()
pub fn validate(&self, num_signers: u32, num_keys: u32) -> Result<(), SignerError> {
    // ... existing validation ...
    
    // NEW: Enforce key_id uniqueness across signers
    let mut seen_key_ids = HashSet::new();
    for (signer_id, key_ids) in &self.signer_key_ids {
        for key_id in key_ids {
            if !seen_key_ids.insert(*key_id) {
                return Err(SignerError::Config(ConfigError::DuplicateKeyId(*key_id)));
            }
        }
    }
    
    Ok(())
}
```

**Secondary Defense:**
Add runtime duplicate detection in `dkg_end_gathered()`:

```rust
// In src/state_machine/coordinator/fire.rs, dkg_end_gathered()
fn dkg_end_gathered(&mut self) -> Result<(), Error> {
    let mut party_polynomials = HashMap::new();
    for signer_id in self.dkg_private_shares.keys() {
        for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
            if party_polynomials.insert(*party_id, comm.clone()).is_some() {
                return Err(Error::DuplicatePartyId);
            }
        }
    }
    self.party_polynomials = party_polynomials;
    // ... rest of function ...
}
```

**Testing Recommendations:**
1. Add test case with overlapping key_ids in v1 configuration
2. Verify validation error is raised before DKG starts
3. Test that existing valid configurations still pass validation
4. Add integration test for the runtime duplicate detection

**Deployment Considerations:**
- This is a breaking change that will reject previously "accepted" configurations
- Audit all existing configurations before deploying
- Provide clear error messages indicating which key_ids are duplicated
- Document the requirement that key_ids must be unique across signers

### Proof of Concept

**Exploitation Steps:**

1. **Setup malicious configuration:**
```rust
// Signer 0 controls key_ids [1, 2]
let mut key_ids_0 = HashSet::new();
key_ids_0.insert(1);
key_ids_0.insert(2);
public_keys.signer_key_ids.insert(0, key_ids_0);

// Signer 1 maliciously also controls key_id 2
let mut key_ids_1 = HashSet::new();
key_ids_1.insert(2);
key_ids_1.insert(3);
public_keys.signer_key_ids.insert(1, key_ids_1);
```

2. **Both signers create polynomial commitments:**
    - Signer 0 creates commitments for party_ids [1, 2]
    - Signer 1 creates commitments for party_ids [2, 3]
    - Both pass `validate_party_id` checks

3. **DKG proceeds normally until dkg_end_gathered:**
    - Both send DkgPublicShares
    - Both send DkgPrivateShares
    - Both send DkgEnd with success status

4. **Coordinator processes commitments:**
```rust
// First loop iteration (signer 0):
self.party_polynomials.insert(1, comm_0_1);  // OK
self.party_polynomials.insert(2, comm_0_2);  // OK

// Second loop iteration (signer 1):
self.party_polynomials.insert(2, comm_1_2);  // OVERWRITES comm_0_2!
self.party_polynomials.insert(3, comm_1_3);  // OK
```

5. **Result:**
    - `party_polynomials` = {1: comm_0_1, 2: comm_1_2, 3: comm_1_3}
    - Missing: comm_0_2 (signer 0's commitment for party_id 2)
    - Aggregate key calculation uses all 4 commitments from dkg_public_shares
    - But stored polynomials only have 3 (with wrong one for party_id 2)

**Expected Behavior:**
- Configuration validation should reject overlapping key_ids
- OR runtime detection should return `Error::DuplicatePartyId`

**Actual Behavior:**
- Configuration passes validation
- DKG appears to complete successfully
- One polynomial commitment silently lost
- Subsequent operations fail with cryptographic errors

**Reproduction:**
1. Create v1 configuration with overlapping key_ids as shown above
2. Run DKG with both signers
3. Observe that `party_polynomials.len()` < total expected commitments
4. Attempt signing operation and observe verification failures

### Citations

**File:** src/state_machine/mod.rs (L106-136)
```rust
    pub fn validate(&self, num_signers: u32, num_keys: u32) -> Result<(), SignerError> {
        for (signer_id, _key) in &self.signers {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }
        }

        for (key_id, _key) in &self.key_ids {
            if !validate_key_id(*key_id, num_keys) {
                return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
            }
        }

        for (signer_id, key_ids) in &self.signer_key_ids {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }

            for key_id in key_ids {
                if !validate_key_id(*key_id, num_keys) {
                    return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
                }
            }
        }

        Ok(())
    }
```

**File:** src/v1.rs (L696-705)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        match signer_key_ids.get(&signer_id) {
            Some(key_ids) => key_ids.contains(&party_id),
            None => false,
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L994-1001)
```rust
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L794-812)
```rust
    fn dkg_end_gathered(&mut self) -> Result<(), Error> {
        // Cache the polynomials used in DKG for the aggregator
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
        }

        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
        self.move_to(State::Idle)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1384-1406)
```rust
    fn set_key_and_party_polynomials(
        &mut self,
        aggregate_key: Point,
        party_polynomials: Vec<(u32, PolyCommitment)>,
    ) -> Result<(), Error> {
        let computed_key = party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
        if computed_key != aggregate_key {
            return Err(Error::AggregateKeyPolynomialMismatch(
                computed_key,
                aggregate_key,
            ));
        }
        let party_polynomials_len = party_polynomials.len();
        let party_polynomials = HashMap::from_iter(party_polynomials);
        if party_polynomials.len() != party_polynomials_len {
            return Err(Error::DuplicatePartyId);
        }
        self.aggregate_public_key = Some(aggregate_key);
        self.party_polynomials = party_polynomials;
        Ok(())
    }
```

**File:** src/v2.rs (L644-650)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        _signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        signer_id == party_id
    }
```
