### Title
Denial of Service via Empty Polynomial Vector in PolyCommitment During DKG

### Summary
A malicious signer can cause honest signers and coordinators to crash by submitting a `PolyCommitment` with an empty polynomial vector during DKG. The vulnerability exists because `PolyCommitment::verify()` accesses `poly[0]` without bounds checking, causing a panic before polynomial degree validation can occur. This prevents DKG completion but does NOT bypass checks or allow threshold manipulation.

### Finding Description

The vulnerability is located in the `PolyCommitment::verify()` method: [1](#0-0) 

This function unconditionally accesses `self.poly[0]` without verifying the vector is non-empty. When an empty poly vector is provided, this causes a runtime panic with an index out of bounds error.

The `check_public_shares()` helper function compounds this issue through unsafe evaluation order: [2](#0-1) 

Due to Rust's short-circuit boolean evaluation, `poly_comm.verify(ctx)` is called BEFORE `poly_comm.poly.len() == threshold` is checked. If verify panics, the length check never executes.

**Attack Path:**

1. A malicious signer crafts a `DkgPublicShares` message containing a `PolyCommitment` with an empty poly vector. The `PolyCommitment` struct allows this because it derives `Serialize`/`Deserialize` without validation: [3](#0-2) 

2. The malicious message is deserialized and stored without validation: [4](#0-3) 

3. When `DkgEndBegin` is processed, signers call `check_public_shares()` on the stored commitments: [5](#0-4) 

4. The `verify()` call panics before the length check, crashing the node.

The coordinator has the same vulnerability: [6](#0-5) 

**Root Cause:** Missing bounds checking before array access combined with unsafe evaluation order in boolean expressions.

**Why Existing Mitigations Fail:** No validation exists at deserialization time or during message storage. The honest construction path prevents empty vectors, but the network protocol accepts arbitrary serialized data: [7](#0-6) 

### Impact Explanation

**Specific Harm:** A malicious signer participating in DKG can crash all honest signers and the coordinator by sending a single malformed message. This prevents DKG from completing successfully.

**Quantified Impact:**
- DKG fails for all participants who process the malicious commitment
- No threshold manipulation occurs (the question's hypothesis is incorrect)
- No polynomial degree checks are bypassed (nodes crash before checks complete)
- Nodes can be restarted, but DKG will fail again if the malicious signer participates

**Who is Affected:** All honest signers and coordinators participating in the same DKG round as the attacker.

**Severity Justification:** According to the provided scope, this maps to **Low severity**: "Any remotely-exploitable denial of service in a node." The attack requires the attacker to be a DKG participant but can crash multiple nodes with a single message. It does NOT cause chain-level impacts such as network shutdown, consensus failures, or fund loss.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a registered signer participating in DKG
- Requires ability to send network messages (standard participant capability)
- No cryptographic secrets or breaks required

**Attack Complexity:** Trivial. The attacker simply constructs a `PolyCommitment` with `poly: Vec::new()` and any arbitrary `id` value.

**Economic Feasibility:** Zero cost beyond normal DKG participation. The attack succeeds immediately upon message processing.

**Detection Risk:** High detectability. The crash is obvious, and the malformed message can be traced to the sender through message authentication. However, the damage (crashed nodes) occurs before detection.

**Estimated Probability:** 100% success rate if the attacker is a DKG participant. The vulnerability is deterministic and requires no timing or race conditions.

### Recommendation

**Primary Fix:** Add bounds checking before accessing `poly[0]`:

```rust
pub fn verify(&self, ctx: &[u8]) -> bool {
    if self.poly.is_empty() {
        return false;
    }
    self.id.verify(&self.poly[0], ctx)
}
```

**Defense in Depth:** Reorder the boolean expression in `check_public_shares()` to check length first:

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.poly.len() == threshold && poly_comm.verify(ctx)
}
```

**Additional Validation:** Add validation at deserialization or storage time to reject empty poly vectors immediately.

**Testing Recommendations:**
- Add unit tests for `verify()` with empty poly vectors
- Add integration tests for DKG with malformed commitments
- Fuzz test `PolyCommitment` deserialization with edge cases

**Deployment Considerations:** This is a backward-incompatible protocol change. All nodes must upgrade simultaneously, or malicious/buggy nodes could continue sending malformed commitments.

### Proof of Concept

**Exploitation Algorithm:**

1. Construct a malicious `PolyCommitment`:
```
poly_comm = PolyCommitment {
    id: ID::new(&attacker_id, &Scalar::random(), &ctx, &mut rng),
    poly: Vec::new(),  // Empty vector
}
```

2. Wrap in `DkgPublicShares`:
```
malicious_msg = DkgPublicShares {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id,
    comms: vec![(attacker_party_id, poly_comm)],
    kex_public_key: Point::generator(),
}
```

3. Send message during DKG public shares phase

**Expected Behavior:** Honest nodes should reject the commitment as invalid (empty polynomial).

**Actual Behavior:** Honest nodes panic with "index out of bounds: the len is 0 but the index is 0" when processing `DkgEndBegin`.

**Reproduction:**
- Modify any DKG test to inject a `PolyCommitment` with empty poly
- Run DKG to the `DkgEndBegin` phase
- Observe panic at `check_public_shares()` call

**Note:** The question asks whether this bypasses checks and allows threshold manipulation. The answer is **NO** - it does neither. The node crashes before any checks complete, and no threshold manipulation is possible. However, this is still a valid Low-severity DoS vulnerability.

### Citations

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L36-39)
```rust
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L1023-1025)
```rust
        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
```

**File:** src/state_machine/coordinator/fire.rs (L632-639)
```rust
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
```

**File:** src/net.rs (L141-147)
```rust
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
```
