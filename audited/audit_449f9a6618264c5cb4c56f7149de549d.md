### Title
Signer Lacks Round ID Validation Enabling Replay-Based Denial of Service

### Summary
The signer initializes `sign_id` and `sign_iter_id` to 1 but never validates these or `dkg_id` in incoming signing requests. This initialization does not prevent replay attacks. An attacker can replay legitimately signed `NonceRequest` or `SignatureShareRequest` messages from the coordinator, forcing signers to waste computational resources on elliptic curve operations for stale signing rounds that the coordinator will ultimately reject.

### Finding Description

**Exact Location:** [1](#0-0) 

The signer initializes round tracking fields that are never used for validation: [2](#0-1) 

**Root Cause:**
The signer's `nonce_request()` and `sign_share_request()` methods blindly accept incoming requests without validating that the `dkg_id`, `sign_id`, and `sign_iter_id` match the signer's expected state: [3](#0-2) [4](#0-3) 

The signer simply copies the IDs from the request into the response without verification. Additionally, the signer's `sign_id` and `sign_iter_id` fields are never updated after initialization, making them useless for tracking progression through signing rounds.

**Why Existing Mitigations Fail:**
While the coordinator validates round IDs when receiving responses from signers, this occurs AFTER the signer has already expended computational resources: [5](#0-4) 

Packet signature verification authenticates message origin but does not prevent replay of legitimately signed messages: [6](#0-5) 

### Impact Explanation

**Specific Harm:**
An attacker with network access can capture legitimately signed coordinator messages (e.g., `NonceRequest` with `dkg_id=1, sign_id=1, sign_iter_id=1`) and replay them repeatedly or during later signing rounds. Each replayed message causes the signer to:
1. Generate fresh cryptographic nonces via `gen_nonces()` (elliptic curve scalar multiplications)
2. Compute signature shares (additional curve operations)
3. Waste network bandwidth sending responses that will be rejected

**Quantification:**
- Each nonce generation requires scalar multiplications on secp256k1
- A signer controlling multiple key IDs performs operations for each key
- An attacker can replay multiple stale messages in parallel
- Coordinator rejection is quick, but signer resources are already consumed

**Affected Parties:**
All signer nodes in the WSTS network are vulnerable to computational resource exhaustion.

**Severity Justification:**
Maps to **Low severity** per audit scope: "Any remotely-exploitable denial of service in a node." The attack can degrade or temporarily disable a signer node through resource exhaustion, but does not compromise signature validity (coordinator validation prevents that) or cause chain-level impact.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Network access to observe coordinator-to-signer messages
- Ability to capture and replay packets
- No cryptographic breaks required
- No insider access or secrets needed

**Attack Complexity:**
Low. The attacker needs only:
1. Capture any legitimate `NonceRequest` or `SignatureShareRequest` from the coordinator
2. Replay the captured message to target signer(s) repeatedly
3. The packet signature remains valid (legitimate coordinator signature)
4. The signer processes each replayed message without state checks

**Economic Feasibility:**
Trivial. Network-level message capture and replay require minimal resources.

**Detection Risk:**
Medium. Coordinator logs will show rejected responses with mismatched IDs, but attributing this to malicious replay vs. legitimate network issues may be difficult.

**Probability of Success:**
High. The signer has no defense mechanism against processing replayed messages until the coordinator rejection phase.

### Recommendation

**Proposed Code Changes:**

Add round ID validation in the signer's message handlers:

```rust
fn nonce_request<R: RngCore + CryptoRng>(
    &mut self,
    nonce_request: &NonceRequest,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Validate round IDs match expected state
    if nonce_request.dkg_id != self.dkg_id {
        warn!("NonceRequest dkg_id mismatch: got {} expected {}", 
              nonce_request.dkg_id, self.dkg_id);
        return Err(Error::BadStateChange(format!(
            "NonceRequest dkg_id {} does not match signer dkg_id {}", 
            nonce_request.dkg_id, self.dkg_id
        )));
    }
    
    // existing logic...
}
```

Similar validation should be added to `sign_share_request()`.

**Alternative Mitigations:**
1. Implement message sequence numbers or timestamps with expiration
2. Maintain a cache of recently processed message hashes to detect duplicates
3. Update `sign_id` and `sign_iter_id` as signing rounds progress to enable proper validation

**Testing Recommendations:**
- Add unit tests that attempt to send requests with mismatched round IDs
- Add integration tests that replay captured messages
- Verify coordinator and signer ID progression through multiple DKG and signing rounds

**Deployment Considerations:**
This is a protocol-level change requiring coordinated deployment across all signers to maintain compatibility.

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Deploy a WSTS network with coordinator at `dkg_id=1, sign_id=1, sign_iter_id=1` and signers at `dkg_id=1, sign_id=1, sign_iter_id=1` after first DKG round.

2. **Capture**: Network attacker captures legitimate `NonceRequest`:
```
NonceRequest {
    dkg_id: 1,
    sign_id: 1, 
    sign_iter_id: 1,
    message: [/* original message bytes */],
    signature_type: SignatureType::Frost,
}
```
With valid coordinator signature in the `Packet`.

3. **Advance State**: Coordinator progresses to signing round 2: [7](#0-6) 
Now coordinator has `sign_id=2, sign_iter_id=2`.

4. **Replay Attack**: Attacker replays the captured `NonceRequest` (with `sign_id=1`) to a signer.

5. **Signer Processes**: Signer receives packet, verifies signature (passes), and processes without checking IDs: [3](#0-2) 
Signer generates fresh nonces and sends `NonceResponse` with `sign_id=1`.

6. **Coordinator Rejects**: Coordinator receives response with `sign_id=1` but expects `sign_id=2`: [8](#0-7) 
Returns `Error::BadSignId(1, 2)` and discards response.

7. **Resource Waste**: Signer has wasted CPU cycles on elliptic curve operations for a stale request.

**Expected vs Actual Behavior:**
- Expected: Signer validates IDs and rejects stale requests immediately
- Actual: Signer blindly processes stale requests, wasting resources

**Reproduction:**
Run WSTS integration tests with a modified attacker node that captures and replays coordinator messages. Monitor signer CPU usage and coordinator rejection logs to confirm resource waste.

### Citations

**File:** src/state_machine/signer/mod.rs (L199-203)
```rust
    pub dkg_id: u64,
    /// current signing round ID
    pub sign_id: u64,
    /// current signing iteration ID
    pub sign_iter_id: u64,
```

**File:** src/state_machine/signer/mod.rs (L326-328)
```rust
            dkg_id: 0,
            sign_id: 1,
            sign_iter_id: 1,
```

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L757-842)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };

            self.signer.gen_nonces(&self.network_private_key, rng);

            let response = SignatureShareResponse {
                dkg_id: sign_request.dkg_id,
                sign_id: sign_request.sign_id,
                sign_iter_id: sign_request.sign_iter_id,
                signer_id: self.signer_id,
                signature_shares,
            };
            info!(
                signer_id = %self.signer_id,
                dkg_id = %sign_request.dkg_id,
                sign_id = %sign_request.sign_id,
                sign_iter_id = %sign_request.sign_iter_id,
                "sending SignatureShareResponse"
            );

            Ok(vec![Message::SignatureShareResponse(response)])
        } else {
            debug!(signer_id = %self.signer_id, "signer not included in SignatureShareRequest");
            Ok(Vec::new())
        }
    }
```

**File:** src/state_machine/coordinator/fire.rs (L846-861)
```rust
        if let Message::NonceResponse(nonce_response) = &packet.msg {
            if nonce_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(nonce_response.dkg_id, self.current_dkg_id));
            }
            if nonce_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    nonce_response.sign_id,
                    self.current_sign_id,
                ));
            }
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1468-1476)
```rust
        if let Some(id) = sign_id {
            self.current_sign_id = id;
        } else {
            self.current_sign_id = self.current_sign_id.wrapping_add(1);
        }
        info!("Starting signing round {}", self.current_sign_id);
        self.move_to(State::NonceRequest(signature_type))?;
        self.request_nonces(signature_type)
    }
```

**File:** src/net.rs (L485-600)
```rust
impl Packet {
    /// This function verifies the packet's signature, returning true if the signature is valid,
    /// i.e. is appropriately signed by either the provided coordinator or one of the provided signer public keys
    pub fn verify(
        &self,
        signers_public_keys: &PublicKeys,
        coordinator_public_key: &ecdsa::PublicKey,
    ) -> bool {
        match &self.msg {
            Message::DkgBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgBegin message with an invalid signature.");
                    return false;
                }
            }
            Message::DkgPrivateBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgPrivateBegin message with an invalid signature.");
                    return false;
                }
            }
            Message::DkgEndBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgEndBegin message with an invalid signature.");
                    return false;
                }
            }
            Message::DkgEnd(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicEnd message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicEnd message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
            Message::NonceRequest(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a NonceRequest message with an invalid signature.");
                    return false;
                }
            }
            Message::NonceResponse(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a NonceResponse message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a NonceResponse message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
            Message::SignatureShareRequest(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a SignatureShareRequest message with an invalid signature.");
                    return false;
                }
            }
            Message::SignatureShareResponse(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!(
                            "Received a SignatureShareResponse message with an invalid signature."
                        );
                        return false;
                    }
                } else {
                    warn!(
                        "Received a SignatureShareResponse message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
        }
        true
```
