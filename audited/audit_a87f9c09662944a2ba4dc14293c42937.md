# Audit Report

## Title
Empty Polynomial in DkgPublicShares Causes Panic-Based Denial of Service

## Summary
A malicious signer can send DkgPublicShares messages containing empty polynomial vectors, causing all participants (signers and coordinators) to panic and crash when attempting to validate the shares. This vulnerability allows a single malicious participant to trigger network-wide denial of service, preventing DKG completion and blocking signature generation.

## Finding Description

The vulnerability exists in the interaction between `check_public_shares()` and `PolyCommitment::verify()`. The `PolyCommitment::verify()` method directly accesses `self.poly[0]` without checking if the vector is empty: [1](#0-0) 

The `check_public_shares()` function calls this verify method before checking the polynomial length: [2](#0-1) 

Due to Rust's left-to-right evaluation of the `&&` operator, `poly_comm.verify(ctx)` executes first. When the polynomial vector is empty, accessing `self.poly[0]` triggers an index out of bounds panic before the length check `poly_comm.poly.len() == threshold` is ever evaluated.

This validation function is called from multiple critical code paths:

**V1 Implementation:** [3](#0-2) 

**V2 Implementation:** [4](#0-3) 

**Signer State Machine:** [5](#0-4) 

**FIRE Coordinator (during malicious signer detection):** [6](#0-5) 

The attack succeeds because messages are received and stored without polynomial validation. The `dkg_public_share()` method stores the message without validating the polynomial commitments: [7](#0-6) 

The validation only occurs later during `compute_secret()`, at which point the panic has already been triggered. The DkgPublicShares struct itself allows empty polynomial vectors, as demonstrated in the existing test suite: [8](#0-7) 

## Impact Explanation

This vulnerability maps to **Low** severity as defined in the scope: "Any remotely-exploitable denial of service in a node."

A single malicious signer can crash all honest participants:
- All honest signers crash when calling `compute_secret()` with the malicious shares
- The coordinator crashes when attempting to validate `BadPublicShares` reports
- DKG cannot complete, preventing any threshold signatures from being generated
- The protocol remains offline until all nodes restart and the malicious signer is excluded

While this is a serious availability issue, it does not compromise cryptographic security, cause loss of funds, enable unauthorized signatures, or create consensus failures. The attack causes process termination through panic rather than exploiting memory safety or producing invalid cryptographic material.

## Likelihood Explanation

The likelihood of exploitation is **very high** if a malicious signer participates in DKG:

**Attacker Requirements:**
- Must be an authorized signer (within the protocol's threat model of up to threshold-1 malicious parties)
- Requires only the ability to send network messages
- No cryptographic secrets or special privileges needed

**Attack Complexity:** Trivial
1. Create a `PolyCommitment` with `poly: vec![]` (empty vector)
2. Include it in a `DkgPublicShares` message
3. Send the message during DKG public share gathering
4. All recipients panic when validating the message

**Success Rate:** 100% if the message reaches any honest participant

**Detection:** The panic is immediately visible in logs and process crashes, but identifying which signer sent the malicious message may be difficult if the coordinator crashes before logging.

## Recommendation

Fix the validation order by checking the polynomial length before accessing its elements. Replace the current implementation:

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

With:

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.poly.len() == threshold && poly_comm.verify(ctx)
}
```

This ensures the length check occurs first. If the polynomial is empty or has incorrect length, the function returns `false` without calling `verify()`, preventing the panic.

Additionally, consider adding defensive bounds checking in `PolyCommitment::verify()`:

```rust
pub fn verify(&self, ctx: &[u8]) -> bool {
    if self.poly.is_empty() {
        return false;
    }
    self.id.verify(&self.poly[0], ctx)
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_empty_polynomial_panic() {
    use crate::common::{check_public_shares, PolyCommitment};
    use crate::schnorr::ID;
    use crate::curve::scalar::Scalar;
    use crate::util::create_rng;
    
    let mut rng = create_rng();
    let ctx = 0u64.to_be_bytes();
    
    // Create a PolyCommitment with empty polynomial
    let malicious_comm = PolyCommitment {
        id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
        poly: vec![], // Empty polynomial vector
    };
    
    // This will panic with "index out of bounds"
    check_public_shares(&malicious_comm, 3, &ctx);
}
```

This test demonstrates that calling `check_public_shares()` with an empty polynomial causes a panic rather than returning `false`.

### Citations

**File:** src/common.rs (L37-39)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/v1.rs (L162-163)
```rust
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
```

**File:** src/v2.rs (L136-137)
```rust
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
```

**File:** src/state_machine/signer/mod.rs (L557-558)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
```

**File:** src/state_machine/signer/mod.rs (L1023-1024)
```rust
        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L633-637)
```rust
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
```

**File:** src/net.rs (L721-730)
```rust
        let public_shares = DkgPublicShares {
            dkg_id: 0,
            signer_id: 0,
            comms: vec![(
                0,
                PolyCommitment {
                    id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
                    poly: vec![],
                },
            )],
```
