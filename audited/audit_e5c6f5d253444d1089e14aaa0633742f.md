### Title
Unbounded Encrypted Share Size Enables Memory Exhaustion DoS During DKG

### Summary
The `decrypt()` function in `src/util.rs` has no size limit on input data, and the `DkgPrivateShares` network message allows arbitrary-size encrypted shares. A malicious signer can send extremely large encrypted shares (gigabytes) during DKG private share distribution, causing memory exhaustion and CPU exhaustion in honest signers when they attempt to decrypt these payloads, preventing DKG completion.

### Finding Description

The vulnerability exists in the decryption of DKG private shares with three contributing factors:

**1. Unbounded decrypt() function:** [1](#0-0) 

The `decrypt()` function accepts `data: &[u8]` with no size validation. It extracts a 12-byte nonce and passes the remainder to AES-GCM decryption, which will allocate memory for the output and process all ciphertext data regardless of size.

**2. Variable-size encrypted shares in network messages:** [2](#0-1) 

The `DkgPrivateShares` struct contains `shares: Vec<(u32, HashMap<u32, Vec<u8>>)>` where the `Vec<u8>` can be arbitrarily large. There are no size constraints in the struct definition or during serde deserialization.

**3. Unvalidated decryption in message processing:** [3](#0-2) 

When processing incoming `DkgPrivateShares` messages, signers call `decrypt(&shared_secret, bytes)` at line 1076 where `bytes` comes directly from the network message without size validation. The error handling only catches failures after decryption attempts, by which point resources have been consumed.

**Root cause:** The code assumes encrypted shares will be reasonably sized (normal shares are ~60 bytes: 32-byte Scalar + 12-byte nonce + 16-byte auth tag), but enforces no such constraint on received messages.

**Why existing mitigations fail:**
- Message signature verification (line 1076) validates authenticity but not content size
- Error handling (lines 1089-1095) occurs after resource consumption
- No packet size limits exist in the network layer
- Serde deserialization will allocate memory for arbitrary-size vectors without limits

### Impact Explanation

**Specific harm:**
A malicious signer can cause denial-of-service in targeted honest signers by sending DKG private share messages with extremely large encrypted payloads (e.g., 1 GB per share). When victims attempt to decrypt these payloads:
- Memory exhaustion occurs from allocating output buffers during AES-GCM decryption
- CPU exhaustion occurs from processing large ciphertexts
- The signer's message processing thread blocks or crashes

**Quantified impact:**
- In a DKG round with N parties and M key IDs per party, each signer expects N×M encrypted shares
- An attacker sending 1 GB payloads × M key IDs can exhaust memory on typical signer nodes (often 4-8 GB available)
- Multiple signers can be targeted simultaneously, preventing threshold from being met
- DKG round fails to complete, blocking group key generation

**Who is affected:**
All honest signers participating in a DKG round where a malicious signer is present.

**Severity justification:**
This maps to **Low** severity under the protocol scope definition: "Any remotely-exploitable denial of service in a node." The attack causes DoS in individual signer nodes during DKG but does not directly impact the blockchain, cause consensus failures, or lead to loss of funds.

### Likelihood Explanation

**Required attacker capabilities:**
- Must be a registered signer with valid ECDSA signing key
- Must have network access to send messages to other signers
- Knows the DKG round parameters (dkg_id)

**Attack complexity:**
Low. The attacker simply:
1. Constructs a `DkgPrivateShares` message with large `Vec<u8>` values (e.g., 1 GB of random bytes)
2. Signs the message with their valid ECDSA key
3. Broadcasts to target signers during the DKG private share phase

**Economic feasibility:**
Trivial. The attack requires minimal resources:
- Network bandwidth to send large messages (one-time cost)
- No computational work beyond message signing
- Can target multiple victims with one malicious message

**Detection risk:**
Moderate. The attack:
- Produces observable network anomalies (large message sizes)
- Causes visible resource exhaustion in victim nodes
- Leaves the attacker identifiable via their signer_id in the malicious message
- However, damage occurs before detection can prevent it

**Estimated probability:** 
High if an attacker gains signer credentials (via compromise or as an insider). Medium overall when factoring in the prerequisite of being a registered signer.

### Recommendation

**Primary mitigation - Add size validation before decryption:**

In `src/state_machine/signer/mod.rs`, add size validation before calling `decrypt()`:

```rust
// Before line 1076, add:
const MAX_ENCRYPTED_SHARE_SIZE: usize = 128; // 32-byte scalar + nonce + auth tag + margin

for (dst_key_id, bytes) in shares {
    if bytes.len() > MAX_ENCRYPTED_SHARE_SIZE {
        warn!("Encrypted share from signer {} exceeds size limit: {} bytes", 
              src_signer_id, bytes.len());
        self.invalid_private_shares.insert(
            src_signer_id,
            self.make_bad_private_share(src_signer_id, rng)?,
        );
        continue;
    }
    if key_ids.contains(dst_key_id) {
        // existing decrypt logic...
    }
}
```

**Alternative mitigations:**
1. Add a global constant for maximum message/packet size and enforce during deserialization
2. Configure serde deserializers with size limits for Vec types
3. Implement network-layer message size limits before processing

**Testing recommendations:**
1. Unit test: Verify decrypt rejects oversized inputs
2. Integration test: Send DkgPrivateShares with large payloads and verify rejection
3. Fuzz test: Random large message sizes to ensure consistent handling
4. Load test: Verify normal DKG operation with size limits in place

**Deployment considerations:**
- Backwards compatible: honest signers already send small shares
- Coordinate deployment: ensure all signers upgrade before next DKG round
- Monitor: log size limit violations to detect attack attempts

### Proof of Concept

**Exploitation algorithm:**

1. **Setup**: Attacker is registered signer with ID `attacker_id` and valid ECDSA key `attacker_key`

2. **Craft malicious message**:
```
dkg_id = <current_round_id>
large_payload = vec![0u8; 1_000_000_000]  // 1 GB of zeros
shares = vec![(attacker_party_id, HashMap::from([
    (target_key_id_1, large_payload.clone()),
    (target_key_id_2, large_payload.clone()),
    // ... for each target key ID
]))]
msg = DkgPrivateShares { dkg_id, signer_id: attacker_id, shares }
```

3. **Sign and send**:
```
signature = ecdsa_sign(msg.hash(), attacker_key)
packet = Packet { msg, sig: signature }
broadcast(packet)
```

4. **Expected victim behavior**:
   - Victim receives packet, validates signature (passes)
   - Victim calls `dkg_private_shares()` handler
   - At line 1076: `decrypt(&shared_secret, large_payload)`
   - Decrypt allocates ~1 GB for output buffer
   - Memory exhaustion or OOM kill occurs
   - DKG round cannot complete

**Reproduction instructions:**
1. Set up WSTS DKG with 3+ signers
2. Modify one signer to send 1 GB encrypted shares in DkgPrivateShares
3. Observe target signers experiencing memory exhaustion during message processing
4. Verify DKG fails to complete due to missing shares from crashed/blocked signers

**Parameter values:**
- Payload size: 1 GB (exceeds typical node memory when combined with other allocations)
- Number of shares: N×M where N=parties, M=key_ids (typically 10-100 total)
- Attack bandwidth: ~1-10 GB total depending on number of targets

### Citations

**File:** src/util.rs (L102-116)
```rust
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/state_machine/signer/mod.rs (L1072-1099)
```rust
        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
```
