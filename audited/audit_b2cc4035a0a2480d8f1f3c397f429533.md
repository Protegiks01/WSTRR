### Title
DKG Private Shares HashMap Overwrite via Duplicate Party IDs Enables Denial of Service

### Summary
The `dkg_private_shares()` function processes incoming private shares without validating for duplicate `src_id` (party_id) entries in the shares vector. A malicious signer can exploit this by sending a `DkgPrivateShares` message containing duplicate party IDs, causing the HashMap insertion at line 1099 to overwrite previously decrypted shares and resulting in incomplete share data that fails DKG validation.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The `dkg_private_shares()` function iterates over `dkg_private_shares.shares`, which is defined as a `Vec<(u32, HashMap<u32, Vec<u8>>)>` [2](#0-1)  without checking for duplicate `src_id` values. At line 1099, `self.decrypted_shares.insert(*src_id, decrypted_shares)` uses HashMap's insert method, which overwrites any existing entry for the same key.

The loop structure at [3](#0-2)  processes each `(src_id, shares)` tuple sequentially. For each iteration, a fresh `decrypted_shares` HashMap is created (line 1073), populated with decrypted shares for the current `src_id`, then inserted into `self.decrypted_shares` at line 1099. If the incoming `shares` Vec contains multiple entries with the same `src_id`, the last one completely replaces all previous entries for that `src_id`.

**Why Existing Mitigations Fail**:

1. Party ID ownership validation [4](#0-3)  only verifies each party_id belongs to the sender, not that party_ids are unique within the message.

2. Duplicate message detection [5](#0-4)  prevents receiving multiple DkgPrivateShares messages from the same signer_id, but doesn't validate the internal structure of a single message.

3. Packet signature verification [6](#0-5)  ensures message authenticity but not structural correctness.

### Impact Explanation

**Specific Harm**: A malicious signer can cause DKG failure by sending incomplete share data to other signers, preventing distributed key generation from completing successfully.

**Mechanism**: When duplicate party_ids exist in the shares Vec, later entries overwrite earlier ones. If the first entry contains `{dst_key_1: share1, dst_key_2: share2}` and the second entry contains `{dst_key_3: share3}`, only `dst_key_3` remains after processing. When `compute_secrets()` [7](#0-6)  is called, the missing shares for `dst_key_1` and `dst_key_2` cause `DkgError::MissingPrivateShares` validation failure [8](#0-7) .

**Who is Affected**: Any signer receiving the malicious DkgPrivateShares message will experience DKG failure, requiring a restart of the entire DKG process.

**Severity**: **Low** - Maps to "Any remotely-exploitable denial of service in a node" from the protocol scope. The attack prevents DKG completion but does not affect existing keys, signatures, or cause chain-level impacts.

### Likelihood Explanation

**Required Attacker Capabilities**:
- Must be a legitimate participating signer in the DKG round
- Must have valid network private key for message signing
- Must be able to craft custom `DkgPrivateShares` messages (requires control over message construction)

**Attack Complexity**: Low. The attacker simply constructs a DkgPrivateShares message with duplicate party_id entries in the shares vector. Example structure:
```
DkgPrivateShares {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id,
    shares: vec![
        (party_id_A, HashMap{ key1: enc_share1, key2: enc_share2 }),
        (party_id_A, HashMap{ key3: enc_share3 })  // Duplicate - causes overwrite
    ]
}
```

**Detection Risk**: Medium. DKG failure would be detected, but attributing it to a specific malicious signer requires analyzing the received messages, which may not be automatically logged or audited.

**Economic Feasibility**: High for an insider. No additional resources beyond existing signer credentials required.

**Estimated Probability**: High (>80%) for a malicious insider signer. The attack reliably causes DKG failure and bypasses all current validations.

### Recommendation

**Primary Fix**: Add duplicate detection before processing the shares vector:

```rust
// After line 1061, before line 1063
let mut seen_party_ids = HashSet::new();
for (party_id, _) in &dkg_private_shares.shares {
    if !seen_party_ids.insert(*party_id) {
        warn!("Signer {src_signer_id} sent duplicate party_id {party_id} in DkgPrivateShares");
        return Ok(vec![]);
    }
}
```

**Alternative Mitigation**: Convert the shares processing loop to use a HashMap with entry API to detect duplicates:

```rust
for (src_id, shares) in &dkg_private_shares.shares {
    if self.decrypted_shares.contains_key(src_id) {
        warn!("Duplicate src_id {src_id} in DkgPrivateShares from signer {src_signer_id}");
        return Ok(vec![]);
    }
    // ... rest of decryption logic
}
```

**Testing Recommendations**:
1. Unit test: Create a DkgPrivateShares message with duplicate party_ids and verify rejection
2. Integration test: Simulate malicious signer sending duplicates and verify DKG doesn't fail
3. Fuzz testing: Generate random DkgPrivateShares messages with various duplicate patterns

**Deployment Considerations**: This is a backward-compatible change that only adds validation. No protocol version changes needed. Should be deployed as a security patch to all nodes.

### Proof of Concept

**Exploitation Steps**:

1. Attacker (legitimate signer with ID=1, controlling party_id=1) participates in DKG
2. During private share distribution phase, attacker constructs malicious message:
   - First entry: `(party_id=1, {dst_key_0: valid_encrypted_share_0, dst_key_1: valid_encrypted_share_1})`
   - Second entry: `(party_id=1, {dst_key_2: valid_encrypted_share_2})`
3. Attacker signs message with valid network_private_key
4. Attacker broadcasts message to network

**Processing at Victim Signer**:
- Line 1047-1056: Both party_id=1 entries pass ownership validation (both belong to signer_id=1)
- Line 1058-1061: First DkgPrivateShares from signer_id=1, so passes duplicate message check
- Line 1072: Loop begins, processes first entry
  - Line 1073: Creates `decrypted_shares = {}`
  - Lines 1074-1097: Decrypts and adds dst_key_0 and dst_key_1 shares
  - Line 1099: `self.decrypted_shares.insert(1, {0: share0, 1: share1})`
- Line 1072: Loop continues, processes second entry
  - Line 1073: Creates new `decrypted_shares = {}`
  - Lines 1074-1097: Decrypts and adds dst_key_2 share only
  - Line 1099: `self.decrypted_shares.insert(1, {2: share2})` **OVERWRITES PREVIOUS**
- Final state: `self.decrypted_shares[1] = {2: share2}` (missing keys 0 and 1)

**Expected Behavior**: All three shares retained: `self.decrypted_shares[1] = {0: share0, 1: share1, 2: share2}`

**Actual Behavior**: Only last entry retained: `self.decrypted_shares[1] = {2: share2}`

**DKG Failure**: When `dkg_ended()` calls `compute_secrets()`, the validation at [8](#0-7)  detects missing shares for dst_key_0 and dst_key_1, returning `DkgError::MissingPrivateShares`. The signer sends `DkgEnd` with failure status [9](#0-8) , aborting the DKG round.

### Citations

**File:** src/state_machine/signer/mod.rs (L463-469)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/signer/mod.rs (L601-608)
```rust
        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
```

**File:** src/state_machine/signer/mod.rs (L612-616)
```rust
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
```

**File:** src/state_machine/signer/mod.rs (L1029-1110)
```rust
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/net.rs (L192-199)
```rust
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```

**File:** src/v2.rs (L146-163)
```rust
        let mut missing_shares = Vec::new();
        for dst_key_id in &self.key_ids {
            for src_key_id in public_shares.keys() {
                match private_shares.get(dst_key_id) {
                    Some(shares) => {
                        if shares.get(src_key_id).is_none() {
                            missing_shares.push((*dst_key_id, *src_key_id));
                        }
                    }
                    None => {
                        missing_shares.push((*dst_key_id, *src_key_id));
                    }
                }
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }
```
