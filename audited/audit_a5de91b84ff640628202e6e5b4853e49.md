### Title
Missing Polynomial Commitment Validation Allows DKG to Complete with Invalid Group Key

### Summary
When a party has `self.f = None`, the `Party::get_poly_commitment()` function returns `None`, causing the commitment to be silently excluded from DKG. The signer state machine validation only checks if the commitments list is completely empty, not whether all expected parties have submitted commitments. This allows DKG to complete successfully with an incomplete set of polynomial commitments, producing an invalid group key that is missing contributions from one or more parties.

### Finding Description

**Root Cause**: The validation logic in the signer state machine fails to verify that each signer sends commitments for all their assigned key IDs.

When `Party::get_poly_commitment()` is called with `self.f = None`, it logs a warning and returns `None`: [1](#0-0) 

The `Signer::get_poly_commitments()` implementation silently skips `None` commitments: [2](#0-1) 

The signer state machine creates `DkgPublicShares` messages using only the non-None commitments: [3](#0-2) 

**Why Existing Validation Fails**: The signer's `dkg_ended()` method only validates whether `comms` is completely empty, not whether it contains the expected number of commitments: [4](#0-3) 

This validation checks `shares.comms.is_empty()` but does not compare `shares.comms.len()` against the expected number of key IDs from `self.public_keys.signer_key_ids.get(signer_id)`. If a signer controls 3 key IDs but only sends 2 commitments (because one party has `f = None`), the validation passes.

The coordinator similarly lacks validation and blindly inserts whatever commitments are received: [5](#0-4) 

When computing the aggregate public key, only the received commitments are summed: [6](#0-5) 

**How `f = None` Occurs**: Parties can have `f = None` through legitimate operations:
- Loading from saved state where `polynomial = None` [7](#0-6) 
- Calling `clear_polys()` after DKG completion [8](#0-7) 

### Impact Explanation

**Specific Harm**: DKG completes successfully but produces an invalid group key that is missing polynomial contributions from one or more parties. The group key equals the sum of only the received commitments, not all expected parties.

**Quantified Impact**: 
- If a signer with 3 key IDs has 1 party with `f = None`, the group key will be missing 1/n of the expected contributions (where n = total key IDs)
- Each party derives a private key share that corresponds to this incorrect group key
- Signatures produced using these shares will verify under the incorrect group key, but NOT under the correct expected group key
- In a blockchain context where the expected group key is registered or verified independently, all signatures will be invalid

**Who is Affected**: All participants in the DKG round and any downstream systems relying on the group key.

**Severity Justification**: **Critical** - This directly violates the DKG invariant "Group public key must equal the sum of valid polynomial constants." The invalid group key can cause:
- **Confirmation of invalid transactions** if the incorrect group key is used for verification (in-scope: "confirmation of an invalid transaction")
- **Direct loss of funds** if the group key cannot sign valid transactions because it doesn't match registered keys (in-scope: "causing the direct loss of funds")
- **Chain split** if different nodes have different expectations about the correct group key (in-scope: "chain split caused by different nodes processing the same block or transaction and yielding different results")

### Likelihood Explanation

**Required Prerequisites**:
1. A signer must have one or more parties with `f = None` when `get_poly_commitments()` is called
2. The signer must control multiple key IDs (at least 2) so that `comms` is non-empty but incomplete
3. Normal DKG protocol execution

**Attack Complexity**: Low to Medium
- **Unintentional trigger**: A signer saves state after calling `clear_polys()`, then crashes and reloads. If DKG is initiated without calling `reset_polys()` first, the vulnerability triggers automatically.
- **Intentional exploitation**: An attacker controlling a signer node can deliberately call `clear_poly()` on specific parties before DKG, causing their commitments to be excluded.

**Economic Feasibility**: High - requires controlling a signer node, which in a permissioned setup means being a legitimate participant. No additional resources needed beyond normal participation.

**Detection Risk**: Low - The warning "get_poly_commitment called with no polynomial" is logged, but this doesn't abort DKG and may be overlooked in normal operation. The resulting invalid group key will only be detected when signatures fail verification against the expected key.

**Probability of Success**: High - Once the condition is triggered, DKG will complete successfully 100% of the time with an invalid group key due to the missing validation.

### Recommendation

**Primary Fix**: Add validation in `dkg_ended()` to verify that each signer sends commitments for all their assigned key IDs:

```rust
// In src/state_machine/signer/mod.rs, dkg_ended() function, after line 551:
for signer_id in &signer_ids_set {
    let expected_key_ids = match self.public_keys.signer_key_ids.get(signer_id) {
        Some(ids) => ids,
        None => {
            missing_public_shares.insert(*signer_id);
            continue;
        }
    };
    
    if let Some(shares) = self.dkg_public_shares.get(signer_id) {
        if shares.comms.is_empty() {
            missing_public_shares.insert(*signer_id);
        } else if shares.comms.len() != expected_key_ids.len() {
            // NEW VALIDATION: Check count matches
            missing_public_shares.insert(*signer_id);
        } else {
            // Verify each party_id in comms belongs to this signer
            let received_party_ids: HashSet<u32> = shares.comms.iter().map(|(id, _)| *id).collect();
            if received_party_ids != *expected_key_ids {
                missing_public_shares.insert(*signer_id);
            }
            // existing validation continues...
        }
    } else {
        missing_public_shares.insert(*signer_id);
    }
}
```

**Secondary Fix**: Add assertion in `get_poly_commitments()` to prevent silent failures:

```rust
// In src/v1.rs, get_poly_commitments() function:
fn get_poly_commitments<RNG: RngCore + CryptoRng>(
    &self,
    ctx: &[u8],
    rng: &mut RNG,
) -> Vec<PolyCommitment> {
    let mut polys = Vec::new();
    for party in &self.parties {
        let comm = party.get_poly_commitment(ctx, rng);
        if let Some(poly) = &comm {
            polys.push(poly.clone());
        } else {
            // Convert warning to error
            panic!("Party {} has no polynomial during DKG", party.id);
        }
    }
    polys
}
```

**Testing Recommendations**:
1. Add test case where a signer calls `clear_poly()` on one party before DKG
2. Verify that DKG now fails with `MissingPublicShares` error
3. Test state save/load cycle to ensure polynomials are properly restored

**Deployment Considerations**: This is a breaking change that will cause previously-passing DKG rounds to fail if any party has `f = None`. Ensure all nodes call `reset_polys()` before initiating DKG.

### Proof of Concept

**Exploitation Algorithm**:

1. **Setup**: Create a signer with multiple key IDs (e.g., [1, 2, 3])
2. **Trigger condition**: Call `clear_poly()` on party with key_id=2
3. **Initiate DKG**: Start normal DKG protocol
4. **Observe**: 
   - `get_poly_commitments()` returns only 2 commitments (for key_ids 1 and 3)
   - `DkgPublicShares` message contains only 2 entries in `comms`
   - Validation in `dkg_ended()` checks `comms.is_empty()` â†’ false, passes
   - Validation does NOT check `comms.len() == 3`, so passes
5. **Result**: DKG completes successfully with group key = sum of commitments from key_ids 1 and 3 only

**Reproduction Steps**:

```rust
// Based on test pattern from src/v1.rs
let mut rng = create_rng();
let mut signer = v1::Signer::new(0, &[1, 2, 3], 10, 7, &mut rng);

// Trigger vulnerability: clear one party's polynomial
signer.parties[1].clear_poly(); // Party with key_id=2

// Run DKG normally
let ctx = 0u64.to_be_bytes();
let comms = signer.get_poly_commitments(&ctx, &mut rng);
assert_eq!(comms.len(), 2); // VULNERABILITY: Only 2 commitments instead of 3

// This would proceed through state machine and complete DKG
// with an invalid group key missing party 2's contribution
```

**Expected vs Actual Behavior**:
- **Expected**: DKG should fail with an error indicating that signer 0 is missing commitment for key_id=2
- **Actual**: DKG completes successfully with a group key computed from only 2 of the 3 expected commitments

### Citations

**File:** src/v1.rs (L68-84)
```rust
    pub fn load(id: u32, n: u32, t: u32, group_key: &Point, state: &traits::PartyState) -> Self {
        assert_eq!(state.private_keys.len(), 1);
        assert_eq!(state.private_keys[0].0, id);

        let private_key = state.private_keys[0].1;

        Self {
            id,
            num_keys: n,
            threshold: t,
            f: state.polynomial.clone(),
            public_key: private_key * G,
            private_key,
            group_key: *group_key,
            nonce: state.nonce.clone(),
        }
    }
```

**File:** src/v1.rs (L107-123)
```rust
    pub fn get_poly_commitment<RNG: RngCore + CryptoRng>(
        &self,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Option<PolyCommitment> {
        if let Some(poly) = &self.f {
            Some(PolyCommitment {
                id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
                poly: (0..poly.data().len())
                    .map(|i| &poly.data()[i] * G)
                    .collect(),
            })
        } else {
            warn!("get_poly_commitment called with no polynomial");
            None
        }
    }
```

**File:** src/v1.rs (L613-626)
```rust
    fn get_poly_commitments<RNG: RngCore + CryptoRng>(
        &self,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Vec<PolyCommitment> {
        let mut polys = Vec::new();
        for party in &self.parties {
            let comm = party.get_poly_commitment(ctx, rng);
            if let Some(poly) = &comm {
                polys.push(poly.clone());
            }
        }
        polys
    }
```

**File:** src/v1.rs (L634-638)
```rust
    fn clear_polys(&mut self) {
        for party in self.parties.iter_mut() {
            party.clear_poly();
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L551-566)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L862-883)
```rust
        let comms = self
            .signer
            .get_poly_commitments(&self.dkg_id.to_be_bytes(), rng);

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            "sending DkgPublicShares"
        );

        let mut public_share = DkgPublicShares {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            comms: Vec::new(),
            kex_public_key: self.kex_private_key * G,
        };

        for poly in &comms {
            public_share
                .comms
                .push((poly.id.id.get_u32(), poly.clone()));
        }
```

**File:** src/state_machine/coordinator/frost.rs (L318-321)
```rust
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            for (party_id, comm) in &dkg_public_shares.comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
```

**File:** src/state_machine/coordinator/frost.rs (L435-438)
```rust
        let key = self
            .party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```
