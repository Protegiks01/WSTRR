### Title
DkgBegin Message Lacks Monotonic dkg_id Validation Enabling DKG Replay Attacks

### Summary
The signer's DkgBegin message handler does not validate that incoming dkg_id values are monotonically increasing, allowing attackers to replay old coordinator-signed DkgBegin messages. This forces targeted signers to reset to outdated DKG round IDs, partitioning the signer network and preventing successful DKG completion when threshold requirements cannot be met.

### Finding Description

**Code Location:** 
- Message structure: [1](#0-0) 
- Vulnerable handler: [2](#0-1) 
- State reset: [3](#0-2) 

**Root Cause:**
When a signer receives a DkgBegin message through the process function [4](#0-3) , it unconditionally accepts the dkg_id and calls reset with that value. The reset function sets `self.dkg_id = dkg_id` without verifying that the new dkg_id is greater than the current value, violating the state machine invariant that "Round IDs (dkg_id, sign_id, sign_iter_id) must match expected values" and "State transitions must be ordered and unskippable."

**Why Existing Mitigations Fail:**
While the coordinator validates dkg_id on incoming responses from signers [5](#0-4)  and [6](#0-5) , this only causes the coordinator to reject mismatched messages. It does not prevent signers from accepting replayed DkgBegin messages with stale dkg_id values. The signature verification [7](#0-6)  confirms the message is from the legitimate coordinator but cannot distinguish between a fresh message and a replayed old message, as there is no nonce or timestamp in the DkgBegin structure.

### Impact Explanation

**Specific Harm:**
An attacker can partition the WSTS signer network by forcing different signers onto incompatible DKG rounds. When the coordinator initiates DKG round N, an attacker with captured old DkgBegin messages can replay DkgBegin(dkg_id=M, M<N) to targeted signers. These signers reset to dkg_id=M and respond with that dkg_id, causing the coordinator to reject their messages. If the attacker affects enough signers that the remaining honest signers cannot meet the dkg_threshold, the DKG round fails entirely.

**Quantified Impact:**
- If `dkg_threshold = t` and `total_signers = n`, an attacker needs to target `(n - t + 1)` signers to prevent DKG completion
- With typical threshold configurations (e.g., t=7, n=10), compromising 4 signers prevents DKG
- Failed DKG prevents establishment of new group keys, impacting key rotation and system recovery scenarios
- This creates a network partition where affected signers operate on incompatible DKG round IDs

**Severity Justification:**
This qualifies as **High severity** under the scope definition "Any unintended chain split or network partition." The attack partitions the signer network into groups on different dkg_id values that cannot cooperatively complete DKG. This is beyond simple node-level DoS (Low severity) as it affects network-wide coordination and prevents threshold operations.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. **Network Access:** Ability to send messages to signer nodes (standard network access to WSTS protocol ports)
2. **Message Capture:** Ability to observe and store DkgBegin messages from previous rounds (publicly observable on the network)
3. **No Cryptographic Breaks:** Attack uses valid coordinator signatures from old messages; no need to forge signatures

**Attack Complexity:**
- **Low Complexity:** Simple message replay attack requiring basic network access
- **Race Condition Advantage:** Attacker can race coordinator's legitimate DkgBegin messages or exploit network delays
- **Persistent Effect:** Once a signer resets to old dkg_id, it remains stuck until receiving a new valid DkgBegin with higher dkg_id

**Economic Feasibility:**
- Minimal cost: requires only network bandwidth and storage for captured messages
- No expensive cryptographic operations needed
- Can be executed repeatedly using the same captured messages

**Detection Risk:**
- Low detection risk: replayed messages have valid signatures and proper structure
- Coordinator will see threshold failures but may not immediately identify cause as replay attack
- No obvious forensic evidence distinguishes replay from legitimate stale messages

**Success Probability:**
High - the attack is reliable when targeting sufficient signers, as there is no defense mechanism preventing acceptance of old dkg_id values.

### Recommendation

**Primary Fix - Monotonic dkg_id Validation:**
Add validation in the signer's dkg_begin function to reject dkg_id values that are not strictly greater than the current value:

```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Reject non-increasing dkg_id to prevent replay attacks
    if dkg_begin.dkg_id <= self.dkg_id {
        warn!(
            "Rejected DkgBegin with non-increasing dkg_id: {} <= {}",
            dkg_begin.dkg_id, self.dkg_id
        );
        return Ok(vec![]);
    }
    
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Alternative Mitigation - Nonce-Based Replay Prevention:**
Add a nonce or timestamp to DkgBegin messages and track processed values:
- Include `nonce: u64` field in DkgBegin structure
- Maintain `seen_nonces: HashSet<u64>` in signer state
- Reject messages with duplicate nonces

**Testing Recommendations:**
1. Unit test: Verify dkg_begin rejects messages with dkg_id <= current_dkg_id
2. Integration test: Attempt to replay old DkgBegin during active DKG round
3. Negative test: Confirm legitimate DkgBegin with incremented dkg_id succeeds
4. Threshold test: Verify attack fails when insufficient signers are targeted

**Deployment Considerations:**
- Backward compatibility: All signers must upgrade simultaneously to maintain consensus on dkg_id progression
- Migration: Ensure initial dkg_id values are synchronized across all signers
- Monitoring: Add alerting for rejected DkgBegin messages to detect replay attempts

### Proof of Concept

**Attack Algorithm:**

```
Prerequisites:
- Attacker has network access to signer nodes
- Captured DkgBegin packet with dkg_id=1 from early system operation
- System is currently on dkg_id=100

Attack Steps:
1. Monitor for coordinator initiating new DKG (DkgBegin with dkg_id=101)
2. Before target signers receive legitimate message, send replayed DkgBegin(dkg_id=1)
3. Target signers process replayed message and reset to dkg_id=1
4. Coordinator receives DkgPublicShares responses with dkg_id=1
5. Coordinator rejects these as mismatched (expecting dkg_id=101)
6. If targeting >= (n - dkg_threshold + 1) signers, DKG fails

Expected Behavior (with fix):
- Signers reject DkgBegin(dkg_id=1) as dkg_id <= 100
- Signers accept only DkgBegin(dkg_id=101) 
- DKG proceeds normally with all eligible signers

Actual Behavior (current code):
- Signers accept DkgBegin(dkg_id=1) and reset state
- Signers respond with dkg_id=1 in DkgPublicShares
- Coordinator rejects responses, DKG fails to meet threshold
```

**Reproduction Instructions:**
1. Start WSTS system with signers A, B, C and dkg_threshold=2
2. Complete initial DKG with dkg_id=1, capture DkgBegin packet
3. Progress system to dkg_id=10
4. Have coordinator initiate new DKG with dkg_id=11
5. Before signers A and B receive coordinator's message, send replayed DkgBegin(dkg_id=1)
6. Observe signers A and B reset to dkg_id=1
7. Observe coordinator reject their DkgPublicShares due to dkg_id mismatch
8. Observe DKG failure due to insufficient responses (only signer C on correct dkg_id=11)

### Citations

**File:** src/net.rs (L125-137)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG begin message from coordinator to signers
pub struct DkgBegin {
    /// DKG round ID
    pub dkg_id: u64,
}

impl Signable for DkgBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
    }
}
```

**File:** src/net.rs (L494-498)
```rust
            Message::DkgBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgBegin message with an invalid signature.");
                    return false;
                }
```

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L472-472)
```rust
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L479-483)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
```

**File:** src/state_machine/coordinator/fire.rs (L527-532)
```rust
            if dkg_private_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_private_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```
