# Audit Report

## Title
DKG Signer List Mismatch Allows Unvalidated Shares in Private Key Computation

## Summary
The `can_dkg_end()` function checks two different signer lists (`dkg_private_begin.signer_ids` and `dkg_end_begin.signer_ids`) without enforcing consistency between them. This allows private shares from signers excluded from the final DKG participant list to be included in private key computation without their commitments being validated or included in the group public key, violating the fundamental DKG invariant `private_key * G == group_key` and rendering all generated signatures invalid.

## Finding Description

The vulnerability exists in the DKG finalization logic across three functions:

**1. can_dkg_end() checks inconsistent signer lists:**

The function requires public shares from signers in `dkg_private_begin.signer_ids` but only requires private shares from signers in `dkg_end_begin.signer_ids`. [1](#0-0) 

These two lists can legitimately differ when the coordinator excludes slow-responding signers between DKG phases, as seen in the FireCoordinator implementation where `dkg_end_begin.signer_ids` is dynamically set to only signers who sent private shares to the coordinator. [2](#0-1) 

**2. dkg_private_shares() accepts shares from ANY signer:**

When a signer receives DkgPrivateShares messages, it processes and stores them in `self.decrypted_shares` regardless of whether the sender is in any coordinator-specified signer list. The only checks are for valid signer_id and party_id. [3](#0-2) 

**3. dkg_ended() only validates commitments from dkg_end_begin signers:**

When DKG completes, commitments are only processed and validated for signers in `dkg_end_begin.signer_ids`, but `self.decrypted_shares` contains shares from ALL signers who sent DkgPrivateShares. [4](#0-3) 

**4. compute_secret() sums unvalidated shares:**

In the v2 implementation, when computing the private key, shares from parties without corresponding commitments receive only a warning but are still included in the final private key sum via `shares.values().sum()`. Meanwhile, the group public key only includes commitments from the validated subset. [5](#0-4) 

**Attack Scenario:**

1. Signers [1,2,3,4,5] send DkgPublicShares (broadcast)
2. Coordinator sends DkgPrivateBegin with `signer_ids=[1,2,3,4,5]`
3. Signers [1,2,3,4,5] send DkgPrivateShares (broadcast to all signers)
4. Each signer receives and stores shares from all 5 parties in `self.decrypted_shares`
5. Coordinator sends DkgEndBegin with `signer_ids=[1,2,3]` (excluding slow signers 4,5)
6. Each signer's `dkg_ended()` processes commitments only from parties [1,2,3]
7. But `compute_secret()` sums shares from ALL parties [1,2,3,4,5]
8. Result: `private_key = f₁(j) + f₂(j) + f₃(j) + f₄(j) + f₅(j)` but `group_key = f₁(0)·G + f₂(0)·G + f₃(0)·G`

This breaks the fundamental DKG security guarantee that each signer's private key share, when multiplied by the generator point, equals their contribution to the group public key.

## Impact Explanation

This vulnerability has **Critical** severity as it maps to "confirmation of an invalid transaction" in the scope definition.

When the DKG completes with this inconsistency:
- All signature shares will be computed using incorrect private keys that include contributions from excluded signers
- The aggregated signature will be mathematically invalid under the group public key
- Signature verification will fail: the Schnorr verification equation `R + c·A == s·G` cannot hold when `A` (group key) doesn't match the private key used to generate `s`
- The threshold signature scheme becomes completely non-functional, preventing any valid transaction signatures from being produced

This renders the entire signing system inoperable, blocking transaction confirmation indefinitely until a new DKG round is successfully completed without this mismatch.

## Likelihood Explanation

**High Likelihood** - This vulnerability can manifest in two ways:

**Scenario 1: Normal Network Operation (No Attacker Required)**
- Network latency naturally causes different signers to respond at different speeds
- Coordinator includes all initial responders in DkgPrivateBegin
- Some signers send DkgPrivateShares with delays or experience packet loss to the coordinator
- Coordinator times out waiting and sends DkgEndBegin with only confirmed responsive signers
- All other signers have already received and processed the broadcast DkgPrivateShares
- DKG completes with broken keys

**Scenario 2: Malicious Coordinator**
- Coordinator deliberately manipulates the `signer_ids` lists between phases
- No cryptographic attack or key compromise needed
- Simply requires sending different lists in DkgPrivateBegin vs DkgEndBegin messages

The vulnerability requires no special attacker capabilities beyond standard network participation and will naturally occur in production environments with variable network conditions.

## Recommendation

**Fix Option 1: Enforce Signer List Consistency**

Modify `can_dkg_end()` to require that both messages use identical signer lists:

```rust
pub fn can_dkg_end(&self) -> bool {
    if self.state == State::DkgPrivateGather {
        if let Some(dkg_private_begin) = &self.dkg_private_begin_msg {
            if let Some(dkg_end_begin) = &self.dkg_end_begin_msg {
                // NEW: Enforce signer list consistency
                let private_signers: HashSet<_> = dkg_private_begin.signer_ids.iter().collect();
                let end_signers: HashSet<_> = dkg_end_begin.signer_ids.iter().collect();
                if private_signers != end_signers {
                    warn!("Signer list mismatch between DkgPrivateBegin and DkgEndBegin");
                    return false;
                }
                
                // Existing checks...
                for signer_id in &dkg_private_begin.signer_ids {
                    if !self.dkg_public_shares.contains_key(signer_id) {
                        return false;
                    }
                }
                for signer_id in &dkg_end_begin.signer_ids {
                    if !self.dkg_private_shares.contains_key(signer_id) {
                        return false;
                    }
                }
                return true;
            }
        }
    }
    false
}
```

**Fix Option 2: Filter Decrypted Shares Before Key Computation**

Modify `dkg_ended()` to filter `self.decrypted_shares` to only include parties from signers in `dkg_end_begin.signer_ids` before passing to `compute_secrets()`:

```rust
let filtered_shares: HashMap<u32, HashMap<u32, Scalar>> = self.decrypted_shares
    .iter()
    .filter(|(party_id, _)| {
        // Check if this party_id belongs to a signer in dkg_end_begin.signer_ids
        signer_ids_set.iter().any(|signer_id| {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
                key_ids.contains(party_id)
            } else {
                false
            }
        })
    })
    .map(|(k, v)| (*k, v.clone()))
    .collect();

match self.signer.compute_secrets(&filtered_shares, &self.commitments, &self.dkg_id.to_be_bytes()) {
    // ...
}
```

**Fix Option 3: Strict Validation in compute_secret()**

Make `compute_secret()` return an error instead of warning when shares lack corresponding commitments:

```rust
for (sender, s) in shares {
    if let Some(comm) = public_shares.get(sender) {
        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
            bad_shares.push(*sender);
        }
    } else {
        // Change from warn to error
        return Err(DkgError::MissingCommitmentForShare(*sender));
    }
}
```

**Recommended Approach:** Implement Fix Option 1 as the primary defense (fail-fast at state validation) AND Fix Option 3 as defense-in-depth (fail-safe at computation).

## Proof of Concept

```rust
#[test]
fn test_dkg_signer_list_mismatch() {
    use crate::state_machine::signer::Signer;
    use crate::v2;
    
    // Setup: 5 signers, threshold=3
    let num_signers = 5u32;
    let keys_per_signer = 1u32;
    let threshold = 3u32;
    
    let mut rng = OsRng;
    let mut signers: Vec<Signer<v2::Signer>> = Vec::new();
    
    // Create 5 signers
    for i in 0..num_signers {
        let signer = create_signer(i, num_signers, keys_per_signer, threshold, &mut rng);
        signers.push(signer);
    }
    
    // Phase 1: All 5 signers send DkgPublicShares
    let public_packets = signers.iter_mut()
        .map(|s| s.dkg_begin(&create_dkg_begin(0), &mut rng).unwrap())
        .collect::<Vec<_>>();
    
    // All signers receive all public shares
    for packet in &public_packets {
        for signer in &mut signers {
            signer.dkg_public_share(packet).unwrap();
        }
    }
    
    // Phase 2: Coordinator sends DkgPrivateBegin with signer_ids=[0,1,2,3,4]
    let private_begin = create_dkg_private_begin(0, vec![0,1,2,3,4]);
    for signer in &mut signers {
        signer.dkg_private_begin(&private_begin, &mut rng).unwrap();
    }
    
    // Phase 3: All 5 signers send DkgPrivateShares (broadcast)
    let private_packets = signers.iter_mut()
        .map(|s| s.generate_private_shares(&mut rng))
        .collect::<Vec<_>>();
    
    // All signers receive all private shares
    for packets in &private_packets {
        for packet in packets {
            for signer in &mut signers {
                signer.dkg_private_shares(packet, &mut rng).unwrap();
            }
        }
    }
    
    // Phase 4: Coordinator sends DkgEndBegin with ONLY signer_ids=[0,1,2]
    let end_begin = create_dkg_end_begin(0, vec![0,1,2]); // Excluding signers 3,4
    for signer in &mut signers {
        signer.dkg_end_begin(&end_begin).unwrap();
    }
    
    // Verify vulnerability: can_dkg_end() returns true
    assert!(signers[0].can_dkg_end(), "DKG should proceed despite signer list mismatch");
    
    // Each signer computes keys
    for signer in &mut signers {
        let result = signer.dkg_ended(&mut rng).unwrap();
        // Should succeed but produces broken keys
        assert_eq!(result.status, DkgStatus::Success);
    }
    
    // Verify the invariant is broken
    let signer0 = &signers[0];
    let private_key = signer0.signer.get_private_key(0).unwrap();
    let group_key = signer0.signer.get_group_key();
    
    // This should fail: private_key * G should equal group_key
    assert_ne!(
        private_key * G, 
        group_key,
        "VULNERABILITY: Private key includes shares from signers [0,1,2,3,4] but group key only from [0,1,2]"
    );
}
```

This test demonstrates that when `dkg_end_begin.signer_ids` excludes signers who already sent private shares, the DKG completes successfully but produces keys that violate the fundamental invariant, making all future signatures invalid.

### Citations

**File:** src/state_machine/signer/mod.rs (L504-620)
```rust
    pub fn dkg_ended<R: RngCore + CryptoRng>(&mut self, rng: &mut R) -> Result<Message, Error> {
        if !self.can_dkg_end() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadState),
            }));
        }

        // only use the public shares from the DkgEndBegin signers
        let mut missing_public_shares = HashSet::new();
        let mut missing_private_shares = HashSet::new();
        let mut bad_public_shares = HashSet::new();
        let threshold: usize = self.threshold.try_into().unwrap();

        let Some(dkg_end_begin) = &self.dkg_end_begin_msg else {
            // no cached DkgEndBegin message
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadState),
            }));
        };

        // fist check to see if dkg_threshold has been met
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
        let mut num_dkg_keys = 0u32;
        for id in &signer_ids_set {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(id) {
                let len: u32 = key_ids.len().try_into()?;
                num_dkg_keys = num_dkg_keys.saturating_add(len);
            }
        }

        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
        }

        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }

        if !missing_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPublicShares(missing_public_shares)),
            }));
        }

        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }

        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
        }

        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
```

**File:** src/state_machine/signer/mod.rs (L685-721)
```rust
    pub fn can_dkg_end(&self) -> bool {
        debug!(
            "can_dkg_end: state {:?} DkgPrivateBegin {} DkgEndBegin {}",
            self.state,
            self.dkg_private_begin_msg.is_some(),
            self.dkg_end_begin_msg.is_some(),
        );

        if self.state == State::DkgPrivateGather {
            if let Some(dkg_private_begin) = &self.dkg_private_begin_msg {
                // need public shares from active signers
                for signer_id in &dkg_private_begin.signer_ids {
                    if !self.dkg_public_shares.contains_key(signer_id) {
                        debug!("can_dkg_end: false, missing public shares from signer {signer_id}");
                        return false;
                    }
                }

                if let Some(dkg_end_begin) = &self.dkg_end_begin_msg {
                    // need private shares from active signers
                    for signer_id in &dkg_end_begin.signer_ids {
                        if !self.dkg_private_shares.contains_key(signer_id) {
                            debug!("can_dkg_end: false, missing private shares from signer {signer_id}");
                            return false;
                        }
                    }
                    debug!("can_dkg_end: true");

                    return true;
                }
            }
        } else {
            debug!("can_dkg_end: false, bad state {:?}", self.state);
            return false;
        }
        false
    }
```

**File:** src/state_machine/signer/mod.rs (L1028-1110)
```rust
    /// handle incoming DkgPrivateShares
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/fire.rs (L448-475)
```rust
    /// Ask signers to compute shares and send DKG end
    pub fn start_dkg_end(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting DkgEnd Distribution"
        );

        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
        let dkg_end_begin_msg = Packet {
            sig: dkg_end_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgPrivateBegin"),
            msg: Message::DkgEndBegin(dkg_end_begin),
        };
        self.move_to(State::DkgEndGather)?;
        self.dkg_end_start = Some(Instant::now());
        Ok(dkg_end_begin_msg)
    }
```

**File:** src/v2.rs (L123-201)
```rust
    pub fn compute_secret(
        &mut self,
        private_shares: &HashMap<u32, HashMap<u32, Scalar>>,
        public_shares: &HashMap<u32, PolyCommitment>,
        ctx: &[u8],
    ) -> Result<(), DkgError> {
        self.private_keys.clear();
        self.group_key = Point::zero();

        let threshold: usize = self.threshold.try_into()?;

        let mut bad_ids = Vec::new();
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }

        let mut missing_shares = Vec::new();
        for dst_key_id in &self.key_ids {
            for src_key_id in public_shares.keys() {
                match private_shares.get(dst_key_id) {
                    Some(shares) => {
                        if shares.get(src_key_id).is_none() {
                            missing_shares.push((*dst_key_id, *src_key_id));
                        }
                    }
                    None => {
                        missing_shares.push((*dst_key_id, *src_key_id));
                    }
                }
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }

        let mut bad_shares = Vec::new();
        for key_id in &self.key_ids {
            if let Some(shares) = private_shares.get(key_id) {
                for (sender, s) in shares {
                    if let Some(comm) = public_shares.get(sender) {
                        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
                            bad_shares.push(*sender);
                        }
                    } else {
                        warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", sender);
                    }
                }
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }
        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }

        for key_id in &self.key_ids {
            self.private_keys.insert(*key_id, Scalar::zero());
            if let Some(shares) = private_shares.get(key_id) {
                let secret = shares.values().sum();
                self.private_keys.insert(*key_id, secret);
            } else {
                warn!(
                    "no private shares for key_id {}, even though we checked for it above",
                    key_id
                );
            }
        }

        Ok(())
```
