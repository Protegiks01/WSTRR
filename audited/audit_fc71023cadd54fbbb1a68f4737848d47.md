### Title
DKG Signer List Mismatch Allows Unvalidated Shares in Private Key Computation

### Summary
The `can_dkg_end()` function uses different signer lists from `dkg_private_begin_msg` and `dkg_end_begin_msg` without validation, allowing private shares from signers excluded from `dkg_end_begin_msg` to be included in the final private key computation without their commitments being validated or included in the group public key. This breaks the fundamental DKG invariant that `private_key * G == group_key`, rendering all generated signatures invalid.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**

The `can_dkg_end()` function checks for completeness using two different signer lists without validating they match: [2](#0-1) 

It requires public shares from all signers in `dkg_private_begin.signer_ids` but only requires private shares from signers in `dkg_end_begin.signer_ids`. These lists are created by the coordinator at different phases and can legitimately differ in normal operation when signers drop out between phases. [3](#0-2) [4](#0-3) 

When `dkg_ended()` processes the DKG completion, it only validates and includes commitments from signers in `dkg_end_begin.signer_ids`: [5](#0-4) 

However, `self.decrypted_shares` contains shares from ALL signers who sent DkgPrivateShares, regardless of whether they're in `dkg_end_begin.signer_ids`: [6](#0-5) 

In the v2 `compute_secret()` function, shares without corresponding commitments are not validated but are still included in the private key sum: [7](#0-6) [8](#0-7) 

The warning at line 174 does not prevent the unvalidated share from being summed at line 191.

**Why Existing Mitigations Fail:**

The threshold check at line 543 prevents having too few signers but does not prevent including extra unvalidated shares. The commitment validation at lines 556-562 only processes signers in `dkg_end_begin.signer_ids`, missing signers who sent shares but aren't in that list.

### Impact Explanation

**Specific Harm:**

When signers in `dkg_private_begin.signer_ids` are excluded from `dkg_end_begin.signer_ids` but have already sent private shares, the resulting DKG produces inconsistent keys:

- **Private keys** include contributions from ALL parties whose shares were decrypted (both included and excluded signers)
- **Group public key** only includes commitments from parties in `dkg_end_begin.signer_ids`

This violates the fundamental DKG property: `private_key * G ≠ group_key`

**Concrete Impact:**

1. All signature shares generated with the incorrect private keys will fail verification when aggregated
2. The aggregated signature will be invalid under the group public key
3. This maps to **Critical severity**: "confirmation of an invalid transaction" - the threshold signature scheme cannot produce valid signatures, breaking transaction confirmation

**Quantified Impact:**

With realistic parameters (5 signers, threshold=3, dkg_threshold=3):
- If signers [1,2,3,4,5] send public shares
- Signers [1,2,3,4,5] send private shares  
- Coordinator sends DkgEndBegin with only [1,2,3]
- Each signer computes: private_key = f₁(j) + f₂(j) + f₃(j) + f₄(j) + f₅(j)
- But group_key = f₁(0)·G + f₂(0)·G + f₃(0)·G
- Result: private_key · G ≠ group_key, all signatures invalid

**Who is Affected:**

All signers participating in the DKG round, and any system relying on signatures from that key.

### Likelihood Explanation

**Required Attacker Capabilities:**

**Scenario 1 - Normal Operation (No attacker needed):**
- Occurs naturally when network latency causes signers to respond at different times
- Coordinator includes fast responders in DkgPrivateBegin
- Some signers send private shares late or fail to send them
- Coordinator sends DkgEndBegin with only the responsive subset
- Honest signers accept this and compute broken keys

**Scenario 2 - Malicious Coordinator:**
- Coordinator can arbitrarily manipulate which signers are included in each message
- No cryptographic secrets required
- Simply send different signer lists in DkgPrivateBegin vs DkgEndBegin

**Attack Complexity:**

Low - the vulnerability triggers in the normal protocol flow when timing varies between signers.

**Economic Feasibility:**

No additional cost - happens due to natural network conditions or coordinator misconfiguration.

**Detection Risk:**

Low - the DKG appears to complete successfully. The break only becomes apparent when trying to use the keys for signing, at which point all signatures fail validation.

**Estimated Probability:**

High - this will occur in production environments with variable network latency or any coordinator implementation that doesn't carefully synchronize the signer lists between DKG phases.

### Recommendation

**Proposed Fix:**

Add validation in `can_dkg_end()` to ensure the signer lists match:

```rust
pub fn can_dkg_end(&self) -> bool {
    if self.state == State::DkgPrivateGather {
        if let Some(dkg_private_begin) = &self.dkg_private_begin_msg {
            if let Some(dkg_end_begin) = &self.dkg_end_begin_msg {
                // NEW: Validate that signer lists match
                let private_signers: HashSet<u32> = 
                    dkg_private_begin.signer_ids.iter().copied().collect();
                let end_signers: HashSet<u32> = 
                    dkg_end_begin.signer_ids.iter().copied().collect();
                
                if private_signers != end_signers {
                    debug!("can_dkg_end: false, signer lists don't match");
                    return false;
                }
                
                // Continue with existing checks...
```

**Alternative Mitigation:**

Modify `compute_secret()` to reject (not just warn) when shares lack corresponding commitments:

```rust
// In v2.rs compute_secret(), replace line 173-175:
} else {
    bad_shares.push(*sender); // Treat as bad share instead of warning
}
```

**Testing Recommendations:**

1. Add unit test with mismatched signer lists and verify DKG fails appropriately
2. Add integration test simulating delayed signer responses
3. Verify that private_key * G == group_key after DKG completes

**Deployment Considerations:**

This fix may cause more DKG rounds to fail when signers have inconsistent response times. The coordinator should be updated to ensure consistent signer list management across DKG phases.

### Proof of Concept

**Exploitation Steps:**

1. **Setup:** 5 signers (each with 1 key_id), threshold=3, dkg_threshold=3

2. **DKG Public Phase:**
   - All signers [1,2,3,4,5] broadcast DkgPublicShares with their polynomial commitments
   - Each commitment contains the polynomial constant f_i(0)·G

3. **Coordinator sends DkgPrivateBegin:**
   - Message contains `signer_ids = [1,2,3,4,5]`
   - All signers prepare to send private shares

4. **DKG Private Phase:**
   - All signers [1,2,3,4,5] send DkgPrivateShares
   - Each signer decrypts received shares into `self.decrypted_shares`

5. **Coordinator sends DkgEndBegin:**
   - Message contains `signer_ids = [1,2,3]` (excludes 4,5)
   - Can be intentional (malicious) or due to timeout (honest but buggy)

6. **Signer receives DkgEndBegin, runs can_dkg_end():**
   - Checks public shares from [1,2,3,4,5]: all present ✓
   - Checks private shares from [1,2,3]: all present ✓
   - Returns **true**

7. **Signer runs dkg_ended():**
   - Only adds commitments from signers [1,2,3] to `self.commitments`
   - Calls `compute_secrets(&self.decrypted_shares, &self.commitments, ...)`
   - `self.decrypted_shares` contains shares from parties [1,2,3,4,5]
   - `self.commitments` contains commitments only from parties [1,2,3]

8. **compute_secret() executes:**
   - Validates shares from parties [1,2,3] against commitments ✓
   - For shares from parties [4,5]: logs warning "no corresponding public share" 
   - Does NOT add parties [4,5] to `bad_shares`
   - Computes: `private_key = share₁ + share₂ + share₃ + share₄ + share₅`
   - Computes: `group_key = f₁(0)·G + f₂(0)·G + f₃(0)·G`

9. **Result - Broken DKG:**
   - `private_key · G = (f₁(j) + f₂(j) + f₃(j) + f₄(j) + f₅(j)) · G`
   - This equals `f₁(j)·G + f₂(j)·G + f₃(j)·G + f₄(j)·G + f₅(j)·G`
   - But `group_key = f₁(0)·G + f₂(0)·G + f₃(0)·G`
   - Therefore: `private_key · G ≠ group_key` ❌

10. **Signing Phase Failure:**
    - When signers attempt to create signature shares, the shares will be computed using the incorrect private keys
    - The aggregated signature will fail verification under the group_key
    - All transactions using this key will be rejected

**Expected vs Actual Behavior:**

- **Expected:** DKG should fail if signer participation changes between phases, or all signers should be consistently included/excluded
- **Actual:** DKG succeeds with inconsistent key material, producing unusable keys

### Citations

**File:** src/state_machine/signer/mod.rs (L529-566)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
        let mut num_dkg_keys = 0u32;
        for id in &signer_ids_set {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(id) {
                let len: u32 = key_ids.len().try_into()?;
                num_dkg_keys = num_dkg_keys.saturating_add(len);
            }
        }

        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
        }

        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L685-721)
```rust
    pub fn can_dkg_end(&self) -> bool {
        debug!(
            "can_dkg_end: state {:?} DkgPrivateBegin {} DkgEndBegin {}",
            self.state,
            self.dkg_private_begin_msg.is_some(),
            self.dkg_end_begin_msg.is_some(),
        );

        if self.state == State::DkgPrivateGather {
            if let Some(dkg_private_begin) = &self.dkg_private_begin_msg {
                // need public shares from active signers
                for signer_id in &dkg_private_begin.signer_ids {
                    if !self.dkg_public_shares.contains_key(signer_id) {
                        debug!("can_dkg_end: false, missing public shares from signer {signer_id}");
                        return false;
                    }
                }

                if let Some(dkg_end_begin) = &self.dkg_end_begin_msg {
                    // need private shares from active signers
                    for signer_id in &dkg_end_begin.signer_ids {
                        if !self.dkg_private_shares.contains_key(signer_id) {
                            debug!("can_dkg_end: false, missing private shares from signer {signer_id}");
                            return false;
                        }
                    }
                    debug!("can_dkg_end: true");

                    return true;
                }
            }
        } else {
            debug!("can_dkg_end: false, bad state {:?}", self.state);
            return false;
        }
        false
    }
```

**File:** src/state_machine/signer/mod.rs (L1058-1102)
```rust
        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L432-435)
```rust
        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
            key_ids: vec![],
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/v2.rs (L166-176)
```rust
        for key_id in &self.key_ids {
            if let Some(shares) = private_shares.get(key_id) {
                for (sender, s) in shares {
                    if let Some(comm) = public_shares.get(sender) {
                        if s * G != compute::poly(&compute::id(*key_id), &comm.poly)? {
                            bad_shares.push(*sender);
                        }
                    } else {
                        warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", sender);
                    }
                }
```

**File:** src/v2.rs (L188-192)
```rust
        for key_id in &self.key_ids {
            self.private_keys.insert(*key_id, Scalar::zero());
            if let Some(shares) = private_shares.get(key_id) {
                let secret = shares.values().sum();
                self.private_keys.insert(*key_id, secret);
```
