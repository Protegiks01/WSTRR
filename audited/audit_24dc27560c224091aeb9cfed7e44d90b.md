# Audit Report

## Title
Coordinator Panic Due to Premature Wait List Removal Before Signature Share Validation

## Summary
The `gather_sig_shares()` function in the FireCoordinator removes signers from the wait list before validating their signature share responses. When validation subsequently fails, the signer remains in `public_nonces` but is absent from `signature_shares`, causing a panic during aggregation when the code attempts to index into the BTreeMap. A single malicious signer can exploit this to crash the coordinator and prevent transaction signing.

## Finding Description

The vulnerability exists in the FireCoordinator's `gather_sig_shares()` function where the ordering of operations creates a critical invariant violation. [1](#0-0) 

The function checks if a signer is in the wait list, then immediately removes them: [2](#0-1) 

However, critical validation checks occur AFTER this removal: [3](#0-2) 

These validations can fail and return errors (e.g., at lines 1050-1052 for missing public key, or lines 1063 for missing key IDs, or lines 1075 for mismatched key_ids). When validation fails, the function returns an error without adding the signer to `signature_shares`: [4](#0-3) 

The signer was already removed from the wait list (line 1042-1044) but was never added to `signature_shares`. Meanwhile, the signer's entry remains in `public_nonces` from the earlier nonce gathering phase. [5](#0-4) 

When all other (honest) signers respond successfully, the wait list becomes empty and aggregation proceeds: [6](#0-5) 

At line 1134, the code iterates over all signers in `public_nonces` and attempts to access their shares via BTreeMap indexing: `self.signature_shares[i]`. Since `signature_shares` is a BTreeMap and the failed signer's ID is not present, Rust's Index trait implementation panics. [7](#0-6) 

The error handler in the `process()` function only catches returned errors, not panics: [8](#0-7) 

**Attack Scenario:**
1. Malicious signer participates normally in DKG and nonce gathering (gets added to `public_nonces`)
2. During signature share gathering, malicious signer sends a response with incorrect `key_ids` that don't match their configured keys
3. The coordinator removes the signer from the wait list (line 1042-1044)
4. Validation fails at line 1073-1076, returning an error
5. The signer is NOT added to `signature_shares`
6. Other honest signers respond successfully, emptying the wait list
7. Aggregation begins and panics at line 1134 when accessing the missing entry

## Impact Explanation

This vulnerability has **Critical** severity impact:

- **Coordinator Crash**: The panic causes complete coordinator node failure with no graceful error handling or recovery mechanism
- **Transaction Signing Failure**: The signing round fails permanently, preventing any transactions requiring threshold signatures from being confirmed
- **Persistent DoS**: The malicious signer is never marked as malicious, allowing them to repeat the attack on every subsequent signing attempt
- **Manual Intervention Required**: The coordinator must be manually restarted after each attack

If WSTS coordinators are used in blockchain systems (e.g., Stacks) for signing Bitcoin transactions, this maps directly to the Critical severity definition: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks." The attacker can indefinitely prevent transaction confirmation by repeating this attack.

## Likelihood Explanation

This vulnerability has **High** likelihood:

**Attacker Capabilities Required:**
- Control of a single signer within the threshold set (within threat model)
- Ability to send network messages to the coordinator (standard protocol operation)
- No cryptographic secrets or primitive breaks required

**Attack Complexity:**
- **Low**: The attacker simply sends a SignatureShareResponse with mismatched `key_ids`
- No race conditions or timing requirements
- Deterministic outcome (100% success rate)

**Economic Feasibility:**
- **High**: If the attacker is already a signer, there are no additional costs
- Attack requires minimal computational resources

**Detection Difficulty:**
- **High**: The panic occurs during aggregation, not during the malicious signer's message processing, making attribution difficult
- No logging of which signer caused the validation failure before the panic

## Recommendation

Reorder the operations in `gather_sig_shares()` to remove the signer from the wait list ONLY after all validations pass and the shares are successfully added to `signature_shares`. This is the pattern already correctly implemented in the FrostCoordinator. [9](#0-8) 

The fix should move the wait list removal from line 1042-1044 to after line 1090 in the FireCoordinator implementation. Additionally, consider using safe indexing (`.get()`) instead of direct indexing (`[]`) during aggregation to prevent panics and provide better error messages.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "no entry found for key")]
fn test_premature_wait_list_removal_causes_panic() {
    use crate::curve::{point::Point, scalar::Scalar};
    use crate::net::{Message, NonceResponse, Packet, PublicNonce, SignatureShare, SignatureShareResponse};
    use crate::state_machine::coordinator::{Config, State};
    use hashbrown::HashSet;
    
    let mut rng = create_rng();
    let config = Config::new(2, 2, 2, Scalar::random(&mut rng));
    let mut coordinator = FireCoordinator::<v2::Aggregator>::new(config.clone());
    
    // Setup: Complete DKG and set up for signing
    coordinator.current_dkg_id = 0;
    coordinator.current_sign_id = 0;
    coordinator.state = State::NonceGather(SignatureType::Frost);
    
    // Both signers send valid nonces
    for signer_id in 0..2 {
        let nonce_response = NonceResponse {
            dkg_id: 0,
            sign_id: 0,
            sign_iter_id: 0,
            signer_id,
            key_ids: vec![signer_id],
            nonces: vec![PublicNonce {
                D: Point::from(Scalar::random(&mut rng)),
                E: Point::from(Scalar::random(&mut rng)),
            }],
            message: vec![0u8],
        };
        let packet = Packet {
            msg: Message::NonceResponse(nonce_response),
            sig: Default::default(),
        };
        coordinator.gather_nonces(&packet, SignatureType::Frost).unwrap();
    }
    
    coordinator.state = State::SigShareGather(SignatureType::Frost);
    
    // Malicious signer (id=0) sends signature share with WRONG key_ids
    let malicious_sig_share = SignatureShareResponse {
        dkg_id: 0,
        sign_id: 0,
        sign_iter_id: 0,
        signer_id: 0,
        signature_shares: vec![SignatureShare {
            id: 0,
            z_i: Scalar::random(&mut rng),
            key_ids: vec![999], // WRONG KEY_ID!
        }],
    };
    let packet = Packet {
        msg: Message::SignatureShareResponse(malicious_sig_share),
        sig: Default::default(),
    };
    
    // This returns an error due to validation failure
    let result = coordinator.gather_sig_shares(&packet, SignatureType::Frost);
    assert!(result.is_err()); // Validation failed
    
    // But signer was removed from wait list and NOT added to signature_shares
    assert!(!coordinator.signature_shares.contains_key(&0));
    
    // Honest signer (id=1) sends valid signature share
    let honest_sig_share = SignatureShareResponse {
        dkg_id: 0,
        sign_id: 0,
        sign_iter_id: 0,
        signer_id: 1,
        signature_shares: vec![SignatureShare {
            id: 1,
            z_i: Scalar::random(&mut rng),
            key_ids: vec![1],
        }],
    };
    let packet = Packet {
        msg: Message::SignatureShareResponse(honest_sig_share),
        sig: Default::default(),
    };
    
    // This will trigger aggregation since wait list is now empty
    // The aggregation code will panic when trying to access signature_shares[0]
    coordinator.gather_sig_shares(&packet, SignatureType::Frost).unwrap();
    // PANIC OCCURS HERE at line 1134: self.signature_shares[i]
}
```

This test demonstrates that when a signer sends an invalid signature share response, they are removed from the wait list but not added to `signature_shares`, causing a panic during aggregation when the code attempts to access the missing BTreeMap entry.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L45-45)
```rust
    signature_shares: BTreeMap<u32, Vec<SignatureShare>>,
```

**File:** src/state_machine/coordinator/fire.rs (L327-333)
```rust
                State::SigShareGather(signature_type) => {
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L998-1002)
```rust
    fn gather_sig_shares(
        &mut self,
        packet: &Packet,
        signature_type: SignatureType,
    ) -> Result<(), Error> {
```

**File:** src/state_machine/coordinator/fire.rs (L1015-1044)
```rust
        let waiting = response_info
            .sign_wait_signer_ids
            .contains(&sig_share_response.signer_id);

        if !waiting {
            warn!(
                "Sign round {} SignatureShareResponse for round {} from signer {} not in the wait list",
                self.current_sign_id, sig_share_response.sign_id, sig_share_response.signer_id,
            );
            return Ok(());
        }

        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }

        // we were waiting on you, and you sent a packet for this sign round, so we won't take
        // another packet from you
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1076)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };

        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1113-1135)
```rust
        if message_nonce.sign_wait_signer_ids.is_empty() {
            // Calculate the aggregate signature
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/state_machine/coordinator/frost.rs (L613-656)
```rust
            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
                warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
                return Ok(());
            };

            // check that the key_ids match the config
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&sig_share_response.signer_id)
            else {
                warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
            }

            let have_shares = self
                .signature_shares
                .contains_key(&sig_share_response.signer_id);

            if have_shares {
                info!(signer_id = %sig_share_response.signer_id, "received duplicate SignatureShareResponse");
                return Ok(());
            }

            self.signature_shares.insert(
                sig_share_response.signer_id,
                sig_share_response.signature_shares.clone(),
            );
            self.ids_to_await.remove(&sig_share_response.signer_id);
```
