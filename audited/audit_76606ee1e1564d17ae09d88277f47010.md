### Title
Signature Type Substitution Attack via Inconsistent merkle_root Validation Between NonceRequest and SignatureShareRequest

### Summary
A malicious coordinator can exploit the lack of signature_type consistency validation between NonceRequest and SignatureShareRequest messages to trick signers into generating signature shares for a different Taproot merkle_root than they agreed to. This allows the coordinator to obtain valid signatures for Taproot outputs with undisclosed script paths, potentially enabling theft of funds through hidden alternative spending conditions.

### Finding Description

**Exact Code Location:**
- `src/net.rs`, lines 299-304: `NonceRequest::hash()` implementation for `SignatureType::Taproot`
- `src/net.rs`, lines 425-430: `SignatureShareRequest::hash()` implementation for `SignatureType::Taproot`
- `src/state_machine/signer/mod.rs`, lines 723-754: `nonce_request()` handler that doesn't store `signature_type`
- `src/state_machine/signer/mod.rs`, lines 808-818: `sign_share_request()` handler that uses `signature_type` without validation

**Root Cause:**

The `NonceRequest::hash()` and `SignatureShareRequest::hash()` methods conditionally include the `merkle_root` in their message authentication hashes: [1](#0-0) [2](#0-1) 

When a signer receives a `NonceRequest`, it generates nonces but does not store the `signature_type` from that request: [3](#0-2) 

Nonce generation is independent of the message or signature type: [4](#0-3) 

When the signer later receives a `SignatureShareRequest`, it directly uses the `signature_type` from that request without validating it matches the one from the original `NonceRequest`: [5](#0-4) 

The signature computation uses the `merkle_root` to calculate the tweak, which affects the tweaked public key used in the challenge: [6](#0-5) [7](#0-6) 

**Why Existing Mitigations Fail:**

Both messages are authenticated via ECDSA packet signatures verified by the signer, confirming they come from the coordinator. However, there is no cross-validation ensuring the `signature_type` remains consistent across the two-phase signing protocol. The coordinator can validly sign both messages with different `signature_type` values, and signers accept them independently.

### Impact Explanation

**Specific Harm:**

In BIP-341 Taproot, the `merkle_root` parameter commits to a script tree containing alternative spending paths. When `merkle_root` is `None`, the output is key-path-only with no script alternatives. When `Some(root)`, the output includes script paths that may allow spending under different conditions.

A malicious coordinator can:

1. Present `NonceRequest` with `Taproot(None)` to make signers believe they're approving a key-path-only spend
2. Collect nonces from honest signers
3. Send `SignatureShareRequest` with `Taproot(Some(root))` where `root` commits to a script tree controlled by the coordinator
4. Obtain valid signature shares for the tweaked key `group_key + hash(group_key || root) * G`
5. Aggregate these into a valid signature for a Taproot output containing hidden script paths

**Quantified Impact:**

- Direct loss of funds: The coordinator can include script paths with timelocks or alternative signing conditions that allow them to claim funds after a delay
- Invalid transaction confirmation: Signers approve transactions believing they have certain properties (key-path-only) when they actually have different properties (script paths)
- Affects all signers in threshold: Once threshold signers are tricked, the malicious signature can be completed

**Who is Affected:**

All honest signers participating in Taproot signing rounds with a malicious or compromised coordinator.

**Severity Justification:**

This meets the **Critical** severity criteria: "Any causing the direct loss of funds other than through any form of freezing." The vulnerability enables a coordinator to obtain signatures for Taproot outputs with undisclosed spending conditions, directly leading to potential fund loss when those alternative paths are exploited.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Malicious or compromised coordinator with the private key to sign network messages
- No cryptographic breaks required
- No special network position beyond coordinator role

**Attack Complexity:**

Low complexity. The coordinator simply:
1. Constructs legitimate `NonceRequest` with `Taproot(None)`, signs it
2. Collects `NonceResponse` messages
3. Constructs legitimate `SignatureShareRequest` with `Taproot(Some(root))`, signs it
4. Aggregates resulting signature shares

**Economic Feasibility:**

Highly feasible. The coordinator already has message-signing capabilities and controls transaction construction. No additional resources needed beyond normal coordinator operations.

**Detection Risk:**

Very low. Signers have no visibility into the inconsistency without manual log correlation. The attack leaves no on-chain evidence until funds are stolen via the hidden script paths.

**Estimated Probability:**

High. Any malicious coordinator can execute this attack with 100% success against current code, limited only by the difficulty of compromising a coordinator.

### Recommendation

**Proposed Code Changes:**

1. **Store signature_type in signer state:** Modify the `Signer` struct to track the expected `signature_type` when processing `NonceRequest`:

```rust
pub struct Signer<SignerType: SignerTrait> {
    // ... existing fields ...
    /// Expected signature type for current signing round
    pub expected_signature_type: Option<SignatureType>,
}
```

2. **Save signature_type in nonce_request handler:** [3](#0-2) 

Add after line 730:
```rust
self.expected_signature_type = Some(nonce_request.signature_type);
```

3. **Validate consistency in sign_share_request handler:** [8](#0-7) 

Add before line 808:
```rust
// Validate signature_type matches what was in NonceRequest
if let Some(expected_type) = self.expected_signature_type {
    if expected_type != sign_request.signature_type {
        warn!(
            signer_id = %self.signer_id,
            "SignatureShareRequest signature_type mismatch"
        );
        return Err(Error::InvalidSignatureShare);
    }
}
```

4. **Clear state after signing:** Reset `expected_signature_type` to `None` after successful signature share generation.

**Alternative Mitigations:**

Include the `signature_type` in the binding computation so that different signature types produce different bindings and thus incompatible signature shares: [9](#0-8) 

**Testing Recommendations:**

1. Add unit test with malicious coordinator sending mismatched signature_types
2. Add integration test verifying rejection of inconsistent SignatureShareRequest
3. Test all three signature type combinations (Frost, Schnorr, Taproot variations)
4. Verify state is properly cleared between signing rounds

**Deployment Considerations:**

This is a protocol-breaking change requiring coordinated upgrade of all signers. Deploy as a mandatory version bump with clear migration path.

### Proof of Concept

**Exploitation Steps:**

1. **Setup:** Coordinator and 3 signers with threshold=2, configured for Taproot signing

2. **Step 1 - Malicious NonceRequest:**
   - Coordinator creates `NonceRequest` with:
     - `message = b"Transfer 10 BTC to Alice"`
     - `signature_type = Taproot(None)`
   - Coordinator signs with `message_private_key`
   - Sends to all signers

3. **Step 2 - Honest Nonce Generation:**
   - Each signer verifies coordinator signature ✓
   - Each signer generates nonces using `Nonce::random(secret_key, rng)` 
   - Nonces are independent of `signature_type`
   - Each signer sends `NonceResponse` back

4. **Step 3 - Malicious SignatureShareRequest:**
   - Coordinator collects `NonceResponse` messages
   - Coordinator constructs malicious script tree:
     ```
     Script 1: Standard multisig (key path)
     Script 2: OP_IF coordinator_key OP_CHECKSIG OP_ELSE 144 OP_CSV OP_ENDIF
     ```
   - Computes `merkle_root = hash(script1 || script2)`
   - Creates `SignatureShareRequest` with:
     - `message = b"Transfer 10 BTC to Alice"` (same)
     - `signature_type = Taproot(Some(merkle_root))` (different!)
   - Coordinator signs with `message_private_key`
   - Sends to all signers

5. **Step 4 - Signature Share Generation:**
   - Each signer verifies coordinator signature ✓
   - Each signer calls `sign_taproot(msg, signer_ids, key_ids, nonces, Some(merkle_root))`
   - Tweak computed as: `t = hash("TapTweak" || group_key.x || merkle_root)`
   - Tweaked key: `tweaked_key = group_key + t*G`
   - Challenge: `c = hash("BIP0340/challenge" || R.x || tweaked_key.x || msg)`
   - Signature share: `z_i = r_i + c * private_key_i * lambda_i`
   - Each signer returns valid signature share for `tweaked_key`

6. **Step 5 - Exploitation:**
   - Coordinator aggregates shares into valid Taproot signature
   - Signature validates against `tweaked_key` (with merkle_root)
   - Funds sent to Taproot output with hidden script paths
   - After 144 blocks, coordinator can spend via Script 2 using `coordinator_key`

**Expected vs Actual Behavior:**

- **Expected:** Signers only generate shares for the `signature_type` they approved in `NonceRequest`
- **Actual:** Signers blindly use whatever `signature_type` appears in `SignatureShareRequest`, allowing coordinator to substitute values

**Reproduction:**

Create a test in `src/state_machine/signer/mod.rs`:

```rust
#[test]
fn test_signature_type_substitution_attack() {
    // Send NonceRequest with Taproot(None)
    // Collect nonces
    // Send SignatureShareRequest with Taproot(Some([1u8; 32]))
    // Verify signers accept and generate shares (vulnerability)
    // After fix: should return Error::InvalidSignatureShare
}
```

### Citations

**File:** src/net.rs (L299-304)
```rust
            SignatureType::Taproot(merkle_root) => {
                hasher.update("SIGNATURE_TYPE_TAPROOT".as_bytes());
                if let Some(merkle_root) = merkle_root {
                    hasher.update(merkle_root);
                }
            }
```

**File:** src/net.rs (L425-430)
```rust
            SignatureType::Taproot(merkle_root) => {
                hasher.update("SIGNATURE_TYPE_TAPROOT".as_bytes());
                if let Some(merkle_root) = merkle_root {
                    hasher.update(merkle_root);
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L723-754)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
```

**File:** src/state_machine/signer/mod.rs (L757-818)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/common.rs (L78-88)
```rust
    fn gen<RNG: RngCore + CryptoRng>(secret_key: &Scalar, rng: &mut RNG) -> Scalar {
        let mut bytes: [u8; 32] = [0; 32];
        rng.fill_bytes(&mut bytes);

        let mut hasher = Sha256::new();

        hasher.update(bytes);
        hasher.update(secret_key.to_bytes());

        hash_to_scalar(&mut hasher)
    }
```

**File:** src/compute.rs (L17-33)
```rust
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```

**File:** src/compute.rs (L156-165)
```rust
pub fn tweak(public_key: &Point, merkle_root: Option<[u8; 32]>) -> Scalar {
    let mut hasher = tagged_hash("TapTweak");

    hasher.update(public_key.x().to_bytes());
    if let Some(root) = merkle_root {
        hasher.update(root);
    }

    hash_to_scalar(&mut hasher)
}
```

**File:** src/v2.rs (L672-682)
```rust
    fn sign_taproot(
        &self,
        msg: &[u8],
        signer_ids: &[u32],
        key_ids: &[u32],
        nonces: &[PublicNonce],
        merkle_root: Option<[u8; 32]>,
    ) -> Vec<SignatureShare> {
        let tweak = compute::tweak(&self.group_key, merkle_root);
        vec![self.sign_with_tweak(msg, signer_ids, key_ids, nonces, Some(tweak))]
    }
```
