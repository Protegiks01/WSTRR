### Title
Aggregator Accepts Duplicate Signature Shares Enabling Denial of Service

### Summary
The `sign()`, `sign_schnorr()`, and `sign_taproot()` methods in both v1 and v2 Aggregator implementations do not validate that signature shares have unique party IDs or that key_ids are not duplicated across multiple shares. A malicious signer can exploit this by sending multiple SignatureShare objects with duplicate party IDs or overlapping key_ids, causing signature aggregation to fail and denying service to the signing protocol.

### Finding Description

**Exact code locations:**

The vulnerability exists in multiple locations where signature shares are aggregated without duplicate checks:

1. **v2::Aggregator::sign_with_tweak()** - Aggregates signature shares without checking for duplicate party IDs: [1](#0-0) 

2. **v1::Aggregator::sign_with_tweak()** - Same issue in v1 implementation: [2](#0-1) 

3. **SignatureShare structure** - Contains party ID and key_ids without uniqueness constraints: [3](#0-2) 

**Root cause:**

Both aggregator implementations extract party IDs from signature shares and sum all z_i values without verifying uniqueness. The v2 implementation creates a party_ids vector that may contain duplicates, and the v1 implementation creates a signers vector with the same issue. Both then unconditionally sum all z_i values from all provided signature shares.

**Why existing mitigations fail:**

The coordinator's validation logic in `gather_sig_shares()` checks that the unique set of key_ids matches the configuration but does not prevent duplicate party IDs or duplicate key_ids within a single SignatureShareResponse: [4](#0-3) 

This validation uses a HashSet which automatically deduplicates, so if a malicious signer sends multiple SignatureShare objects claiming the same key_ids, the HashSet will contain only unique values and pass validation. The coordinator then stores all signature shares and passes them to the aggregator: [5](#0-4) 

When aggregating, all duplicate shares are included: [6](#0-5) 

### Impact Explanation

**Specific harm:**
A malicious signer can prevent the protocol from producing valid signatures by including duplicate SignatureShare objects in their SignatureShareResponse. When the aggregator sums the z_i values including duplicates, the mathematical relationship required for signature verification is violated, causing the aggregate signature to be invalid.

**Quantified impact:**
- Each signing round can be disrupted by a single malicious signer
- The protocol must restart the signing process, wasting computational resources
- Repeated attacks can prevent any signatures from being generated
- All participants in the signing round are affected

**Who is affected:**
All coordinators and honest signers participating in signing rounds where at least one malicious signer is present.

**Severity justification:**
This vulnerability maps to **Low severity** per the protocol scope: "Any remotely-exploitable denial of service in a node." The attack allows a malicious signer to remotely cause denial of service by preventing valid signatures from being created, but does not allow creation of invalid signatures that would be accepted, compromise keys, or cause consensus failures.

### Likelihood Explanation

**Required attacker capabilities:**
- Attacker must be a registered signer in the WSTS protocol
- Attacker must have valid credentials to participate in signing rounds
- Attacker can send arbitrary SignatureShareResponse messages (no cryptographic secrets required)

**Attack complexity:**
Low. The attacker simply crafts a SignatureShareResponse containing duplicate SignatureShare objects:
- Same party ID across multiple shares
- Same or overlapping key_ids
- Can use the same z_i value or different values (both cause failure)

**Economic feasibility:**
Highly feasible. No special resources required beyond being a legitimate signer. The attack is computationally trivial.

**Detection risk:**
Moderate. The coordinator's `check_signature_shares()` will identify bad signature shares after verification fails, potentially flagging the malicious signer. However, the attacker achieves their DoS objective before detection. [7](#0-6) 

**Estimated probability of success:**
100% if the attacker is a valid signer. The lack of duplicate checks guarantees that duplicate shares will be accepted and aggregated, causing signature verification to fail.

### Recommendation

**Proposed code changes:**

1. Add duplicate party ID validation in the aggregator before aggregation:

```rust
// In both v1 and v2 Aggregator::sign_with_tweak(), add before line 308/325:
let mut seen_party_ids = HashSet::new();
for sig_share in sig_shares {
    if !seen_party_ids.insert(sig_share.id) {
        return Err(AggregatorError::DuplicatePartyId(sig_share.id));
    }
}
```

2. Add duplicate key_id validation across all signature shares:

```rust
let mut seen_key_ids = HashSet::new();
for sig_share in sig_shares {
    for key_id in &sig_share.key_ids {
        if !seen_key_ids.insert(*key_id) {
            return Err(AggregatorError::DuplicateKeyId(*key_id));
        }
    }
}
```

3. Add validation in the coordinator's `gather_sig_shares()` method to check for duplicate party IDs within signature_shares vector:

```rust
// After line 1071 in fire.rs:
let mut party_ids_in_response = HashSet::new();
for sig_share in &sig_share_response.signature_shares {
    if !party_ids_in_response.insert(sig_share.id) {
        warn!(signer_id = %sig_share_response.signer_id, party_id = %sig_share.id, 
              "SignatureShareResponse contains duplicate party IDs");
        return Err(Error::DuplicatePartyId(sig_share.id));
    }
}
```

**Alternative mitigations:**
If maintaining backward compatibility is critical, add the validation in the state machine coordinator only, which will prevent malicious shares from reaching the aggregator.

**Testing recommendations:**
- Add unit tests that attempt to aggregate signature shares with duplicate party IDs
- Add unit tests with duplicate key_ids across different signature shares
- Add integration tests where a malicious signer sends duplicate shares
- Verify that the error is properly propagated and the malicious signer is identified

**Deployment considerations:**
This is a breaking change that requires all nodes to upgrade simultaneously, as previously valid (though malicious) messages will now be rejected.

### Proof of Concept

**Exploitation algorithm:**

1. Attacker participates as a legitimate signer in the WSTS protocol
2. During a signing round, attacker receives a SignatureShareRequest from the coordinator
3. Instead of using the protocol's sign methods, attacker crafts a malicious SignatureShareResponse:

```
SignatureShareResponse {
    dkg_id: <current_dkg_id>,
    sign_id: <current_sign_id>,
    sign_iter_id: <current_sign_iter_id>,
    signer_id: <attacker_signer_id>,
    signature_shares: vec![
        SignatureShare {
            id: 1,  // party ID
            z_i: <computed_value>,
            key_ids: vec![1, 2, 3],
        },
        SignatureShare {
            id: 1,  // DUPLICATE party ID
            z_i: <computed_value>,
            key_ids: vec![1, 2, 3],  // DUPLICATE key_ids
        },
    ],
}
```

4. Coordinator's validation at lines 1066-1076 passes because:
   - HashSet deduplicates: {1, 2, 3} matches config
   - No check for duplicate party IDs within the vector

5. Coordinator stores both signature shares and later passes them to aggregator

6. Aggregator sums z_i values including the duplicate:
   - z = z_1 + z_2 + ... + z_i + z_i (duplicate)

7. Signature verification equation fails:
   - z * G â‰  R + c * PK (due to double-counted contribution)

8. Signing round fails, coordinator must retry or abort

**Reproduction instructions:**
- Set up a WSTS signing session with multiple signers
- Have one signer send a SignatureShareResponse with duplicate SignatureShare objects
- Observe that signature aggregation produces an invalid signature
- Verify that `check_signature_shares()` identifies the bad shares but only after the DoS has occurred

### Notes
The vulnerability applies to both v1 and v2 implementations with slightly different semantics. In v1, each party controls one key, so duplicate party IDs directly mean duplicate keys. In v2, parties can control multiple keys, so the vulnerability manifests both as duplicate party IDs and as duplicate key_ids across different SignatureShare objects within the same response.

### Citations

**File:** src/v2.rs (L296-340)
```rust
    pub fn sign_with_tweak(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        _key_ids: &[u32],
        tweak: Option<Scalar>,
    ) -> Result<(Point, Signature), AggregatorError> {
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }

        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &party_ids, nonces);
        let mut z = Scalar::zero();
        let mut cx_sign = Scalar::one();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                let key = compute::tweaked_public_key_from_tweak(&aggregate_public_key, t);
                if !key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                key
            } else {
                aggregate_public_key
            }
        } else {
            aggregate_public_key
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        // optimistically try to create the aggregate signature without checking for bad keys or sig shares
        for sig_share in sig_shares {
            z += sig_share.z_i;
        }

        // The signature shares have already incorporated the private key adjustments, so we just have to add the tweak.  But the tweak itself needs to be adjusted if the tweaked public key is odd
        if let Some(t) = tweak {
            z += cx_sign * c * t;
        }

        let sig = Signature { R, z };

        Ok((tweaked_public_key, sig))
    }
```

**File:** src/v2.rs (L347-417)
```rust
    pub fn check_signature_shares(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
        tweak: Option<Scalar>,
    ) -> AggregatorError {
        if nonces.len() != sig_shares.len() {
            return AggregatorError::BadNonceLen(nonces.len(), sig_shares.len());
        }

        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (Rs, R) = compute::intermediate(msg, &party_ids, nonces);
        let mut bad_party_keys = Vec::new();
        let mut bad_party_sigs = Vec::new();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                compute::tweaked_public_key_from_tweak(&aggregate_public_key, t)
            } else {
                aggregate_public_key
            }
        } else {
            aggregate_public_key
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r_sign = Scalar::one();
        let mut cx_sign = Scalar::one();
        if let Some(t) = tweak {
            if !R.has_even_y() {
                r_sign = -Scalar::one();
            }
            if t != Scalar::zero() {
                if !tweaked_public_key.has_even_y() ^ !aggregate_public_key.has_even_y() {
                    cx_sign = -Scalar::one();
                }
            } else if !aggregate_public_key.has_even_y() {
                cx_sign = -Scalar::one();
            }
        }

        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
        if !bad_party_keys.is_empty() {
            AggregatorError::BadPartyKeys(bad_party_keys)
        } else if !bad_party_sigs.is_empty() {
            AggregatorError::BadPartySigs(bad_party_sigs)
        } else {
            AggregatorError::BadGroupSig
        }
    }
```

**File:** src/v1.rs (L314-354)
```rust
    pub fn sign_with_tweak(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        tweak: Option<Scalar>,
    ) -> Result<(Point, Signature), AggregatorError> {
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }

        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &signers, nonces);
        let mut z = Scalar::zero();
        let mut cx_sign = Scalar::one();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = match tweak {
            Some(t) if t != Scalar::zero() => {
                let key = compute::tweaked_public_key_from_tweak(&aggregate_public_key, t);
                if !key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                key
            }
            _ => aggregate_public_key,
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);

        for sig_share in sig_shares {
            z += sig_share.z_i;
        }

        // The signature shares have already incorporated the private key adjustments, so we just have to add the tweak.  But the tweak itself needs to be adjusted if the tweaked public key is odd
        if let Some(t) = tweak {
            z += cx_sign * c * t;
        }

        let sig = Signature { R, z };

        Ok((tweaked_public_key, sig))
    }
```

**File:** src/common.rs (L211-220)
```rust
#[derive(Clone, Deserialize, Serialize, PartialEq)]
/// A share of the party signature with related values
pub struct SignatureShare {
    /// The ID of the party
    pub id: u32,
    /// The party signature
    pub z_i: Scalar,
    /// The key IDs of the party
    pub key_ids: Vec<u32>,
}
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1131-1135)
```rust
            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```
