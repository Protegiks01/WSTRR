# Audit Report

## Title
Coordinator Panic via Signature Share Validation Failure During Aggregation

## Summary
The FIRE coordinator's `gather_sig_shares()` function contains a critical ordering flaw that allows a malicious signer to crash the coordinator. By removing signers from the wait list before validating their signature shares, the function creates an inconsistent state where a signer remains in `public_nonces` but is absent from `signature_shares`. When aggregation occurs, unsafe indexing causes a panic.

## Finding Description

The vulnerability exists in the signature share gathering logic. During normal operation:

1. **Nonce gathering phase**: A signer provides valid nonces and is added to both `public_nonces` and `sign_wait_signer_ids` [1](#0-0) 

2. **Share request phase**: The coordinator clears `signature_shares` when requesting new signature shares [2](#0-1) 

3. **Share gathering phase - Critical flaw**: When a `SignatureShareResponse` arrives, the signer is immediately removed from `sign_wait_signer_ids` BEFORE validation [3](#0-2) 

4. **Validation checks**: Multiple validation checks follow that can fail and return early with errors [4](#0-3) 

5. **Conditional insertion**: Shares are only inserted into `signature_shares` if all validations pass [5](#0-4) 

6. **Aggregation trigger**: When `sign_wait_signer_ids` becomes empty, the aggregation code executes [6](#0-5) 

7. **Unsafe indexing - PANIC**: The aggregation iterates over `public_nonces` and uses unsafe indexing into `signature_shares` [7](#0-6) 

The error handling at the caller level catches validation failures but does not repair the inconsistent state: [8](#0-7) 

**Attack scenario:**
A malicious signer participates normally during nonce gathering, then sends a `SignatureShareResponse` with invalid data (e.g., `key_ids` that don't match the configured `signer_key_ids`). The validation at line 1073-1076 fails and returns an error. The signer has been removed from the wait list but was never added to `signature_shares`. When honest signers complete their responses and the wait list empties, line 1134 attempts to access `self.signature_shares[malicious_signer_id]`, causing a panic.

## Impact Explanation

**Severity: Low (potentially Medium)**

This vulnerability enables a remotely-exploitable denial of service against the coordinator node. A single malicious signer can deterministically crash the coordinator during any signing round, which:

- Forces coordinator restart and signing round retry
- Prevents signature production during the crash
- Blocks transaction confirmations in dependent systems
- In blockchain deployments (e.g., Stacks), halts mining and transaction processing

This maps to **Low severity** under the defined scope: "Any remotely-exploitable denial of service in a node." However, if the coordinator crash causes transient consensus failures or affects more than 10% of miners in a distributed deployment, this escalates to **Medium severity**: "Any transient consensus failures."

## Likelihood Explanation

**Likelihood: HIGH**

The attack requires only:
- Valid signer credentials (within the protocol threat model - threshold signature systems assume some signers may be malicious)
- Network access to the coordinator
- Ability to send protocol messages

**Attack complexity: LOW**
1. Participate in nonce gathering with valid nonces
2. Send a `SignatureShareResponse` with mismatched `key_ids`
3. Wait for honest signers to respond
4. Coordinator panics on aggregation

**Probability of success: Near 100%** - The attack is deterministic once the attacker is a valid signer. No cryptographic operations need to be broken, no timing dependencies exist, and the malformed response appears as a normal validation failure until the panic occurs.

**Economic feasibility: Trivial** - No financial cost beyond normal network participation.

## Recommendation

Fix the ordering by validating signature shares BEFORE removing the signer from the wait list:

```rust
fn gather_sig_shares(
    &mut self,
    packet: &Packet,
    signature_type: SignatureType,
) -> Result<(), Error> {
    // ... existing checks ...
    
    // Perform all validation FIRST
    let signer_public_keys = &self.config.public_keys.signers;
    if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
        warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
        return Err(Error::MissingPublicKeyForSigner(
            sig_share_response.signer_id,
        ));
    };
    
    // ... all other validation checks ...
    
    // ONLY remove from wait list AFTER all validation passes
    response_info
        .sign_wait_signer_ids
        .remove(&sig_share_response.signer_id);
        
    self.signature_shares.insert(
        sig_share_response.signer_id,
        sig_share_response.signature_shares.clone(),
    );
    
    // ... rest of function ...
}
```

Alternatively, use safe indexing in the aggregation code:
```rust
let shares = message_nonce
    .public_nonces
    .iter()
    .filter_map(|(i, _)| self.signature_shares.get(i).cloned())
    .flatten()
    .collect::<Vec<SignatureShare>>();
```

## Proof of Concept

```rust
#[test]
fn test_coordinator_panic_on_invalid_signature_shares() {
    use crate::state_machine::coordinator::test::{setup, feedback_messages};
    use crate::net::{Message, SignatureShareResponse, SignatureType};
    use crate::common::SignatureShare;
    use crate::curve::scalar::Scalar;
    use hashbrown::HashSet;
    
    // Setup with 3 signers, 1 key each
    let (mut coordinators, mut signers) = setup::<FireCoordinator<v2::Aggregator>, v2::Signer>(3, 1);
    
    // Run DKG first
    let (mut coordinators, mut signers) = run_dkg::<FireCoordinator<v2::Aggregator>, v2::Signer>(3, 1);
    
    // Start signing round
    let msg = b"test message".to_vec();
    let message = coordinators[0].start_signing_round(&msg, SignatureType::Frost, None).unwrap();
    
    // Gather nonces from all signers (including malicious signer 0)
    let (outbound_messages, _) = feedback_messages(&mut coordinators, &mut signers, &[message]);
    
    // Now signer 0 will send invalid signature shares
    // Create malformed SignatureShareResponse with wrong key_ids
    let mut invalid_shares = vec![];
    let malicious_signer_id = 0;
    invalid_shares.push(SignatureShare {
        id: malicious_signer_id,
        z_i: Scalar::random(&mut OsRng),
        key_ids: vec![999], // Invalid key_id not in config
    });
    
    let invalid_response = SignatureShareResponse {
        dkg_id: coordinators[0].current_dkg_id,
        sign_id: coordinators[0].current_sign_id,
        sign_iter_id: coordinators[0].current_sign_iter_id,
        signer_id: malicious_signer_id,
        signature_shares: invalid_shares,
    };
    
    let invalid_packet = Packet {
        msg: Message::SignatureShareResponse(invalid_response),
        sig: vec![],
    };
    
    // Process invalid response - should return error but leave inconsistent state
    let _ = coordinators[0].process(&invalid_packet);
    
    // Now have honest signers 1 and 2 respond normally
    let (_, results) = feedback_messages(&mut coordinators, &mut signers, &outbound_messages);
    
    // This should panic when coordinator tries to aggregate!
    // The panic occurs because signer 0 is in public_nonces but not in signature_shares
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L328-333)
```rust
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L931-942)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());

            // ignore the passed key_ids
            for key_id in signer_key_ids {
                nonce_info.nonce_recv_key_ids.insert(*key_id);
            }

            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L964-965)
```rust
    fn request_sig_shares(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.signature_shares.clear();
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1076)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };

        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1113-1135)
```rust
        if message_nonce.sign_wait_signer_ids.is_empty() {
            // Calculate the aggregate signature
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```
