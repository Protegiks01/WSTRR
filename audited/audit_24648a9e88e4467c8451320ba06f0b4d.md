### Title
Out-of-Bounds Panic in DKG Public Share Validation Enables Remote Denial of Service

### Summary
A malicious signer can crash honest signers and the coordinator by sending a `DkgPublicShares` message containing a `PolyCommitment` with an empty polynomial vector. The vulnerability exists because `check_public_shares()` calls `verify()` before validating the vector length, and `verify()` unconditionally accesses `poly[0]`, causing an out-of-bounds panic. This prevents DKG completion and can impact network availability.

### Finding Description

The vulnerability exists in the `check_public_shares()` function and affects both v1 and v2 implementations. The root cause is an incorrect order of validation operations. [1](#0-0) 

The function calls `poly_comm.verify(ctx)` first, which unconditionally accesses the first element of the polynomial vector: [2](#0-1) 

If `poly` is empty, this array access causes a panic before the length check `poly_comm.poly.len() == threshold` is ever evaluated.

The vulnerability is triggered when processing `DkgPublicShares` network messages. In the signer state machine, received public shares are validated during DKG end processing: [3](#0-2) 

The v1 `Party::compute_secret()` function also accesses `poly[0]` after the check passes: [4](#0-3) 

However, the panic occurs earlier during the validation check, so this line is never reached with empty polynomials.

The v2 implementation has identical logic: [5](#0-4) 

The coordinator also calls `check_public_shares()` when verifying bad share reports: [6](#0-5) 

**Why existing mitigations fail:** The `PolyCommitment` structure derives `Deserialize` without custom validation, allowing empty vectors to be deserialized from network messages: [7](#0-6) 

There is no validation during message deserialization or before calling `check_public_shares()`.

### Impact Explanation

**Specific Harm:**
- Any registered signer can crash all honest signers and the coordinator by sending a single malformed `DkgPublicShares` message
- DKG cannot complete when signers are crashed during validation
- Without successful DKG, threshold signatures cannot be generated
- The coordinator crashes when attempting to verify bad share reports

**Quantification:**
- Attack affects all signers processing the malicious message (potentially 100% of signers)
- Requires only one malicious signer among all registered signers
- Each DKG round can be attacked, requiring repeated restarts
- No funds are directly lost, but signature-dependent operations are blocked

**Affected Parties:**
- All honest signers participating in DKG
- The coordinator node
- Any dependent systems requiring WSTS threshold signatures

**Severity Justification:**
Per the protocol scope, this is a **Low** severity issue as it constitutes "any remotely-exploitable denial of service in a node." However, if the attack impacts more than 10% of miners in a deployment where WSTS signers are miners, it could escalate to network-level DoS. If DKG failures prevent transaction confirmation in dependent systems, it could constitute a **Medium** severity "transient consensus failure."

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a registered signer with a `signer_id` in the coordinator's configuration
- Must be able to send network messages to other signers
- No cryptographic secrets or private keys required
- No special timing requirements

**Attack Complexity:**
- Trivial to execute: construct a `DkgPublicShares` message with `comms: vec![(party_id, PolyCommitment { id: valid_id, poly: vec![] })]`
- Requires only basic understanding of the message format
- Can be automated and repeated
- Difficult to attribute since it appears as malformed data rather than cryptographic attack

**Economic Feasibility:**
- Essentially zero cost to execute
- No computational resources needed beyond message construction
- Can be executed repeatedly to prevent DKG completion indefinitely

**Detection Risk:**
- Crashes are visible but may be attributed to software bugs rather than attacks
- No cryptographic signature verification failures to trigger alerts
- Malicious signer may remain undetected across multiple rounds

**Estimated Probability:** Near 100% success rate if attacker controls any registered signer ID.

### Recommendation

**Primary Fix:** Reorder the validation checks in `check_public_shares()` to validate the length before calling `verify()`:

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.poly.len() == threshold && poly_comm.verify(ctx)
}
```

**Alternative Mitigation:** Add bounds checking in `PolyCommitment::verify()`:

```rust
pub fn verify(&self, ctx: &[u8]) -> bool {
    !self.poly.is_empty() && self.id.verify(&self.poly[0], ctx)
}
```

**Additional Hardening:** Implement custom deserialization for `PolyCommitment` that validates the polynomial length against expected threshold values before accepting the message.

**Testing Recommendations:**
1. Add unit test with empty polynomial vector to verify panic is prevented
2. Add integration test simulating malicious `DkgPublicShares` with empty poly
3. Fuzz test deserialization with various malformed `PolyCommitment` structures
4. Verify both v1 and v2 implementations handle the fix correctly

**Deployment Considerations:**
- This is a critical fix that should be deployed urgently
- All nodes (signers and coordinators) must be updated
- The fix is backward-compatible as it only adds validation
- Consider adding monitoring for malformed DKG messages to detect attack attempts

### Proof of Concept

**Exploitation Steps:**

1. Attacker registers as a signer with valid `signer_id` in coordinator configuration
2. During DKG public shares phase, attacker constructs malicious message:

```rust
let malicious_msg = DkgPublicShares {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id,
    comms: vec![(
        1, // party_id
        PolyCommitment {
            id: valid_schnorr_id, // Can be any valid ID
            poly: vec![], // Empty polynomial vector
        }
    )],
    kex_public_key: attacker_public_key,
};
```

3. Attacker broadcasts message to all signers and coordinator
4. When honest signers reach DKG end phase, they call `check_public_shares()` on the malicious commitment
5. Panic occurs at `poly[0]` access in `verify()` before length check
6. All processing signers crash with out-of-bounds error
7. If coordinator verifies bad share reports, it also crashes

**Expected Behavior:** `check_public_shares()` should return `false` for empty polynomial vectors without panicking.

**Actual Behavior:** Process panics with "index out of bounds" error.

**Reproduction:** Create a test case that constructs a `PolyCommitment` with empty poly and calls `check_public_shares()` to demonstrate the panic.

### Citations

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L37-39)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/v1.rs (L161-167)
```rust
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
```

**File:** src/v2.rs (L135-140)
```rust
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
```

**File:** src/state_machine/coordinator/fire.rs (L632-640)
```rust
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }
```
