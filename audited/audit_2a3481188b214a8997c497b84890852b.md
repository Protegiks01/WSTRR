### Title
DKG ID Validation Bypass Allows Signing with Mismatched Key Sets

### Summary
Signers do not validate that incoming `NonceRequest` and `SignatureShareRequest` messages reference a successfully completed DKG round. When a coordinator initiates a new DKG round, signers retain their previous DKG round's private keys and will sign with these stale keys if the coordinator requests signatures before the new DKG completes. This breaks the protocol invariant that `dkg_id` identifies which key set was used for signing, potentially causing signature verification failures or acceptance of invalid signatures.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the signer's message handlers:
- `nonce_request` method: [1](#0-0) 
- `sign_share_request` method: [2](#0-1) 

**Root Cause:**

When a signer receives a `NonceRequest`, it does not validate that:
1. The `dkg_id` in the request matches its current `self.dkg_id`
2. DKG for that `dkg_id` has been successfully completed
3. The signer has valid keys derived from that specific DKG round

The `nonce_request` method simply generates nonces and responds with whatever `dkg_id` was in the request, without any validation. [3](#0-2) 

Similarly, `sign_share_request` calls the signer's `sign` methods using the currently stored `private_keys` and `group_key`, regardless of whether they match the `dkg_id` in the request. [4](#0-3) 

**Why Existing Mitigations Fail:**

When a signer receives `DkgBegin` for a new DKG round, it calls `reset()` which updates `self.dkg_id` but does NOT clear the computed secrets: [5](#0-4) 

The `reset_polys` method only resets the polynomial used for generating new shares, not the derived private keys: [6](#0-5) 

The private keys from the previous DKG round remain in `self.signer.private_keys` and `self.signer.group_key` until a new DKG completes and calls `compute_secret`, which clears and recomputes them: [7](#0-6) 

### Impact Explanation

**Specific Harm:**

A coordinator (malicious or buggy) can request signatures for a DKG round that has not completed, causing signers to produce signature shares using keys from a different DKG round. This violates the critical signing invariant that "Signature shares must be consistent with party IDs, nonces, and key ownership."

**Quantified Impact:**

1. **Signature Verification Failures**: If signers use keys from DKG round N while the coordinator's aggregator was initialized with commitments from DKG round N+1, the aggregated signature will fail verification, causing a transient consensus failure (Medium severity per protocol scope).

2. **Invalid Signature Acceptance Risk**: If the coordinator's state is also inconsistent (e.g., it still has commitments from DKG round N but requests signatures with `dkg_id=N+1`), it may successfully aggregate and verify a signature that has an incorrect `dkg_id`, violating the protocol's round ID invariant.

**Affected Parties:**

All signers participating in threshold signature generation are affected, as they will unknowingly sign with incorrect keys. Dependent systems relying on the `dkg_id` field to track key rotation will receive misleading information.

**Severity Justification:**

This maps to **Medium** severity (transient consensus failures) in the protocol scope, as signature verification will typically fail when keys are mismatched, preventing invalid signatures from being accepted. However, it could escalate to **High** if the inconsistency allows acceptance of signatures with incorrect metadata.

### Likelihood Explanation

**Required Attacker Capabilities:**

- Attacker must control the coordinator or exploit a buggy coordinator implementation
- No cryptographic breaks required
- No special network position needed beyond being the coordinator

**Attack Complexity:**

The attack is straightforward:
1. Complete DKG round 1 (dkg_id=1)
2. Start DKG round 2 (dkg_id=2) by sending `DkgBegin`
3. Before DKG round 2 completes, send `NonceRequest` with `dkg_id=2`
4. Signers respond with nonces (using keys from round 1)
5. Send `SignatureShareRequest` with `dkg_id=2`
6. Signers compute shares using round 1 keys but label them as round 2

**Economic Feasibility:**

No additional resources required beyond coordinator access. The attack is entirely protocol-level.

**Detection Risk:**

The vulnerability is difficult to detect during normal operation because:
- Signers don't log warnings about DKG ID mismatches
- The coordinator receives valid-looking signature shares
- Only signature verification failure (if aggregator uses different commitments) reveals the issue

**Probability of Success:**

High (90%+) if the coordinator is compromised or buggy, as there are no validation checks to prevent this attack.

### Recommendation

**Proposed Code Changes:**

1. In `nonce_request`, add validation that the request's `dkg_id` matches the signer's current `dkg_id` and that DKG has been successfully completed:

```rust
fn nonce_request<R: RngCore + CryptoRng>(
    &mut self,
    nonce_request: &NonceRequest,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Validate dkg_id matches
    if nonce_request.dkg_id != self.dkg_id {
        warn!(
            "Received NonceRequest with dkg_id {} but current dkg_id is {}",
            nonce_request.dkg_id, self.dkg_id
        );
        return Err(Error::BadStateChange(
            "NonceRequest dkg_id mismatch".to_string()
        ));
    }
    
    // Validate DKG was successfully completed for this dkg_id
    // This requires tracking completion state, e.g., a flag set after compute_secrets succeeds
    if !self.dkg_completed {
        warn!("Received NonceRequest but DKG has not completed");
        return Err(Error::BadStateChange(
            "DKG not completed".to_string()
        ));
    }
    
    // ... existing nonce generation code ...
}
```

2. Add similar validation in `sign_share_request` to ensure the `dkg_id` matches and DKG is complete.

3. Add a `dkg_completed: bool` field to the signer state machine, set to `false` in `reset()` and `true` when `compute_secrets` succeeds in `dkg_ended`.

**Alternative Mitigations:**

- Clear `private_keys` and `group_key` in the `reset()` method to ensure stale keys cannot be used
- Add a `dkg_id_for_keys: Option<u64>` field that tracks which DKG round the current keys came from, and validate it matches the request

**Testing Recommendations:**

- Add integration tests that start a new DKG round and attempt to request signatures before completion
- Verify that signers reject requests with mismatched `dkg_id`
- Test the race condition where DKG completes between nonce request and signature share request

**Deployment Considerations:**

This is a protocol-level change that requires coordination between coordinator and signer implementations. Existing deployments must be updated simultaneously to maintain compatibility.

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Configure 4 signers with threshold=7, total_keys=10
2. **DKG Round 1 (dkg_id=1)**: 
   - Coordinator sends `DkgBegin{dkg_id: 1}`
   - Complete full DKG flow
   - Signers compute secrets, derive private_keys K1, group_key PK1
   - Coordinator stores commitments C1, aggregate_public_key APK1

3. **DKG Round 2 (dkg_id=2)**:
   - Coordinator sends `DkgBegin{dkg_id: 2}`
   - Signers receive it and call `reset(2)` which:
     - Sets `self.dkg_id = 2`
     - Calls `reset_polys()` (resets polynomial only)
     - **Leaves private_keys=K1 and group_key=PK1 intact**

4. **Premature Signing Request**:
   - Before DKG round 2 completes, coordinator sends `NonceRequest{dkg_id: 2, ...}`
   - Signers' `nonce_request` method does not validate DKG completion
   - Signers respond with `NonceResponse{dkg_id: 2, ...}`

5. **Signature Share Generation**:
   - Coordinator sends `SignatureShareRequest{dkg_id: 2, ...}`
   - Signers' `sign_share_request` calls `self.signer.sign()` which uses:
     - `self.private_keys` (still K1 from round 1)
     - `self.group_key` (still PK1 from round 1)
   - Signers return `SignatureShareResponse{dkg_id: 2, ...}` but shares were computed with K1/PK1

**Expected vs Actual Behavior:**

- **Expected**: Signers should reject signing requests for incomplete DKG rounds or validate that keys match the requested `dkg_id`
- **Actual**: Signers accept the request and sign with keys from DKG round 1 while labeling the shares as from DKG round 2

**Reproduction:**

Using the existing test infrastructure, modify a coordinator test to send `NonceRequest` immediately after `DkgBegin` for a new round, before the DKG flow completes. The signers will respond without error, demonstrating the vulnerability.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L757-842)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };

            self.signer.gen_nonces(&self.network_private_key, rng);

            let response = SignatureShareResponse {
                dkg_id: sign_request.dkg_id,
                sign_id: sign_request.sign_id,
                sign_iter_id: sign_request.sign_iter_id,
                signer_id: self.signer_id,
                signature_shares,
            };
            info!(
                signer_id = %self.signer_id,
                dkg_id = %sign_request.dkg_id,
                sign_id = %sign_request.sign_id,
                sign_iter_id = %sign_request.sign_iter_id,
                "sending SignatureShareResponse"
            );

            Ok(vec![Message::SignatureShareResponse(response)])
        } else {
            debug!(signer_id = %self.signer_id, "signer not included in SignatureShareRequest");
            Ok(Vec::new())
        }
    }
```

**File:** src/v2.rs (L123-130)
```rust
    pub fn compute_secret(
        &mut self,
        private_shares: &HashMap<u32, HashMap<u32, Scalar>>,
        public_shares: &HashMap<u32, PolyCommitment>,
        ctx: &[u8],
    ) -> Result<(), DkgError> {
        self.private_keys.clear();
        self.group_key = Point::zero();
```

**File:** src/v2.rs (L583-585)
```rust
    fn reset_polys<RNG: RngCore + CryptoRng>(&mut self, rng: &mut RNG) {
        self.f = Some(VSS::random_poly(self.threshold - 1, rng));
    }
```
