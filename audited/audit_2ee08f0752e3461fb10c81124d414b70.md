# Audit Report

## Title
Coordinator Fails to Validate MissingPrivateShares Claims Enabling Persistent DKG Denial of Service

## Summary
A malicious signer can selectively withhold encrypted private shares from specific participants during DKG, causing honest signers to report `MissingPrivateShares` failures. The coordinator performs no validation of these claims despite having all necessary data, resulting in DKG failure without identifying the malicious party. This enables persistent denial of service as the attacker is never marked malicious and can participate in unlimited retry attempts.

## Finding Description

The vulnerability exists in the coordinator's `gather_dkg_end` function where `DkgFailure::MissingPrivateShares` reports are received but not validated. [1](#0-0) 

In stark contrast, the coordinator performs extensive validation (over 100 lines) for `BadPrivateShares` claims, verifying tuple proofs and checking share correctness: [2](#0-1) 

**Attack Mechanism:**

1. During DKG private share distribution, each signer creates a `DkgPrivateShares` message containing encrypted shares for destination key_ids: [3](#0-2) 

A malicious signer can selectively omit destination key_ids from the `encrypted_shares` HashMap (line 932), controlling which parties receive shares.

2. Honest signers detect missing shares by checking if all their key_ids are present in received `DkgPrivateShares` messages: [4](#0-3) 

3. Honest signers report the failure: [5](#0-4) 

4. The coordinator collects failures but when any are reported, returns `Error::DkgFailure` without attribution: [6](#0-5) 

**Why Validation is Possible but Missing:**

The coordinator has all necessary data to validate claims:
- All `DkgPrivateShares` messages are stored: [7](#0-6) 

- The coordinator knows which key_ids each signer controls: [8](#0-7) 

The coordinator could check if the accused signer's `DkgPrivateShares.shares` contains encrypted values for all of the reporting signer's key_ids, but this validation is not implemented.

## Impact Explanation

**Severity: LOW to MEDIUM**

This vulnerability enables persistent denial of service against DKG operations:

1. **DKG Operation Failure**: Any `MissingPrivateShares` report causes DKG to fail with `reported_failures` but empty `malicious_signers`: [9](#0-8) 

2. **No Blame Attribution**: Malicious signers are only added to `malicious_dkg_signer_ids` if identified in the `malicious_signers` set: [10](#0-9) 

Since `MissingPrivateShares` never populates this set, the attacker is never marked malicious and can participate in all retry attempts.

3. **Persistent DoS**: A single malicious signer can prevent DKG completion indefinitely, blocking threshold signature operations.

This maps to **LOW** severity: "Any network denial of service impacting more than 10 percent of miners that does not shut down the network" - if miners require DKG for signing operations. Could escalate to **MEDIUM**: "Any transient consensus failures" - if DKG failures prevent block signing.

## Likelihood Explanation

**Probability: HIGH**

- **Attacker Requirements**: Control of one signer identity participating in DKG
- **Attack Complexity**: Trivial - simply omit certain `dst_key_id` entries when building the `encrypted_shares` HashMap
- **Cryptographic Requirements**: None - no need to break encryption or forge signatures  
- **Detection Risk**: Zero - coordinator explicitly does not attribute blame
- **Success Rate**: 100% deterministic if attacker controls any participating signer
- **Repeatability**: Unlimited - works on every retry attempt since no attribution occurs

## Recommendation

Implement validation for `MissingPrivateShares` claims similar to the existing `BadPrivateShares` validation:

```rust
DkgFailure::MissingPrivateShares(missing_shares) => {
    for bad_signer_id in missing_shares {
        // Get the reporting signer's expected key_ids
        let Some(reporting_signer_key_ids) = 
            self.config.public_keys.signer_key_ids.get(signer_id)
        else {
            warn!("No key IDs for reporting signer_id {signer_id}");
            continue;
        };
        
        // Get the accused signer's DkgPrivateShares
        let Some(dkg_private_shares) = 
            self.dkg_private_shares.get(bad_signer_id)
        else {
            warn!("Signer {signer_id} reported MissingPrivateShares from {bad_signer_id} who didn't send any shares");
            malicious_signers.insert(*signer_id);
            continue;
        };
        
        // Check if all of the reporting signer's key_ids have shares
        let mut is_missing = false;
        for reporting_key_id in reporting_signer_key_ids {
            let mut found = false;
            for (_src_party_id, key_shares) in &dkg_private_shares.shares {
                if key_shares.contains_key(reporting_key_id) {
                    found = true;
                    break;
                }
            }
            if !found {
                is_missing = true;
                break;
            }
        }
        
        if !is_missing {
            // Reporter was lying
            warn!("Signer {signer_id} falsely reported MissingPrivateShares from {bad_signer_id}");
            malicious_signers.insert(*signer_id);
        } else {
            // Shares actually missing
            warn!("Signer {bad_signer_id} withheld private shares from {signer_id}");
            malicious_signers.insert(*bad_signer_id);
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_missing_private_shares_dos() {
    // Setup DKG with 3 signers, threshold 2
    let mut coordinator = setup_coordinator(3, 2);
    
    // Signer 0 (malicious) sends DkgPublicShares
    coordinator.process_dkg_public_shares(0);
    // Signers 1 and 2 (honest) send DkgPublicShares  
    coordinator.process_dkg_public_shares(1);
    coordinator.process_dkg_public_shares(2);
    
    // Coordinator sends DkgPrivateBegin
    coordinator.start_private_shares();
    
    // Malicious signer 0 creates DkgPrivateShares but omits signer 1's key_ids
    let mut malicious_shares = create_dkg_private_shares(0);
    malicious_shares.shares[0].1.remove(&key_id_of_signer_1); // Omit shares
    coordinator.process_dkg_private_shares(malicious_shares);
    
    // Honest signers send complete shares
    coordinator.process_dkg_private_shares(create_dkg_private_shares(1));
    coordinator.process_dkg_private_shares(create_dkg_private_shares(2));
    
    // Coordinator sends DkgEndBegin
    coordinator.start_dkg_end();
    
    // Signer 1 detects missing shares and reports
    let dkg_end_1 = DkgEnd {
        status: DkgStatus::Failure(
            DkgFailure::MissingPrivateShares(hashset![0])
        )
    };
    
    // Process failure
    let result = coordinator.gather_dkg_end(dkg_end_1);
    
    // Verify: DKG fails but malicious_signers is empty
    assert!(matches!(result, Err(Error::DkgFailure { 
        reported_failures: _, 
        malicious_signers 
    }) if malicious_signers.is_empty()));
    
    // Verify: Attacker not in malicious_dkg_signer_ids
    assert!(!coordinator.malicious_dkg_signer_ids.contains(&0));
    
    // Retry will include the same attacker, enabling persistent DoS
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L41-41)
```rust
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L282-293)
```rust
                        if let Error::DkgFailure {
                            reported_failures,
                            malicious_signers,
                        } = error
                        {
                            return Ok((
                                None,
                                Some(OperationResult::DkgError(DkgError::DkgEndFailure {
                                    reported_failures,
                                    malicious_signers,
                                })),
                            ));
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L768-770)
```rust
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L601-608)
```rust
        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
```

**File:** src/state_machine/signer/mod.rs (L932-948)
```rust
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
```

**File:** src/state_machine/mod.rs (L95-101)
```rust
pub struct PublicKeys {
    /// signer_id -> public key
    pub signers: HashMap<u32, ecdsa::PublicKey>,
    /// key_id -> public key
    pub key_ids: HashMap<u32, ecdsa::PublicKey>,
    /// map of signer_id to controlled key_ids
    pub signer_key_ids: HashMap<u32, HashSet<u32>>,
```
