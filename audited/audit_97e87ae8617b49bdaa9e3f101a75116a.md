### Title
Missing sign_iter_id Validation in Signature Share Collection Allows Cross-Iteration Replay Attacks

### Summary
Both FROST and FIRE coordinator implementations fail to validate the `sign_iter_id` field when receiving `SignatureShareResponse` messages, despite validating it for `NonceResponse` messages. This inconsistency allows a malicious signer to replay signature shares from previous signing iterations, causing the coordinator to aggregate shares computed with mismatched nonces, resulting in invalid signatures and denial of service.

### Finding Description

**Exact Code Locations:**

The FROST coordinator validates `dkg_id` and `sign_id` but NOT `sign_iter_id` in `gather_sig_shares`: [1](#0-0) 

In contrast, the FROST coordinator DOES validate `sign_iter_id` in `gather_nonces`: [2](#0-1) 

Similarly, the FIRE coordinator validates `dkg_id` and `sign_id` but NOT `sign_iter_id` in `gather_sig_shares`: [3](#0-2) 

But the FIRE coordinator DOES validate `sign_iter_id` in `gather_nonces`: [4](#0-3) 

**Root Cause:**

The `SignatureShareResponse` message includes a `sign_iter_id` field: [5](#0-4) 

However, the validation logic in both coordinators is inconsistent. While nonce responses are validated for all three round identifiers (dkg_id, sign_id, sign_iter_id), signature share responses only validate two (dkg_id, sign_id), omitting the critical `sign_iter_id` check.

Additionally, the `SignatureShareResponse.hash()` implementation does not include `sign_iter_id` in the signature: [6](#0-5) 

This means even with packet signature verification enabled, the `sign_iter_id` field is not cryptographically bound to the message.

**Why Existing Mitigations Fail:**

The coordinator clears the `signature_shares` map at the start of each signature share request phase: [7](#0-6) 

However, this clearing happens BEFORE accepting new responses, not during validation. The coordinator then accepts any `SignatureShareResponse` where the `signer_id` is in the wait list and the `sign_id` matches, regardless of `sign_iter_id`.

### Impact Explanation

**Specific Harm:**
When a malicious signer replays signature shares from a previous iteration (with different `sign_iter_id` and different nonces), the coordinator aggregates these old shares alongside current-iteration shares. Since signature shares are cryptographically bound to the nonces used during computation, mixing shares from different iterations produces an invalid aggregate signature. The aggregation uses current nonces but receives shares computed with old nonces: [8](#0-7) 

**Quantified Impact:**
- Signing rounds fail to produce valid signatures
- Coordinator must retry the signing process
- Malicious signer is eventually identified through `check_signature_shares` validation
- No fund loss or invalid transaction confirmation occurs (invalid signatures are rejected)

**Affected Parties:**
- FIRE coordinator deployments with timeout-based retries (most affected, as `sign_iter_id` increments on timeout)
- FROST coordinator deployments if external coordination changes `sign_iter_id`
- All participants experience signing delays and DoS

**Severity Justification:**
This maps to **Low severity** per the protocol scope: "Any remotely-exploitable denial of service in a node." The attack causes signing to fail but does not lead to fund loss, invalid confirmations, or consensus failures. The cryptographic validation in the aggregator catches the invalid shares.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a participating signer in the threshold signature protocol
- Must have network access to send messages to the coordinator
- No cryptographic breaks required

**Attack Complexity:**
1. Participate normally in signing iteration N with `sign_iter_id=N`
2. Receive `SignatureShareRequest` with nonces and compute valid shares
3. Delay sending the response (or save it for later replay)
4. Wait for timeout (FIRE) or external event that triggers iteration N+1
5. In iteration N+1, coordinator sends new `NonceRequest` with `sign_iter_id=N+1`
6. Coordinator receives new nonces and sends new `SignatureShareRequest`
7. Replay saved `SignatureShareResponse` from iteration N (with `sign_iter_id=N`)
8. Coordinator accepts it due to missing validation
9. Signing fails, malicious signer detected

**Economic Feasibility:**
- No economic cost to the attacker beyond normal participation
- Can cause repeated DoS by triggering timeouts deliberately

**Detection Risk:**
- Eventually detected through aggregator's signature share validation
- Logged as malicious behavior in coordinator logs
- Could be detected through monitoring of repeated signing failures

**Estimated Probability:**
- High for FIRE coordinators with timeouts (timeouts occur naturally in distributed systems)
- Medium for FROST coordinators (depends on external `sign_iter_id` changes)
- Malicious signer can reliably trigger this by delaying responses to cause timeouts

### Recommendation

**Proposed Code Changes:**

Add `sign_iter_id` validation in both coordinators' `gather_sig_shares` functions:

For FROST coordinator, add after line 610:
```rust
if sig_share_response.sign_iter_id != self.current_sign_iter_id {
    return Err(Error::BadSignIterId(
        sig_share_response.sign_iter_id,
        self.current_sign_iter_id,
    ));
}
```

For FIRE coordinator, add after line 1037:
```rust
if sig_share_response.sign_iter_id != self.current_sign_iter_id {
    return Err(Error::BadSignIterId(
        sig_share_response.sign_iter_id,
        self.current_sign_iter_id,
    ));
}
```

**Alternative Mitigation:**
Include `sign_iter_id` in the `SignatureShareResponse.hash()` implementation to bind it cryptographically: [6](#0-5) 

Add after line 454:
```rust
hasher.update(self.sign_iter_id.to_be_bytes());
```

**Testing Recommendations:**
- Add integration tests that simulate timeout scenarios with replayed messages
- Verify that responses with mismatched `sign_iter_id` are rejected with `Error::BadSignIterId`
- Test both FROST and FIRE coordinators with multiple signing iterations
- Verify that packet signature verification (when enabled) properly validates all fields

**Deployment Considerations:**
- This is a backward-compatible fix (adds stricter validation)
- Existing honest signers already send correct `sign_iter_id` values
- Only affects malicious or buggy signers attempting cross-iteration replay

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup Phase:**
   - Start FIRE coordinator with 3 signers (threshold=2)
   - Complete DKG successfully with `dkg_id=1`
   - Set signing timeout to 5 seconds

2. **Iteration 1 - Capture Phase:**
   - Coordinator starts signing with `sign_id=1, sign_iter_id=1`
   - Coordinator sends `NonceRequest(sign_id=1, sign_iter_id=1)`
   - All signers respond with `NonceResponse` containing nonces N1
   - Coordinator sends `SignatureShareRequest(sign_id=1, sign_iter_id=1, nonces=N1)`
   - Malicious signer computes shares S1_mal using nonces N1
   - Malicious signer SAVES but does NOT send `SignatureShareResponse(sign_id=1, sign_iter_id=1, shares=S1_mal)`
   - Wait for timeout (5 seconds)

3. **Iteration 2 - Replay Attack:**
   - FIRE coordinator timeout triggers, increments to `sign_iter_id=2`
   - Coordinator sends `NonceRequest(sign_id=1, sign_iter_id=2)`
   - Coordinator validates incoming responses check `sign_iter_id=2` ✓
   - Honest signers respond with new `NonceResponse` containing nonces N2
   - Coordinator sends `SignatureShareRequest(sign_id=1, sign_iter_id=2, nonces=N2)`
   - Honest signers compute shares S2 using nonces N2, send responses with `sign_iter_id=2`
   - Malicious signer REPLAYS saved message: `SignatureShareResponse(sign_id=1, sign_iter_id=1, shares=S1_mal)`

4. **Expected Behavior:**
   - Coordinator should reject with `Error::BadSignIterId(1, 2)`

5. **Actual Behavior:**
   - Coordinator's `gather_sig_shares` validates: `dkg_id=1` ✓, `sign_id=1` ✓
   - No check for `sign_iter_id` (1 vs 2)
   - Coordinator accepts S1_mal computed with old nonces N1
   - Coordinator aggregates: S2 (with nonces N2) + S1_mal (with nonces N1)
   - Signature verification fails (nonce mismatch)
   - `check_signature_shares` identifies malicious signer
   - Signing round fails, must retry

**Reproduction Instructions:**
1. Modify a signer to delay sending `SignatureShareResponse` by 10 seconds
2. Configure FIRE coordinator with 5-second sign timeout
3. Start signing round with message "test"
4. Observe timeout and iteration increment
5. Have delayed signer send old response
6. Observe signing failure and retry

### Citations

**File:** src/state_machine/coordinator/frost.rs (L479-493)
```rust
            if nonce_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(nonce_response.dkg_id, self.current_dkg_id));
            }
            if nonce_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    nonce_response.sign_id,
                    self.current_sign_id,
                ));
            }
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
            }
```

**File:** src/state_machine/coordinator/frost.rs (L600-611)
```rust
            if sig_share_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    sig_share_response.dkg_id,
                    self.current_dkg_id,
                ));
            }
            if sig_share_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    sig_share_response.sign_id,
                    self.current_sign_id,
                ));
            }
```

**File:** src/state_machine/coordinator/fire.rs (L847-861)
```rust
            if nonce_response.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(nonce_response.dkg_id, self.current_dkg_id));
            }
            if nonce_response.sign_id != self.current_sign_id {
                return Err(Error::BadSignId(
                    nonce_response.sign_id,
                    self.current_sign_id,
                ));
            }
            if nonce_response.sign_iter_id != self.current_sign_iter_id {
                return Err(Error::BadSignIterId(
                    nonce_response.sign_iter_id,
                    self.current_sign_iter_id,
                ));
            }
```

**File:** src/state_machine/coordinator/fire.rs (L964-966)
```rust
    fn request_sig_shares(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.signature_shares.clear();
        info!(
```

**File:** src/state_machine/coordinator/fire.rs (L1027-1038)
```rust
        if sig_share_response.dkg_id != self.current_dkg_id {
            return Err(Error::BadDkgId(
                sig_share_response.dkg_id,
                self.current_dkg_id,
            ));
        }
        if sig_share_response.sign_id != self.current_sign_id {
            return Err(Error::BadSignId(
                sig_share_response.sign_id,
                self.current_sign_id,
            ));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1114-1169)
```rust
            // Calculate the aggregate signature
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();

            debug!(
                "aggregator.sign({}, {:?}, {:?}, {})",
                bs58::encode(&self.message).into_string(),
                nonces.len(),
                shares.len(),
                self.party_polynomials.len(),
            );

            self.aggregator.init(&self.party_polynomials)?;

            if let SignatureType::Taproot(merkle_root) = signature_type {
                let schnorr_proof = self.aggregator.sign_taproot(
                    &self.message,
                    &nonces,
                    &shares,
                    &key_ids,
                    merkle_root,
                )?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else if let SignatureType::Schnorr = signature_type {
                let schnorr_proof =
                    self.aggregator
                        .sign_schnorr(&self.message, &nonces, &shares, &key_ids)?;
                debug!("SchnorrProof ({}, {})", schnorr_proof.r, schnorr_proof.s);
                self.schnorr_proof = Some(schnorr_proof);
            } else {
                let signature = self
                    .aggregator
                    .sign(&self.message, &nonces, &shares, &key_ids)?;
                debug!("Signature ({}, {})", signature.R, signature.z);
                self.signature = Some(signature);
            }
```

**File:** src/net.rs (L437-448)
```rust
pub struct SignatureShareResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Signature shares from this Signer
    pub signature_shares: Vec<SignatureShare>,
}
```

**File:** src/net.rs (L450-465)
```rust
impl Signable for SignatureShareResponse {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("SIGNATURE_SHARE_RESPONSE".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());

        for signature_share in &self.signature_shares {
            hasher.update(signature_share.id.to_be_bytes());
            hasher.update(signature_share.z_i.to_bytes());
            for key_id in &signature_share.key_ids {
                hasher.update(key_id.to_be_bytes());
            }
        }
    }
}
```
