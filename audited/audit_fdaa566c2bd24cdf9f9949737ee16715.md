### Title
Duplicate Key IDs Bypass HashSet Validation Causing Signature Generation Denial of Service

### Summary
The `gather_nonces()` function validates nonce response key_ids by converting the Vec to a HashSet before comparison, which removes duplicates. A malicious signer can include duplicate key_ids in their NonceResponse that pass validation but cause all signature shares to be computed with incorrect Lagrange coefficients, resulting in signature verification failure and denial of service for all signing rounds involving the malicious signer.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The validation logic converts `nonce_response.key_ids` (a `Vec<u32>`) to a `HashSet<u32>` before comparing against the configured `signer_key_ids`. This conversion removes duplicates, allowing a Vec like `[1, 1, 2]` to pass validation as `{1, 2}` when the config expects `{1, 2}`. [2](#0-1) 

The NonceResponse struct stores `key_ids` as a `Vec<u32>`, and the entire NonceResponse with the original duplicated Vec is stored: [3](#0-2) 

**Propagation Through Protocol:**

1. The coordinator sends all stored nonce_responses to signers in the SignatureShareRequest: [4](#0-3) 

2. Each signer extracts key_ids by flattening all nonce_responses, preserving duplicates: [5](#0-4) 

3. The coordinator performs the same extraction for aggregation: [6](#0-5) 

**Impact on Lagrange Coefficients:**

The duplicated key_ids list is passed to `compute::lambda`, which computes Lagrange interpolation coefficients: [7](#0-6) 

When key_ids contains duplicates like `[1, 1, 2, 3]`, the lambda computation for `lambda(2, [1, 1, 2, 3])` multiplies the same factor multiple times:
- For j=1 (first occurrence): multiply by `1/(1-2) = -1`
- For j=1 (second occurrence): multiply by `-1` again
- Result: `(-1) * (-1) = 1` instead of just `-1`

This produces incorrect Lagrange coefficients. Signers use these incorrect lambdas when generating signature shares: [8](#0-7) 

The aggregator uses the same incorrect lambdas when checking signature shares: [9](#0-8) 

**Why Existing Mitigations Fail:**

The validation uses HashSet comparison which inherently removes duplicates, making it ineffective against this attack vector. There is no validation that checks the original Vec for duplicates before the HashSet conversion.

### Impact Explanation

**Specific Harm:**
A malicious signer can cause all signing rounds they participate in to fail by including duplicate key_ids in their NonceResponse. Since all signers compute signature shares using the incorrect (duplicated) key_ids list, and the Lagrange interpolation produces wrong coefficients, the aggregated signature will fail verification.

**Quantified Impact:**
- Every signing round involving the malicious signer will fail
- The attack is repeatable across multiple rounds until the malicious signer is detected and removed
- If the malicious signer is required for threshold (e.g., 2-of-3 with threshold=2), this blocks all signatures

**Who is Affected:**
- All honest signers participating in rounds with the malicious signer
- Any system depending on WSTS signatures for transaction signing or block confirmation
- The coordinator attempting to aggregate signatures

**Severity Justification:**
This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." The attack:
- Prevents signature generation (DoS)
- Does not allow invalid signatures to be accepted
- Does not compromise private keys or enable unauthorized signing
- Requires the attacker to be a valid signer in the configuration
- Is detectable (signature verification consistently fails)

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a valid signer in the WSTS configuration with assigned key_ids
- Must have network access to send NonceResponse messages to the coordinator
- No cryptographic breaks required

**Attack Complexity:**
Low. The attacker simply needs to:
1. Receive a NonceRequest from the coordinator
2. Generate valid nonces
3. Modify their NonceResponse to include duplicate key_ids (e.g., change `[3, 4]` to `[3, 3, 4]`)
4. Send the modified response

**Economic Feasibility:**
The attack is essentially free for a malicious insider who is already a valid signer. There are no significant costs.

**Detection Risk:**
High detection probability:
- Signature verification will consistently fail for all rounds involving the attacker
- Logs will show the specific signer_id involved in failed rounds
- The pattern is easy to identify after 1-2 failed rounds

**Probability of Success:**
100% success at causing DoS if the attacker is a valid signer. However:
- The attack is easily detected and mitigated by removing the malicious signer
- The impact is limited to signing rounds requiring that signer
- Does not allow the attacker to create valid signatures or bypass security controls

### Recommendation

**Primary Fix:**
Validate that the original `key_ids` Vec contains no duplicates before the HashSet conversion:

```rust
// In gather_nonces() at line 881, before the HashSet conversion:
let nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

// Add this check:
if nonce_response_key_ids.len() != nonce_response.key_ids.len() {
    warn!(
        signer_id = %nonce_response.signer_id, 
        "Nonce response key_ids contains duplicates"
    );
    return Ok(());
}

if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

**Apply Same Fix to Signature Share Validation:**
Add duplicate detection at lines 1066-1076 in `gather_sig_shares()`: [10](#0-9) 

**Alternative Mitigation:**
Use the config's `signer_key_ids` directly instead of trusting the nonce_response.key_ids when building the key_ids list for aggregation. This is partially done at lines 935-938 but only for tracking, not for the actual key_ids passed to signers.

**Testing Recommendations:**
1. Add unit test with a NonceResponse containing duplicate key_ids
2. Verify that the validation rejects the response
3. Add integration test showing signature generation works correctly after fix
4. Test that legitimate responses with correct key_ids still pass validation

**Deployment Considerations:**
- This is a protocol-level fix that should be deployed to all coordinators
- Backward compatible: honest signers never send duplicates
- Can be deployed without changing the NonceResponse message format
- Consider adding monitoring/alerts for detected duplicate key_ids attempts

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup**: Assume a 2-of-3 threshold configuration where:
   - Honest signer A controls key_ids `[1, 2]`
   - Malicious signer B controls key_ids `[3, 4]`
   - Honest signer C controls key_ids `[5, 6]`
   - Threshold = 4 keys required

2. **Attack Execution**:
   ```
   Step 1: Coordinator sends NonceRequest to all signers
   
   Step 2: Honest signers A and C respond normally:
           A sends NonceResponse with key_ids: [1, 2]
           C sends NonceResponse with key_ids: [5, 6]
   
   Step 3: Malicious signer B sends crafted NonceResponse:
           B sends NonceResponse with key_ids: [3, 3, 4]  // duplicate 3!
   
   Step 4: Coordinator validation:
           A: {1, 2} == config{1, 2} ✓
           B: {3, 4} == config{3, 4} ✓  // duplicates removed by HashSet!
           C: {5, 6} == config{5, 6} ✓
           All pass validation
   
   Step 5: Coordinator sends SignatureShareRequest with all nonce_responses
   
   Step 6: All signers extract key_ids:
           key_ids = [1, 2, 3, 3, 4, 5, 6]  // duplicate 3 preserved!
   
   Step 7: Signer A computes signature share for key_id=1:
           lambda(1, [1, 2, 3, 3, 4, 5, 6]) computes incorrectly
           Signature share z_i uses wrong Lagrange coefficient
   
   Step 8: All signature shares computed with wrong lambdas
   
   Step 9: Aggregator attempts to verify signature:
           Signature verification FAILS
           
   Step 10: Signing round aborted - DoS achieved
   ```

**Expected vs Actual Behavior:**

Expected: `lambda(2, [1, 2, 3, 4])` should compute `(-1) * 3/2 = -3/2`

Actual with duplicates: `lambda(2, [1, 2, 3, 3, 4])` computes `(-1) * (-1) * 3/2 = 3/2`

The sign is flipped, causing signature verification to fail.

**Reproduction Instructions:**

1. Modify the NonceResponse creation in a test signer to include duplicate key_ids
2. Run the signing protocol with the modified signer
3. Observe that all signature verifications fail with the error from check_signature_shares
4. Confirm that the coordinator logs show "Signature verification failed"
5. Apply the fix (duplicate detection) and verify the attack is prevented

### Citations

**File:** src/state_machine/coordinator/fire.rs (L871-889)
```rust
            let Some(signer_key_ids) = self
                .config
                .public_keys
                .signer_key_ids
                .get(&nonce_response.signer_id)
            else {
                warn!(signer_id = %nonce_response.signer_id, "No keys IDs configured");
                return Ok(());
            };

            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-982)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/net.rs (L321-321)
```rust
    pub key_ids: Vec<u32>,
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L69-80)
```rust
/// Compute the Lagrange interpolation value
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L393-404)
```rust
            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }
```
