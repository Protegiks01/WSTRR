# Audit Report

## Title
Non-Participating Signers Can Force DKG Failure Through Stale Invalid Share Records

## Summary
The `dkg_ended()` function contains a logic flaw where it checks if `invalid_private_shares` is empty without filtering by the set of participating signers from the current DKG round. A malicious signer can exploit this by sending invalid private shares to victims, then intentionally failing to complete the DKG themselves. The stale invalid share record persists and causes all victims to report DKG failure, even when all actual participating signers have valid shares.

## Finding Description

The vulnerability exists in the DKG end validation logic. When a signer receives the `DkgEndBegin` message, it processes shares only from participating signers listed in `signer_ids`. [1](#0-0) 

The code carefully validates shares from each participating signer: [2](#0-1) 

However, after all these validations pass, the code performs an unfiltered check on `invalid_private_shares`: [3](#0-2) 

This check does not filter by the participating signers in `signer_ids_set`. If `invalid_private_shares` contains any entry from a non-participating signer, the DKG immediately fails.

The `invalid_private_shares` map is populated during private share distribution when decryption or scalar parsing fails: [4](#0-3) 

While `reset()` clears this map, it only does so at DKG initiation: [5](#0-4) 

Once malformed shares are recorded, they persist throughout the entire DKG round.

**Attack Scenario:**
1. Attacker sends malformed encrypted shares to all victims during private share distribution
2. Victims decrypt and fail to parse the shares, inserting attacker's ID into `invalid_private_shares`
3. Attacker intentionally fails to send shares to coordinator (timeout or disconnect)
4. Coordinator creates `DkgEndBegin` with only responsive signers, excluding the attacker: [6](#0-5) 
5. Victims validate shares from participating signers - all valid
6. But the check at line 611 fails due to attacker's stale record
7. All victims report `BadPrivateShares` failure
8. Coordinator detects failures and aborts entire DKG: [7](#0-6) 

The coordinator's validation logic attempts to verify bad share claims, but since the attacker is not in `dkg_private_shares` (didn't send shares to coordinator), it may incorrectly mark victims as malicious: [8](#0-7) 

## Impact Explanation

This vulnerability causes **complete DKG denial of service**. A single malicious signer can prevent any DKG from completing, regardless of how many honest signers participate or whether the threshold is met.

**Severity: Medium to High**

Maps to Medium severity under "Any transient consensus failures" - the inability to complete DKG is a consensus failure that prevents key generation.

Could escalate to High severity under "Any unintended chain split or network partition" - if the system cannot generate signing keys, different nodes may end up with different key material or fail to agree on a group key, leading to network partition.

**Who Is Affected:**
- All signers in the WSTS network are blocked from completing DKG
- New deployments cannot generate initial keys
- Existing deployments cannot rotate keys
- Systems cannot recover from lost/compromised keys

**Why Not Critical:**
- Doesn't directly cause fund loss
- Doesn't confirm invalid transactions
- Requires attacker to be a registered signer
- Detectable through logs

**Why Not Just Low:**
- Impact is persistent, not transient
- Completely blocks critical functionality
- Violates DKG threshold security model
- Requires manual intervention to resolve

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- Attacker must be a registered signer (realistic threat model assumption)
- Send malformed encrypted shares (random bytes or wrong encryption key)
- Disconnect or timeout on subsequent coordinator messages
- No cryptographic breaks required
- No special hardware or computational resources needed

**Success Rate: ~100%**

The vulnerability is deterministic:
- Logic flaw guarantees the attack works every time
- No race conditions or timing dependencies
- No randomness in victim behavior
- Only defense is manual exclusion of attacker by administrators

**Detection:**
The attack is detectable but attribution is complex. Victim logs will show warnings about invalid shares, but the coordinator's validation may incorrectly blame victims rather than the actual attacker who didn't participate.

## Recommendation

Filter `invalid_private_shares` by the set of participating signers before checking if it's empty. The fix should be applied at line 611:

```rust
// Filter invalid_private_shares to only include participating signers
let invalid_participating_shares: HashMap<u32, BadPrivateShare> = self
    .invalid_private_shares
    .iter()
    .filter(|(signer_id, _)| signer_ids_set.contains(signer_id))
    .map(|(k, v)| (*k, v.clone()))
    .collect();

let dkg_end = if invalid_participating_shares.is_empty() {
    // proceed with compute_secrets
} else {
    // return failure with filtered invalid shares
    DkgEnd {
        dkg_id: self.dkg_id,
        signer_id: self.signer_id,
        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
            invalid_participating_shares,
        )),
    }
};
```

This ensures that only invalid shares from signers who are actually participating in the current DKG round cause failure.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_non_participating_signer_causes_dkg_failure() {
        // Setup: Create a signer with 3 configured signers, threshold 2
        let mut rng = rand::thread_rng();
        let mut signer = Signer::new(/* ... */);
        
        // Step 1: Start DKG
        let dkg_begin = DkgBegin { dkg_id: 1 };
        signer.dkg_begin(&dkg_begin, &mut rng).unwrap();
        
        // Step 2: Simulate receiving invalid shares from signer_id 2
        let malformed_shares = DkgPrivateShares {
            dkg_id: 1,
            signer_id: 2,
            shares: create_malformed_encrypted_shares(), // Invalid encrypted data
        };
        signer.dkg_private_shares(&malformed_shares, &mut rng).unwrap();
        
        // Verify signer_id 2 is now in invalid_private_shares
        assert!(signer.invalid_private_shares.contains_key(&2));
        
        // Step 3: Receive valid shares from signer_id 0 and 1
        let valid_shares_0 = create_valid_shares(0, 1);
        let valid_shares_1 = create_valid_shares(1, 1);
        signer.dkg_private_shares(&valid_shares_0, &mut rng).unwrap();
        signer.dkg_private_shares(&valid_shares_1, &mut rng).unwrap();
        
        // Step 4: Receive DkgEndBegin with only signers 0 and 1 (signer 2 didn't participate)
        let dkg_end_begin = DkgEndBegin {
            dkg_id: 1,
            signer_ids: vec![0, 1], // Signer 2 excluded!
            key_ids: vec![],
        };
        signer.dkg_end_begin_msg = Some(dkg_end_begin);
        
        // Step 5: Call dkg_ended and observe failure
        let result = signer.dkg_ended(&mut rng).unwrap();
        
        // Expected: DKG should succeed because signers 0 and 1 meet threshold
        // Actual: DKG fails because invalid_private_shares contains signer 2
        if let Message::DkgEnd(dkg_end) = result {
            assert!(matches!(dkg_end.status, DkgStatus::Failure(_)));
            // This demonstrates the vulnerability: DKG fails even though
            // all participating signers (0 and 1) have valid shares
        }
    }
}
```

The test demonstrates that a non-participating signer's invalid share record causes DKG failure for all participants, even when the participating signers have sufficient valid shares to meet the threshold.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L529-534)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L551-583)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L611-660)
```rust
        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };
```

**File:** src/state_machine/signer/mod.rs (L1076-1096)
```rust
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L461-465)
```rust
        let dkg_end_begin = DkgEndBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_private_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
```

**File:** src/state_machine/coordinator/fire.rs (L695-701)
```rust
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };
```

**File:** src/state_machine/coordinator/fire.rs (L779-789)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```
