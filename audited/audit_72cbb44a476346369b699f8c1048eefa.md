### Title
Unbounded Message Length Enables Resource Exhaustion DoS in Signature Binding Computation

### Summary
The `expand_to_scalar()` function and the entire signing flow lack maximum message length validation, allowing a malicious coordinator to send arbitrarily large messages (gigabytes) that cause memory exhaustion and CPU-intensive hashing operations in all signer nodes. This constitutes a remotely-exploitable denial of service attack against signer nodes.

### Finding Description

**Exact Code Location:**

The vulnerability exists across multiple code locations:

1. `expand_to_scalar()` function accepts unbounded message length: [1](#0-0) 

2. `start_signing_round()` stores the message without length validation: [2](#0-1) 

3. `NonceRequest` message structure allows unbounded `Vec<u8>`: [3](#0-2) 

4. `binding()` function concatenates the full message into a buffer and passes it to `expand_to_scalar()`: [4](#0-3) 

5. The signing flow in `v1.rs` uses the message directly in binding computation: [5](#0-4) 

**Root Cause:**

The root cause is the absence of input validation on message length at any point in the signing protocol. The code path is:

1. Coordinator calls `start_signing_round(message, ...)` with no length check (line 979 stores `message.to_vec()` directly)
2. Message is embedded in `NonceRequest` and sent to all signers
3. Signers process `SignatureShareRequest` containing the message
4. Each signer's `sign()` method calls `compute::binding(&self.id(), nonces, msg)` which appends the full message to a buffer
5. `binding()` calls `expand_to_scalar(&buf, prefix)` where `buf` contains the concatenated message
6. `expand_to_scalar()` calls `ExpandMsgXmd::<Sha256>::expand_message()` which must hash the entire input buffer

**Why Existing Mitigations Fail:**

No mitigations exist. The security model assumes a trusted coordinator, but provides no defense-in-depth:
- No maximum message length constant defined
- No validation in `start_signing_round()`, `NonceRequest`, or any deserialization code
- No resource limits or rate limiting
- Serde serialization imposes no practical bounds on `Vec<u8>` fields

### Impact Explanation

**Specific Harm:**

A malicious or compromised coordinator can cause denial of service in all participating signer nodes by sending extremely large messages (e.g., 100MB to multiple GB). Each affected signer will:

1. **Memory Exhaustion**: Allocate memory to store the large message in `Vec<u8>`. A 1GB message requires 1GB RAM per signer.

2. **CPU Exhaustion**: Hash the large message via SHA-256 in `ExpandMsgXmd`. SHA-256 processes approximately 400MB/sec, so:
   - 1GB message: ~2.5 seconds per hash operation
   - 10GB message: ~25 seconds per hash operation
   - Multiple hash operations per signature share (binding computed for each party)

3. **Operational Impact**: Legitimate signing operations blocked while processing malicious message, preventing the signer from participating in valid signing rounds.

**Who Is Affected:**

All signer nodes participating in a signing round initiated by the compromised coordinator.

**Severity Justification:**

This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." The attack:
- Is remotely exploitable (coordinator sends malicious message over network)
- Causes denial of service in signer nodes (resource exhaustion)
- Does not cause consensus failure, fund loss, or chain splits (higher severities)

### Likelihood Explanation

**Required Attacker Capabilities:**

- Compromise or control of the coordinator
- Ability to call `start_signing_round()` with arbitrary message content
- No additional cryptographic breaks required

**Attack Complexity:**

Low. The attack is straightforward:
1. Attacker gains coordinator credentials (e.g., compromised private key)
2. Attacker constructs extremely large message (e.g., 1GB of random data)
3. Attacker calls `start_signing_round(large_message, ...)`
4. All signers automatically process the message during signature share computation

**Economic Feasibility:**

Highly feasible. Creating and transmitting large messages requires minimal resources compared to the impact on victim nodes.

**Detection Risk:**

Moderate. Large messages would be observable in network traffic and logs, but may not trigger alerts unless specific monitoring is in place.

**Estimated Probability:**

While the security model assumes a trusted coordinator, coordinator key compromise is a realistic threat in production systems. The lack of any fallback protection (defense-in-depth) makes this attack viable if the trust assumption is violated. Probability depends on coordinator security practices but cannot be dismissed as theoretical.

### Recommendation

**Primary Mitigation:**

Enforce a maximum message length appropriate for the expected use case. For Bitcoin/cryptocurrency contexts, messages are typically transaction data (hundreds of bytes to a few KB):

```rust
pub const MAX_MESSAGE_LENGTH: usize = 65_536; // 64KB

pub fn expand_to_scalar(msg: &[u8], dst: &[u8]) -> Result<Scalar, EllipticCurveError> {
    if msg.len() > MAX_MESSAGE_LENGTH {
        return Err(EllipticCurveError::MessageTooLarge);
    }
    // existing implementation
}
```

**Additional Mitigations:**

1. Add validation in `start_signing_round()` before storing the message: [6](#0-5) 

2. Add validation when deserializing `NonceRequest` messages on the signer side

3. Consider implementing resource limits (timeouts, memory caps) during signature computation

**Testing Recommendations:**

1. Add unit test with message at maximum allowed length (should succeed)
2. Add unit test with message exceeding maximum (should fail with appropriate error)
3. Add integration test measuring resource usage with various message sizes
4. Add benchmark comparing performance with small vs. maximum-sized messages

**Deployment Considerations:**

- This is a breaking change requiring coordination across all nodes
- Choose maximum length based on actual use case requirements
- Document the limit clearly in API documentation
- Consider gradual rollout with warnings before enforcement

### Proof of Concept

**Exploitation Algorithm:**

```
1. Attacker compromises coordinator credentials (private key)

2. Attacker constructs large message:
   message = [0u8; 1_073_741_824]  // 1GB of zeros

3. Attacker initiates signing round:
   coordinator.start_signing_round(&message, SignatureType::Frost, None)

4. Coordinator sends NonceRequest with 1GB message to all signers

5. Each signer receives NonceRequest and stores message in memory:
   - Memory allocation: 1GB per signer
   
6. Coordinator sends SignatureShareRequest

7. Each signer processes request:
   - Calls sign(msg, ...) where msg is the 1GB message
   - Calls compute::binding(&id, nonces, msg)
   - binding() creates buffer: 32 bytes (id) + nonce_data + 1GB (msg)
   - Calls expand_to_scalar(&buffer, prefix)
   - ExpandMsgXmd hashes ~1GB of data: ~2.5 seconds CPU time
   
8. Result: All signers experience:
   - 1GB memory consumption per signing round
   - Multiple seconds of CPU-intensive hashing
   - Inability to process legitimate signing requests during this time
```

**Expected vs. Actual Behavior:**

- **Expected**: Message length validation rejects messages exceeding reasonable size (e.g., 64KB)
- **Actual**: No validation exists; arbitrarily large messages are accepted and processed

**Reproduction Instructions:**

1. Set up WSTS coordinator and signers per standard configuration
2. Modify coordinator test to use large message (e.g., 100MB)
3. Observe signer memory usage and CPU consumption during signature share computation
4. Confirm that processing time scales linearly with message size
5. Verify that legitimate signing requests cannot be processed during attack

**Notes:**

The vulnerability is particularly concerning because:
- The security model's trust assumption (honest coordinator) provides no protection against key compromise
- No defense-in-depth measures exist
- Impact scales with number of signers (distributed DoS)
- Attack is silent and may not be immediately detected without specific monitoring

### Citations

**File:** src/util.rs (L28-34)
```rust
pub fn expand_to_scalar(msg: &[u8], dst: &[u8]) -> Result<Scalar, EllipticCurveError> {
    // The requested output length (32 bytes) means that the underlying hash function will not fail.
    let mut buf = [0u8; 32];
    // This will only fail if the dst exceeds 255 bytes.
    ExpandMsgXmd::<Sha256>::expand_message(&[msg], &[dst], buf.len())?.fill_bytes(&mut buf);
    Ok(Scalar::from(buf))
}
```

**File:** src/state_machine/coordinator/frost.rs (L969-988)
```rust
    fn start_signing_round(
        &mut self,
        message: &[u8],
        signature_type: SignatureType,
        sign_id: Option<u64>,
    ) -> Result<Packet, Error> {
        // We cannot sign if we haven't first set DKG (either manually or via DKG round).
        if self.aggregate_public_key.is_none() {
            return Err(Error::MissingAggregatePublicKey);
        }
        self.message = message.to_vec();
        if let Some(id) = sign_id {
            self.current_sign_id = id;
        } else {
            self.current_sign_id = self.current_sign_id.wrapping_add(1);
        }
        info!("Starting signing round {}", self.current_sign_id);
        self.move_to(State::NonceRequest(signature_type))?;
        self.request_nonces(signature_type)
    }
```

**File:** src/net.rs (L264-275)
```rust
pub struct NonceRequest {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// The message to sign
    pub message: Vec<u8>,
    /// What type of signature to create
    pub signature_type: SignatureType,
}
```

**File:** src/compute.rs (L17-33)
```rust
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```

**File:** src/v1.rs (L217-229)
```rust
    pub fn sign(&self, msg: &[u8], signers: &[u32], nonces: &[PublicNonce]) -> SignatureShare {
        let (_, aggregate_nonce) = compute::intermediate(msg, signers, nonces);
        let mut z = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
        z += compute::challenge(&self.group_key, &aggregate_nonce, msg)
            * &self.private_key
            * compute::lambda(self.id, signers);

        SignatureShare {
            id: self.id,
            z_i: z,
            key_ids: vec![self.id],
        }
    }
```
