### Title
Coordinator Panic Due to Premature Signer Removal from Wait List During Signature Share Gathering

### Summary
The `gather_sig_shares()` function removes signers from the wait list before validating their signature share responses. When validation fails, the signer remains absent from both the wait list and the signature shares map, causing the coordinator to panic when attempting aggregation. This allows any malicious signer to crash the coordinator by sending invalid signature share responses.

### Finding Description

**Exact Code Location:**
- File: `src/state_machine/coordinator/fire.rs`
- Function: `gather_sig_shares()`
- Vulnerable lines: 1042-1044 (premature removal), 1113-1134 (panic during aggregation)

**Root Cause:**
The function removes a signer from `sign_wait_signer_ids` at lines 1042-1044 before performing any validation of the signature share response: [1](#0-0) 

After this removal, several validation checks occur that can fail and return errors: [2](#0-1) 

When any of these validations fail (e.g., `Error::BadKeyIDsForSigner` at line 1075), the function returns an error early. Critically, the signer has already been removed from the wait list but their shares are never added to `self.signature_shares` (which only happens at lines 1088-1090 after successful validation).

Later, when the wait list becomes empty, aggregation proceeds: [3](#0-2) 

At line 1134, the code attempts to access `self.signature_shares[i]` for every signer in `public_nonces`. The BTreeMap index operator `[]` panics when a key doesn't exist, causing the coordinator to crash.

**Why Existing Mitigations Fail:**
- There is no threshold check before aggregation at line 1113; it only checks if the wait list is empty
- The timeout handler at lines 173-208 only marks signers still in the wait list as malicious, missing those already removed due to validation failures
- No defensive programming (e.g., `.get()` instead of `[]`) protects against missing entries in the signature shares map [4](#0-3) 

### Impact Explanation

**Specific Harm:**
A malicious signer can crash the coordinator by sending a signature share response that fails validation after being removed from the wait list. This causes a panic at line 1134 when aggregation attempts to access a non-existent entry in `self.signature_shares`.

**Quantified Impact:**
- **Coordinator Crash:** Immediate panic and termination of the coordinator process
- **DoS Duration:** Indefinite until coordinator is restarted; attacker can repeat the attack on each restart
- **Affected Parties:** All participants waiting for signature completion; any system depending on the coordinator for threshold signatures

**Severity Justification:**
Per the audit scope, "Any remotely-exploitable denial of service in a node" is classified as **LOW** severity. This vulnerability fits precisely this definition:
- Remotely exploitable by any configured signer
- Causes denial of service by crashing the coordinator
- Does not cause invalid signatures to be accepted (crashes before signature is produced)
- Does not directly cause consensus failures or fund loss

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a configured signer with valid credentials in the WSTS network
- Ability to send malformed signature share responses to the coordinator
- No cryptographic breaks required

**Attack Complexity:**
Low. The attacker simply needs to:
1. Participate normally in the nonce gathering phase
2. Send a signature share response with key_ids that don't match their configured key_ids

**Economic Feasibility:**
Extremely feasible. The attack requires only:
- Network access to send messages
- Valid signer credentials (already possessed by legitimate signers)
- No computational cost beyond normal message crafting

**Detection Risk:**
Low detection risk initially. The attack appears as a validation error followed by a coordinator crash, which could be mistaken for a legitimate bug or network issue. However, repeated crashes from the same signer would eventually reveal the attack.

**Estimated Probability:**
High. Any malicious signer can execute this attack with 100% success rate. The only barrier is having signer credentials.

### Recommendation

**Primary Fix:**
Move the wait list removal to occur AFTER all validation passes successfully. The removal should only happen when the signature shares are actually being added to `self.signature_shares`:

1. Remove lines 1042-1044 (early removal)
2. Add the removal immediately before line 1088 (after all validations pass)
3. Add a threshold check before aggregation at line 1113 to verify `sign_recv_key_ids.len() >= self.config.threshold`

**Defensive Programming:**
Replace the BTreeMap index operator `[]` with `.get()` at line 1134 to gracefully handle missing entries:
```rust
let shares = message_nonce
    .public_nonces
    .iter()
    .filter_map(|(i, _)| self.signature_shares.get(i))
    .flat_map(|shares| shares.clone())
    .collect::<Vec<SignatureShare>>();
```

**Testing Recommendations:**
1. Add unit test where a signer sends valid nonces but invalid signature shares with mismatched key_ids
2. Verify the signer remains in wait list after validation failure
3. Verify coordinator doesn't panic when wait list becomes empty with insufficient shares
4. Test that timeout handler correctly marks such signers as malicious

**Deployment Considerations:**
This fix should be deployed urgently as it's a straightforward DoS vector. The change is backward compatible and doesn't affect the protocol's cryptographic properties.

### Proof of Concept

**Setup:**
- Configure 3 signers: A (5 key_ids: {0,1,2,3,4}), B (5 key_ids: {5,6,7,8,9}), Attacker (5 key_ids: {10,11,12,13,14})
- Set threshold = 6 key_ids
- Total available: 15 key_ids

**Exploitation Steps:**

1. **Nonce Phase (Normal):**
   - All three signers (A, B, Attacker) send valid `NonceResponse` messages
   - All added to `message_nonces.public_nonces` map
   - All added to `sign_wait_signer_ids` = {A, B, Attacker}
   - Threshold met (15 ≥ 6), coordinator moves to `State::SigShareRequest`

2. **Signature Share Phase (Attack):**
   - Signer A sends valid `SignatureShareResponse`
     - Passes all validations
     - Added to `self.signature_shares[A]`
     - `sign_recv_key_ids` accumulates 5 key_ids
   
   - Attacker sends `SignatureShareResponse` with **mismatched key_ids**: {99,100,101,102,103}
     - Line 1044: Attacker removed from `sign_wait_signer_ids` → now {B}
     - Line 1073: Validation detects key_id mismatch
     - Line 1075: Returns `Error::BadKeyIDsForSigner(Attacker)`
     - Attacker's shares **NOT** added to `self.signature_shares`
     - State remains `SigShareGather`
   
   - Signer B also sends invalid response or times out
     - Removed from `sign_wait_signer_ids` → now {}
     - B's shares **NOT** added to `self.signature_shares`

3. **Aggregation Trigger (Crash):**
   - Next packet arrives (any subsequent message)
   - `gather_sig_shares()` executes
   - Line 1113: Check `sign_wait_signer_ids.is_empty()` → TRUE
   - Line 1115-1134: Attempts to collect shares
   - Line 1134: `self.signature_shares[Attacker]` → **PANIC: key not found**
   - Coordinator crashes

**Expected Behavior:**
Coordinator should detect insufficient shares and either:
- Continue waiting for more responses
- Mark missing signers as malicious and restart the signing round
- Return an error about insufficient threshold

**Actual Behavior:**
Coordinator panics with error: `attempted to access BTreeMap with non-existent key`

**Reproduction:**
Send a `SignatureShareResponse` message with `signature_shares` containing key_ids that don't match the configured key_ids for the signer. The coordinator will remove the signer from the wait list, fail validation, and later panic when attempting aggregation.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L173-208)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
                        }
                    }
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1040-1044)
```rust
        // we were waiting on you, and you sent a packet for this sign round, so we won't take
        // another packet from you
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1076)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };

        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };

        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1113-1134)
```rust
        if message_nonce.sign_wait_signer_ids.is_empty() {
            // Calculate the aggregate signature
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
```
