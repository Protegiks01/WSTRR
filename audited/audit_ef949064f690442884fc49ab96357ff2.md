Audit Report

## Title
DKG Round ID Not Validated in Signer's dkg_public_share() Enabling Replay/Framing Attacks

## Summary
The signer's `dkg_public_share()` function accepts `DkgPublicShares` messages without validating that the `dkg_id` field matches the current DKG round. This allows network adversaries to replay legitimately-signed messages from previous DKG rounds, causing them to be stored and blocking legitimate current-round messages through duplicate detection. When these replayed shares fail ID proof verification during `dkg_ended()`, the innocent original sender is blamed for providing bad shares, resulting in DKG failure.

## Finding Description

The signer's `dkg_public_share()` method processes incoming `DkgPublicShares` messages but only validates signer ID existence, party ID ownership, and duplicate detection—it never checks if the message's `dkg_id` matches the signer's current `self.dkg_id`. [1](#0-0) 

In contrast, both coordinator implementations properly validate the `dkg_id` field before accepting shares. The FROST coordinator rejects mismatched IDs with `Error::BadDkgId`: [2](#0-1) 

The FIRE coordinator has identical validation: [3](#0-2) 

**Attack Flow:**

1. **Message Capture:** Attacker observes and saves valid `DkgPublicShares` messages from DKG round N
2. **Replay in Round M:** During a new DKG round M (where M ≠ N), attacker replays the old message to victim signers before legitimate round M messages arrive
3. **Storage Without Validation:** The signer's `dkg_public_share()` accepts and stores the replayed message keyed by `signer_id` with first-come-first-served semantics (lines 1023-1024)
4. **Legitimate Message Blocked:** When the legitimate round M message arrives, it's rejected as a duplicate (lines 1004-1011)
5. **Verification Failure:** During `dkg_ended()`, the stored shares are validated against the current `dkg_id` as context: [4](#0-3) 

The `check_public_shares` function calls `PolyCommitment::verify()` with the current round's `dkg_id` as context: [5](#0-4) [6](#0-5) 

The Schnorr ID proof verification recomputes the challenge using the provided context: [7](#0-6) 

The challenge computation includes the context parameter: [8](#0-7) 

Since the replayed share was created with context N but is being verified with context M, the challenge values differ and verification fails.

6. **Innocent Party Blamed:** The signer reports `DkgFailure::BadPublicShares` identifying the original sender (not the attacker) as malicious: [9](#0-8) 

**Why Existing Mitigations Fail:**

Packet signature verification only validates sender identity, not round ID. The `DkgPublicShares` message includes `dkg_id` in its hash for signing: [10](#0-9) 

This means old messages remain validly signed. The `Packet::verify()` method checks signatures but does not validate `dkg_id`: [11](#0-10) 

The signer processes `DkgPublicShares` messages without state-based filtering: [12](#0-11) 

This breaks the security guarantee that DKG rounds are isolated and only accept messages intended for the current round.

## Impact Explanation

This vulnerability enables a **Low severity denial of service** attack against DKG completion:

- **DKG Failure:** Replayed shares fail verification, causing the signer to abort DKG with `BadPublicShares` failure
- **Framing Attack:** The innocent original sender is falsely identified as malicious, potentially leading to their exclusion from future rounds
- **Persistent DoS:** The attack can be repeated for every subsequent DKG round, permanently preventing successful key generation
- **Node-Level Impact:** Each signer processes messages independently, so the attack affects individual nodes

This aligns with "Any remotely-exploitable denial of service in a node" under Low severity. If coordinated against multiple nodes, it could escalate to "Any network denial of service impacting more than 10 percent of miners."

## Likelihood Explanation

This attack is **highly likely** within the WSTS threat model:

**Attacker Capabilities (All Within Threat Model):**
- Network adversary can observe messages (to capture old `DkgPublicShares`)
- Network adversary can delay or reorder messages (to replay old messages before new ones arrive)
- No signature forgery required (uses legitimate old signatures)
- No cryptographic breaks required
- No private key access required

**Attack Simplicity:**
1. Save valid `DkgPublicShares` messages during any successful DKG round
2. Replay them to victim signers during subsequent rounds
3. Requires minimal resources (message storage and network access)

**Detection Difficulty:** The attack uses legitimately-signed messages, making it indistinguishable from network delays until verification fails.

## Recommendation

Add `dkg_id` validation to the signer's `dkg_public_share()` function, matching the coordinator's implementation:

```rust
pub fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Add dkg_id validation
    if dkg_public_shares.dkg_id != self.dkg_id {
        warn!(
            "Received DkgPublicShares with wrong dkg_id: {} (expected {})",
            dkg_public_shares.dkg_id,
            self.dkg_id
        );
        return Ok(vec![]);
    }

    // ... rest of existing validation ...
}
```

This ensures the signer only accepts shares belonging to the current DKG round, preventing replay attacks and maintaining round isolation.

## Proof of Concept

```rust
#[test]
fn test_dkg_public_share_replay_attack() {
    use rand_core::OsRng;
    
    let mut signer = create_test_signer(); // Helper to create configured signer
    
    // DKG Round 1
    signer.dkg_id = 1;
    let dkg_begin_1 = DkgBegin { dkg_id: 1 };
    signer.dkg_begin(&dkg_begin_1, &mut OsRng).unwrap();
    
    // Attacker captures legitimate DkgPublicShares from round 1
    let captured_shares = create_valid_dkg_public_shares(1, 2); // Round 1, from signer 2
    
    // Process legitimate message in round 1
    let result = signer.dkg_public_share(&captured_shares);
    assert!(result.is_ok());
    assert!(signer.dkg_public_shares.contains_key(&2)); // Stored
    
    // Start DKG Round 2
    signer.dkg_id = 2;
    signer.dkg_public_shares.clear(); // Reset state for new round
    let dkg_begin_2 = DkgBegin { dkg_id: 2 };
    signer.dkg_begin(&dkg_begin_2, &mut OsRng).unwrap();
    
    // VULNERABILITY: Attacker replays old message from round 1 in round 2
    let result = signer.dkg_public_share(&captured_shares);
    assert!(result.is_ok()); // Accepted without dkg_id validation!
    assert!(signer.dkg_public_shares.contains_key(&2)); // Wrong-round message stored
    
    // When legitimate round 2 message arrives, it's rejected as duplicate
    let legitimate_shares = create_valid_dkg_public_shares(2, 2); // Round 2, from signer 2
    let result = signer.dkg_public_share(&legitimate_shares);
    assert!(result.is_ok());
    // The stored share is still from round 1, not round 2
    assert_eq!(signer.dkg_public_shares.get(&2).unwrap().dkg_id, 1);
    
    // During dkg_ended(), verification fails because round 1 shares are validated with round 2 context
    // This would result in DkgFailure::BadPublicShares blaming signer 2
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L471-477)
```rust
        let out_msgs = match &packet.msg {
            Message::DkgBegin(dkg_begin) => self.dkg_begin(dkg_begin, rng),
            Message::DkgPrivateBegin(dkg_private_begin) => {
                self.dkg_private_begin(dkg_private_begin, rng)
            }
            Message::DkgEndBegin(dkg_end_begin) => self.dkg_end_begin(dkg_end_begin),
            Message::DkgPublicShares(dkg_public_shares) => self.dkg_public_share(dkg_public_shares),
```

**File:** src/state_machine/signer/mod.rs (L557-558)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
```

**File:** src/state_machine/signer/mod.rs (L593-599)
```rust
        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/coordinator/frost.rs (L292-297)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/state_machine/coordinator/fire.rs (L479-484)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/common.rs (L37-39)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-320)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
```

**File:** src/schnorr.rs (L48-59)
```rust
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }
```

**File:** src/schnorr.rs (L62-65)
```rust
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```

**File:** src/net.rs (L153-156)
```rust
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```
