# Audit Report

## Title
Duplicate key_ids in NonceResponse Bypass HashSet Validation, Causing Denial of Service via Incorrect Lagrange Interpolation

## Summary
A malicious signer can inject duplicate key_ids into their NonceResponse message, bypassing the coordinator's HashSet-based validation. These duplicates propagate through the signing protocol and cause all signers to compute incorrect Lagrange interpolation coefficients, resulting in guaranteed signature verification failure. This enables a single malicious signer to perform a persistent denial of service attack on the threshold signature system.

## Finding Description

The vulnerability exists in the coordinator's validation of `NonceResponse` messages during the nonce gathering phase. The coordinator validates that a signer's `key_ids` match their configured keys by converting the Vec to a HashSet before comparison: [1](#0-0) 

This validation allows a malicious `NonceResponse` with `key_ids = [1, 1, 2, 3]` to pass when the config expects `{1, 2, 3}`, because the HashSet conversion silently removes duplicates during the equality check. However, the original NonceResponse with duplicates intact is stored and used throughout the protocol.

When the coordinator collects signature shares, it flattens all NonceResponse key_ids into a single Vec, preserving any duplicates: [2](#0-1) 

Each signer receives these key_ids in the SignatureShareRequest and extracts them using flat_map, which also preserves duplicates: [3](#0-2) 

The critical failure occurs in the Lagrange coefficient computation. The `lambda` function iterates over all elements in the key_ids slice: [4](#0-3) 

If a key_id appears multiple times (e.g., [1, 1, 2, 3]), the function multiplies by the same factor multiple times. For `lambda(2, [1, 1, 2, 3])`:
- j=1 (first): lambda *= 1/(1-2) = -1
- j=1 (duplicate): lambda *= 1/(1-2) = 1 (sign flips!)
- j=3: lambda *= 3/(3-2) = 3

The correct value `lambda(2, [1, 2, 3]) = -3` becomes `3` with duplicates—both sign and magnitude are wrong.

Each signer computes their signature share using these incorrect coefficients: [5](#0-4) 

Since ALL signers use the same duplicated key_ids list to compute Lagrange coefficients, ALL signature shares become mathematically incorrect. The aggregated signature will fail verification, causing the signing round to abort.

The existing `validate_key_id` function only checks individual key_id ranges, not uniqueness: [6](#0-5) 

## Impact Explanation

This vulnerability enables a single malicious signer to execute a persistent denial of service attack against the threshold signature system:

1. **Immediate Impact**: 100% signature verification failure while the malicious signer participates
2. **No Detection**: The coordinator cannot identify which signer caused the failure
3. **No Automatic Exclusion**: The malicious signer remains in future signing rounds
4. **Resource Waste**: All honest signers waste computational resources computing invalid signature shares

According to the provided severity scope, this maps to **Low** severity: "Any remotely-exploitable denial of service in a node." If WSTS signatures are required for Stacks blockchain transaction confirmation and this prevents network-wide transaction processing, it could escalate to **Critical** severity: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

The threshold signature scheme should tolerate up to threshold-1 malicious signers. However, this vulnerability allows a single malicious signer (which is within the threshold-1 bound for any threshold ≥ 2) to cause complete signing failure through a validation bypass, violating the protocol's security guarantees.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Control of a single signer's signing key (through compromise or Byzantine behavior)
- Ability to construct and send malicious NonceResponse messages
- No cryptographic breaks required

**Attack Complexity:** Very low. The attacker simply modifies their NonceResponse to include duplicate key_ids before transmission. Example: changing `key_ids: vec![1, 2, 3]` to `key_ids: vec![1, 1, 2, 3]`.

**Detection Risk:** None. The validation explicitly allows the malicious message through due to the HashSet conversion, and there is no mechanism to identify the source of signature failures.

**Estimated Probability:** High. Any signer that becomes compromised or exhibits Byzantine behavior can trivially execute this attack with deterministic success until manually excluded from the configuration.

## Recommendation

Fix the validation to detect duplicates before the HashSet conversion:

```rust
// In src/state_machine/coordinator/fire.rs, replace lines 881-889 with:
let nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

// Check for duplicates by comparing lengths
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response contains duplicate key_ids");
    return Ok(());
}

if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

Apply the same fix to the FROST coordinator and to SignatureShareResponse validation (lines 1066-1070 in fire.rs).

Additionally, consider adding a duplicate check in the `lambda` function as a defense-in-depth measure:
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    // Verify no duplicates
    let unique_count = key_ids.iter().collect::<HashSet<_>>().len();
    if unique_count != key_ids.len() {
        panic!("lambda called with duplicate key_ids");
    }
    // ... existing implementation
}
```

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_cause_incorrect_lambda() {
    use crate::compute::lambda;
    
    // Correct Lagrange coefficient for key_id=2 in set [1,2,3]
    let correct = lambda(2, &[1, 2, 3]);
    
    // Incorrect coefficient when duplicates are present
    let with_duplicate = lambda(2, &[1, 1, 2, 3]);
    
    // The duplicate causes incorrect computation
    assert_ne!(correct, with_duplicate, "Duplicates should cause different lambda values");
    
    // Verify the sign flip and magnitude change
    // lambda(2, [1,2,3]) should equal -3
    // lambda(2, [1,1,2,3]) equals 3 (sign flipped, wrong magnitude)
    println!("Correct lambda: {:?}", correct);
    println!("With duplicate: {:?}", with_duplicate);
}
```

This test demonstrates that duplicate key_ids cause the `lambda` function to compute incorrect Lagrange coefficients, which propagates through signature share computation and causes signature verification failure.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/common.rs (L313-315)
```rust
/// Check that the passed `key_id` is valid
pub fn validate_key_id(key_id: u32, num_keys: u32) -> bool {
    key_id > 0 && key_id <= num_keys
```
