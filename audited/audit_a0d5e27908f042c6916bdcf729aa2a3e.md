### Title
Empty Polynomial in DkgPublicShares Causes Panic-Based Denial of Service

### Summary
A malicious signer can send DkgPublicShares messages containing empty polynomial vectors, causing all participants (signers and coordinators) to panic and crash when attempting to validate the shares. This vulnerability allows a single malicious participant to trigger network-wide denial of service, preventing DKG completion and blocking signature generation.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the `check_public_shares()` function and `PolyCommitment::verify()` method: [1](#0-0) [2](#0-1) 

The function is called from multiple critical paths:
- V1 Signer DKG validation: [3](#0-2) 
- V2 Signer DKG validation: [4](#0-3) 
- FIRE Coordinator malicious signer detection: [5](#0-4) 

**Root Cause:**

The `check_public_shares()` function validates polynomial commitments by first calling `poly_comm.verify(ctx)` which attempts to access `self.poly[0]` to verify the Schnorr ID proof. However, it never checks if the polynomial vector is empty before this access. When an empty polynomial is provided, Rust's bounds checking causes an immediate panic (index out of bounds) rather than gracefully returning false.

The validation order is:
1. `poly_comm.verify(ctx)` - tries to access `poly[0]` â†’ **PANIC if empty**
2. `poly_comm.poly.len() == threshold` - never reached

**Why Existing Mitigations Fail:**

While legitimate signers validate that `threshold > 0` during construction [6](#0-5) , this does not prevent the attack because:

1. Network messages are deserialized without polynomial validation [7](#0-6) 
2. An attacker can craft malicious `DkgPublicShares` messages with empty polynomial vectors
3. The panic occurs during validation, not during message receipt
4. Coordinators do not validate threshold bounds at construction [8](#0-7) 

### Impact Explanation

**Specific Harm:**
Any participant (coordinator or signer) that receives a DkgPublicShares message with an empty polynomial will immediately crash with a panic when attempting to validate it. This affects:
- Honest signers during DKG public share validation in `compute_secret()`
- Coordinators when verifying `BadPublicShares` reports from honest signers
- All implementations (v1, v2, FIRE coordinator)

**Quantified Impact:**
- Single malicious signer can crash all N-1 honest signers plus the coordinator
- DKG cannot complete, preventing any signatures from being generated
- Complete protocol shutdown until all participants restart
- Repeated attacks prevent protocol from ever completing DKG

**Who is Affected:**
All participants in any DKG round where a malicious signer participates.

**Severity Justification:**
This maps to **Low** severity per the defined scope: "Any remotely-exploitable denial of service in a node". The attack causes process crashes in multiple nodes but does not compromise cryptographic security, cause fund loss, or create consensus failures. However, it effectively shuts down the WSTS network until the vulnerability is patched.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be an authorized participant in a DKG round (signer role)
- Ability to send network messages to other participants
- No cryptographic material or secrets required

**Attack Complexity:**
Trivial. The attacker simply needs to:
1. Serialize a `DkgPublicShares` message with `comms` containing `PolyCommitment { poly: vec![] }`
2. Send this message during the DkgPublicGather phase
3. All recipients will crash when validating the message

**Economic Feasibility:**
Extremely low cost. Requires only:
- Network bandwidth to send one message
- Participation slot in DKG (which a malicious signer already has)

**Detection Risk:**
High detectability after first occurrence - crashed nodes and logs clearly show the panic. However, determining which signer sent the malicious message may be difficult if the coordinator crashes before logging.

**Estimated Probability:**
If an attacker is present as a signer, exploitation success rate is 100%. The only barrier is detection leading to exclusion from future DKG rounds.

### Recommendation

**Primary Fix:**
Add bounds checking before array access in `PolyCommitment::verify()`:

```rust
impl PolyCommitment {
    pub fn verify(&self, ctx: &[u8]) -> bool {
        if self.poly.is_empty() {
            return false;
        }
        self.id.verify(&self.poly[0], ctx)
    }
}
```

**Alternative Fix:**
Add validation in `check_public_shares()`:

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    if poly_comm.poly.is_empty() {
        return false;
    }
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**Additional Hardening:**
1. Add Config validation in Coordinator construction to reject `threshold == 0`
2. Add network-layer validation to reject DkgPublicShares with empty polynomials during deserialization
3. Add integration tests that specifically test empty polynomial handling

**Testing Recommendations:**
1. Unit test: `check_public_shares()` with empty polynomial should return false, not panic
2. Integration test: Send DkgPublicShares with empty polynomial, verify graceful rejection
3. Fuzz testing: Test `check_public_shares()` with various malformed inputs

**Deployment Considerations:**
This is a critical fix that should be deployed immediately. Coordinate with all network participants to upgrade simultaneously, as mixed versions could still be vulnerable.

### Proof of Concept

**Exploitation Steps:**

1. Join DKG round as a malicious signer with valid credentials
2. Wait for DkgPublicDistribute state
3. Construct malicious DkgPublicShares message:
   ```
   DkgPublicShares {
       dkg_id: <current_dkg_id>,
       signer_id: <attacker_signer_id>,
       comms: vec![(1, PolyCommitment {
           id: <valid_schnorr_id>,
           poly: vec![]  // EMPTY POLYNOMIAL
       })],
       kex_public_key: <attacker_public_key>
   }
   ```
4. Broadcast message to all participants
5. All honest signers crash when calling `compute_secret()` which invokes `check_public_shares()`
6. Coordinator crashes when honest signers report BadPublicShares and coordinator tries to verify

**Expected Behavior:**
`check_public_shares()` should return `false` for empty polynomials, allowing graceful rejection.

**Actual Behavior:**
Rust panics with: `index out of bounds: the len is 0 but the index is 0` when `poly_comm.verify()` tries to access `self.poly[0]`.

**Reproduction Instructions:**
1. Set up a 3-party DKG with threshold=2
2. Make party 1 a malicious signer that sends empty polynomial
3. Observe parties 2, 3, and coordinator all crash with panic during validation
4. DKG cannot complete; network is stuck

### Citations

**File:** src/common.rs (L36-39)
```rust
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/v1.rs (L162-162)
```rust
            if !check_public_shares(comm, threshold, ctx) {
```

**File:** src/v2.rs (L136-136)
```rust
            if !check_public_shares(comm, threshold, ctx) {
```

**File:** src/state_machine/coordinator/fire.rs (L633-637)
```rust
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
```

**File:** src/state_machine/signer/mod.rs (L296-297)
```rust
        if threshold == 0 || threshold > total_keys {
            return Err(Error::Config(ConfigError::InvalidThreshold));
```

**File:** src/net.rs (L141-149)
```rust
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
```

**File:** src/state_machine/coordinator/mod.rs (L180-200)
```rust
    pub fn new(
        num_signers: u32,
        num_keys: u32,
        threshold: u32,
        message_private_key: Scalar,
    ) -> Self {
        Config {
            num_signers,
            num_keys,
            threshold,
            dkg_threshold: num_keys,
            message_private_key,
            dkg_public_timeout: None,
            dkg_private_timeout: None,
            dkg_end_timeout: None,
            nonce_timeout: None,
            sign_timeout: None,
            public_keys: Default::default(),
            verify_packet_sigs: true,
        }
    }
```
