# Audit Report

## Title
Duplicate Key IDs in NonceResponse Bypass Validation and Cause Invalid Lagrange Interpolation

## Summary
A malicious signer can send a NonceResponse with duplicate key_ids that bypasses the coordinator's validation by exploiting HashSet conversion. The duplicates propagate to all signers, causing incorrect Lagrange interpolation coefficients and resulting in all signature shares being invalid. This creates a complete denial of service where a single malicious signer prevents any signatures from being produced.

## Finding Description

**Root Cause - Lambda Function Without Deduplication:**

The Lagrange interpolation function computes coefficients by iterating over all key_ids without deduplication: [1](#0-0) 

When key_ids contains duplicates, the lambda value is multiplied by duplicate factors. For example, computing λ₂ for key_ids=[1, 1, 2]:
- Loop iteration 1 (j=1): multiply by 1/(1-2) = -1
- Loop iteration 2 (j=1 again): multiply by 1/(1-2) = -1 
- Loop iteration 3 (j=2): skip (i==j)
- Result: (-1) × (-1) = 1 instead of the correct -1

**Validation Bypass via HashSet Conversion:**

Both FIRE and FROST coordinators validate NonceResponse key_ids by converting to HashSet: [2](#0-1) [3](#0-2) 

If a malicious signer sends key_ids=[1, 1, 2], it becomes {1, 2} for validation and passes if configured signer_key_ids={1, 2}. However, the original NonceResponse with duplicates is stored: [4](#0-3) 

**Duplicate Propagation to All Signers:**

The coordinator constructs SignatureShareRequest by collecting nonce_responses and flat_mapping their key_ids without deduplication: [5](#0-4) [6](#0-5) 

All signers receive this request and extract key_ids via flat_map: [7](#0-6) 

**Invalid Signature Share Computation:**

Signers pass the duplicate-containing key_ids to their sign functions: [8](#0-7) 

In Party::sign_with_tweak, each signer computes lambda with the duplicate key_ids: [9](#0-8) 

This causes all honest signers to compute incorrect lambda values, making all signature shares invalid.

**Detection Without Prevention:**

The aggregator detects the invalid signature and calls check_signature_shares: [10](#0-9) 

However, check_signature_shares also uses the same duplicate key_ids for lambda computation: [11](#0-10) 

Since both signature creation and verification use the same incorrect lambda values, individual signature shares may appear valid to the check, but the aggregated signature remains invalid. The entire signing round is wasted.

## Impact Explanation

This vulnerability enables a complete denial of service against the WSTS signing protocol:

- **100% Failure Rate**: Every signing round fails when the malicious signer participates
- **All Participants Affected**: Honest signers waste computational resources generating invalid signature shares
- **Persistent DoS**: The attack continues indefinitely as long as the malicious signer participates
- **System Unavailability**: The system becomes unable to produce any valid signatures

This qualifies as **Low severity** per the scope definition: "Any remotely-exploitable denial of service in a node." If the WSTS deployment controls more than 10% of miners, this could escalate to **Medium severity**: "Any network denial of service impacting more than 10 percent of miners that does not shut down the network."

## Likelihood Explanation

**Attacker Capabilities**: The attacker must be a registered signer in the WSTS protocol with the ability to send NonceResponse messages. This is within the protocol's threat model (malicious signers up to threshold-1).

**Attack Complexity**: Trivial. The attacker simply modifies their NonceResponse to include duplicate key_ids (e.g., changing [1, 2] to [1, 1, 2]).

**Economic Feasibility**: Extremely low cost. Sending a single modified network message causes indefinite denial of service.

**Detection Risk**: Medium. The attack is detected when signature verification fails, but the root cause may be difficult to diagnose without detailed logging.

**Probability of Success**: 100%. The validation bypass is guaranteed due to the HashSet conversion, and all signature shares will be computed with incorrect lambda values.

## Recommendation

Add validation to ensure key_ids in NonceResponse contain no duplicates before the HashSet conversion:

```rust
// In gather_nonces() for both FIRE and FROST coordinators
let nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

// Add length check to detect duplicates
if nonce_response_key_ids.len() != nonce_response.key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "NonceResponse contains duplicate key_ids");
    return Ok(());
}

if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

Additionally, consider deduplicating the key_ids list in the signer's extraction logic as a defense-in-depth measure:

```rust
// In signer/mod.rs
let key_ids: Vec<u32> = sign_request
    .nonce_responses
    .iter()
    .flat_map(|nr| nr.key_ids.iter().copied())
    .collect::<HashSet<u32>>()  // Deduplicate
    .into_iter()
    .collect::<Vec<u32>>();
```

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_dos() {
    // Setup: Create a coordinator and signers
    let mut coordinator = /* initialize coordinator */;
    
    // Malicious signer sends NonceResponse with duplicate key_ids
    let malicious_nonce_response = NonceResponse {
        dkg_id: 1,
        sign_id: 1,
        sign_iter_id: 0,
        signer_id: 1,
        key_ids: vec![1, 1, 2], // Duplicate key_id 1
        nonces: vec![/* valid nonces */],
        message: vec![/* message */],
    };
    
    // Process through coordinator - validation passes due to HashSet conversion
    coordinator.gather_nonces(&malicious_nonce_response).unwrap();
    
    // Coordinator sends SignatureShareRequest to all signers
    let sig_share_request = coordinator.request_sig_shares();
    
    // Extract key_ids as signers would
    let key_ids: Vec<u32> = sig_share_request
        .nonce_responses
        .iter()
        .flat_map(|nr| nr.key_ids.iter().copied())
        .collect();
    
    // Verify duplicates are present
    assert!(key_ids.len() > key_ids.iter().collect::<HashSet<_>>().len());
    
    // Compute lambda with duplicates
    let lambda_2 = compute::lambda(2, &key_ids);
    
    // Compute expected lambda without duplicates
    let correct_key_ids: Vec<u32> = key_ids.iter().copied().collect::<HashSet<_>>().into_iter().collect();
    let correct_lambda_2 = compute::lambda(2, &correct_key_ids);
    
    // Verify lambda values are different
    assert_ne!(lambda_2, correct_lambda_2);
    
    // All signers compute signature shares with wrong lambda
    // Aggregation fails verification
    let result = coordinator.aggregate_signature(&sig_share_request);
    assert!(result.is_err());
}
```

### Citations

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-982)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L809-817)
```rust
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L403-403)
```rust
                cx += compute::lambda(*key_id, key_ids) * c * public_key;
```

**File:** src/v2.rs (L455-461)
```rust
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, key_ids, None)?;

        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```
