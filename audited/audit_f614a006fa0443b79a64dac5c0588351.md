### Title
Asymmetric DKG End Status Validation Allows Invalid Aggregate Public Key Computation

### Summary
The `gather_dkg_end()` function in both FIRE and FROST coordinators validates `DkgStatus::Failure` reports but does not validate `DkgStatus::Success` reports. This asymmetric handling violates defense-in-depth principles and could allow an invalid aggregate public key to be computed if there are validation bugs in signer implementations or edge cases in the protocol, leading to signing failures and potential consensus issues.

### Finding Description

**Exact Code Location:**

FIRE coordinator: [1](#0-0) 

FROST coordinator: [2](#0-1) 

**Root Cause:**

The coordinator implementations process `DkgStatus::Failure` and `DkgStatus::Success` asymmetrically:

For **Failure statuses**, FIRE performs extensive validation: [3](#0-2) 

This validates reported failures by re-checking public shares, verifying DH tuple proofs, and validating that private shares match public commitments, ultimately identifying which parties are malicious.

For **Success statuses**, neither FIRE nor FROST performs any validation. The code only checks if `reported_failures` is empty: [4](#0-3) 

If no failures are reported, the coordinator directly computes the aggregate key without validating that the Success claims are consistent with the shares it received: [5](#0-4) 

The coordinator computes the aggregate public key from shares stored in `self.dkg_public_shares`, trusting that signers who reported Success actually validated these shares correctly.

**Why Existing Mitigations Fail:**

While signers do perform validation before reporting Success: [6](#0-5) 

The coordinator has no independent verification that:
1. The shares it received match what signers validated
2. Signers' validation logic is bug-free
3. Success claims are legitimate given the coordinator's view of the data

This creates a single point of failure: if signer validation has any bugs, edge cases, or if there are subtle protocol inconsistencies, the coordinator will compute an incorrect aggregate public key.

### Impact Explanation

**Specific Harm:**

If the coordinator computes an invalid aggregate public key due to unvalidated Success claims:

1. **Signing Operations Fail:** All subsequent signature generation attempts will produce signatures that fail verification, as they'll be checked against the wrong public key
2. **Denial of Service:** The signing system becomes unusable, requiring a complete DKG restart
3. **Consensus Failures:** If the invalid aggregate key is used in blockchain operations (block signing, transaction authorization), it causes consensus failures as nodes reject invalid signatures
4. **Resource Waste:** Failed DKG rounds waste computational resources and delay time-critical operations

**Quantified Impact:**

- If used in a blockchain consensus system with 10 signers and 70% threshold, one failed DKG could delay block production by multiple rounds (minutes to hours)
- Multiple failed DKG attempts due to persistent validation bugs could halt chain progress
- In a production system, this maps to **High severity**: "unintended chain split or network partition" if different nodes compute different aggregate keys, or **Medium severity**: "transient consensus failures" if all nodes fail consistently

**Who Is Affected:**

- All participants in the threshold signature scheme
- Downstream systems depending on valid signatures for consensus
- End users experiencing service disruption

**Severity Justification:**

This is a **High** severity issue because:
- It can cause consensus failures and signing system DoS
- The impact affects entire systems, not just individual nodes
- The fix is straightforward but the current design violates security best practices
- While exploitation requires specific conditions, the defense-in-depth violation is clear

### Likelihood Explanation

**Required Conditions for Exploitation:**

1. **Validation Bug Scenario:** A bug exists in signer validation code (compute_secrets() or check_public_shares()) that causes false Success reports. Given the complexity of cryptographic validation, such bugs are possible though the current implementation appears comprehensive.

2. **Implementation Edge Case:** A subtle protocol edge case exists where signers correctly report Success based on their view, but the coordinator's view is different due to timing, message ordering, or protocol ambiguity.

3. **Future Protocol Changes:** Changes to the DKG protocol could introduce inconsistencies that this missing validation would fail to catch.

**Attack Complexity:**

- Does not require breaking cryptographic primitives
- Does not require coordinator compromise (though malicious coordinator could exploit this)
- Requires specific failure modes in validation logic or protocol edge cases
- Low probability under current implementation but non-zero

**Economic Feasibility:**

- If a validation bug exists, exploitation is automatic and requires no attacker resources
- If an edge case exists, it could be triggered through careful timing or message ordering

**Detection Risk:**

- Failed DKG would be immediately detected (aggregate key doesn't work)
- Root cause analysis would be difficult without coordinator-side validation
- Could be misdiagnosed as network issues rather than validation failure

**Estimated Probability:**

Low likelihood with current implementation (well-tested validation code, protocol protections), but Medium-High likelihood if validation bugs are introduced or protocol is modified without adding coordinator-side validation.

### Recommendation

**Primary Fix:**

Add explicit Success validation in `gather_dkg_end()` before calling `dkg_end_gathered()`:

```rust
// After confirming reported_failures.is_empty()
// Validate that the shares we received are actually valid
for (signer_id, dkg_end) in &self.dkg_end_messages {
    if let DkgStatus::Success = &dkg_end.status {
        // Validate public shares match expected format and verify Schnorr proofs
        if let Some(public_shares) = self.dkg_public_shares.get(signer_id) {
            for (party_id, comm) in &public_shares.comms {
                if !check_public_shares(comm, threshold, &self.current_dkg_id.to_be_bytes()) {
                    return Err(Error::DkgFailure {
                        reported_failures: HashMap::from([(*signer_id, DkgFailure::BadPublicShares(HashSet::from([*party_id])))]),
                        malicious_signers: HashSet::from([*signer_id]),
                    });
                }
            }
        }
        
        // Optionally: validate private shares consistency (requires coordinator to have access to decryption keys)
        // This provides even stronger defense-in-depth
    }
}
```

**Alternative Mitigation:**

If full validation is too expensive, add at least basic consistency checks:
- Verify all Success signers have entries in `dkg_public_shares` and `dkg_private_shares`
- Check that polynomial degrees match threshold
- Validate Schnorr ID proofs on public commitments

**Testing Recommendations:**

1. Add unit tests with malformed public shares and Success status
2. Add integration tests simulating validation bugs in signers
3. Test edge cases where coordinator and signers have different data views
4. Verify that coordinator correctly rejects invalid Success claims

**Deployment Considerations:**

- This fix adds computational overhead to DKG End phase
- Consider making validation depth configurable (basic vs. comprehensive)
- Ensure consistent validation between coordinator and signer implementations
- Add metrics/logging to track validation failures for debugging

### Proof of Concept

**Exploitation Algorithm:**

```
1. Setup: Deploy WSTS with modified signer that has validation bug
   - Bug: compute_secrets() incorrectly accepts invalid private shares
   - Example: Missing check for s*G == poly(x) validation

2. Execute DKG:
   - Signers exchange public shares (valid)
   - Malicious signer M sends invalid private shares to victim signer V
   - V's buggy validation accepts invalid shares, computes wrong secret
   - V reports DkgStatus::Success (incorrectly)
   - Other signers report Success (their shares were valid)

3. Coordinator Processing:
   - Receives all Success statuses
   - Line 779: reported_failures.is_empty() == true
   - Line 780: Calls dkg_end_gathered()
   - Lines 804-807: Computes aggregate key including V's contribution
   - Returns OperationResult::Dkg(invalid_aggregate_key)

4. Result:
   - V computed wrong private key shares
   - Coordinator has wrong aggregate public key
   - Later signing round: V produces invalid signature shares
   - Signature aggregation fails or produces invalid signature
   - System cannot produce valid signatures â†’ DoS

Expected: Coordinator detects validation issue, fails DKG, identifies malicious party
Actual: Coordinator trusts Success, computes invalid aggregate key, signing fails later
```

**Reproduction Steps:**

1. Identify or inject a validation bug in signer's `compute_secrets()` function
2. Run DKG with at least one signer having the bug
3. Observe coordinator completes DKG with Success despite invalid shares
4. Attempt signing operation and observe signature verification failure
5. Compare aggregate public key computed by coordinator vs. by honest signers (will differ)

**Parameter Values:**

- Number of signers: 5
- Threshold: 3
- Keys per signer: 2  
- One signer with validation bug accepting invalid private share
- Coordinator receives all Success statuses
- Invalid aggregate key computed without detection

### Citations

**File:** src/state_machine/coordinator/fire.rs (L572-792)
```rust
    fn gather_dkg_end(&mut self, packet: &Packet) -> Result<(), Error> {
        debug!(
            "DKG Round {}: waiting for Dkg End from signers {:?}",
            self.current_dkg_id, self.dkg_wait_signer_ids
        );
        if let Message::DkgEnd(dkg_end) = &packet.msg {
            if dkg_end.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(dkg_end.dkg_id, self.current_dkg_id));
            }
            if self.dkg_wait_signer_ids.contains(&dkg_end.signer_id) {
                self.dkg_wait_signer_ids.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.dkg_wait_signer_ids,
                    "DkgEnd received"
                );
            } else {
                warn!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    "Got DkgEnd from signer who we weren't waiting on"
                );
            }
        }

        let mut reported_failures = HashMap::new();
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
        let threshold: usize = self.config.threshold.try_into().unwrap();
        if self.dkg_wait_signer_ids.is_empty() {
            // if there are any errors, mark signers malicious and retry
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());

                    match dkg_failure {
                        DkgFailure::BadState => {
                            // signer should not be in a bad state so treat as malicious
                            malicious_signers.insert(*signer_id);
                        }
                        DkgFailure::Threshold => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
                        }
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
                        }
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                    }
                }
            }

            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }

            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L794-812)
```rust
    fn dkg_end_gathered(&mut self) -> Result<(), Error> {
        // Cache the polynomials used in DKG for the aggregator
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
        }

        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
        self.move_to(State::Idle)
    }
```

**File:** src/state_machine/coordinator/frost.rs (L377-420)
```rust
    fn gather_dkg_end(&mut self, packet: &Packet) -> Result<(), Error> {
        debug!(
            dkg_id = %self.current_dkg_id,
            waiting = ?self.ids_to_await,
            "Waiting for Dkg End from signers"
        );
        if let Message::DkgEnd(dkg_end) = &packet.msg {
            if dkg_end.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(dkg_end.dkg_id, self.current_dkg_id));
            }
            if self.ids_to_await.contains(&dkg_end.signer_id) {
                self.ids_to_await.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.ids_to_await,
                    "DkgEnd received"
                );
            }
        }

        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
        }
        Ok(())
    }
```

**File:** src/state_machine/signer/mod.rs (L504-671)
```rust
    pub fn dkg_ended<R: RngCore + CryptoRng>(&mut self, rng: &mut R) -> Result<Message, Error> {
        if !self.can_dkg_end() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadState),
            }));
        }

        // only use the public shares from the DkgEndBegin signers
        let mut missing_public_shares = HashSet::new();
        let mut missing_private_shares = HashSet::new();
        let mut bad_public_shares = HashSet::new();
        let threshold: usize = self.threshold.try_into().unwrap();

        let Some(dkg_end_begin) = &self.dkg_end_begin_msg else {
            // no cached DkgEndBegin message
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadState),
            }));
        };

        // fist check to see if dkg_threshold has been met
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
        let mut num_dkg_keys = 0u32;
        for id in &signer_ids_set {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(id) {
                let len: u32 = key_ids.len().try_into()?;
                num_dkg_keys = num_dkg_keys.saturating_add(len);
            }
        }

        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
        }

        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
        }

        if !missing_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPublicShares(missing_public_shares)),
            }));
        }

        if !bad_public_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPublicShares(bad_public_shares)),
            }));
        }

        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
        }

        let dkg_end = if self.invalid_private_shares.is_empty() {
            match self.signer.compute_secrets(
                &self.decrypted_shares,
                &self.commitments,
                &self.dkg_id.to_be_bytes(),
            ) {
                Ok(()) => DkgEnd {
                    dkg_id: self.dkg_id,
                    signer_id: self.signer_id,
                    status: DkgStatus::Success,
                },
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
                    }
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
                }
            }
        } else {
            DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                    self.invalid_private_shares.clone(),
                )),
            }
        };

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            status = ?dkg_end.status,
            "sending DkgEnd"
        );

        let dkg_end = Message::DkgEnd(dkg_end);
        Ok(dkg_end)
    }
```
