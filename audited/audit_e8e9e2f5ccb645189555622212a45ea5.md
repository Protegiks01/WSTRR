### Title
State Machine Allows Resource Exhaustion via Repeated DKG Round Resets

### Summary
The signer state machine allows transitions from `DkgPublicGather` back to `DkgPublicDistribute` without validating the `dkg_id` or checking if a DKG round is already in progress. A compromised or malicious coordinator can exploit this to force signers into an infinite loop of expensive cryptographic operations (polynomial generation and commitment computation), causing resource exhaustion and preventing legitimate DKG completion.

### Finding Description

**Location:** [1](#0-0) 

The `can_move_to()` function permits the state transition from `DkgPublicGather` back to `DkgPublicDistribute`: [2](#0-1) 

When a signer receives a `DkgBegin` message, the `dkg_begin()` function unconditionally accepts it and transitions to `DkgPublicDistribute`: [3](#0-2) 

**Root Cause:**

The signer does not validate:
1. Whether a DKG round is already in progress
2. Whether the new `dkg_id` is greater than the current one
3. Whether the signer is in an appropriate state to start a new DKG round

The `reset()` function unconditionally clears all accumulated state and regenerates cryptographic material: [4](#0-3) 

Each reset triggers `reset_polys()` which generates new random polynomials, and `dkg_public_begin()` computes polynomial commitments via expensive elliptic curve operations: [5](#0-4) 

The polynomial commitment requires `threshold` scalar multiplications (one per coefficient), where each coefficient is multiplied by the generator point G.

**Why Existing Mitigations Fail:**

Packet signature verification (when enabled) only ensures messages come from the coordinator, but does not prevent a compromised coordinator from abusing this mechanism. The `verify_packet_sigs` flag can also be disabled: [6](#0-5) 

There is no rate limiting, cooldown period, or `dkg_id` monotonicity check to prevent repeated resets.

### Impact Explanation

**Specific Harm:**
- **CPU Exhaustion:** Each cycle forces generation of `threshold` random scalars and `threshold` elliptic curve scalar multiplications
- **Memory Churn:** Repeated allocation and deallocation of HashMaps and state structures
- **Network Bandwidth:** Each cycle sends a `DkgPublicShares` message with polynomial commitments
- **Wasted Work:** All legitimate DKG progress is discarded on each reset

**Quantification:**
For a typical Stacks configuration with threshold=28 and 40 total keys:
- Each reset generates 28 random scalars
- Computes 28 elliptic curve scalar multiplications (secp256k1)
- Clears multiple HashMaps with accumulated shares
- Sends ~1-2KB network message

An attacker sending 100 `DkgBegin` messages per second would force:
- 2,800 scalar multiplications per second per signer
- Sustained high CPU usage preventing legitimate work
- Prevention of DKG completion

**Who Is Affected:**
All signers controlled by the compromised coordinator. In a network with 10+ signers, if threshold cannot be met, the entire signer set cannot complete DKG.

**Severity Justification:**
Per the defined scope, this maps to **Low severity**: "Any remotely-exploitable denial of service in a node." However, if the attack prevents threshold number of signers from completing DKG for extended periods, it could escalate to **Critical** by preventing "new valid transactions" from being confirmed for multiple blocks.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Control of the coordinator's private key (compromise or malicious insider)
2. OR ability to send messages if `verify_packet_sigs` is disabled
3. Network access to signer nodes

**Attack Complexity:**
Low - requires only sending repeated `DkgBegin` messages with any `dkg_id` values.

**Economic Feasibility:**
Very low cost - minimal network bandwidth (few KB per message). The computational cost is borne by the victims (signers).

**Detection Risk:**
Moderate - unusual pattern of repeated `DkgBegin` messages and state resets would be visible in logs. However, may be attributed to coordinator bugs rather than malicious intent.

**Estimated Probability:**
- High if coordinator is compromised
- Low in properly configured production (requires coordinator compromise)
- Medium if `verify_packet_sigs` is disabled

### Recommendation

**Primary Fix:**
Add `dkg_id` validation in `dkg_begin()`:

```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Reject if dkg_id is not greater than current
    if dkg_begin.dkg_id <= self.dkg_id {
        warn!("Ignoring DkgBegin with stale dkg_id {} (current: {})", 
              dkg_begin.dkg_id, self.dkg_id);
        return Ok(vec![]);
    }
    
    // Only accept DkgBegin from Idle state
    if self.state != State::Idle {
        warn!("Ignoring DkgBegin while in state {:?}", self.state);
        return Ok(vec![]);
    }
    
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Alternative Mitigations:**
1. Remove backward transitions in `can_move_to()` - only allow `DkgPublicDistribute` from `State::Idle`
2. Add rate limiting: track timestamp of last DKG reset and enforce minimum delay
3. Add coordinator-side validation to prevent rapid DKG restarts

**Testing Recommendations:**
1. Unit test: Verify repeated `DkgBegin` messages are rejected
2. Integration test: Measure resource consumption during rapid DKG restart attempts
3. Fuzz test: Send random sequences of `DkgBegin` messages with varying `dkg_id` values

**Deployment Considerations:**
- This is a backward-compatible change that only adds validation
- Should be deployed to all signer implementations
- Coordinator implementations should also add safeguards against accidental rapid restarts

### Proof of Concept

**Exploitation Algorithm:**
```
1. Attacker compromises coordinator's private key
2. Wait for signer to reach DkgPublicGather state
3. Loop:
   a. Sign and send DkgBegin{dkg_id: random_u64()} using coordinator key
   b. Signer transitions: DkgPublicGather → DkgPublicDistribute → DkgPublicGather
   c. Signer performs:
      - reset_polys(): generates threshold random scalars
      - get_poly_commitments(): computes threshold EC multiplications
      - Sends DkgPublicShares message
   d. Sleep 10ms (optional rate control)
4. Continue until signer resource exhaustion or detection
```

**Parameter Values:**
- threshold = 28 (typical Stacks configuration)
- Each polynomial has 28 coefficients
- Each commitment requires 28 secp256k1 scalar multiplications
- At 100 messages/second: 2,800 scalar mults/second

**Expected vs Actual Behavior:**
- Expected: Signer should reject `DkgBegin` when not in `Idle` state, or validate `dkg_id` is incrementing
- Actual: Signer accepts any `DkgBegin` from valid coordinator regardless of current state, allowing infinite loop

**Reproduction Instructions:**
1. Set up signer with `verify_packet_sigs = true` and valid coordinator key
2. Start legitimate DKG round with `DkgBegin{dkg_id: 1}`
3. Wait for signer to reach `DkgPublicGather`
4. Send `DkgBegin{dkg_id: 2}` from coordinator
5. Observe signer resets state and regenerates polynomials
6. Repeat step 4 rapidly
7. Monitor CPU usage and observe sustained high utilization
8. Verify legitimate DKG never completes

## Notes

This vulnerability exists because the state machine prioritizes flexibility over safety - allowing transitions that should be restricted. The coordinator state machines (both FROST and FIRE) correctly restrict `DkgPublicDistribute` to only be reachable from `Idle`, but the signer does not enforce this constraint when receiving `DkgBegin` messages.

The attack is limited to scenarios where the coordinator is compromised or `verify_packet_sigs` is disabled. In properly secured production deployments with packet signature verification enabled and a trusted coordinator, the likelihood is low. However, the lack of defense-in-depth means a single compromise leads to complete DoS capability.

### Citations

**File:** src/state_machine/signer/mod.rs (L416-432)
```rust
    /// Reset internal state
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/signer/mod.rs (L1157-1179)
```rust
    fn can_move_to(&self, state: &State) -> Result<(), Error> {
        let prev_state = &self.state;
        let accepted = match state {
            State::Idle => true,
            State::DkgPublicDistribute => {
                prev_state == &State::Idle
                    || prev_state == &State::DkgPublicGather
                    || prev_state == &State::DkgPrivateDistribute
            }
            State::DkgPublicGather => prev_state == &State::DkgPublicDistribute,
            State::DkgPrivateDistribute => prev_state == &State::DkgPublicGather,
            State::DkgPrivateGather => prev_state == &State::DkgPrivateDistribute,
            State::SignGather => prev_state == &State::Idle,
        };
        if accepted {
            debug!("state change from {prev_state:?} to {state:?}");
            Ok(())
        } else {
            Err(Error::BadStateChange(format!(
                "{prev_state:?} to {state:?}"
            )))
        }
    }
```

**File:** src/v2.rs (L87-100)
```rust
    pub fn get_poly_commitment<RNG: RngCore + CryptoRng>(
        &self,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Option<PolyCommitment> {
        if let Some(poly) = &self.f {
            Some(PolyCommitment {
                id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
                poly: (0..poly.data().len())
                    .map(|i| &poly.data()[i] * G)
                    .collect(),
            })
        } else {
            warn!("get_poly_commitment called with no polynomial");
```
