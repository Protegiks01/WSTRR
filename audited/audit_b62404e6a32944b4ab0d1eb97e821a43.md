### Title
Duplicate Key IDs in NonceResponse Bypass Validation and Cause Invalid Lagrange Interpolation

### Summary
A malicious signer can send a NonceResponse with duplicate key_ids that bypasses the coordinator's validation by converting to a HashSet for comparison. The duplicates are then propagated to all signers via SignatureShareRequest, causing all parties to compute incorrect Lagrange interpolation coefficients. This results in all signature shares being invalid, creating a denial of service where a single malicious signer can prevent any signatures from being produced.

### Finding Description

**Root Cause:**

The Lagrange interpolation function computes coefficients by iterating over all key_ids in the signers list without deduplication: [1](#0-0) 

When the `key_ids` array contains duplicates, the lambda value is multiplied by duplicate factors. For example, if computing λ₂ for key_ids=[1, 1, 2], the result is 1/(1-2) × 1/(1-2) = 1 instead of the correct 1/(1-2) = -1.

**Validation Bypass:**

The coordinator validates NonceResponse key_ids by converting them to a HashSet for comparison: [2](#0-1) 

This validation silently removes duplicates during the HashSet conversion. If a malicious signer sends key_ids=[1, 1, 2], it becomes {1, 2} for validation purposes and passes if the configured signer_key_ids={1, 2}. However, the original NonceResponse with duplicates is stored: [3](#0-2) 

**Duplicate Propagation:**

When constructing the SignatureShareRequest, the coordinator flat_maps all nonce_responses' key_ids without deduplication: [4](#0-3) 

All signers receive this request and reconstruct the key_ids list with duplicates: [5](#0-4) 

**Invalid Signature Share Computation:**

When signers compute their signature shares, they pass the duplicate-containing key_ids as the signers parameter: [6](#0-5) 

This flows to Party::sign_precomputed which computes the signature share using the incorrect lambda: [7](#0-6) 

All signature shares are computed with wrong lambda values, making them invalid.

**Detection but No Prevention:**

The aggregator verifies the final signature and rejects it: [8](#0-7) 

However, the damage is already done—the entire signing round has been wasted.

### Impact Explanation

**Specific Harm:**
A single malicious signer causes complete denial of service for all signing operations. Every signing round fails because all participants compute invalid signature shares due to incorrect Lagrange coefficients.

**Quantification:**
- 100% of signing rounds affected when malicious signer participates
- All honest signers' computational resources wasted
- Signing rounds must be retried, but will continue to fail while malicious signer participates
- System becomes unable to produce any valid signatures

**Who is Affected:**
All participants in the WSTS signing protocol, including honest signers and the coordinator.

**Severity Justification:**
This qualifies as **Low severity** per the protocol scope: "Any remotely-exploitable denial of service in a node." If the WSTS deployment controls more than 10% of miners, this could qualify as **Medium severity**: "Any network denial of service impacting more than 10 percent of miners that does not shut down the network."

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a registered signer in the WSTS protocol
- Requires ability to send modified NonceResponse messages
- No cryptographic secrets needed beyond valid signer credentials

**Attack Complexity:**
Trivial. The attacker simply modifies their client to send a NonceResponse with duplicate key_ids (e.g., [1, 1, 2] instead of [1, 2]).

**Economic Feasibility:**
Extremely low cost. Sending a single modified network message causes indefinite denial of service.

**Detection Risk:**
Medium. The attack is detected when signature verification fails, but attribution is difficult because check_signature_shares also uses the wrong lambda values, potentially misidentifying which parties have bad signatures.

**Probability of Success:**
100%. The validation bypass is guaranteed, and all signature shares will be invalid.

### Recommendation

**Primary Fix:**
Add duplicate detection in the coordinator's NonceResponse validation:

```rust
// In src/state_machine/coordinator/fire.rs, around line 881
let nonce_response_key_ids = nonce_response
    .key_ids
    .iter()
    .cloned()
    .collect::<HashSet<u32>>();

// Add this check:
if nonce_response_key_ids.len() != nonce_response.key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response contains duplicate key_ids");
    return Err(Error::DuplicateKeyIds(nonce_response.signer_id));
}

if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    return Ok(());
}
```

**Alternative Mitigation:**
Deduplicate key_ids when constructing the list for signature share requests, though this would mask the malicious behavior rather than reject it.

**Testing Recommendations:**
1. Add test case where malicious signer sends NonceResponse with duplicate key_ids
2. Verify coordinator rejects the duplicate-containing message
3. Add integration test confirming signature round completes successfully after rejection

**Deployment Considerations:**
This is a protocol-level fix that requires coordinator updates. All coordinators must be updated to prevent the attack. Backward compatibility is maintained as honest signers never send duplicates.

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Deploy WSTS with threshold t=2, three signers where Signer A controls keys [1, 2], Signer B controls [3], Signer C controls [4]

2. **Malicious Signer A constructs NonceResponse**:
   - Set key_ids = [1, 1, 2] (duplicate key 1)
   - Generate corresponding nonces
   - Send to coordinator

3. **Coordinator validation**:
   - Converts [1, 1, 2] to HashSet {1, 2}
   - Compares {1, 2} == {1, 2} configured → PASS
   - Stores NonceResponse with [1, 1, 2]

4. **Coordinator broadcasts SignatureShareRequest**:
   - key_ids = [1, 1, 2, 3, 4] (flattened from all nonce_responses)

5. **All signers compute signature shares**:
   - Signer B (key 3) computes: λ₃ with key_ids=[1,1,2,3,4]
   - Correct: λ₃ = (1/(1-3)) × (2/(2-3)) × (4/(4-3)) = (-1/2) × (-2) × 4 = 4
   - With duplicate: λ₃ = (1/(1-3)) × (1/(1-3)) × (2/(2-3)) × (4/(4-3)) = (-1/2) × (-1/2) × (-2) × 4 = -2
   - Wrong lambda produces wrong signature share

6. **Aggregation fails**:
   - All signature shares use incorrect lambdas
   - Aggregated signature is invalid
   - Verification rejects: signature round fails

**Expected vs Actual Behavior**:
- Expected: Coordinator rejects NonceResponse with duplicate key_ids
- Actual: Duplicates pass validation and poison entire signing round

**Reproduction**:
Modify a signer client to duplicate a key_id in the NonceResponse.key_ids vector before sending. Observe that all subsequent signature verifications fail.

### Citations

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L1126-1129)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/v1.rs (L283-283)
```rust
        let mut cx = c * &self.private_key * compute::lambda(self.id, signers);
```

**File:** src/v1.rs (L464-470)
```rust
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, None)?;

        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, None))
        }
```

**File:** src/v1.rs (L714-719)
```rust
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
        self.parties
            .iter()
            .map(|p| p.sign_precomputed(msg, key_ids, nonces, &aggregate_nonce))
            .collect()
    }
```
