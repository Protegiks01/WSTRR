### Title
Panic-Induced Denial of Service via Malformed Polynomial Commitments in DKG Public Shares

### Summary
A malicious signer can crash other signers by sending DkgPublicShares messages containing PolyCommitment structures with empty polynomial vectors. The check in `can_dkg_end()` only verifies key existence, allowing these malformed shares to pass initial validation. When `dkg_ended()` attempts to verify the commitments, it triggers a panic by accessing an out-of-bounds index, crashing the signer process.

### Finding Description

**Exact Code Location:**
- File: `src/state_machine/signer/mod.rs`
- Initial check: Lines 696-701 in `can_dkg_end()` function
- Insertion point: Lines 993-1024 in `dkg_public_share()` function  
- Panic trigger: Line 557 in `dkg_ended()` function
- Root cause: Line 37-38 in `src/common.rs`, `PolyCommitment::verify()` method [1](#0-0) [2](#0-1) [3](#0-2) 

**Root Cause Analysis:**

The vulnerability exists due to insufficient validation at multiple checkpoints:

1. In `can_dkg_end()`, the function only checks if a key exists in the `dkg_public_shares` map, not whether the associated value contains valid data.

2. In `dkg_public_share()`, when receiving DkgPublicShares messages, the validation loop only verifies that party_ids are valid but does not validate the content of the PolyCommitment structures (specifically, the `poly` vector). [4](#0-3) 

3. In `dkg_ended()`, there is a check for empty `comms` vectors at line 553, but this only catches cases where the entire `comms` vector is empty. It does not detect cases where `comms` contains elements with empty `poly` fields.

4. When `check_public_shares()` is called at line 557, it invokes `poly_comm.verify()` which unconditionally accesses `self.poly[0]`: [5](#0-4) 

This causes a panic when `poly` is an empty vector, as Rust's bounds checking triggers a runtime panic on out-of-bounds access.

**Why Existing Mitigations Fail:**

The empty check at line 553 only validates that `shares.comms.is_empty()`, not that individual commitments within `comms` have non-empty polynomial vectors. A malicious payload like:

```
DkgPublicShares {
    comms: vec![(party_id, PolyCommitment { id: ..., poly: vec![] })],
    ...
}
```

bypasses this check because `comms.is_empty()` returns `false`.

### Impact Explanation

**Specific Harm:**
A malicious signer can crash all other signers participating in the DKG round, causing a complete denial of service for the DKG protocol. When honest signers process the malformed message:

1. The signer process panics at the out-of-bounds access
2. The signer node crashes or becomes unresponsive
3. The DKG round cannot complete
4. No threshold signature scheme can be established

**Quantified Impact:**
- All signers processing the malicious message will crash
- The DKG protocol cannot complete, blocking signature generation
- The attack can be repeated in subsequent DKG rounds
- If WSTS is used in a blockchain context (e.g., Stacks), this prevents the signing committee from being established
- Transaction signing cannot proceed without a functioning DKG

**Who is Affected:**
All honest signers in the DKG round are affected. The coordinator may also be affected if it processes the same malformed shares. [6](#0-5) 

**Severity Justification:**
This maps to **High severity** under the provided scope:
- "Any remotely-exploitable denial of service in a node" - The attack crashes signer nodes remotely via network messages
- "Any network denial of service impacting more than 10 percent of miners" - All participating signers are affected

If the DKG failure prevents block signing in dependent systems, this could escalate to **Critical severity** by preventing the network from confirming transactions for multiple blocks.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a legitimate signer with valid credentials (private key for a registered signer_id)
- Ability to send network messages to other signers
- No special access beyond normal signer privileges required

**Attack Complexity:**
Very low complexity. The attacker simply needs to:
1. Construct a DkgPublicShares message with non-empty `comms` but empty `poly` vectors
2. Sign it with their legitimate signer private key
3. Broadcast it during the DKG public share gathering phase [7](#0-6) 

**Economic Feasibility:**
Extremely low cost. The attack requires only:
- Standard network bandwidth to send one malformed message
- No computational resources beyond normal message creation and signing
- No economic stake or penalty avoidance needed

**Detection Risk:**
Low detection risk for the attacker:
- The panic appears as a protocol failure, not necessarily malicious behavior
- No explicit logging identifies the malformed poly vectors before the panic
- The attacker is a legitimate signer, so authentication succeeds

**Estimated Probability of Success:**
Near 100% if executed correctly. The vulnerability is deterministic - sending a properly formatted DkgPublicShares message with empty poly vectors will reliably crash other signers.

### Recommendation

**Proposed Code Changes:**

1. Add validation in `dkg_public_share()` before inserting shares:

```rust
// In src/state_machine/signer/mod.rs, around line 1002
for (party_id, comm) in &dkg_public_shares.comms {
    if !SignerType::validate_party_id(
        signer_id,
        *party_id,
        &self.public_keys.signer_key_ids,
    ) {
        warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
        return Ok(vec![]);
    }
    // ADD THIS CHECK:
    if comm.poly.is_empty() {
        warn!(%signer_id, %party_id, "signer sent polynomial commitment with empty poly vector");
        return Ok(vec![]);
    }
    if comm.poly.len() != threshold.try_into().unwrap() {
        warn!(%signer_id, %party_id, "signer sent polynomial with incorrect degree");
        return Ok(vec![]);
    }
}
```

2. Add defensive bounds checking in `PolyCommitment::verify()`:

```rust
// In src/common.rs, replace line 37-39
pub fn verify(&self, ctx: &[u8]) -> bool {
    if self.poly.is_empty() {
        return false;
    }
    self.id.verify(&self.poly[0], ctx)
}
```

3. Enhance the check in `can_dkg_end()` to validate share contents:

```rust
// In src/state_machine/signer/mod.rs, replace lines 696-701
for signer_id in &dkg_private_begin.signer_ids {
    if let Some(shares) = self.dkg_public_shares.get(signer_id) {
        if shares.comms.is_empty() {
            debug!("can_dkg_end: false, missing public shares from signer {signer_id}");
            return false;
        }
        for (_, comm) in &shares.comms {
            if comm.poly.is_empty() {
                debug!("can_dkg_end: false, invalid public shares from signer {signer_id}");
                return false;
            }
        }
    } else {
        debug!("can_dkg_end: false, missing public shares from signer {signer_id}");
        return false;
    }
}
```

**Testing Recommendations:**
1. Add unit test sending DkgPublicShares with empty poly vectors
2. Add unit test sending DkgPublicShares with incorrect poly lengths
3. Add integration test verifying signers reject malformed shares without crashing
4. Add fuzzing test for DkgPublicShares message parsing

**Deployment Considerations:**
This is a critical fix that should be deployed urgently. The fix is backward compatible as it only adds validation. All nodes should be upgraded before running new DKG rounds.

### Proof of Concept

**Exploitation Steps:**

1. Attacker obtains legitimate signer credentials (signer_id and private key)

2. During DKG public share phase, construct malicious DkgPublicShares:
```rust
let malicious_shares = DkgPublicShares {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id,
    comms: vec![(
        attacker_party_id,
        PolyCommitment {
            id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
            poly: vec![], // EMPTY VECTOR - TRIGGERS PANIC
        },
    )],
    kex_public_key: attacker_kex_public_key,
};
```

3. Sign the message with attacker's private key:
```rust
let packet = Packet {
    msg: Message::DkgPublicShares(malicious_shares.clone()),
    sig: malicious_shares.sign(&attacker_private_key).expect("sign failed"),
};
```

4. Broadcast packet to other signers

5. When honest signers process the packet:
   - `dkg_public_share()` accepts it (party_id validation passes)
   - Share is stored in `dkg_public_shares` map
   - When all shares collected, `can_dkg_end()` returns true
   - `dkg_ended()` is called
   - At line 557, `check_public_shares()` calls `poly_comm.verify()`
   - `poly_comm.verify()` accesses `self.poly[0]` on empty vector
   - **PANIC: index out of bounds**
   - Signer process crashes

**Expected vs Actual Behavior:**

Expected: Invalid shares should be rejected with an error message, DKG should fail gracefully

Actual: Signer process panics and crashes, requiring restart

**Reproduction Instructions:**

1. Set up a WSTS DKG with multiple signers
2. Modify one signer to send the malformed message above during DkgPublicShares phase
3. Observe other signers panic when processing the message
4. Verify panic occurs at `PolyCommitment::verify()` when accessing `poly[0]`

### Citations

**File:** src/state_machine/signer/mod.rs (L492-495)
```rust
                if self.can_dkg_end() {
                    let dkg_end_msgs = self.dkg_ended(rng)?;
                    out.push(dkg_end_msgs);
                    self.move_to(State::Idle)?;
```

**File:** src/state_machine/signer/mod.rs (L552-563)
```rust
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L696-701)
```rust
                for signer_id in &dkg_private_begin.signer_ids {
                    if !self.dkg_public_shares.contains_key(signer_id) {
                        debug!("can_dkg_end: false, missing public shares from signer {signer_id}");
                        return false;
                    }
                }
```

**File:** src/state_machine/signer/mod.rs (L993-1002)
```rust
        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L1023-1024)
```rust
        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/common.rs (L37-38)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
```

**File:** src/net.rs (L526-538)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
```
