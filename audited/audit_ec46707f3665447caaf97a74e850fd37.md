### Title
Missing Length Validation in Nonce Processing Enables Denial of Service Attack

### Summary
The `compute_intermediate()` function and related nonce processing code do not verify that the `nonces` array length matches the `key_ids` array length. A malicious signer can exploit this by sending a `NonceResponse` with mismatched array lengths, causing honest signers to panic when computing aggregate nonces, effectively shutting down the signing protocol.

### Finding Description

The vulnerability exists across multiple code locations in the nonce processing pipeline:

**1. Core computation function** [1](#0-0) 

The `intermediate()` function uses `zip(nonces, rhos)` which silently truncates to the shorter array when lengths don't match. This creates inconsistent intermediate values.

**2. Aggregate nonce computation** [2](#0-1) 

The `aggregate_nonce()` function creates `scalars` array with length `2*party_ids.len()` and `points` array with length `2*nonces.len()`. When these lengths differ, `Point::multimult(scalars, points)` receives mismatched array lengths, likely causing an error.

**3. NonceResponse structure lacks constraints** [3](#0-2) 

The `NonceResponse` struct contains separate `key_ids: Vec<u32>` and `nonces: Vec<PublicNonce>` fields with no enforced relationship between their lengths.

**4. Coordinator validation is insufficient** [4](#0-3) 

The FROST coordinator validates that `key_ids` match the configured set using a HashSet comparison, but never checks that `nonces.len() == key_ids.len()`.

**5. Similar validation gap in FIRE coordinator** [5](#0-4) 

**6. Signer processes arrays without validation** [6](#0-5) 

When processing a `SignatureShareRequest`, signers flatten all `nonces` and `key_ids` arrays from the nonce responses without validating length consistency.

**7. Panic point in v1 signer** [7](#0-6) 

The v1 signer calls `compute::aggregate_nonce(msg, key_ids, nonces).unwrap()`, which will panic if the function returns an error due to mismatched array lengths.

**Why existing mitigations fail:**
- Set-based validation only checks element membership, not cardinality
- Individual nonce validity checks (`is_valid()`) don't catch length mismatches
- No validation exists at the message deserialization layer
- The trait definition provides no length validation requirements

### Impact Explanation

**Specific harm:**
A single malicious signer can crash all honest signers participating in a signing round, preventing signature generation and halting the network's ability to confirm transactions.

**Attack scenario:**
1. Malicious signer sends `NonceResponse` with `key_ids = [1, 2, 3]` but `nonces = [nonce1, nonce2]`
2. Coordinator validates and broadcasts this in `SignatureShareRequest`
3. All honest signers attempt to compute `aggregate_nonce(msg, [1,2,3], [nonce1, nonce2])`
4. Function creates 6 scalars but 4 points, causing `multimult` to error
5. The `.unwrap()` panics, crashing all honest signers simultaneously

**Quantified impact:**
- All participating signers crash (100% of signing participants)
- Signing round fails completely
- Network cannot produce signatures until signers restart and malicious party is excluded
- Multiple consecutive rounds can be disrupted

**Who is affected:**
All signers in any signing round where a malicious participant is present.

**Severity justification:**
This maps to **HIGH** severity under the protocol scope definition: "Any remotely-exploitable denial of service in a node." While individual node DoS is typically LOW severity, this attack simultaneously crashes all participating signers in a coordinated signing operation, effectively preventing the network from confirming transactions, which approaches network shutdown conditions.

### Likelihood Explanation

**Required attacker capabilities:**
- Must be a registered signer in the WSTS protocol
- Must pass DKG phase to become a valid signing participant
- Can craft network messages (standard capability)
- No cryptographic breaks required

**Attack complexity:**
Very low. The attacker simply needs to:
1. Modify their client to send `NonceResponse` with `key_ids.len() != nonces.len()`
2. Send this message during the nonce exchange phase
3. Wait for coordinator to broadcast and signers to crash

**Economic feasibility:**
Nearly free. No computational cost beyond normal protocol participation.

**Detection risk:**
Low detection risk before impact. The malformed message passes all coordinator validation checks. Detection only occurs when honest signers crash, at which point damage is done.

**Estimated probability of success:**
~100%. No mitigations exist, and the attack vector is deterministic.

### Recommendation

**Primary fix - Add length validation in coordinator:**

Add validation in both FROST and FIRE coordinators' `gather_nonces()` functions:

```rust
// After line 521 in frost.rs and line 889 in fire.rs
if nonce_response.key_ids.len() != nonce_response.nonces.len() {
    warn!(
        signer_id = %nonce_response.signer_id,
        key_ids_len = %nonce_response.key_ids.len(),
        nonces_len = %nonce_response.nonces.len(),
        "Nonce response has mismatched array lengths"
    );
    return Ok(());
}
```

**Secondary fix - Add defensive checks in compute functions:**

```rust
// In compute.rs intermediate() function at line 85
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    assert_eq!(party_ids.len(), nonces.len(), 
        "party_ids and nonces must have equal length");
    // ... rest of function
}

// In compute.rs aggregate_nonce() function at line 100
pub fn aggregate_nonce(...) -> Result<Point, PointError> {
    if party_ids.len() != nonces.len() {
        return Err(PointError::InvalidLength);
    }
    // ... rest of function
}
```

**Alternative mitigation:**
Modify `NonceResponse` struct to enforce the invariant at the type level by using a single `Vec<(u32, PublicNonce)>` instead of separate vectors.

**Testing recommendations:**
1. Unit test: Call `compute::intermediate()` with mismatched array lengths and verify panic/error
2. Integration test: Send malformed `NonceResponse` and verify coordinator rejects it
3. Fuzz testing: Generate random `NonceResponse` messages with varying array lengths

**Deployment considerations:**
- This is a critical fix that should be deployed immediately
- Backward compatible if implemented in coordinator validation
- Requires coordinated update of all coordinators
- Consider adding telemetry to detect attempted exploitation

### Proof of Concept

**Exploitation algorithm:**

1. **Setup**: Become a valid signer through normal DKG process
2. **Trigger**: When coordinator requests nonces for signing round
3. **Exploit**: Instead of normal nonce generation, create malformed response:

```rust
// Malicious signer code
let malicious_nonce_response = NonceResponse {
    dkg_id: current_dkg_id,
    sign_id: current_sign_id,
    sign_iter_id: current_sign_iter_id,
    signer_id: self.id,
    key_ids: vec![1, 2, 3],  // 3 key IDs
    nonces: vec![nonce1, nonce2],  // Only 2 nonces
    message: message.clone(),
};
```

4. **Expected behavior**: Coordinator should reject this message
5. **Actual behavior**: 
   - Coordinator accepts message (passes set validation)
   - Coordinator broadcasts in `SignatureShareRequest`
   - All honest signers call `aggregate_nonce(msg, [1,2,3], [nonce1, nonce2])`
   - Function creates `scalars = [1, rho1, 1, rho2, 1, rho3]` (6 elements)
   - Function creates `points = [D1, E1, D2, E2]` (4 elements)
   - `Point::multimult(scalars, points)` errors on length mismatch
   - `.unwrap()` panics, crashing all signers

**Reproduction steps:**
1. Set up 3+ signer WSTS deployment
2. Modify one signer to send `NonceResponse` with `key_ids.len() = 3`, `nonces.len() = 2`
3. Initiate signing round
4. Observe all honest signers panic at `aggregate_nonce().unwrap()` call
5. Signing round fails, no signature produced

### Citations

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** src/compute.rs (L100-121)
```rust
pub fn aggregate_nonce(
    msg: &[u8],
    party_ids: &[u32],
    nonces: &[PublicNonce],
) -> Result<Point, PointError> {
    let compressed_nonces: Vec<(Compressed, Compressed)> = nonces
        .iter()
        .map(|nonce| (nonce.D.compress(), nonce.E.compress()))
        .collect();
    let scalars: Vec<Scalar> = party_ids
        .iter()
        .flat_map(|&i| {
            [
                Scalar::from(1),
                binding_compressed(&id(i), &compressed_nonces, msg),
            ]
        })
        .collect();
    let points: Vec<Point> = nonces.iter().flat_map(|nonce| [nonce.D, nonce.E]).collect();

    Point::multimult(scalars, points)
}
```

**File:** src/net.rs (L311-323)
```rust
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/signer/mod.rs (L781-804)
```rust
        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/v1.rs (L714-714)
```rust
        let aggregate_nonce = compute::aggregate_nonce(msg, key_ids, nonces).unwrap();
```
