### Title
Missing DKG Round ID Validation Enables Denial of Service via State Reset

### Summary
The signer's `reset()` function clears critical DKG state (commitments, decrypted_shares, decryption_keys) without validating whether it is safe to do so, and message handlers fail to validate incoming `dkg_id` fields. A malicious coordinator can exploit this to repeatedly reset signer state, preventing DKG completion and causing persistent denial of service.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `reset()` function unconditionally clears critical DKG state including commitments, decrypted_shares, and decryption_keys without any validation checks.

**Root Cause:**
The signer's `dkg_begin()` handler unconditionally calls `reset()` when receiving a DkgBegin message: [2](#0-1) 

There are no checks to validate:
1. Whether the new `dkg_id` is appropriate (e.g., greater than current `dkg_id`)
2. Whether the current DKG round has completed
3. Whether accumulated state should be preserved

Additionally, other message handlers fail to validate that incoming message `dkg_id` fields match `self.dkg_id`:

**dkg_public_share handler** - no dkg_id validation: [3](#0-2) 

**dkg_private_shares handler** - no dkg_id validation: [4](#0-3) 

**dkg_private_begin handler** - no dkg_id validation: [5](#0-4) 

**dkg_end_begin handler** - no dkg_id validation: [6](#0-5) 

All DKG messages contain `dkg_id` fields: [7](#0-6) 

**Why Existing Mitigations Fail:**
While the coordinator has duplicate `dkg_id` detection, the signer does not. The KEX key rotation during `reset()` prevents certain cross-round message acceptance attacks but does not prevent the DoS scenario where a coordinator can repeatedly trigger resets.

### Impact Explanation

**Specific Harm:**
A malicious coordinator can prevent DKG completion by repeatedly sending `DkgBegin` messages with incrementing `dkg_id` values. Each message triggers `reset()`, clearing all accumulated DKG shares and commitments. This results in:

1. **DKG Never Completes:** Signers are perpetually reset before they can gather sufficient shares to complete the DKG protocol
2. **Signing Group Cannot Form:** Without completed DKG, the threshold signing group cannot be established
3. **Service Disruption:** In blockchain contexts like Stacks, inability to form signing groups could prevent block signing and transaction confirmation

**Quantified Impact:**
- Affects all signers in the DKG round simultaneously
- Requires only O(1) malicious messages per reset cycle
- Can be sustained indefinitely with minimal resources

**Severity Justification:**
This maps to **Low** severity per the protocol scope: "Any remotely-exploitable denial of service in a node." While this prevents DKG completion, it does not directly shut down the entire network (which would be Critical) but does impact individual nodes and could affect mining operations if more than 10% of miners participate in the affected DKG round.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Malicious coordinator with valid signing credentials, OR
- Network attacker with ability to inject/modify coordinator messages (if packet signature verification is disabled)

**Attack Complexity:**
Low - The attack is straightforward:
1. Coordinator sends `DkgBegin{dkg_id: 1}`
2. Signers begin DKG round, accumulating shares
3. Before completion, coordinator sends `DkgBegin{dkg_id: 2}`
4. All signer state is cleared via `reset()`
5. Repeat with incrementing `dkg_id` values

**Economic Feasibility:**
Minimal cost - only requires network bandwidth to send small DkgBegin messages repeatedly.

**Detection Risk:**
Medium - The attack generates valid protocol messages with proper signatures. Detection would require monitoring for abnormal DKG restart patterns, which may not be implemented in typical deployments.

**Probability of Success:**
High if the coordinator is compromised. The coordinator is typically a trusted entity with message signing capabilities: [8](#0-7) 

### Recommendation

**Proposed Code Changes:**

1. **Add dkg_id validation in message handlers:**
   - In `dkg_begin()`: Check that `dkg_begin.dkg_id > self.dkg_id` or that current state is `Idle`
   - In `dkg_public_share()`: Validate `dkg_public_shares.dkg_id == self.dkg_id`
   - In `dkg_private_shares()`: Validate `dkg_private_shares.dkg_id == self.dkg_id`
   - In `dkg_private_begin()`: Validate `dkg_private_begin.dkg_id == self.dkg_id`
   - In `dkg_end_begin()`: Validate `dkg_end_begin.dkg_id == self.dkg_id`

2. **Add state validation in reset():**
   - Check that current DKG is complete or state is `Idle` before allowing reset
   - Optionally log warnings when discarding accumulated state

3. **Implement monotonic dkg_id enforcement:**
   - Track that `dkg_id` values only increase
   - Reject messages with `dkg_id <= self.dkg_id` (except for idempotent retry scenarios)

**Alternative Mitigations:**
- Implement rate limiting on DKG round initiation
- Add coordinator reputation/trust scoring
- Deploy monitoring for abnormal DKG restart patterns

**Testing Recommendations:**
- Add unit tests for dkg_id validation in all message handlers
- Add integration tests for DKG restart scenarios
- Fuzz test with out-of-order and replayed messages

**Deployment Considerations:**
- This is a protocol-level change requiring coordinated upgrade
- Consider backward compatibility if existing deployments don't validate dkg_id
- Monitor for increased message rejection rates during rollout

### Proof of Concept

**Exploitation Algorithm:**

```
Attack: Persistent DKG Denial of Service

Prerequisites:
- Attacker controls coordinator (has coordinator private key)
- Signers have verify_packet_sigs enabled (default)

Steps:
1. Attacker (as coordinator) initiates DKG round:
   - Send DkgBegin{dkg_id: 1}
   - Signers call reset(1), transition to DkgPublicDistribute
   
2. Signers begin normal DKG flow:
   - Send DkgPublicShares messages
   - Accumulate commitments from other signers
   - Transition to DkgPublicGather state
   
3. Before DKG completion, attacker sends:
   - DkgBegin{dkg_id: 2}
   
4. Each signer processes the message:
   - dkg_begin() calls reset(2) [line 849]
   - commitments.clear() [line 419]
   - decrypted_shares.clear() [line 420]
   - decryption_keys.clear() [line 421]
   - All accumulated state from round 1 is lost
   
5. Signers restart DKG from scratch with dkg_id=2

6. Attacker repeats steps 3-5 indefinitely with incrementing dkg_ids

Expected Behavior:
- Signers should reject DkgBegin during active DKG rounds
- Or require explicit completion/abort before accepting new DKG round

Actual Behavior:
- Signers unconditionally reset and discard accumulated state
- DKG never completes
- Denial of service persists as long as attacker continues

Reproduction:
- Deploy test coordinator and 3+ signers
- Monitor signer state during DKG
- Send DkgBegin with dkg_id=N+1 during active round N
- Observe state reset and DKG restart
- Verify accumulated shares are lost
```

**Parameter Values:**
- Network: Any WSTS deployment
- Number of signers: 3+ (arbitrary)
- Attack frequency: Can be sustained at message-per-second rates
- Resource cost: Minimal (small message payloads)

### Citations

**File:** src/state_machine/signer/mod.rs (L416-432)
```rust
    /// Reset internal state
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/signer/mod.rs (L892-956)
```rust
    fn dkg_private_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_begin: &DkgPrivateBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let mut private_shares = DkgPrivateShares {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            shares: Vec::new(),
        };
        let mut active_key_ids = HashSet::new();
        for signer_id in &dkg_private_begin.signer_ids {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
                for key_id in key_ids {
                    active_key_ids.insert(*key_id);
                }
            }
        }

        self.dkg_private_begin_msg = Some(dkg_private_begin.clone());
        self.move_to(State::DkgPrivateDistribute)?;

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            "sending DkgPrivateShares"
        );

        trace!(
            "Signer {} shares {:?}",
            self.signer_id,
            &self.signer.get_shares()
        );
        for (party_id, shares) in &self.signer.get_shares() {
            debug!(
                "Signer {} addding dkg private share for party_id {party_id}",
                self.signer_id
            );
            // encrypt each share for the recipient
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
        }

        let private_shares = Message::DkgPrivateShares(private_shares);
        msgs.push(private_shares);

        self.move_to(State::DkgPrivateGather)?;
        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L958-971)
```rust
    /// handle incoming DkgEndBegin
    pub fn dkg_end_begin(&mut self, dkg_end_begin: &DkgEndBegin) -> Result<Vec<Message>, Error> {
        let msgs = vec![];

        self.dkg_end_begin_msg = Some(dkg_end_begin.clone());

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            "received DkgEndBegin"
        );

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L973-1026)
```rust
    /// handle incoming DkgPublicShares
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/state_machine/signer/mod.rs (L1028-1110)
```rust
    /// handle incoming DkgPrivateShares
    pub fn dkg_private_shares<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_shares: &DkgPrivateShares,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        // go ahead and decrypt here, since we know the signer_id and hence the pubkey of the sender
        let src_signer_id = dkg_private_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&src_signer_id) else {
            warn!(%src_signer_id, "No public key configured");
            return Ok(vec![]);
        };

        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };

        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }

        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }

        self.dkg_private_shares
            .insert(src_signer_id, dkg_private_shares.clone());

        // make a HashSet of our key_ids so we can quickly query them
        let key_ids: HashSet<u32> = self.signer.get_key_ids().into_iter().collect();

        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
        debug!(
            "received DkgPrivateShares from signer {} {}/{}",
            dkg_private_shares.signer_id,
            self.decrypted_shares.len(),
            self.signer.get_num_parties(),
        );
        Ok(vec![])
    }
```

**File:** src/net.rs (L127-241)
```rust
pub struct DkgBegin {
    /// DKG round ID
    pub dkg_id: u64,
}

impl Signable for DkgBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
    }
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}

impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private begin message from signer to all signers and coordinator
pub struct DkgPrivateBegin {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    pub signer_ids: Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    pub key_ids: Vec<u32>,
}

impl Signable for DkgPrivateBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PRIVATE_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }
        for signer_id in &self.signer_ids {
            hasher.update(signer_id.to_be_bytes());
        }
    }
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}

impl Signable for DkgPrivateShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PRIVATE_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // make sure we hash consistently by sorting the keys
        for (src_id, share) in &self.shares {
            hasher.update(src_id.to_be_bytes());
            let mut dst_ids = share.keys().cloned().collect::<Vec<u32>>();
            dst_ids.sort();
            for dst_id in &dst_ids {
                hasher.update(dst_id.to_be_bytes());
                hasher.update(&share[dst_id]);
            }
        }
    }
}

#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG end begin message from signer to all signers and coordinator
pub struct DkgEndBegin {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    pub signer_ids: Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    pub key_ids: Vec<u32>,
}

impl Signable for DkgEndBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_END_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }
        for signer_id in &self.signer_ids {
            hasher.update(signer_id.to_be_bytes());
        }
    }
}
```
