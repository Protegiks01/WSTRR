### Title
Unbounded Message Size in NonceRequest Enables Memory Exhaustion DoS Attack

### Summary
The `NonceRequest` structure accepts arbitrarily large messages without size validation, enabling a malicious coordinator to cause memory exhaustion in all signer nodes. The message is cloned multiple times through the protocol flow and amplified in `SignatureShareRequest`, where it appears (N+1) times for N responding signers, leading to multi-gigabyte packet sizes that exhaust memory when deserialized, hashed, and processed.

### Finding Description

**Exact Code Locations:**

The `NonceRequest` struct defines the message field as an unbounded `Vec<u8>` with no size constraints: [1](#0-0) 

When signers receive `NonceRequest`, they clone the entire message into `NonceResponse`: [2](#0-1) 

The coordinator creates `SignatureShareRequest` containing all `NonceResponse` objects (each with a message copy) plus another direct message copy: [3](#0-2) 

The message is hashed in its entirety during signature verification for `NonceRequest`: [4](#0-3) 

The message is also copied into a buffer during binding value computation in every signing operation: [5](#0-4) 

**Root Cause:**

The vulnerability exists because:
1. No size validation is performed when setting the message in `start_signing_round`: [6](#0-5) 

2. The `Vec<u8>` type has no inherent bounds, allowing multi-gigabyte allocations
3. The protocol design amplifies the message: for N signers, `SignatureShareRequest` contains (N+1) copies of the message
4. Multiple memory-intensive operations (deserialization, hashing, buffer copying) occur without size checks

**Why Existing Mitigations Fail:**

No mitigations exist:
- No `MAX_MESSAGE_SIZE` constant or validation logic anywhere in the codebase
- Serde's `Deserialize` trait has no default size limits configured
- No transport-layer message size enforcement visible in the protocol implementation
- The coordinator state machine accepts any message size passed to it

### Impact Explanation

**Specific Harm:**

A malicious coordinator sends a `NonceRequest` with a message of M bytes. With N signers responding:
- Each signer allocates M bytes to store and process the message
- Coordinator allocates N × M bytes storing all `NonceResponse` messages
- Coordinator sends `SignatureShareRequest` of size (N+1) × M bytes to each signer
- Each signer must deserialize and process (N+1) × M bytes

**Quantified Impact:**

With realistic parameters (M = 100 MB, N = 10 signers):
- Initial `NonceRequest`: 100 MB sent to each of 10 signers = 1 GB total network traffic
- `NonceResponse` messages: 10 × 100 MB = 1 GB sent back to coordinator
- `SignatureShareRequest`: 1.1 GB sent to each of 10 signers = 11 GB total network traffic
- Each signer must allocate ~1.1 GB memory to process the request

This causes:
- Memory exhaustion and potential crashes in signer nodes
- Severe performance degradation during deserialization and hashing
- Prevention of legitimate signing operations
- Denial of service across all participating signers

**Who is Affected:**

All signer nodes attempting to participate in the signing round are affected. The coordinator node also experiences memory pressure storing N copies of the message.

**Severity Justification:**

This maps to **LOW severity** per the protocol scope: "Any remotely-exploitable denial of service in a node." While it can impact multiple nodes simultaneously and prevent signing operations, it does not directly cause chain-level failures such as invalid signatures being accepted, fund loss, or chain splits. The signing round simply fails to complete.

### Likelihood Explanation

**Required Attacker Capabilities:**

The attacker must possess the coordinator's ECDSA private key, as `NonceRequest` messages must be signed by the coordinator and are rejected if the signature verification fails: [7](#0-6) 

This means the attacker must either:
1. Compromise the coordinator's key material
2. Be a malicious coordinator operator
3. Exploit a separate vulnerability to gain access to coordinator credentials

**Attack Complexity:**

Once coordinator access is obtained, the attack is trivial:
1. Call `start_signing_round()` with a large message (e.g., 100 MB - 1 GB)
2. The protocol automatically propagates the message to all signers
3. Signers process and respond, causing memory pressure
4. Coordinator sends amplified `SignatureShareRequest`, exhausting signer memory

No sophisticated exploitation techniques are required beyond crafting a large message payload.

**Economic Feasibility:**

Extremely low cost - generating large messages requires minimal computational resources. Network bandwidth costs are the primary expense, but remain feasible for a determined attacker.

**Detection Risk:**

Low detection risk during execution, as the messages are validly signed and follow the protocol structure. However, unusual message sizes would be observable in network monitoring and logs.

**Estimated Probability:**

Given the requirement for coordinator compromise, probability depends on:
- Coordinator key security practices
- Whether the coordinator is operated by a trusted party
- Insider threat risk

The technical exploitation is 100% reliable once coordinator access is obtained.

### Recommendation

**Immediate Fix:**

1. Add a maximum message size constant and validate it in `start_signing_round()`:

```rust
const MAX_MESSAGE_SIZE: usize = 10 * 1024 * 1024; // 10 MB

fn start_signing_round(
    &mut self,
    message: &[u8],
    signature_type: SignatureType,
    sign_id: Option<u64>,
) -> Result<Packet, Error> {
    if message.len() > MAX_MESSAGE_SIZE {
        return Err(Error::MessageTooLarge(message.len()));
    }
    // ... existing code
}
```

Apply location: [8](#0-7) 

2. Add corresponding validation in signer's `nonce_request()` method to reject oversized messages early:

```rust
fn nonce_request<R: RngCore + CryptoRng>(
    &mut self,
    nonce_request: &NonceRequest,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    if nonce_request.message.len() > MAX_MESSAGE_SIZE {
        return Err(Error::MessageTooLarge(nonce_request.message.len()));
    }
    // ... existing code
}
```

Apply location: [9](#0-8) 

**Alternative Mitigations:**

1. Use streaming hashing for large messages instead of buffering entire message
2. Implement message size limits at the transport/serialization layer
3. Add rate limiting on message processing to prevent rapid exhaustion attempts

**Testing Recommendations:**

1. Unit test: Verify `start_signing_round()` rejects messages exceeding `MAX_MESSAGE_SIZE`
2. Integration test: Confirm signers reject oversized `NonceRequest` messages
3. Stress test: Validate memory usage remains bounded with maximum-size messages
4. Regression test: Ensure legitimate signing operations with normal-sized messages continue to work

**Deployment Considerations:**

- Choose `MAX_MESSAGE_SIZE` based on legitimate use cases (e.g., signing Bitcoin transactions, which are typically < 1 MB)
- Consider making the limit configurable for different deployment scenarios
- Document the size limit for library users
- Coordinate the rollout to ensure all nodes enforce the limit consistently

### Proof of Concept

**Exploitation Algorithm:**

```
1. Setup:
   - Attacker has coordinator private key
   - WSTS network with N signers is operational

2. Create large message:
   message = [0u8; 100_000_000]  // 100 MB of zeros

3. Initiate signing round:
   coordinator.start_signing_round(&message, SignatureType::Frost, None)

4. Observe protocol flow:
   - NonceRequest (100 MB) sent to all N signers
   - Each signer allocates 100 MB, clones to NonceResponse
   - N × NonceResponse (100 MB each) sent back to coordinator
   - Coordinator stores N × 100 MB in message_nonces BTreeMap
   - SignatureShareRequest ((N+1) × 100 MB) sent to each signer
   - Each signer attempts to deserialize (N+1) × 100 MB

5. Result:
   - Signers experience memory exhaustion
   - Potential OOM kills or severe performance degradation
   - Signing round fails to complete
```

**Parameter Values:**

- Message size (M): 100 MB (100,000,000 bytes)
- Number of signers (N): 10
- Total SignatureShareRequest size: 1.1 GB
- Network bandwidth consumed: ~12 GB per attack iteration
- Expected memory usage per signer: >1 GB during processing

**Expected vs Actual Behavior:**

Expected (secure): Message size validated, oversized requests rejected before memory allocation
Actual (vulnerable): No validation, full message deserialized and processed, causing memory exhaustion

**Reproduction Instructions:**

1. Set up WSTS coordinator and 10 signer nodes
2. Modify coordinator test to use large message:
   ```rust
   let large_message = vec![0u8; 100_000_000];
   coordinator.start_signing_round(&large_message, SignatureType::Frost, None);
   ```
3. Monitor signer memory usage with system tools
4. Observe memory allocation growing to >1 GB per signer
5. Confirm signing round failure or system instability

**Notes**

While this vulnerability requires coordinator compromise to exploit, it represents a defense-in-depth failure. The coordinator is a trusted role in WSTS, but the protocol should still enforce reasonable bounds on message sizes to prevent accidental or malicious resource exhaustion. The message amplification factor in `SignatureShareRequest` (where N+1 copies of the message are transmitted) significantly magnifies the impact beyond the initial message size, making this particularly concerning in deployments with many signers.

### Citations

**File:** src/net.rs (L262-275)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce request message from coordinator to signers
pub struct NonceRequest {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// The message to sign
    pub message: Vec<u8>,
    /// What type of signature to create
    pub signature_type: SignatureType,
}
```

**File:** src/net.rs (L289-307)
```rust
impl Signable for NonceRequest {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("NONCE_REQUEST".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.sign_id.to_be_bytes());
        hasher.update(self.sign_iter_id.to_be_bytes());
        hasher.update(self.message.as_slice());
        match self.signature_type {
            SignatureType::Frost => hasher.update("SIGNATURE_TYPE_FROST".as_bytes()),
            SignatureType::Schnorr => hasher.update("SIGNATURE_TYPE_SCHNORR".as_bytes()),
            SignatureType::Taproot(merkle_root) => {
                hasher.update("SIGNATURE_TYPE_TAPROOT".as_bytes());
                if let Some(merkle_root) = merkle_root {
                    hasher.update(merkle_root);
                }
            }
        }
    }
}
```

**File:** src/net.rs (L557-562)
```rust
            Message::NonceRequest(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a NonceRequest message with an invalid signature.");
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L964-996)
```rust
    fn request_sig_shares(&mut self, signature_type: SignatureType) -> Result<Packet, Error> {
        self.signature_shares.clear();
        info!(
            sign_id = %self.current_sign_id,
            "Requesting Signature Shares"
        );
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
            message: self.message.clone(),
            signature_type,
        };
        let sig_share_request_msg = Packet {
            sig: sig_share_request
                .sign(&self.config.message_private_key)
                .expect("Failed to sign SignatureShareRequest"),
            msg: Message::SignatureShareRequest(sig_share_request),
        };
        self.move_to(State::SigShareGather(signature_type))?;
        self.sign_start = Some(Instant::now());

        Ok(sig_share_request_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L1457-1476)
```rust
    fn start_signing_round(
        &mut self,
        message: &[u8],
        signature_type: SignatureType,
        sign_id: Option<u64>,
    ) -> Result<Packet, Error> {
        // We cannot sign if we haven't first set DKG (either manually or via DKG round).
        if self.aggregate_public_key.is_none() {
            return Err(Error::MissingAggregatePublicKey);
        }
        self.message = message.to_vec();
        if let Some(id) = sign_id {
            self.current_sign_id = id;
        } else {
            self.current_sign_id = self.current_sign_id.wrapping_add(1);
        }
        info!("Starting signing round {}", self.current_sign_id);
        self.move_to(State::NonceRequest(signature_type))?;
        self.request_nonces(signature_type)
    }
```

**File:** src/compute.rs (L17-33)
```rust
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```
