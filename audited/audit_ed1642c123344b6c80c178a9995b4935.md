# Audit Report

## Title
Malicious Signers Evade Detection by Sending Invalid Nonces Instead of Timing Out

## Summary
The FIRE coordinator only marks signers as malicious during signature share timeouts, not when they send cryptographically invalid data. Attackers can send invalid nonces (with mismatched key IDs or invalid elliptic curve points) to disrupt signing while avoiding permanent exclusion from the `malicious_signer_ids` set, enabling persistent denial of service attacks.

## Finding Description

The FIRE coordinator implements asymmetric handling of misbehaving signers, creating an exploitable detection gap.

When a signer sends a `NonceResponse` with invalid key IDs that don't match the configuration, the coordinator logs a warning and returns `Ok()` without adding the signer to `sign_wait_signer_ids`: [1](#0-0) 

Similarly, when nonces fail the `is_valid()` check (invalid elliptic curve points), the response is rejected with `Ok()` return, preventing the signer from being added to the wait list: [2](#0-1) 

Normal processing adds valid signers to `sign_wait_signer_ids` later in the function: [3](#0-2) 

The critical issue is that malicious marking occurs exclusively during signature share timeouts, where ALL signers remaining in `sign_wait_signer_ids` are marked malicious: [4](#0-3) 

This is the **only** location in the entire codebase where signers are added to `malicious_signer_ids` (confirmed via comprehensive grep). Since attackers who sent invalid nonces were never added to `sign_wait_signer_ids`, they escape being marked.

The `Error::MaliciousSigner` variant exists in the error enum: [5](#0-4) 

However, it is commented out at the only location where it could mark invalid nonce senders: [6](#0-5) 

Once marked malicious, future nonce responses from those signers are silently dropped (same code path above), but attackers sending invalid data never reach this marked state.

The coordinator's threshold feasibility check relies on accurate `malicious_signer_ids` tracking: [7](#0-6) 

If unmarked malicious signers aren't counted, the coordinator may incorrectly believe threshold is achievable when it's not, leading to infinite retry loops. The `reset()` function preserves `malicious_signer_ids` across rounds but never populates it for invalid nonce senders: [8](#0-7) 

**Attack Flow:**
1. Attacker joins as legitimate signer with N keys
2. During signing, sends `NonceResponse` with invalid key IDs or invalid curve points
3. Coordinator rejects response with `Ok()`, doesn't add to `sign_wait_signer_ids`
4. If threshold can't be met without attacker's keys, signing fails
5. On retry, attacker repeats step 2
6. System enters infinite loop because threshold check thinks attacker's keys are available

## Impact Explanation

**Severity: Medium** - Maps to "transient consensus failures" per the defined scope.

The vulnerability enables:

1. **Incorrect Threshold Accounting**: The coordinator's feasibility check (`num_keys - num_malicious_keys >= threshold`) excludes unmarked malicious signers from the count, causing false positives about signing viability.

2. **Persistent Denial of Service**: Attackers can repeatedly disrupt signing across multiple rounds without being permanently excluded, as the retry mechanism continues requesting nonces from them.

3. **Resource Exhaustion**: Legitimate signers waste computational resources (nonce generation, DH computations, network overhead) in signing attempts doomed to fail.

4. **Consensus Delays**: In blockchain integration scenarios (e.g., Stacks), repeated signing failures delay block production and transaction confirmation.

**Quantified Example**: With 40 total keys, threshold 28, and an attacker controlling 13 keys who sends invalid nonces, the system believes 40 keys are available (should be 27), causing indefinite retry loops.

While the cryptographic validation layer prevents acceptance of invalid signatures (maintaining safety), the liveness guarantee is violated. The system cannot make progress despite having honest participants capable of meeting threshold.

## Likelihood Explanation

**Probability: High**

**Attacker Requirements:**
- Control of one or more signers within the WSTS network (within threat model for up to threshold-1 malicious parties)
- Ability to send protocol messages (normal participant capability)
- No cryptographic breaks, key theft, or social engineering required

**Attack Complexity: Trivial**
- Modify `NonceResponse.key_ids` to not match configuration (single field change)
- Or set `PublicNonce.D` and `PublicNonce.E` to invalid points like `Point::new()` or the generator `G` (both fail `is_valid()`)
- Send modified message to coordinator via normal message channel

**Detection Difficulty: High**
- Coordinator only logs warnings indistinguishable from implementation bugs
- No mechanism to attribute repeated failures to specific signers sending invalid data
- External observers see generic signing timeouts without visibility into root cause

**Economic Feasibility: Very High**
- Zero cost beyond joining as legitimate participant
- Can join with minimal keys and still disrupt if threshold margins are tight
- Repeatable indefinitely with deterministic success

## Recommendation

Mark signers as malicious when they send cryptographically invalid data, not just when they timeout. Specifically:

1. **Uncomment and use `Error::MaliciousSigner`** at line 913 in `fire.rs` for already-marked signers, OR return it when invalid data is detected.

2. **Add malicious marking for invalid key IDs** (around line 888):
```rust
if *signer_key_ids != nonce_response_key_ids {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
    self.malicious_signer_ids.insert(nonce_response.signer_id);
    return Ok(());
}
```

3. **Add malicious marking for invalid nonces** (around line 899):
```rust
if !nonce.is_valid() {
    warn!(...);
    self.malicious_signer_ids.insert(nonce_response.signer_id);
    return Ok(());
}
```

4. **Add malicious marking for other validation failures** (missing public key at line 867, missing key IDs at line 878) to ensure comprehensive tracking.

5. **Optional**: Add `malicious_signer_ids.clear()` to `reset()` if malicious marking should not persist across DKG rounds, OR document that persistence is intentional for operational tracking.

This ensures the coordinator's threshold feasibility check accurately reflects available keys and prevents retry loops with permanently unavailable signers.

## Proof of Concept

```rust
#[test]
fn test_invalid_nonce_evades_malicious_marking() {
    // Setup: 10 signers, 3 keys each (30 total), threshold 20
    let num_signers = 10;
    let keys_per_signer = 3;
    let threshold = 20;
    
    let mut config = Config::new(num_signers, keys_per_signer, threshold, ...);
    let mut coordinator = Coordinator::new(config);
    
    // Run DKG successfully
    coordinator.start_dkg_round().unwrap();
    // ... complete DKG ...
    
    // Start signing round
    let msg = b"test message".to_vec();
    coordinator.start_signing_round(&msg, SignatureType::Frost, None).unwrap();
    
    // Attacker (signer_id=0, controls 3 keys) sends invalid nonces
    let mut malicious_response = NonceResponse {
        dkg_id: coordinator.current_dkg_id,
        sign_id: coordinator.current_sign_id,
        sign_iter_id: coordinator.current_sign_iter_id,
        signer_id: 0,
        key_ids: vec![999, 998, 997], // WRONG KEY IDs
        nonces: vec![...],
        message: msg.clone(),
    };
    
    let packet = Packet { 
        msg: Message::NonceResponse(malicious_response),
        sig: ...
    };
    
    // Process malicious response
    coordinator.process(&packet).unwrap();
    
    // VULNERABILITY: Signer 0 is NOT in malicious_signer_ids
    assert!(!coordinator.malicious_signer_ids.contains(&0));
    
    // Remaining 9 signers send valid nonces (27 keys)
    // But threshold is 20, so we're below threshold (27 < 30 - unmarked_malicious_3)
    
    // Trigger signature share timeout
    coordinator.process_timeout().unwrap();
    
    // Coordinator marks timeout signers as malicious but NOT signer 0
    // Threshold check: 30 - 0 = 30 >= 20 âœ“ (WRONG, should be 30 - 3 = 27)
    
    // System retries indefinitely because it thinks it has enough keys
    // This demonstrates the DoS and incorrect accounting
}
```

The PoC demonstrates that a signer sending invalid key IDs avoids being marked in `malicious_signer_ids`, causing incorrect threshold accounting and enabling persistent DoS through retry loops.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L178-186)
```rust
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L188-191)
```rust
                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
```

**File:** src/state_machine/coordinator/fire.rs (L886-889)
```rust
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L891-900)
```rust
            for nonce in &nonce_response.nonces {
                if !nonce.is_valid() {
                    warn!(
                        sign_id = %nonce_response.sign_id,
                        sign_iter_id = %nonce_response.sign_iter_id,
                        signer_id = %nonce_response.signer_id,
                        "Received invalid nonce in NonceResponse"
                    );
                    return Ok(());
                }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L940-942)
```rust
            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1479-1490)
```rust
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```

**File:** src/state_machine/coordinator/mod.rs (L65-67)
```rust
    /// A malicious signer sent the received message
    #[error("Malicious signer {0}")]
    MaliciousSigner(u32),
```
