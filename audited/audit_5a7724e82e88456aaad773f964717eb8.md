### Title
Unauthenticated DH Key Exchange in DKG Enables MitM Extraction of Private Shares

### Summary
The key exchange public keys (`kex_public_key`) distributed during the DKG phase are not authenticated. Because the signature on the DkgPublicShares message does not cover the `kex_public_key` field, an attacker can substitute their own key, perform a man-in-the-middle attack, and decrypt DKG shares intended for honest participants, enabling full key compromise and signature forgery.

### Finding Description
- The message hashing logic for DkgPublicShares in `src/net.rs` excludes the `kex_public_key` from the signed message hash, so signatures do not bind this field to the message or signer. This allows an attacker with network access to alter the `kex_public_key` in transit while retaining a valid signature.
- On receipt, signers and coordinators accept and use any `kex_public_key` present in a DkgPublicShares message after successful signature verification, without independently authenticating the key value. This enables a man-in-the-middle to later decrypt encrypted DKG private shares intended for the targeted party.
- Code location: 
  - DkgPublicShares::hash() (does not hash `kex_public_key`) (`src/net.rs`)
  - Packet::verify() (`src/net.rs`)
  - DkgPublicShares handling in signers and coordinators (`src/state_machine/signer/mod.rs`, `src/state_machine/coordinator/frost.rs`, `src/state_machine/coordinator/fire.rs`)
- Exploitation: An attacker intercepts and modifies a signed DkgPublicShares message, replacing the `kex_public_key` with their own, forwards it, and thereafter decrypts any DKG private shares encrypted for that key. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

### Impact Explanation
- Any adversary capable of network interception can compromise DKG private shares in transit.
- If they compromise the threshold number of shares, they can reconstruct the group private key and unilaterally forge signatures.
- This constitutes "direct loss of funds," "confirmation of invalid transactions," and could enable a "chain split" if used for conflicting signed messages, qualifying as Critical severity.
- All protocol users are at risk if they lack authenticated channels.

### Likelihood Explanation
- Exploitation requires that an attacker be able to intercept and modify DKG messages on the network between parties (standard MitM prerequisites).
- No cryptographic break or special secret knowledge is required.
- The attack is straightforward: swap `kex_public_key`, log shares, decrypt off-path.
- Detection is difficult (messages retain valid signatures).
- Probability of success is high in unprotected networks.

### Recommendation
- Change the hashing function for DkgPublicShares (and supporting signing/verification code) to include `kex_public_key` in the hash that is signed and verified.
- Perform an audit to ensure that all fields relevant to protocol security/cryptography are bound to their signatures throughout the protocol.
- Deploy regression/unit/integration tests to confirm mitigation; test with altered `kex_public_key` and expect the signature to fail.

### Proof of Concept
**Step-by-step attack:**
1. Attacker generates (attacker_sk, attacker_pk)
2. Intercepts DkgPublicShares from honest signer; replaces `kex_public_key` with attacker_pk; forwards the message.
3. Target signs/encrypts using attacker_pk, thinking it belongs to the honest participant.
4. Attacker intercepts DKG private shares, decrypts them with attacker_sk.
5. If sufficient shares are stolen, reconstructs the distributed private key and forges protocol signatures.

(Alter the DkgPublicShares protobuf to drop/rewrite `kex_public_key` and test signature validation before/after fix.)

---

Notes:
- This vulnerability is concrete and practical.
- No countermeasures (e.g., tuple proofs or post-decryption validation) in current code can prevent the attack, since the attacker intercepts before DKG private share encryption and exploits the lack of key authentication.
- The fix must be protocol-enforced and not only discouraged by "out-of-band" documentation or operator guidance.

### Citations

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/coordinator/frost.rs (L290-334)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.ids_to_await.remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            for (party_id, comm) in &dkg_public_shares.comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }

            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.ids_to_await.is_empty() {
            self.move_to(State::DkgPrivateDistribute)?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```
