### Title
Signature Share ID Spoofing Enables False Blame Assignment and Denial of Service

### Summary
The `Aggregator::check_signature_shares()` function uses the unvalidated `sig_share.id` field to identify malicious parties when signature aggregation fails. A malicious signer can set this field to an arbitrary party ID (including IDs they don't control) to frame innocent parties, while the coordinator only validates the `sig_share.key_ids` field. This enables attackers to hide their identity and cause honest parties to be falsely accused of submitting invalid signatures, potentially leading to their removal from the signing set and transient consensus failures.

### Finding Description

**Exact Code Location:**
- `src/v1.rs`, function `Aggregator::check_signature_shares()`, lines 361-426
- `src/v2.rs`, function `Aggregator::check_signature_shares()`, lines 350-417
- `src/state_machine/coordinator/frost.rs`, signature share validation, lines 620-641

**Root Cause:**

The vulnerability exists because of a disconnect between which fields are validated and which fields are used for blame assignment:

1. In `check_signature_shares()`, the function uses `sig_shares[i].id` to identify which party submitted a bad signature: [1](#0-0) 

2. When verification fails, the `sig_shares[i].id` value is added to the `bad_party_sigs` list: [2](#0-1) 

3. However, the coordinator only validates that the union of all `sig_share.key_ids` matches the expected key IDs for that signer, but never validates that `sig_share.id` itself is legitimate: [3](#0-2) 

4. The `SignatureShare` structure contains both an `id` field (used for blame assignment) and a `key_ids` field (validated by coordinator): [4](#0-3) 

**Why Existing Mitigations Fail:**

There is no validation that enforces `sig_share.id` must be one of the signer's legitimate key IDs or that it must match the actual submitter. The coordinator's validation only checks the `key_ids` field, creating a trust gap that allows ID spoofing.

### Impact Explanation

**Specific Harm:**

1. **False Accusations**: Honest signers can be incorrectly identified as malicious when signature aggregation fails
2. **Attacker Anonymity**: The actual malicious signer remains undetected and unreported
3. **Denial of Service**: If coordinators or upper layers automatically ban or penalize parties identified in `BadPartySigs` errors, honest parties are removed from the signing set
4. **Threshold Degradation**: Repeated false accusations can reduce the available honest signers below the signing threshold, preventing valid signatures from being created

**Quantified Impact:**

In a deployment with 10 signers and a threshold of 7:
- A single malicious signer can frame up to 3 honest parties per failed signing round
- After 2-3 attack iterations, honest parties could fall below threshold (7 - 3 = 4 remaining)
- This causes inability to produce signatures, constituting a transient consensus failure

**Who Is Affected:**

- Honest signers: Falsely blamed and potentially banned
- Coordinators: Receive false information about which parties are malicious  
- Dependent systems: Cannot obtain signatures if threshold is not met

**Severity Justification:**

This maps to **Medium** severity per the protocol scope definition: "Any transient consensus failures"

If enough honest parties are falsely accused and removed, the signing threshold cannot be met, preventing signature generation. This is a transient consensus failure because signature production is temporarily halted. While not as severe as invalid signatures being accepted (Critical) or permanent network shutdown (Critical), it still impacts the availability and reliability of the signing protocol.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a legitimate participant in the signing protocol with at least one valid key ID
- Must have the ability to submit signature shares (standard participant privilege)
- No cryptographic secrets or coordinator privileges required

**Attack Complexity:**
The attack is straightforward to execute:
1. During a signing round, generate signature shares for all owned key IDs
2. Modify the `id` field of one or more signature shares to point to victim party IDs
3. Keep the `key_ids` field unchanged (pointing to legitimate owned keys)
4. Submit the modified signature shares to the coordinator
5. When aggregation fails (either naturally or deliberately induced), victims are blamed

**Economic Feasibility:**
- No additional resources required beyond normal protocol participation
- Attack can be repeated in multiple signing rounds
- Cost is minimal (just modifying a field value)

**Detection Risk:**
- Low: Without additional logging/auditing, the coordinator cannot detect that `sig_share.id` doesn't match the actual submitter
- The attack leaves no cryptographic evidence
- Victim parties have no way to prove they didn't submit the bad signature

**Estimated Probability:**
High - any malicious signer can trivially execute this attack with 100% success rate for framing victims. The only limiting factor is whether the coordinator actually bans accused parties (implementation-dependent).

### Recommendation

**Proposed Code Changes:**

1. **Add validation in coordinator** (`src/state_machine/coordinator/frost.rs`):
   ```rust
   // After line 636, add:
   for sig_share in &sig_share_response.signature_shares {
       if !sig_share.key_ids.contains(&sig_share.id) {
           warn!(
               signer_id = %sig_share_response.signer_id,
               sig_share_id = %sig_share.id,
               "SignatureShare id not in key_ids"
           );
           return Ok(());
       }
   }
   ```

2. **Alternative: Bind signature to signer identity**:
   Instead of relying on the `id` field for blame assignment, use the authenticated signer identity from the message signature or store the mapping of which signer submitted which signature shares.

3. **Alternative: Remove redundant id field**:
   Since `sig_share.key_ids` already contains the relevant information, consider removing the `id` field entirely from `SignatureShare` and using `key_ids` for all purposes, or making it derivative rather than user-controlled.

**Testing Recommendations:**
- Add a test case where a malicious signer submits signature shares with fraudulent `id` values
- Verify that the coordinator rejects such shares
- Test that `check_signature_shares` correctly identifies the actual malicious party

**Deployment Considerations:**
- This is a protocol-level fix that requires updating both coordinator and signer implementations
- Backward compatibility: Existing signature shares with valid `id` fields will continue to work
- Invalid shares will be rejected early (during coordinator validation) rather than later (during aggregation)

### Proof of Concept

**Exploitation Algorithm:**

```
Setup:
- Malicious Signer A controls key IDs [1, 2, 3]
- Honest Signer B controls key IDs [4, 5, 6]  
- Signing threshold requires 5 keys

Attack Steps:
1. Coordinator initiates signing round for message M
2. All signers submit nonces
3. Coordinator requests signature shares

4. Malicious Signer A creates signature shares:
   - Share 1: {id: 1, z_i: <valid sig for key 1>, key_ids: [1, 2, 3]}
   - Share 2: {id: 2, z_i: <valid sig for key 2>, key_ids: [1, 2, 3]}
   - Share 3: {id: 4, z_i: <INVALID sig>, key_ids: [1, 2, 3]}  // SPOOFED!
   
5. Coordinator validates:
   - Union of key_ids from all shares = {1, 2, 3} âœ“ Matches expected
   - Accepts all signature shares from Signer A
   
6. Coordinator attempts aggregation:
   - Aggregation fails (due to invalid signature or deliberate sabotage)
   - Calls check_signature_shares()
   
7. In check_signature_shares():
   - For i=2 (Share 3):
     - Computes id = 4 (Signer B's key)
     - Computes public_key for key ID 4 (Signer B's key)
     - Uses nonce from position 2 (Signer A's nonce for key 3)
     - Verification: z_i * G != R + c*lambda*public_key_4
     - Adds key ID 4 to bad_party_sigs
     
8. Error returned: BadPartySigs([4])
   - Key ID 4 belongs to honest Signer B
   - Actual attacker (Signer A) is not identified
```

**Expected vs Actual Behavior:**

Expected: When Signer A submits an invalid signature, key IDs [1, 2, 3] should be reported as malicious
Actual: Key ID 4 (belonging to honest Signer B) is reported as malicious

**Reproduction Instructions:**

1. Set up a test with 2 signers (A controlling [1,2,3], B controlling [4,5,6])
2. During signing, have Signer A modify one of their signature shares to set `id: 4` 
3. Trigger a signing round that will fail (either naturally or by submitting one bad signature)
4. Observe that the `BadPartySigs` error contains [4] instead of the actual malicious key IDs
5. Verify that this can be repeated to frame multiple honest parties

### Citations

**File:** src/v1.rs (L399-407)
```rust
        for i in 0..sig_shares.len() {
            let id = compute::id(sig_shares[i].id);
            let public_key = match compute::poly(&id, &self.poly) {
                Ok(p) => p,
                Err(_) => {
                    bad_party_keys.push(sig_shares[i].id);
                    Point::zero()
                }
            };
```

**File:** src/v1.rs (L411-416)
```rust
            if z_i * G
                != r_sign * Rs[i]
                    + cx_sign * (compute::lambda(sig_shares[i].id, &signers) * c * public_key)
            {
                bad_party_sigs.push(sig_shares[i].id);
            }
```

**File:** src/state_machine/coordinator/frost.rs (L631-641)
```rust
            let mut sig_share_response_key_ids = HashSet::new();
            for sig_share in &sig_share_response.signature_shares {
                for key_id in &sig_share.key_ids {
                    sig_share_response_key_ids.insert(*key_id);
                }
            }

            if *signer_key_ids != sig_share_response_key_ids {
                warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/common.rs (L211-220)
```rust
#[derive(Clone, Deserialize, Serialize, PartialEq)]
/// A share of the party signature with related values
pub struct SignatureShare {
    /// The ID of the party
    pub id: u32,
    /// The party signature
    pub z_i: Scalar,
    /// The key IDs of the party
    pub key_ids: Vec<u32>,
}
```
