### Title
Signer Denial of Service via Repeated DKG Resets

### Summary
A malicious or compromised coordinator can force signer nodes into resource exhaustion by sending repeated `DkgBegin` messages with different `dkg_id` values. The signer lacks duplicate detection and processes each message by resetting state, generating expensive polynomial commitments, and broadcasting shares. This causes CPU exhaustion, memory churn, and network flooding, preventing legitimate DKG completion.

### Finding Description

**Exact code location:** [1](#0-0) 

The vulnerability exists in the `dkg_begin()` function which unconditionally resets signer state and regenerates polynomials for every `DkgBegin` message received, without checking if the `dkg_id` has already been processed.

**Root cause:**
Unlike the coordinator which tracks `current_dkg_id` to prevent duplicate processing: [2](#0-1) 

The signer has no such protection. Each `DkgBegin` message triggers:
1. Complete state reset via `reset()` [3](#0-2) 
2. Polynomial regeneration via `reset_polys()` [4](#0-3) 
3. Expensive polynomial commitment generation [5](#0-4) 

Each polynomial generation creates `threshold` random scalars [6](#0-5)  and computes `threshold` point multiplications for commitments [7](#0-6) .

**Why existing mitigations fail:**
The only mitigation is signature verification [8](#0-7)  which requires the coordinator's private key. However:
- If the coordinator is malicious or compromised, this provides no protection
- If `verify_packet_sigs` is disabled (configurable via saved state), any network participant can exploit this
- There is no rate limiting or duplicate `dkg_id` detection

The state machine allows transitions from `DkgPublicGather` back to `DkgPublicDistribute` [9](#0-8)  but the actual attack vector is repeated `DkgBegin` messages forcing resets from any state back through the DKG cycle.

### Impact Explanation

**Specific harm:**
- Signer nodes experience CPU exhaustion from continuous polynomial generation
- Memory churn from repeated allocation/deallocation cycles
- Network flooding from repeated `DkgPublicShares` broadcasts to all signers
- Complete inability to complete legitimate DKG rounds due to constant resets
- If multiple signers are targeted, network-wide DKG failure occurs

**Quantified impact:**
For a typical configuration with threshold=7:
- Each reset generates 7 random scalars and performs 7 point multiplications
- With 100 resets/second, this represents 700 point multiplications/second per signer
- Multiplied across all signers in the network creates significant resource drain

**Who is affected:**
All signer nodes receiving the malicious `DkgBegin` messages. Since coordinators broadcast to all signers, this impacts the entire network.

**Severity justification:**
This maps to **Low severity** under the protocol scope: "Any remotely-exploitable denial of service in a node". While it prevents DKG completion, it does not directly cause transaction confirmation failures, chain splits, or fund loss unless the DKG was required for emergency key rotation or new signer onboarding.

### Likelihood Explanation

**Required attacker capabilities:**
- Possession of coordinator's ECDSA private key (via compromise or malicious insider), OR
- Access to a misconfigured signer with `verify_packet_sigs=false`

**Attack complexity:**
Trivial once prerequisites are met. Attacker simply sends `DkgBegin` messages with incrementing `dkg_id` values (1, 2, 3, ...) at high frequency.

**Economic feasibility:**
Very low cost - only requires network bandwidth to send small messages. No computational expense for attacker.

**Detection risk:**
Moderate - unusual patterns of DKG resets and repeated `DkgPublicShares` messages would be visible in logs, but may be attributed to network issues initially.

**Estimated probability:**
If coordinator is compromised: 100% success rate
If relying on misconfiguration: Low probability unless defaults are changed

### Recommendation

**Proposed code changes:**

Add duplicate `dkg_id` tracking to the signer, similar to the coordinator:

```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Add duplicate detection
    if self.dkg_id == dkg_begin.dkg_id && self.state != State::Idle {
        info!("Ignoring duplicate DkgBegin for dkg_id {}", dkg_begin.dkg_id);
        return Ok(vec![]);
    }
    
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Alternative mitigations:**
1. Implement rate limiting on `DkgBegin` message processing (e.g., max 1 per 30 seconds)
2. Require state to be `Idle` before accepting new `DkgBegin`
3. Add coordinator accountability logging for forensic analysis

**Testing recommendations:**
- Unit test: Send multiple `DkgBegin` messages with same `dkg_id`, verify only first is processed
- Integration test: Measure resource usage under rapid `DkgBegin` flooding
- Security test: Verify fix doesn't break legitimate DKG restart scenarios

**Deployment considerations:**
This is a protocol-level change requiring coordinated upgrade of all signers to maintain compatibility.

### Proof of Concept

**Exploitation algorithm:**
```
1. Attacker obtains coordinator private key (via compromise)
2. For dkg_id = 1 to infinity:
   a. Construct DkgBegin{dkg_id: dkg_id}
   b. Sign with coordinator private key
   c. Broadcast to all signers
   d. Wait minimal delay (10ms)
3. Monitor signer CPU usage climbing to 100%
4. Observe DKG never completes due to constant resets
```

**Expected behavior:**
Signer should ignore duplicate `dkg_id` or enforce rate limits

**Actual behavior:**
Signer processes every `DkgBegin` message, causing:
- `reset()` called repeatedly [10](#0-9) 
- Polynomial regeneration each time [11](#0-10) 
- Network spam from repeated shares [12](#0-11) 

**Reproduction instructions:**
1. Set up WSTS test network with coordinator and 3 signers
2. From coordinator, send `DkgBegin{dkg_id: 1}`, observe normal processing
3. Immediately send `DkgBegin{dkg_id: 2}`, observe state reset
4. Repeat with `dkg_id: 3, 4, 5...` at 10Hz frequency
5. Monitor signer CPU and observe sustained high usage
6. Attempt to complete legitimate DKG and observe failure

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L463-469)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/signer/mod.rs (L862-864)
```rust
        let comms = self
            .signer
            .get_poly_commitments(&self.dkg_id.to_be_bytes(), rng);
```

**File:** src/state_machine/signer/mod.rs (L885-886)
```rust
        let public_share = Message::DkgPublicShares(public_share);
        msgs.push(public_share);
```

**File:** src/state_machine/signer/mod.rs (L1161-1165)
```rust
            State::DkgPublicDistribute => {
                prev_state == &State::Idle
                    || prev_state == &State::DkgPublicGather
                    || prev_state == &State::DkgPrivateDistribute
            }
```

**File:** src/state_machine/coordinator/frost.rs (L76-78)
```rust
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
```

**File:** src/v2.rs (L93-97)
```rust
            Some(PolyCommitment {
                id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
                poly: (0..poly.data().len())
                    .map(|i| &poly.data()[i] * G)
                    .collect(),
```

**File:** src/v2.rs (L583-585)
```rust
    fn reset_polys<RNG: RngCore + CryptoRng>(&mut self, rng: &mut RNG) {
        self.f = Some(VSS::random_poly(self.threshold - 1, rng));
    }
```

**File:** src/vss.rs (L11-13)
```rust
    pub fn random_poly<RNG: RngCore + CryptoRng>(n: u32, rng: &mut RNG) -> Polynomial<Scalar> {
        let params: Vec<Scalar> = (0..n + 1).map(|_| Scalar::random(rng)).collect();
        Polynomial::new(params)
```
