### Title
Missing Cross-Signer Key ID Uniqueness Validation Causes Incorrect Lagrange Coefficient Calculations

### Summary
The `PublicKeys::validate()` method fails to enforce uniqueness of key_ids across different signers, allowing multiple signers to be assigned the same key_id. During signature aggregation, key_ids are collected into a Vec using `flat_map`, causing duplicates to appear in the Lagrange coefficient calculation. This results in mathematically incorrect coefficients and invalid group signatures, preventing the signing protocol from producing valid outputs.

### Finding Description

The vulnerability exists in the `PublicKeys` validation logic and its usage during signature aggregation:

**Root Cause - Incomplete Validation:**

The `PublicKeys::validate()` method only validates that signer_ids and key_ids are within valid ranges, but does not check for duplicate key_ids across different signers: [1](#0-0) 

This validation allows configurations where multiple signers control the same key_id, e.g., Signer 0 controls [1,2] and Signer 1 controls [2,3].

**Exploitation Path - Key ID Collection:**

During signing, the coordinator collects all key_ids from nonce responses using `flat_map`, which creates a Vec that can contain duplicates if multiple signers claim the same key_id: [2](#0-1) 

**Incorrect Lagrange Coefficients:**

This duplicated Vec is passed to each signer during signature share computation and to the `lambda` function for calculating Lagrange coefficients: [3](#0-2) 

The `lambda` function iterates over all elements in the key_ids slice, multiplying the coefficient by j/(j-i) for each j≠i: [4](#0-3) 

If key_ids contains duplicates (e.g., [1,2,2,3]), the function will process the duplicate value multiple times, producing an incorrect Lagrange coefficient. For example, computing λ₁ over [1,2,2,3] yields: λ₁ = (2/(2-1)) × (2/(2-1)) × (3/(3-1)) = 6, when the correct value over [1,2,3] should be: λ₁ = (2/(2-1)) × (3/(3-1)) = 3.

**Why Existing Mitigations Fail:**

The `Signer::new()` constructor calls `public_keys.validate()`, but this validation is incomplete: [5](#0-4) 

The `Coordinator::new()` constructor accepts a Config without performing any validation on the PublicKeys: [6](#0-5) 

### Impact Explanation

**Specific Harm:**

When PublicKeys is misconfigured with duplicate key_ids across signers, the signing protocol produces invalid signatures that fail verification. This completely breaks the threshold signing capability.

**Quantified Impact:**

In a production deployment using WSTS for threshold signing (such as Stacks blockchain's block signing):
- The signing group cannot produce valid signatures for blocks or transactions
- New blocks/transactions cannot be confirmed
- The network halts until the configuration is corrected and signers are restarted

**Affected Parties:**

- All users of the network depending on WSTS threshold signatures
- Block producers unable to sign valid blocks
- Transaction submitters whose transactions cannot be confirmed

**Severity Justification:**

This maps to **Critical** scope: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks." A misconfigured PublicKeys with duplicate key_ids would prevent the production of any valid signatures, blocking all transaction confirmations until the issue is detected and corrected.

### Likelihood Explanation

**Required Capabilities:**

An attacker needs the ability to influence the PublicKeys configuration during system initialization. This could occur through:
1. Compromising the configuration generation process
2. Social engineering of operators during setup
3. Exploiting a separate vulnerability in configuration management

Alternatively, an honest operator could accidentally misconfigure the system.

**Attack Complexity:**

Low - The attack requires only providing a malformed PublicKeys configuration. No cryptographic attacks or complex timing manipulations are needed.

**Economic Feasibility:**

High - If an attacker can influence configuration (e.g., as a compromised operator or through supply chain attack), the cost is minimal. The DoS impact would halt the network.

**Detection Risk:**

Medium - The misconfiguration would be detected after the first failed signature attempt, but by then the damage (network halt) would already occur. The system provides no early warning during configuration validation.

**Probability:**

Medium to High - While this requires configuration access, the complete lack of validation makes accidental misconfiguration likely in complex deployments where multiple administrators coordinate key assignments.

### Recommendation

**Primary Fix - Add Cross-Signer Uniqueness Validation:**

Modify `PublicKeys::validate()` to check that no key_id appears in multiple signers' HashSets:

```rust
pub fn validate(&self, num_signers: u32, num_keys: u32) -> Result<(), SignerError> {
    // ... existing validation ...
    
    // Check for duplicate key_ids across signers
    let mut all_key_ids = HashSet::new();
    for (signer_id, key_ids) in &self.signer_key_ids {
        for key_id in key_ids {
            if !all_key_ids.insert(*key_id) {
                return Err(SignerError::Config(ConfigError::DuplicateKeyIdAcrossSigners(*key_id)));
            }
        }
    }
    
    Ok(())
}
```

**Add Validation to Coordinator:**

Ensure `Coordinator::new()` validates the PublicKeys in its Config parameter:

```rust
fn new(config: Config) -> Result<Self, Error> {
    config.public_keys.validate(config.num_signers, config.num_keys)?;
    // ... rest of constructor ...
}
```

**Testing Recommendations:**

1. Add unit tests verifying that duplicate key_ids across signers are rejected during validation
2. Add integration tests demonstrating that signatures with properly validated (unique) key_ids succeed
3. Add regression tests showing that the old behavior (accepting duplicates) is now prevented

**Deployment Considerations:**

This is a breaking change that will reject previously accepted configurations. During deployment:
1. Audit all existing PublicKeys configurations for duplicate key_ids
2. Provide a migration tool to detect and report invalid configurations
3. Document the new validation requirement clearly
4. Consider adding a grace period with warnings before enforcement

### Proof of Concept

**Exploitation Steps:**

1. Create a malicious PublicKeys configuration with duplicate key_ids:
```rust
let mut public_keys = PublicKeys::default();

// Signer 0 controls key_ids [1, 2]
let mut keys_0 = HashSet::new();
keys_0.insert(1);
keys_0.insert(2);
public_keys.signer_key_ids.insert(0, keys_0);

// Signer 1 controls key_ids [2, 3] - note duplicate key_id 2
let mut keys_1 = HashSet::new();
keys_1.insert(2);  // DUPLICATE
keys_1.insert(3);
public_keys.signer_key_ids.insert(1, keys_1);

// Populate public keys for signers and key_ids
// ... 

// This configuration passes validation but is invalid
assert!(public_keys.validate(2, 3).is_ok());  // Current code: passes
```

2. Initialize Coordinator with this configuration:
```rust
let config = Config {
    num_signers: 2,
    num_keys: 3,
    threshold: 2,
    public_keys,
    // ... other fields
};

let mut coordinator = Coordinator::new(config);
```

3. Attempt to sign a message - key_ids will be collected as [1,2,2,3]:
```rust
// During gather_sig_shares in frost.rs line 675-678:
// key_ids = [1, 2, 2, 3]  <- duplicate 2 from two signers
```

4. Lambda coefficients will be computed incorrectly:
```rust
// lambda(1, [1,2,2,3]) = 1 * (2/1) * (2/1) * (3/2) = 6
// Correct: lambda(1, [1,2,3]) = 1 * (2/1) * (3/2) = 3
```

5. The resulting aggregate signature will fail verification:
```rust
assert!(signature.verify(&group_key, msg).is_err());  // Verification fails
```

**Expected Behavior:**

The `PublicKeys::validate()` method should reject the configuration at step 1, preventing the coordinator from being created with an invalid configuration.

**Actual Behavior:**

The configuration is accepted, and signature generation produces invalid signatures that fail verification, causing the signing protocol to fail.

### Citations

**File:** src/state_machine/mod.rs (L106-136)
```rust
    pub fn validate(&self, num_signers: u32, num_keys: u32) -> Result<(), SignerError> {
        for (signer_id, _key) in &self.signers {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }
        }

        for (key_id, _key) in &self.key_ids {
            if !validate_key_id(*key_id, num_keys) {
                return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
            }
        }

        for (signer_id, key_ids) in &self.signer_key_ids {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }

            for key_id in key_ids {
                if !validate_key_id(*key_id, num_keys) {
                    return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
                }
            }
        }

        Ok(())
    }
```

**File:** src/state_machine/coordinator/frost.rs (L675-678)
```rust
            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();
```

**File:** src/state_machine/coordinator/frost.rs (L803-806)
```rust
    fn new(config: Config) -> Self {
        Self {
            aggregator: Aggregator::new(config.num_keys, config.threshold),
            config,
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/signer/mod.rs (L314-314)
```rust
        public_keys.validate(total_signers, total_keys)?;
```
