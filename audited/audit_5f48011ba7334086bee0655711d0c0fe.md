### Title
Man-in-the-Middle Attack on DKG Key Exchange Allows Framing Honest Signers as Malicious

### Summary
The `kex_public_key` field in `DkgPublicShares` messages is not included in the signed hash, allowing network attackers to replace it with attacker-controlled public keys. This causes victims to fail decryption of legitimate private shares, generate false accusations against honest signers, and ultimately causes DKG to fail. The attack allows remotely-exploitable denial of service that prevents threshold key generation.

### Finding Description

**Exact Location:**
- Vulnerable signing implementation: [1](#0-0) 
- Decryption key storage: [2](#0-1) 
- Malicious signer determination: [3](#0-2) 

**Root Cause:**
The `DkgPublicShares::hash()` implementation excludes the `kex_public_key` field from the signed message digest. [1](#0-0)  The hash only includes `dkg_id`, `signer_id`, and polynomial commitments, but not the ephemeral public key used for Diffie-Hellman key exchange.

When a signer processes incoming `DkgPublicShares`, it stores the `kex_public_key` without validating that it was part of the authenticated message. [4](#0-3)  Later, when computing the shared secret for decryption, it retrieves this stored (potentially manipulated) key. [5](#0-4) 

**Why Existing Mitigations Fail:**
Message signature verification is implemented and enforced by default. [6](#0-5)  However, the signature only covers the message fields included in the hash function. Since `kex_public_key` is excluded from the hash, an attacker can modify it post-signature without invalidating the signature. The signature verification in `Signable::verify()` calls `self.hash()` which omits the `kex_public_key`. [7](#0-6) 

### Impact Explanation

**Specific Harm:**
An attacker with man-in-the-middle network access can prevent DKG from completing, causing the entire threshold signature scheme to fail initialization. The coordinator marks honest signers as malicious and returns `Error::DkgFailure`, halting the DKG process. [8](#0-7) 

**Attack Flow:**
1. Attacker intercepts honest Signer A's `DkgPublicShares` message containing `kex_public_key = A_pub`
2. Attacker replaces `kex_public_key` with `Attacker_pub` (signature remains valid)
3. Victim Signer B and Coordinator store `Attacker_pub` as A's key exchange public key
4. Signer A encrypts private shares using legitimate DH shared secret (`A_priv * B_pub`)
5. Signer B attempts decryption using manipulated shared secret (`B_priv * Attacker_pub`) and fails [9](#0-8) 
6. Signer B generates `BadPrivateShare` with tuple proof using manipulated key [10](#0-9) 
7. Coordinator verifies the tuple proof against the manipulated key (passes) and attempts decryption (fails) [11](#0-10) 
8. Coordinator incorrectly marks honest Signer A as malicious [12](#0-11) 

**Severity Justification:**
This maps to **Medium severity** under "Any transient consensus failures" if DKG is required for consensus operations. At minimum, it is **Low severity** as "Any remotely-exploitable denial of service in a node." The attack prevents new threshold keys from being generated, which could block transaction signing, validator set changes, or other threshold-dependent operations.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Network position to intercept and modify packets between signers (man-in-the-middle)
- Ability to generate valid secp256k1 key pairs (no secret knowledge required)
- No need to break signatures, decrypt messages, or compromise any participant's keys

**Attack Complexity:**
Low. The attacker only needs to:
1. Intercept one `DkgPublicShares` message
2. Deserialize the message structure
3. Replace the `kex_public_key` field with an attacker-generated public key (any valid curve point)
4. Forward the modified message

**Economic Feasibility:**
Highly feasible. Standard man-in-the-middle techniques (ARP spoofing, BGP hijacking, malicious routers) can intercept P2P traffic. The computational cost is negligible (one key pair generation).

**Detection Risk:**
Low. The attack is transparent to both sender and receiver since all signature verifications pass. Only cryptographic analysis of the key exchange or out-of-band key verification would detect the manipulation.

**Probability of Success:**
Near 100% given network position. The attack has no probabilistic elements - if the attacker can intercept and modify the message, the attack succeeds deterministically.

### Recommendation

**Primary Fix:**
Include `kex_public_key` in the `DkgPublicShares::hash()` implementation:

```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // ADD THIS LINE:
        hasher.update(self.kex_public_key.compress().as_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**Alternative Mitigation:**
Implement explicit binding between the signer's identity (long-term ECDSA key) and the ephemeral `kex_public_key` using a signature or zero-knowledge proof. This ensures the `kex_public_key` is authentically from the claimed signer.

**Testing Recommendations:**
1. Add test case where attacker modifies `kex_public_key` - should fail signature verification after fix
2. Verify backward compatibility if deployed systems exist
3. Test that honest DKG still succeeds after fix
4. Fuzz test message serialization/deserialization with manipulated fields

**Deployment Considerations:**
This is a breaking protocol change requiring coordinated upgrade of all participants. Version negotiation or protocol versioning may be needed.

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:** Attacker generates keypair `(Attacker_priv, Attacker_pub)` using standard secp256k1 key generation

2. **Interception:** Attacker intercepts `DkgPublicShares` packet from honest Signer A (signer_id = 1) to Signer B

3. **Manipulation:**
   ```
   Original message: {dkg_id: X, signer_id: 1, comms: [...], kex_public_key: A_pub}
   Modified message: {dkg_id: X, signer_id: 1, comms: [...], kex_public_key: Attacker_pub}
   Signature: unchanged (still valid because kex_public_key not in hash)
   ```

4. **Expected Behavior (Honest Case):**
   - B computes `shared_secret = B_priv * A_pub`
   - B successfully decrypts A's private shares
   - DKG succeeds

5. **Actual Behavior (Attack Case):**
   - B stores `Attacker_pub` as A's key exchange key
   - B computes `shared_secret = B_priv * Attacker_pub`
   - B fails to decrypt A's shares (encrypted with `A_priv * B_pub`)
   - B sends `DkgEnd` with `BadPrivateShares` accusing A
   - Coordinator verifies tuple proof using `Attacker_pub` (proof valid!)
   - Coordinator attempts decryption using `Attacker_pub` (fails!)
   - Coordinator marks A as malicious
   - DKG fails with `Error::DkgFailure`

**Reproduction Instructions:**
1. Set up three participants: Coordinator, Signer A, Signer B
2. Start DKG round
3. Intercept `DkgPublicShares` from A before B receives it
4. Replace `kex_public_key` field with attacker-controlled public key
5. Forward modified packet to B and Coordinator
6. Observe: signature verification passes, decryption fails, A marked malicious, DKG fails

### Citations

**File:** src/net.rs (L33-45)
```rust
    fn verify(&self, signature: &[u8], public_key: &ecdsa::PublicKey) -> bool {
        let mut hasher = Sha256::new();

        self.hash(&mut hasher);

        let hash = hasher.finalize();
        let sig = match ecdsa::Signature::try_from(signature) {
            Ok(sig) => sig,
            Err(_) => return false,
        };

        sig.verify(hash.as_slice(), public_key)
    }
```

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/state_machine/signer/mod.rs (L1076-1096)
```rust
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
```

**File:** src/state_machine/signer/mod.rs (L1100-1101)
```rust
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
```

**File:** src/state_machine/signer/mod.rs (L1131-1147)
```rust
    #[allow(non_snake_case)]
    fn make_bad_private_share<R: RngCore + CryptoRng>(
        &self,
        signer_id: u32,
        rng: &mut R,
    ) -> Result<BadPrivateShare, Error> {
        let a = self.kex_private_key;
        let A = a * G;
        let B = self.get_kex_public_key(signer_id)?;
        let K = a * B;
        let tuple_proof = TupleProof::new(&a, &A, &B, &K, rng);

        Ok(BadPrivateShare {
            shared_key: K,
            tuple_proof,
        })
    }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L775-789)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }

            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
            }
```
