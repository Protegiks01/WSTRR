# Audit Report

## Title
Schnorr ID Proof Bypassed by Identity Point Allows DKG Threshold Reduction

## Summary
The `ID::verify()` function does not validate that the public key point `A` is not the identity point (point at infinity). An attacker can exploit this by creating a trivial proof with identity point values that always passes verification, allowing malicious DKG participants to be counted as valid contributors without actually contributing to the group key. This effectively reduces the threshold security from T parties to (T-K) parties where K is the number of malicious participants exploiting this vulnerability.

## Finding Description

The vulnerability exists in the Schnorr identity proof verification used during Distributed Key Generation (DKG). The core issue is in the `ID::verify()` function which performs proof verification without validating that the public key point is not the identity element. [1](#0-0) 

This verification equation checks `kca * G == kG + c * A` where `A` is the public key point being proven. When an attacker sets `A = Point::identity()`, `kG = Point::identity()`, and `kca = Scalar::zero()`, the equation becomes:

- Left side: `Scalar::zero() * G = Point::identity()`
- Right side: `Point::identity() + c * Point::identity() = Point::identity()`
- Result: `Point::identity() == Point::identity()` (always true)

This bypasses the proof-of-knowledge requirement entirely.

During DKG, polynomial commitments use this ID proof, passing `poly[0]` (the polynomial's constant term representing the party's public key contribution) as the `A` parameter: [2](#0-1) 

The validation function only checks the Schnorr proof validity and polynomial length, but does not verify that `poly[0]` is not the identity point: [3](#0-2) 

Both v1 and v2 implementations then add the validated `poly[0]` to compute the group key: [4](#0-3) [5](#0-4) 

Since adding the identity point is a no-op in elliptic curve arithmetic, the attacker contributes nothing to the group key while being counted as a valid participant.

While the codebase validates that `PublicNonce` points are not identity points to prevent attacks: [6](#0-5) 

No similar validation exists for `poly[0]` in polynomial commitments. The state machine's DKG validation uses the same vulnerable `check_public_shares()` function: [7](#0-6) 

## Impact Explanation

This vulnerability breaks the fundamental threshold security guarantee of WSTS. If the configured threshold is T out of N parties, and K malicious parties exploit this vulnerability, the actual security threshold is reduced to only (T-K) honest parties, while the system still believes T parties are required for signatures.

In the worst case where K â‰¥ T malicious parties exploit this, fewer than T honest parties control the group key, completely breaking the threshold assumption. This enables signature forgery with fewer honest parties than the protocol promises.

For Bitcoin/Stacks applications using WSTS for multisig custody, this allows theft of funds by reducing the actual signing threshold below the configured security level. An attacker who can participate in DKG and subsequently compromise (T-K) honest parties can forge signatures and steal funds, when they should need to compromise T honest parties.

This maps to **Critical** severity because it enables:
- "Any confirmation of an invalid transaction" - attackers can forge signatures that should require T parties with only (T-K) honest parties
- "Any causing the direct loss of funds" - in Bitcoin/Stacks multisig applications, this enables theft by breaking the threshold assumption

## Likelihood Explanation

The attack has very high likelihood of success because:

**Required Attacker Capabilities:**
- Must be an authorized DKG participant (have a valid signer_id)
- Can send network messages during the DKG phase
- No cryptographic breaks or special computational resources required

**Attack Complexity:**
Low. The attacker simply constructs a malicious `PolyCommitment` message with:
1. `id.kG = Point::identity()`
2. `id.kca = Scalar::zero()`
3. `id.id = Scalar::from(attacker_signer_id)`
4. `poly = vec![Point::identity(), ...]` (with remaining coefficients set to any valid points)

The p256k1 crate used for elliptic curve operations supports serialization of the identity point, so this message can be constructed and transmitted through normal protocol channels.

**Economic Feasibility:**
Extremely feasible - no additional costs beyond normal DKG participation. The attack is deterministic and succeeds 100% of the time once the malicious commitment is accepted.

**Detection Risk:**
Low. The malicious commitment appears valid to all verification checks. Detection would require manually inspecting polynomial commitments for identity points, which is not currently implemented.

**Estimated Probability:**
Near 100% success rate if the attacker is a DKG participant. The only requirement is being included in the DKG participant set.

## Recommendation

Add identity point validation to the `ID::verify()` function or the `check_public_shares()` function. The fix should mirror the existing validation pattern used for `PublicNonce`:

```rust
// In src/schnorr.rs, modify ID::verify():
pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
    // Reject identity point for A
    if A == &Point::identity() {
        return false;
    }
    let c = Self::challenge(&self.id, &self.kG, A, ctx);
    &self.kca * &G == &self.kG + c * A
}
```

Alternatively, add the check in `check_public_shares()`:

```rust
// In src/common.rs:
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) 
        && poly_comm.poly.len() == threshold
        && poly_comm.poly[0] != Point::identity()
}
```

Additionally, validate all polynomial coefficients are not identity points to prevent similar attacks on other coefficients:

```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) 
        && poly_comm.poly.len() == threshold
        && poly_comm.poly.iter().all(|p| p != &Point::identity())
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::curve::{point::Point, scalar::Scalar};
    use crate::schnorr::ID;
    use crate::common::PolyCommitment;
    
    #[test]
    fn identity_point_bypass_schnorr_proof() {
        // Construct malicious ID proof with identity point
        let malicious_id = ID {
            id: Scalar::from(1),
            kG: Point::identity(),
            kca: Scalar::zero(),
        };
        
        // The proof should verify against the identity point
        let ctx = 0u64.to_be_bytes();
        assert!(malicious_id.verify(&Point::identity(), &ctx));
        
        // Construct malicious polynomial commitment
        let threshold = 3;
        let malicious_poly_comm = PolyCommitment {
            id: malicious_id,
            poly: vec![
                Point::identity(),  // poly[0] is identity - contributes nothing to group key
                Point::from(Scalar::from(2)),
                Point::from(Scalar::from(3)),
            ],
        };
        
        // This malicious commitment passes all validation checks
        assert!(check_public_shares(&malicious_poly_comm, threshold, &ctx));
        
        // When added to group key, it contributes nothing
        let mut group_key = Point::from(Scalar::from(5));
        let original_key = group_key.clone();
        group_key += malicious_poly_comm.poly[0];
        
        // Group key unchanged - attacker contributed nothing but passed validation
        assert_eq!(group_key, original_key);
    }
}
```

This test demonstrates that a malicious polynomial commitment with `poly[0] = Point::identity()` and a trivial Schnorr proof passes all validation checks, but contributes nothing to the group key, effectively reducing the threshold security.

### Citations

**File:** src/schnorr.rs (L62-65)
```rust
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```

**File:** src/common.rs (L37-39)
```rust
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/v1.rs (L162-166)
```rust
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
```

**File:** src/v2.rs (L136-140)
```rust
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
```

**File:** src/state_machine/signer/mod.rs (L557-562)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```
