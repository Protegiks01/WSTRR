### Title
Incomplete Nonce Clearing in reset() Enables Private Key Extraction via Nonce Reuse

### Summary
The `reset()` function at line 417 fails to clear private nonces stored in underlying Party objects, only clearing the state machine's public nonce cache. This allows nonces to persist across DKG rounds, enabling nonce reuse if a SignatureShareRequest is processed without a fresh NonceRequest. Nonce reuse with the same private key allows mathematical extraction of the private key, resulting in total loss of key control and theft of all protected funds.

### Finding Description

**Exact Code Location:**
- File: `src/state_machine/signer/mod.rs`
- Function: `reset()` at lines 417-432
- Related: Party nonce storage in `src/v2.rs` line 37 and `src/v1.rs` line 32
- Related: `reset_polys()` implementations in `src/v2.rs` lines 583-585 and `src/v1.rs` lines 126-128 [1](#0-0) 

**Root Cause:**

The `reset()` function only clears `self.public_nonces` at the state machine level [2](#0-1)  but does not clear the private nonces stored in each Party's `nonce` field. The function calls `self.signer.reset_polys(rng)` [3](#0-2)  which only regenerates polynomials for DKG, not nonces.

In v2::Signer, `reset_polys()` only resets the polynomial: [4](#0-3) 

The private nonce components remain stored in `party.nonce` (comprising `d` and `e` scalars) [5](#0-4)  and are used directly during signing [6](#0-5) .

**Why Existing Mitigations Fail:**

1. The state machine tracks `sign_id` and `sign_iter_id` fields [7](#0-6)  but does not enforce that a NonceRequest must be processed before accepting a SignatureShareRequest.

2. The `sign_share_request()` function performs validation checks [8](#0-7)  but does not verify that nonces were freshly generated for the current signing round.

3. The normal protocol expects NonceRequest before SignatureShareRequest [9](#0-8) , but this is not cryptographically enforced.

### Impact Explanation

**Specific Harm:**

When nonces are reused with the same private key to sign two different messages, the Schnorr/FROST signature scheme is catastrophically broken. An attacker can extract the private key using:
- z₁ = r + c₁·x (signature share for message M₁)
- z₂ = r + c₂·x (signature share for message M₂, same nonce r)
- x = (z₁ - z₂) / (c₁ - c₂) → **private key extracted**

**Quantified Impact:**

- **Complete loss of key control**: Once the private key is extracted, the attacker has full control over the signer's share
- **Threshold compromise**: If enough signers' keys are compromised through this vulnerability, the threshold is broken
- **Unlimited fund theft**: All Bitcoin or other assets protected by the threshold signature can be stolen
- **Invalid transaction confirmation**: The attacker can sign arbitrary transactions with the compromised key shares

**Affected Parties:**

- All signers who participate in DKG rounds during active signing rounds
- All users whose funds are protected by the compromised threshold signature
- The entire Stacks blockchain if the threshold signature protects consensus-critical operations

**Severity Justification:**

This maps directly to the **Critical** severity scope:
- "Any causing the direct loss of funds other than through any form of freezing"
- "Any confirmation of an invalid transaction, such as with an incorrect nonce"

The vulnerability enables mathematical extraction of private keys, which represents the worst-case cryptographic failure for a signature scheme.

### Likelihood Explanation

**Required Attacker Capabilities:**

1. **Coordinator Control or Race Condition**: Attacker must either control the coordinator or exploit a race condition where:
   - A NonceRequest is sent (signer generates nonces N₁)
   - Before SignatureShareRequest arrives, a DkgBegin message triggers reset()
   - Coordinator sends SignatureShareRequest without a new NonceRequest

2. **DKG Failure/Abort**: After reset(), the DKG must fail or abort before `compute_secrets()` is called, preserving old private keys [10](#0-9) 

**Attack Complexity:**

- **Low to Medium**: The attack requires either:
  - Malicious coordinator (if coordinator is compromised)
  - Timing manipulation (if attacker can delay messages or trigger DKG at specific times)
  - Protocol implementation bug (if coordinator software has race conditions)

**Economic Feasibility:**

- **High ROI**: The cost is minimal (message manipulation) vs. potential gain (all funds protected by threshold)
- **No cryptographic breaks required**: Uses only protocol-level message manipulation

**Detection Risk:**

- **Low**: The nonce reuse occurs internally; only two signature shares are needed to extract the key
- **Post-exploitation**: Once the key is extracted, the theft appears as a valid transaction from the signer

**Probability of Success:**

- **High** if coordinator is malicious or buggy
- **Medium** in normal operation due to race conditions during DKG initiation
- **Increases over time** as DKG rounds occur during active signing operations

### Recommendation

**Primary Fix - Clear Nonces in reset():**

Add explicit nonce clearing to the `reset()` function. After line 424, add:

```rust
// Clear all private nonces from underlying parties
for (_, party_state) in self.signer.save().parties.iter_mut() {
    party_state.nonce = Nonce::zero();
}
```

Or better, add a `reset_nonces()` method to the Signer trait and call it:

```rust
pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
    self.dkg_id = dkg_id;
    self.commitments.clear();
    self.decrypted_shares.clear();
    self.decryption_keys.clear();
    self.invalid_private_shares.clear();
    self.public_nonces.clear();
    self.signer.reset_polys(rng);
    self.signer.reset_nonces();  // ADD THIS
    self.dkg_public_shares.clear();
    self.dkg_private_shares.clear();
    self.dkg_private_begin_msg = None;
    self.dkg_end_begin_msg = None;
    self.kex_private_key = Scalar::random(rng);
    self.kex_public_keys.clear();
    self.state = State::Idle;
}
```

**Secondary Fix - Enforce Nonce Freshness:**

Track the last `sign_id` and `sign_iter_id` for which nonces were generated, and reject SignatureShareRequests that don't match:

```rust
fn sign_share_request<R: RngCore + CryptoRng>(
    &mut self,
    sign_request: &SignatureShareRequest,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // ADD: Check nonce freshness
    if self.last_nonce_sign_id != sign_request.sign_id 
        || self.last_nonce_sign_iter_id != sign_request.sign_iter_id {
        return Err(Error::StaleNonces);
    }
    // ... rest of function
}
```

**Testing Recommendations:**

1. Add unit test that calls reset() mid-signing-round and verifies nonces are cleared
2. Add integration test simulating DKG interruption during signing
3. Verify that SignatureShareRequest after reset() without NonceRequest generates fresh nonces or errors

**Deployment Considerations:**

- **Critical Priority**: Deploy immediately as this is a key-extraction vulnerability
- **Backward Compatibility**: The fix is backward compatible as it only affects internal state
- **Coordination Required**: All signers must upgrade to prevent mixed-version vulnerabilities

### Proof of Concept

**Exploitation Algorithm:**

```
Phase 1: Setup
1. Wait for DKG Round 1 to complete
   → Signer has private keys K₁
   
Phase 2: Generate Stale Nonces
2. Coordinator sends NonceRequest(sign_id=1, msg=M₁)
   → Signer generates nonces N₁ = (d₁, e₁)
   → Nonces stored in party.nonce field
   → Signer returns NonceResponse with public nonces PN₁

Phase 3: Trigger Reset (Race Condition)
3. Attacker triggers DkgBegin(dkg_id=2) before SignatureShareRequest
   → Signer.dkg_begin() calls reset(dkg_id=2, rng)
   → reset() clears self.public_nonces (line 423)
   → reset() calls reset_polys() (line 424) - only clears polynomials
   → CRITICAL: party.nonce still contains N₁
   
Phase 4: Abort DKG
4. DKG Round 2 fails before compute_secrets()
   → Private keys K₁ remain in party.private_keys
   → Nonces N₁ still in party.nonce
   → State returns to Idle

Phase 5: Nonce Reuse
5. Coordinator sends SignatureShareRequest(sign_id=2, msg=M₂)
   WITHOUT sending NonceRequest first
   → Signer.sign_share_request() at line 757
   → No state check prevents this
   → Line 810-817: calls sign_taproot/sign_schnorr/sign
   → v2.rs line 257: computes r = d₁ + e₁·b (using stale N₁)
   → Returns signature share: z₂ = r + c₂·x (using N₁ and K₁)

Phase 6: Key Extraction
6. Attacker computes from two signature shares:
   z₁ = r + c₁·x  (from original M₁ if completed, or from new M₁)
   z₂ = r + c₂·x  (from M₂ with reused nonces)
   
   Private key extraction:
   x = (z₁ - z₂) / (c₁ - c₂)
   
7. Attacker now has full control of signer's key share
   → Can sign arbitrary transactions
   → Can steal all funds if enough shares compromised
```

**Reproduction Steps:**

1. Set up a 2-of-3 threshold signature configuration
2. Complete DKG Round 1
3. Send NonceRequest for message "test1" to all signers
4. Before collecting responses, send DkgBegin to trigger reset()
5. Abort or fail the new DKG (e.g., timeout)
6. Send SignatureShareRequest for message "test2" WITHOUT NonceRequest
7. Observe that signers reuse nonces from step 3
8. Extract private key using standard Schnorr nonce reuse attack

**Expected vs Actual Behavior:**

- **Expected**: reset() clears all nonces, forcing fresh nonce generation for any subsequent signing
- **Actual**: reset() only clears public_nonces cache; private nonces persist and can be reused

### Citations

**File:** src/state_machine/signer/mod.rs (L200-203)
```rust
    /// current signing round ID
    pub sign_id: u64,
    /// current signing iteration ID
    pub sign_iter_id: u64,
```

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L772-795)
```rust
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }
```

**File:** src/v2.rs (L129-129)
```rust
        self.private_keys.clear();
```

**File:** src/v2.rs (L257-257)
```rust
        let mut r = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
```

**File:** src/v2.rs (L583-585)
```rust
    fn reset_polys<RNG: RngCore + CryptoRng>(&mut self, rng: &mut RNG) {
        self.f = Some(VSS::random_poly(self.threshold - 1, rng));
    }
```

**File:** src/common.rs (L54-59)
```rust
pub struct Nonce {
    /// The first committed value
    pub d: Scalar,
    /// The second committed value
    pub e: Scalar,
}
```
