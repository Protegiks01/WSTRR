### Title
Missing DKG Round ID Validation Enables Replay Attack and Denial of Service

### Summary
The `dkg_public_share()` function in the signer state machine accepts `DkgPublicShares` messages without validating that the message's `dkg_id` matches the signer's current `self.dkg_id`. This allows an attacker to replay legitimately-signed `DkgPublicShares` from previous DKG rounds, causing the current DKG round to fail when cryptographic verification detects the mismatch during finalization.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `dkg_public_share()` function performs several validation checks on incoming `DkgPublicShares` messages:
- Validates signer_id exists in configuration
- Validates party_id ownership
- Checks for duplicate messages from the same signer_id

However, it critically **does not validate** that `dkg_public_shares.dkg_id == self.dkg_id` before storing the shares.

**Root Cause:**

The `DkgPublicShares` struct contains a `dkg_id` field that identifies which DKG round the shares belong to: [2](#0-1) 

The coordinator properly validates this field early: [3](#0-2) 

But signers do not perform equivalent validation when receiving shares peer-to-peer.

**Why Existing Mitigations Fail:**

1. **Message Signature Authentication**: While messages are authenticated via ECDSA signatures, these only prove the message was sent by the claimed signer. The signature covers the `dkg_id` field but does not prevent replay of legitimately-signed old messages: [4](#0-3) 

2. **Duplicate Detection**: The function checks for duplicates by `signer_id` only, not by `(signer_id, dkg_id)` pair: [5](#0-4) 

3. **Late Cryptographic Verification**: Polynomial commitments are cryptographically bound to the DKG ID via Schnorr proofs, but this is only verified during `dkg_ended()`: [6](#0-5) [7](#0-6) [8](#0-7) 

By this point, the invalid shares have already been stored and the DKG round fails.

### Impact Explanation

**Specific Harm:**
An attacker can force DKG rounds to fail by replaying their own legitimately-signed `DkgPublicShares` from previous rounds. When victims process these shares during finalization, the Schnorr proof verification fails because the polynomial commitments were bound to a different `dkg_id` context. The victim marks the attacker as having "bad public shares" and reports DKG failure.

**Quantified Impact:**
- Each DKG round can be disrupted by any participant from previous rounds
- Multiple DKG rounds can be attacked sequentially using saved messages
- All signers receiving the replayed messages will experience DKG failure
- The attack persists until the replaying signer is removed from the configuration

**Who Is Affected:**
All signers participating in any DKG round are vulnerable. In the WSTS deployment context (Stacks blockchain), this could prevent threshold signing setup, blocking operations requiring the distributed key.

**Severity Justification:**
This maps to **Low** severity per the provided scope:
- "Any remotely-exploitable denial of service in a node"
- Potentially "Any network denial of service impacting more than 10 percent of miners that does not shut down the network" if multiple miners are targeted

While this causes DKG failures, it does not directly result in invalid signatures being accepted, funds loss, or chain consensus failures. It is a denial-of-service attack on the key generation process.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Must be a legitimate participant in at least one DKG round (to obtain signed `DkgPublicShares`)
2. Must have network access to send messages directly to target signers
3. No cryptographic secrets required beyond normal participation

**Attack Complexity:**
Low. The attack is straightforward:
1. Participate normally in DKG round N
2. Save the signed `DkgPublicShares` message sent during that round
3. Wait for DKG round N+M (M > 0)
4. Replay the saved message to victim signers before or instead of sending legitimate shares
5. Victims accept and store the message (no validation)
6. DKG fails during finalization

**Economic Feasibility:**
Minimal cost. The attacker only needs to:
- Be a participant once (one-time entry cost)
- Store a small message (~1-10 KB depending on polynomial degree)
- Send messages over the network (negligible bandwidth)

**Detection Risk:**
Low. The replayed messages are legitimately signed and indistinguishable from valid messages until cryptographic verification during `dkg_ended()`. By then, the damage is done.

**Estimated Probability of Success:**
Very high (~99%). The attack succeeds unless:
- All signers communicate exclusively through a coordinator that validates `dkg_id` (bypassing peer-to-peer)
- Network-level replay detection is implemented (not present in the codebase)

### Recommendation

**Proposed Code Change:**

Add `dkg_id` validation in `dkg_public_share()` immediately after the existing `signer_id` validation:

```rust
pub fn dkg_public_share(
    &mut self,
    dkg_public_shares: &DkgPublicShares,
) -> Result<Vec<Message>, Error> {
    // Existing signer_id check...
    let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
        warn!(%signer_id, "No public key configured");
        return Ok(vec![]);
    };

    // ADD THIS CHECK:
    if dkg_public_shares.dkg_id != self.dkg_id {
        warn!(
            received_dkg_id = %dkg_public_shares.dkg_id,
            current_dkg_id = %self.dkg_id,
            signer_id = %signer_id,
            "Rejecting DkgPublicShares with mismatched dkg_id"
        );
        return Ok(vec![]);
    }

    // Continue with existing validation...
}
```

**Alternative Mitigations:**
1. Implement sequence numbers or monotonic message IDs to prevent any replay
2. Add timestamp validation with acceptable clock skew bounds
3. Require coordinator-mediated message exchange only (disable peer-to-peer for DKG messages)

**Testing Recommendations:**
1. Add unit test with `DkgPublicShares` having `dkg_id != signer.dkg_id`
2. Add integration test simulating replay attack across multiple DKG rounds
3. Verify coordinator's existing validation is sufficient when peer-to-peer is disabled

**Deployment Considerations:**
- This is a simple validation check with no performance impact
- Should be deployed as a security patch to all WSTS nodes
- Consider adding similar validation to `dkg_private_shares()` function for consistency

### Proof of Concept

**Exploitation Algorithm:**

```
Setup Phase (DKG Round N=100):
1. Attacker is configured as signer_id=5 with valid credentials
2. Coordinator broadcasts DkgBegin{dkg_id: 100}
3. All signers call reset(100) and clear old state
4. Attacker generates legitimate DkgPublicShares:
   - dkg_id: 100
   - signer_id: 5
   - comms: [(party_id_5, PolyCommitment bound to dkg_id=100)]
   - kex_public_key: <ephemeral key>
5. Attacker signs message and broadcasts to all peers
6. Attacker saves complete signed Packet locally
7. DKG round 100 completes successfully

Attack Phase (DKG Round M=101):
8. Coordinator broadcasts DkgBegin{dkg_id: 101}
9. All signers call reset(101), setting self.dkg_id = 101
10. Legitimate signers send DkgPublicShares{dkg_id: 101, ...}
11. Attacker replays saved Packet from step 6 to victim signer_id=1:
    - Packet contains DkgPublicShares{dkg_id: 100, signer_id: 5, ...}
    - Signature is valid (legitimately signed in round 100)
12. Victim's dkg_public_share() processes the message:
    - Line 988-991: signer_id=5 exists in config ✓
    - Line 993-1002: party_id ownership valid ✓
    - Line 1004-1011: no duplicate for signer_id=5 yet ✓
    - MISSING: no check that dkg_id=100 != self.dkg_id=101
    - Line 1023-1024: stores invalid shares in self.dkg_public_shares[5]

Failure Phase:
13. Coordinator sends DkgEndBegin to all signers
14. Victim's dkg_ended() processes stored shares:
    - Line 557: calls check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes())
    - Passes dkg_id=101 context to verification
    - Line 319-321: poly_comm.verify(&[101...]) called
    - Line 37-38: Schnorr ID verification with ctx=[101...]
    - Line 62-64: Challenge computed with dkg_id=101 but proof was for dkg_id=100
    - Verification FAILS
    - Line 558: signer_id=5 added to bad_public_shares
15. Victim reports DkgEnd{status: Failure(BadPublicShares({5}))}
16. DKG round 101 fails for all participants
```

**Expected Behavior:**
DKG round 101 completes successfully with all participants sending fresh shares.

**Actual Behavior:**
DKG round 101 fails with victim reporting attacker has "bad public shares" despite the message being legitimately signed. The root cause is accepting shares from a different DKG round.

**Reproduction Instructions:**
1. Set up WSTS test environment with 3+ signers
2. Complete DKG round N successfully, capturing network traffic
3. Extract attacker's signed DkgPublicShares message
4. Start DKG round N+1
5. Before attacker sends legitimate shares for N+1, replay the saved message from N to victim signers
6. Observe DKG failure in victim logs showing "BadPublicShares" for attacker's signer_id

### Citations

**File:** src/state_machine/signer/mod.rs (L557-557)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```

**File:** src/net.rs (L139-150)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG public shares message from signer to all signers and coordinator
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/state_machine/coordinator/fire.rs (L479-484)
```rust
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/schnorr.rs (L47-59)
```rust
    /// Compute the schnorr challenge
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }
```
