### Title
Coordinator State Exposure Allows Invariant Bypass and Protocol Compromise

### Summary
The `coordinator` module exposes critical state fields as public in its primary structs, allowing external code to directly modify fields controlling DKG/signing rounds, state machine progression, cryptographic keys, and signed messages. This permits bypassing all state machine invariants, enabling attacks such as forced state transitions, message substitution, key substitution, and invalid round manipulation, leading to acceptance of invalid signatures or chain splits.

### Finding Description
- Affected code:
  - `src/state_machine/coordinator/frost.rs`, `src/state_machine/coordinator/fire.rs`: Both Coordinator structs expose fields such as `state`, `current_dkg_id`, `current_sign_id`, `current_sign_iter_id`, `aggregate_public_key`, `message`, and others as `pub`. [1](#0-0) [2](#0-1) 
  - The coordinator module is public (`pub mod coordinator`), as are its submodules, and the `State` enum is `pub`, making its variants accessible externally. [3](#0-2) [4](#0-3) 
  - The `SavedState` struct and its fields are all public, and the `load()` methods for both Coordinator variants perform direct field assignment with no validation. [5](#0-4) [6](#0-5) [7](#0-6) 
- **Root cause:** Any code with a mutable reference to a Coordinator can mutate critical protocol state without triggering invariant checks.

**Why existing mitigations fail:** State checks (such as DKG/signing round validation, state machine sequencing, and key commitments) depend on these fields being consistent and only mutated internally, generally through strictly checked methods. However, direct field access enables attackers to:
- Change the signing message between nonce collection and signature aggregation, causing invalid or unintended signatures to be accepted (message substitution attack).
- Overwrite the group public key with an attacker-controlled value, causing signatures to be verified or accepted under the wrong cryptographic key (key substitution attack).
- Force the coordinator to skip or replay protocol steps by directly changing the state or round IDs, bypassing order and timeout checks entirely (state or round manipulation).
- Manipulate party polynomials and commitments, leading to invalid DKG aggregation.

### Impact Explanation
- External code (e.g., malicious dependency, plugin, or privileged script) can bypass all state machine and cryptographic invariants enforced by the coordinator by direct field assignment.
- This directly enables confirmation of invalid transactions (signing the wrong message or under invalid keys), chain splits, consensus failures, or unintended key control, which map to the protocol's "Critical" and "High" scope impacts.

Examples of concrete impacts:
- Funds could be spent with signatures not authorized by intended parties (invalid transaction confirmation/forgery).
- Signing group could be split on which messages or keys are in force (chain split or divergence).
- DKG threshold, signer liveness, and malicious detection protections can be bypassed, leading to decentralized authority breakdown.

### Likelihood Explanation
- **Required attacker capabilities:** Access to a mutable reference of the Coordinator struct (e.g., a compromised library or plugin running in the same process, or developer error).
- **Attack complexity:** Trivial — requires only a field assignment.
- **Economic feasibility:** Very high for attackers — no cryptographic breaks, minimal technical knowledge needed.
- **Detection risk:** High if defenses rely only on library-level checks or code review, not encapsulation.
- **Estimated probability of success:** High in any deployment where Coordinator is exposed to unvetted dependencies or uncontrolled code.

### Recommendation
- Make all sensitive state fields in Coordinator, SavedState, and support structs private, exposing only controlled getters and methods that preserve protocol invariants.
- Enforce all transitions and mutations via invariant-checked public APIs (e.g., through the StateMachine trait interface).
- Audit dependent code for any instances of direct field assignment and refactor to use approved accessors/mutators.
- Add integration tests that attempt state invariance violations via reflection or unsafe, and ensure such attempts fail.
- Consider cargo visibility enforcement or formal encapsulation wrappers.

### Proof of Concept

```rust
// Assume `coord` is a mutable Coordinator instance accessible in external code.
// Bypass round ordering by resetting state and round IDs (bypassing timeouts and double-signing protections):
coord.state = State::Idle;
coord.current_sign_id += 1;

// Subvert cryptography by swapping message after nonces are generated:
coord.message = attacker_controlled_message;

// Overwrite public key for signature aggregation, causing signatures to validate under wrong key:
coord.aggregate_public_key = Some(attacker_key);

// All these operations compromise invariant enforcement, concrete effect: protocol/chain split, invalid signature, or stolen funds.
```
Direct field assignment to any of these `pub` fields is possible with coordinator references, without triggering any protocol checks. No cryptographic break is required. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

Notes:
- Severity is CRITICAL due to direct loss of protocol/custody guarantees and potential chain splits.
- Attack is not theoretical; it is feasible in any system in which coordinator is exposed outside module boundaries (including tests, plugin systems, integration points, or where unsafe code or aliasing occurs).
- Recommending full field encapsulation—not just removal of `pub` but strict API control.

### Citations

**File:** src/state_machine/coordinator/frost.rs (L26-54)
```rust
pub struct Coordinator<Aggregator: AggregatorTrait> {
    /// common config fields
    config: Config,
    /// current DKG round ID
    pub current_dkg_id: u64,
    /// current signing round ID
    current_sign_id: u64,
    /// current signing iteration ID
    current_sign_iter_id: u64,
    dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
    dkg_end_messages: BTreeMap<u32, DkgEnd>,
    party_polynomials: HashMap<u32, PolyCommitment>,
    public_nonces: BTreeMap<u32, NonceResponse>,
    signature_shares: BTreeMap<u32, Vec<SignatureShare>>,
    /// aggregate public key
    pub aggregate_public_key: Option<Point>,
    signature: Option<Signature>,
    schnorr_proof: Option<SchnorrProof>,
    /// which signers we're currently waiting on
    pub ids_to_await: HashSet<u32>,
    /// the bytes that we're signing
    pub message: Vec<u8>,
    /// current state of the state machine
    pub state: State,
    /// Aggregator object
    aggregator: Aggregator,
    /// coordinator public key
    pub coordinator_public_key: Option<ecdsa::PublicKey>,
```

**File:** src/state_machine/coordinator/frost.rs (L826-847)
```rust
    fn load(state: &SavedState) -> Self {
        Self {
            aggregator: Aggregator::new(state.config.num_keys, state.config.threshold),
            config: state.config.clone(),
            current_dkg_id: state.current_dkg_id,
            current_sign_id: state.current_sign_id,
            current_sign_iter_id: state.current_sign_iter_id,
            dkg_public_shares: state.dkg_public_shares.clone(),
            dkg_private_shares: state.dkg_private_shares.clone(),
            dkg_end_messages: state.dkg_end_messages.clone(),
            party_polynomials: state.party_polynomials.clone(),
            public_nonces: state.message_nonces[&Vec::new()].public_nonces.clone(),
            signature_shares: state.signature_shares.clone(),
            aggregate_public_key: state.aggregate_public_key,
            signature: state.signature.clone(),
            schnorr_proof: state.schnorr_proof.clone(),
            message: state.message.clone(),
            ids_to_await: state.dkg_wait_signer_ids.clone(),
            state: state.state.clone(),
            coordinator_public_key: state.coordinator_public_key,
        }
    }
```

**File:** src/state_machine/coordinator/fire.rs (L31-67)
```rust
pub struct Coordinator<Aggregator: AggregatorTrait> {
    /// common config fields
    config: Config,
    /// current DKG round ID
    pub current_dkg_id: u64,
    /// current signing round ID
    pub current_sign_id: u64,
    /// current signing iteration ID
    pub current_sign_iter_id: u64,
    dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
    dkg_end_messages: BTreeMap<u32, DkgEnd>,
    /// the current view of a successful DKG's participants' commitments
    pub party_polynomials: HashMap<u32, PolyCommitment>,
    signature_shares: BTreeMap<u32, Vec<SignatureShare>>,
    message_nonces: BTreeMap<Vec<u8>, SignRoundInfo>,
    /// aggregate public key
    pub aggregate_public_key: Option<Point>,
    signature: Option<Signature>,
    schnorr_proof: Option<SchnorrProof>,
    /// which signers we're currently waiting on for DKG
    pub dkg_wait_signer_ids: HashSet<u32>,
    /// the bytes that we're signing
    pub message: Vec<u8>,
    /// current state of the state machine
    pub state: State,
    /// Aggregator object
    aggregator: Aggregator,
    nonce_start: Option<Instant>,
    dkg_public_start: Option<Instant>,
    dkg_private_start: Option<Instant>,
    dkg_end_start: Option<Instant>,
    sign_start: Option<Instant>,
    malicious_signer_ids: HashSet<u32>,
    malicious_dkg_signer_ids: HashSet<u32>,
    /// coordinator public key
    pub coordinator_public_key: Option<ecdsa::PublicKey>,
```

**File:** src/state_machine/coordinator/fire.rs (L1309-1337)
```rust
    fn load(state: &SavedState) -> Self {
        Self {
            aggregator: Aggregator::new(state.config.num_keys, state.config.threshold),
            config: state.config.clone(),
            current_dkg_id: state.current_dkg_id,
            current_sign_id: state.current_sign_id,
            current_sign_iter_id: state.current_sign_iter_id,
            dkg_public_shares: state.dkg_public_shares.clone(),
            dkg_private_shares: state.dkg_private_shares.clone(),
            dkg_end_messages: state.dkg_end_messages.clone(),
            party_polynomials: state.party_polynomials.clone(),
            message_nonces: state.message_nonces.clone(),
            signature_shares: state.signature_shares.clone(),
            aggregate_public_key: state.aggregate_public_key,
            signature: state.signature.clone(),
            schnorr_proof: state.schnorr_proof.clone(),
            message: state.message.clone(),
            dkg_wait_signer_ids: state.dkg_wait_signer_ids.clone(),
            state: state.state.clone(),
            dkg_public_start: state.dkg_public_start,
            dkg_private_start: state.dkg_private_start,
            dkg_end_start: state.dkg_end_start,
            nonce_start: state.nonce_start,
            sign_start: state.sign_start,
            malicious_signer_ids: state.malicious_signer_ids.clone(),
            malicious_dkg_signer_ids: state.malicious_dkg_signer_ids.clone(),
            coordinator_public_key: state.coordinator_public_key,
        }
    }
```

**File:** src/state_machine/mod.rs (L149-149)
```rust
pub mod coordinator;
```

**File:** src/state_machine/coordinator/mod.rs (L23-47)
```rust
pub enum State {
    /// The coordinator is idle
    #[default]
    Idle,
    /// The coordinator is asking signers to send public shares
    DkgPublicDistribute,
    /// The coordinator is gathering public shares
    DkgPublicGather,
    /// The coordinator is asking signers to send private shares
    DkgPrivateDistribute,
    /// The coordinator is gathering private shares
    DkgPrivateGather,
    /// The coordinator is asking signers to compute shares and send end
    DkgEndDistribute,
    /// The coordinator is gathering DKG End messages
    DkgEndGather,
    /// The coordinator is requesting nonces
    NonceRequest(SignatureType),
    /// The coordinator is gathering nonces
    NonceGather(SignatureType),
    /// The coordinator is requesting signature shares
    SigShareRequest(SignatureType),
    /// The coordinator is gathering signature shares
    SigShareGather(SignatureType),
}
```

**File:** src/state_machine/coordinator/mod.rs (L249-298)
```rust
pub struct SavedState {
    /// common config fields
    pub config: Config,
    /// current DKG round ID
    pub current_dkg_id: u64,
    /// current signing round ID
    pub current_sign_id: u64,
    /// current signing iteration ID
    pub current_sign_iter_id: u64,
    /// map of DkgPublicShares indexed by signer ID
    pub dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    /// map of DkgPrivateShares indexed by signer ID
    pub dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
    /// map of DkgEnd indexed by signer ID
    pub dkg_end_messages: BTreeMap<u32, DkgEnd>,
    /// the current view of a successful DKG's participants' commitments
    pub party_polynomials: HashMap<u32, PolyCommitment>,
    /// map of SignatureShare indexed by signer ID
    pub signature_shares: BTreeMap<u32, Vec<SignatureShare>>,
    /// map of SignRoundInfo indexed by message bytes
    pub message_nonces: BTreeMap<Vec<u8>, SignRoundInfo>,
    /// aggregate public key
    pub aggregate_public_key: Option<Point>,
    /// current Signature
    pub signature: Option<Signature>,
    /// current SchnorrProof
    pub schnorr_proof: Option<SchnorrProof>,
    /// which signers we're currently waiting on for DKG
    pub dkg_wait_signer_ids: HashSet<u32>,
    /// the bytes that we're signing
    pub message: Vec<u8>,
    /// current state of the state machine
    pub state: State,
    /// start time for NonceRequest
    pub nonce_start: Option<Instant>,
    /// start time for DkgBegin
    pub dkg_public_start: Option<Instant>,
    /// start time for DkgPrivateBegin
    pub dkg_private_start: Option<Instant>,
    /// start time for DkgEndBegin
    pub dkg_end_start: Option<Instant>,
    /// start time for SignatureShareRequest
    pub sign_start: Option<Instant>,
    /// set of malicious signers during signing round
    pub malicious_signer_ids: HashSet<u32>,
    /// set of malicious signers during dkg round
    pub malicious_dkg_signer_ids: HashSet<u32>,
    /// coordinator public key
    pub coordinator_public_key: Option<ecdsa::PublicKey>,
}
```
