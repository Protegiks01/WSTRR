### Title
Signer DoS via Repeated SignatureShareRequest Messages Without Duplicate Detection

### Summary
The `process()` function in the signer state machine lacks duplicate detection for `SignatureShareRequest` messages, allowing a malicious or compromised coordinator to flood signers with repeated valid requests. Each request triggers expensive signature computation operations including Lagrange interpolation, binding calculations, and scalar multiplications, causing CPU exhaustion that can prevent or delay legitimate signing operations and lead to transient consensus failures.

### Finding Description

**Exact Code Location:**
- `src/state_machine/signer/mod.rs`, function `process()` (lines 458-501) and `sign_share_request()` (lines 757-842)
- `src/v2.rs`, function `sign_with_tweak()` (lines 225-276)
- `src/compute.rs`, functions `binding()`, `intermediate()`, `challenge()`, `lambda()` (lines 17-96)

**Root Cause:**
The signer's `sign_share_request()` handler lacks duplicate detection mechanisms that exist for DKG messages. [1](#0-0) 

Unlike `dkg_public_share()` which checks for duplicates and returns early if a message has already been processed from a signer_id, [2](#0-1)  and `dkg_private_shares()` which has similar duplicate protection, [3](#0-2)  the `sign_share_request()` function processes every incoming `SignatureShareRequest` without checking if the same `sign_id`/`sign_iter_id` combination has been handled before.

**Expensive Operations:**
Each `SignatureShareRequest` triggers computationally expensive operations when the signer is included in the signing set. The request handler calls signature generation functions (`sign_taproot()`, `sign_schnorr()`, or `sign()`) [4](#0-3)  which perform expensive cryptographic operations including:

1. Computing intermediate values and binding for all parties/nonces [5](#0-4) 
2. Computing challenge hashes [6](#0-5) 
3. Computing Lagrange interpolation coefficients for each key_id [7](#0-6) 
4. Multiple scalar multiplications and additions [8](#0-7) 

The binding computation processes all nonces in the request, [9](#0-8)  and Lagrange coefficient computation scales with the number of key_ids. [10](#0-9) 

**Why Existing Mitigations Fail:**
- Packet signature verification is performed first, [11](#0-10)  but this only ensures the message is from the coordinator (or a valid signer), not that it's unique or necessary
- The `SignatureShareRequest` structure contains `nonce_responses` as an unbounded vector, [12](#0-11)  and each `NonceResponse` contains an unbounded vector of nonces [13](#0-12) 
- Validation only checks for duplicate signer_ids within a single request and valid ranges, [14](#0-13)  not whether the request itself is a duplicate
- State machine does not track processed sign_id/sign_iter_id combinations

### Impact Explanation

**Specific Harm:**
A malicious or compromised coordinator can exhaust signer CPU resources by sending repeated `SignatureShareRequest` messages. Each message triggers expensive signature computation operations that consume CPU cycles proportional to the number of parties and key_ids involved.

**Quantified Impact:**
- For a configuration with 10 signers and 20 key_ids at threshold 15, each signing operation requires:
  - 10 binding computations (one per party)
  - 20 Lagrange coefficient calculations (one per key_id)  
  - Multiple scalar multiplications and point operations
- A coordinator flooding at 100 requests/second could saturate signer CPUs
- Legitimate signing requests may timeout or fail, causing transactions to not be signed

**Affected Parties:**
- Signers receiving the flood of requests experience CPU exhaustion
- Users/applications waiting for signatures experience delays or failures
- The broader system experiences transient consensus failures if signers cannot respond to legitimate requests within required timeframes

**Severity Justification:**
This maps to **Medium severity** under the protocol scope definition: "Any transient consensus failures." When signers are DoS'd and cannot respond to legitimate signing requests in time, the signing protocol fails transiently, preventing transaction confirmation until the attack stops or mitigations are deployed.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Possession of the coordinator's private key (required to sign `SignatureShareRequest` packets) [15](#0-14) 
- Network access to send packets to targeted signers
- Knowledge that `verify_packet_sigs` is enabled (standard configuration) [16](#0-15) 

**Attack Complexity:**
Low complexity. The attacker only needs to:
1. Craft valid `SignatureShareRequest` messages with arbitrary content
2. Sign them with the coordinator's private key
3. Send them repeatedly to target signers
4. No cryptographic breaks or sophisticated timing required

**Economic Feasibility:**
Highly feasible. Sending network packets is cheap. The asymmetry between attacker effort (sending packets) and defender cost (expensive signature computation) makes this economically viable.

**Detection Risk:**
Medium. The attack generates obvious traffic patterns (repeated requests from coordinator) that could be detected through monitoring, but by the time detection occurs, legitimate operations may have already failed.

**Probability of Success:**
High if coordinator is compromised. The coordinator is a trusted privileged role, but compromise through key theft, insider threat, or software vulnerability is a realistic scenario in distributed systems.

### Recommendation

**Primary Fix - Add Duplicate Detection:**
Implement duplicate tracking for `SignatureShareRequest` messages similar to DKG message handling:

1. Add a field to track processed signing rounds: `processed_sign_requests: HashSet<(u64, u64, u64)>` to store `(dkg_id, sign_id, sign_iter_id)` tuples
2. In `sign_share_request()`, check if the request has been processed before returning early if duplicate
3. Clear the tracking set when transitioning DKG rounds or when appropriate

**Alternative Mitigation - Rate Limiting:**
Implement rate limiting for `SignatureShareRequest` messages:
1. Track timestamps of recent requests
2. Reject requests exceeding a threshold (e.g., 10 requests per second)
3. Apply exponential backoff for repeated identical requests

**Additional Hardening:**
1. Add bounds checking on the total number of nonces across all `NonceResponse` entries in a request
2. Implement maximum request processing time with early termination
3. Add monitoring/alerting for excessive request rates from coordinator

**Testing Recommendations:**
1. Unit test: Verify duplicate requests are rejected after first processing
2. Integration test: Confirm legitimate signing still works with duplicate detection
3. Stress test: Verify rate limiting prevents CPU exhaustion under flood conditions

**Deployment Considerations:**
- Backward compatibility: Duplicate detection only affects local state, no protocol changes
- Coordinate deployment with monitoring to detect any legitimate use cases that appear as duplicates
- Consider making rate limits configurable for different deployment scenarios

### Proof of Concept

**Exploitation Algorithm:**
```
Given:
- coordinator_private_key: The coordinator's signing key
- target_signer: Network address of target signer
- valid_nonce_responses: Legitimately obtained nonce responses from signers

Attack steps:
1. Construct valid SignatureShareRequest:
   request = SignatureShareRequest {
       dkg_id: <current_dkg_id>,
       sign_id: <any_value>,
       sign_iter_id: <any_value>,
       nonce_responses: valid_nonce_responses,
       message: <arbitrary_bytes>,
       signature_type: SignatureType::Schnorr
   }

2. Create signed packet:
   packet = Packet {
       msg: Message::SignatureShareRequest(request),
       sig: sign(&request, &coordinator_private_key)
   }

3. Flood attack:
   loop {
       send(packet, target_signer)
       // Optionally vary sign_id/sign_iter_id to avoid any external filtering
   }
```

**Expected Behavior:**
Without duplicate detection, each packet:
1. Passes signature verification (coordinator key is valid)
2. Passes nonce validation (nonces are valid)
3. Triggers full signature computation
4. Returns SignatureShareResponse
5. Consumes CPU for cryptographic operations

**Actual Behavior:**
Signer CPU usage saturates at ~100% processing repeated requests, causing:
- Increased latency for all operations
- Timeout failures for legitimate signing requests
- Potential process instability if request queue grows unbounded

**Reproduction Instructions:**
1. Deploy WSTS signers and coordinator in test environment
2. Compromise or simulate coordinator key
3. Send 100+ identical SignatureShareRequest messages per second
4. Monitor signer CPU usage (should spike to ~100%)
5. Attempt legitimate signing operation (should timeout or experience high latency)
6. Observe that signer processes each duplicate request without rejection

### Notes

This vulnerability requires coordinator compromise, making it a privileged attacker scenario. However, the coordinator role is a high-value target in threshold signature systems, and compromise through various means (key theft, insider threat, supply chain attack) is a realistic threat model that must be defended against. The lack of duplicate detection represents a missing defense-in-depth layer that should be present even when trusting the coordinator's identity.

### Citations

**File:** src/state_machine/signer/mod.rs (L347-347)
```rust
            verify_packet_sigs: true,
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L757-842)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };

            self.signer.gen_nonces(&self.network_private_key, rng);

            let response = SignatureShareResponse {
                dkg_id: sign_request.dkg_id,
                sign_id: sign_request.sign_id,
                sign_iter_id: sign_request.sign_iter_id,
                signer_id: self.signer_id,
                signature_shares,
            };
            info!(
                signer_id = %self.signer_id,
                dkg_id = %sign_request.dkg_id,
                sign_id = %sign_request.sign_id,
                sign_iter_id = %sign_request.sign_iter_id,
                "sending SignatureShareResponse"
            );

            Ok(vec![Message::SignatureShareResponse(response)])
        } else {
            debug!(signer_id = %self.signer_id, "signer not included in SignatureShareRequest");
            Ok(Vec::new())
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L1004-1011)
```rust
        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }
```

**File:** src/state_machine/signer/mod.rs (L1058-1061)
```rust
        if self.dkg_private_shares.contains_key(&src_signer_id) {
            info!(signer_id = %dkg_private_shares.signer_id, "received duplicate DkgPrivateShares");
            return Ok(vec![]);
        }
```

**File:** src/v2.rs (L255-257)
```rust
        let (_, R) = compute::intermediate(msg, party_ids, nonces);
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
```

**File:** src/v2.rs (L263-265)
```rust
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L267-269)
```rust
        cx = cx_sign * cx;

        let z = r + cx;
```

**File:** src/compute.rs (L17-33)
```rust
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/net.rs (L311-326)
```rust
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/net.rs (L383-396)
```rust
pub struct SignatureShareRequest {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Nonces responses used for this signature
    pub nonce_responses: Vec<NonceResponse>,
    /// Bytes to sign
    pub message: Vec<u8>,
    /// What type of signature to create
    pub signature_type: SignatureType,
}
```

**File:** src/net.rs (L577-582)
```rust
            Message::SignatureShareRequest(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a SignatureShareRequest message with an invalid signature.");
                    return false;
                }
            }
```
