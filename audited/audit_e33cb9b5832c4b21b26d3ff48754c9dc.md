# Audit Report

## Title
Duplicate key_ids Bypass Validation and Corrupt Lagrange Interpolation in Threshold Signing

## Summary
The validation loop in `Signer::new()` fails to check for duplicate key_ids, allowing a malicious signer to register with duplicate key IDs. The coordinator's HashSet-based validation inadvertently accepts these malformed NonceResponse messages by deduplicating during comparison, but then forwards the original response with duplicates. When honest signers use these duplicate key_ids in Lagrange interpolation, the coefficients become corrupted, causing all signature verification attempts to fail and resulting in denial of service.

## Finding Description

**Vulnerability Location and Root Cause:**

The validation in `Signer::new()` only verifies that each key_id is within valid bounds (> 0 and â‰¤ total_keys) but does not check for duplicate values: [1](#0-0) 

The underlying `validate_key_id()` function performs only range checking with no uniqueness constraint: [2](#0-1) 

**How the Attack Propagates Through the System:**

1. **Malicious Signer Initialization:** A malicious signer initializes with duplicate key_ids (e.g., `[3, 3]` instead of `[3]`). In v1, this creates multiple Party instances with the same ID: [3](#0-2) 

When `get_key_ids()` is called, it returns the duplicates: [4](#0-3) 

In v2, duplicates are stored directly and returned: [5](#0-4) [6](#0-5) 

2. **NonceResponse Creation:** When responding to nonce requests, the signer creates a NonceResponse containing the duplicate key_ids: [7](#0-6) 

3. **Coordinator Validation Bypass:** The coordinator's validation converts the incoming `Vec<u32>` to a `HashSet<u32>` for comparison. This deduplicates `[3, 3]` to `{3}`, which matches the expected configuration `{3}`, so validation passes: [8](#0-7) 

The same flawed validation exists in FROST coordinator: [9](#0-8) 

4. **Original NonceResponse Forwarding:** Despite passing validation, the coordinator stores and forwards the **original** NonceResponse with duplicate key_ids: [10](#0-9) [11](#0-10) 

5. **Honest Signers Extract Duplicates:** When honest signers process the SignatureShareRequest, they extract key_ids by flattening all nonce_responses, including the duplicates: [12](#0-11) 

6. **Corrupted Lagrange Interpolation:** The duplicate key_ids are passed to signing functions, where they corrupt the Lagrange coefficient calculation. The lambda function multiplies by `j/(j-i)` for **each occurrence** of `j`: [13](#0-12) 

With duplicate key_id 3 appearing twice in `[1,2,3,3]`, a signer with key_id 2 computes:
- Correct: `lambda(2, [1,2,3]) = 1/(1-2) * 3/(3-2) = -3`
- Corrupted: `lambda(2, [1,2,3,3]) = 1/(1-2) * 3/(3-2) * 3/(3-2) = -9`

The coefficient is wrong by a factor of 3, causing all signature verification attempts to fail.

## Impact Explanation

This vulnerability causes **transient consensus failures** (Medium severity) by preventing threshold signature generation:

**Specific Harm:**
- All signature operations involving the malicious signer fail verification due to incorrect Lagrange coefficients
- The threshold signature protocol cannot produce valid signatures
- Honest participants waste computational resources on failed signing attempts

**Affected Parties:**
- All honest signers participating in signing rounds with the malicious signer
- The coordinator orchestrating the signing protocol
- Any downstream systems depending on timely signature generation

**Severity Justification:**
This maps to **Medium severity** ("Any transient consensus failures") because:
- It blocks critical operations requiring threshold signatures (e.g., Bitcoin peg operations in Stacks)
- It forces repeated signing attempts until the malicious signer is excluded
- It causes operational delays in time-sensitive scenarios
- The denial of service is transient (excluding the malicious signer restores functionality)
- It does not cause permanent damage, fund loss, or chain splits

## Likelihood Explanation

**Likelihood: Medium-High**

**Required Attacker Capabilities:**
- Attacker must be a registered signer in the threshold configuration (within threat model)
- Attacker must control their signer initialization to pass duplicate key_ids to `Signer::new()`
- No cryptographic breaks required; exploits protocol logic flaws only

**Attack Complexity: Low**
The attacker simply needs to:
1. Initialize their signer with `key_ids = vec![k, k]` instead of `vec![k]`
2. Respond normally to nonce requests
3. The malicious data propagates automatically through the protocol

**Economic Feasibility: Very High**
- Attack costs nothing beyond normal protocol participation
- Wastes other participants' computational resources
- Can be repeated indefinitely until detected and excluded

**Detection Risk: Medium**
- Signature failures are observable
- Root cause diagnosis requires inspecting NonceResponse messages
- Malicious signer appears to follow protocol normally
- Duplicates may be difficult to detect without detailed logging

**Probability:**
- High in adversarial scenarios with compromised or malicious signers
- Low in honest deployments where configuration is derived from HashSet-based PublicKeys structure [14](#0-13) 

## Recommendation

Add duplicate detection in the validation logic. In `Signer::new()`, check for duplicate key_ids before accepting the configuration:

```rust
// After line 307 in src/state_machine/signer/mod.rs
let mut seen_key_ids = HashSet::new();
for key_id in &key_ids {
    if !validate_key_id(*key_id, total_keys) {
        return Err(Error::Config(ConfigError::InvalidKeyId(*key_id)));
    }
    if !seen_key_ids.insert(*key_id) {
        return Err(Error::Config(ConfigError::DuplicateKeyId(*key_id)));
    }
}
```

Additionally, add validation in the coordinator's NonceResponse processing to reject responses where key_ids length doesn't match the deduplicated set:

```rust
// After line 885 in src/state_machine/coordinator/fire.rs
if nonce_response.key_ids.len() != nonce_response_key_ids.len() {
    warn!(signer_id = %nonce_response.signer_id, "Nonce response contains duplicate key_ids");
    return Ok(());
}
```

## Proof of Concept

```rust
#[test]
fn test_duplicate_key_ids_corruption() {
    use rand_core::OsRng;
    
    // Create a signer with duplicate key_ids
    let duplicate_key_ids = vec![3, 3]; // Duplicate!
    let signer = Signer::new(
        2,              // threshold
        2,              // dkg_threshold
        3,              // total_signers
        3,              // total_keys
        0,              // signer_id
        duplicate_key_ids.clone(),
        Scalar::random(&mut OsRng),
        PublicKeys::default(),
        &mut OsRng,
    );
    
    // Verify that get_key_ids() returns duplicates
    let returned_key_ids = signer.unwrap().signer.get_key_ids();
    assert_eq!(returned_key_ids, vec![3, 3]);
    
    // Verify lambda calculation is corrupted
    let correct_lambda = lambda(2, &[1, 2, 3]);
    let corrupted_lambda = lambda(2, &[1, 2, 3, 3]);
    
    // Lambda should be different due to duplicate
    assert_ne!(correct_lambda, corrupted_lambda);
    
    // Corrupted lambda is wrong by a factor of 3
    assert_eq!(corrupted_lambda, correct_lambda * Scalar::from(3u32));
}
```

This test demonstrates that:
1. Duplicate key_ids pass validation in `Signer::new()`
2. The duplicates persist and are returned by `get_key_ids()`
3. The lambda function produces incorrect coefficients when given duplicate key_ids
4. The corruption factor is proportional to the number of duplicates

### Citations

**File:** src/state_machine/signer/mod.rs (L308-312)
```rust
        for key_id in &key_ids {
            if !validate_key_id(*key_id, total_keys) {
                return Err(Error::Config(ConfigError::InvalidKeyId(*key_id)));
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L730-741)
```rust
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };
```

**File:** src/state_machine/signer/mod.rs (L800-817)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
```

**File:** src/common.rs (L314-316)
```rust
pub fn validate_key_id(key_id: u32, num_keys: u32) -> bool {
    key_id > 0 && key_id <= num_keys
}
```

**File:** src/v1.rs (L537-540)
```rust
        let parties = key_ids
            .iter()
            .map(|id| Party::new(*id, num_keys, threshold, rng))
            .collect();
```

**File:** src/v1.rs (L605-607)
```rust
    fn get_key_ids(&self) -> Vec<u32> {
        self.parties.iter().map(|p| p.id).collect()
    }
```

**File:** src/v2.rs (L65-65)
```rust
            key_ids: key_ids.to_vec(),
```

**File:** src/v2.rs (L563-565)
```rust
    fn get_key_ids(&self) -> Vec<u32> {
        self.key_ids.clone()
    }
```

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L931-933)
```rust
            nonce_info
                .public_nonces
                .insert(nonce_response.signer_id, nonce_response.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L970-982)
```rust
        let nonce_responses = self
            .message_nonces
            .get(&self.message)
            .ok_or(Error::MissingMessageNonceInfo)?
            .public_nonces
            .values()
            .cloned()
            .collect::<Vec<NonceResponse>>();
        let sig_share_request = SignatureShareRequest {
            dkg_id: self.current_dkg_id,
            sign_id: self.current_sign_id,
            sign_iter_id: self.current_sign_iter_id,
            nonce_responses,
```

**File:** src/state_machine/coordinator/frost.rs (L513-521)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/state_machine/mod.rs (L101-101)
```rust
    pub signer_key_ids: HashMap<u32, HashSet<u32>>,
```
