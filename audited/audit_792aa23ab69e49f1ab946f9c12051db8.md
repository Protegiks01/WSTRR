### Title
FIRE Coordinator Includes Unvalidated Signers in DkgPrivateBegin Leading to Information Leakage

### Summary
The FIRE coordinator's `start_private_shares` function includes signer IDs in `DkgPrivateBegin` based solely on receipt of `DkgPublicShares` messages, without validating the cryptographic correctness of those shares. This causes honest signers to send encrypted private shares to parties that have not contributed valid public shares, violating DKG security assumptions and potentially enabling key compromise when combined with other attacks.

### Finding Description

The vulnerability exists in the FIRE coordinator's DKG flow across three functions:

**1. Public shares accepted without validation:** [1](#0-0) 

The `gather_public_shares` function accepts `DkgPublicShares` messages and inserts them into `self.dkg_public_shares` after only checking: (a) matching `dkg_id`, (b) signer_id exists in config, and (c) not a duplicate. Critically, it does NOT call `check_public_shares` to validate the Schnorr ID proofs or polynomial degree.

**2. Unvalidated signer IDs propagated to DkgPrivateBegin:** [2](#0-1) 

The `start_private_shares` function creates `DkgPrivateBegin` with `signer_ids` populated directly from `self.dkg_public_shares.keys()` (line 434), without any validation of whether those public shares are cryptographically valid.

**3. Honest signers trust coordinator's list:** [3](#0-2) 

The `dkg_private_begin` function trusts the coordinator's `signer_ids` list, builds `active_key_ids` from it, and encrypts/sends private shares to all those key IDs without validating that the corresponding signers provided valid public shares.

**4. Validation happens too late:** [4](#0-3) 

The `check_public_shares` validation only occurs in the `dkg_ended` function, after private shares have already been distributed. At this point, the DKG fails, but the information leakage has already occurred.

**Root Cause:** The coordinator accepts and trusts any `DkgPublicShares` message from authenticated signers without validating the cryptographic commitments, then propagates this trust to honest signers who send private shares to unvalidated parties.

### Impact Explanation

**Primary Impact:**
- Malicious signers can obtain encrypted private shares from honest signers without contributing cryptographically valid public shares
- Violates fundamental DKG security property that all participants must contribute valid shares
- Creates information asymmetry where attackers gain knowledge without providing equivalent information

**Potential Downstream Impacts:**
- In threshold schemes, security relies on adversaries learning fewer than threshold shares. A malicious signer obtaining shares without contributing valid shares weakens this security margin
- If combined with other vulnerabilities or protocol weaknesses, could enable:
  - Reconstruction of private keys below the intended threshold
  - Forging of signatures without sufficient authorization
  - Key compromise leading to unauthorized transaction signing
- In the Stacks blockchain context, this could potentially lead to confirmation of invalid transactions or direct loss of funds

**Who is Affected:**
- All honest signers in the DKG round leak private share information
- The entire WSTS deployment using FIRE coordinator
- Downstream systems (e.g., Stacks blockchain) relying on WSTS key security

**Severity Justification:** This maps to **High** severity as it represents a significant cryptographic protocol violation that could potentially lead to chain splits or consensus failures (High scope) and might enable key compromise scenarios when combined with other attacks. While not immediately Critical, it fundamentally weakens the DKG security model.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a registered signer with valid ECDSA keys in the coordinator's configuration
- Ability to construct and send network messages to coordinator
- Basic understanding of the DKG protocol to craft invalid `DkgPublicShares`

**Attack Complexity:**
- Low complexity: Attacker simply sends `DkgPublicShares` with invalid Schnorr ID proof or wrong polynomial degree
- No cryptographic breaks required
- Can be executed in any DKG round
- Detection only occurs after private shares are distributed

**Economic Feasibility:**
- Very low cost: Only requires sending malformed messages
- No computational resources beyond normal protocol participation
- Repeatable across multiple DKG rounds

**Detection Risk:**
- Medium: The DKG will eventually fail in `dkg_ended` phase when validation occurs
- However, the information leakage has already occurred and is not detectable
- Coordinator does not log or track why DKG failed, making attribution difficult

**Estimated Probability:** High likelihood of successful exploitation if attempted, as there are no preventive controls before the information leakage occurs.

### Recommendation

**Primary Fix - Validate public shares before including in DkgPrivateBegin:**

Modify `gather_public_shares` in `src/state_machine/coordinator/fire.rs` to validate public shares before inserting:

```rust
// After line 500, before inserting into dkg_public_shares:
let threshold: usize = self.config.threshold.try_into().unwrap();
for (party_id, comm) in &dkg_public_shares.comms {
    if !check_public_shares(comm, threshold, &self.current_dkg_id.to_be_bytes()) {
        warn!(
            signer_id = %dkg_public_shares.signer_id,
            party_id = %party_id,
            "Invalid public shares from signer, rejecting"
        );
        return Ok(());
    }
}
```

**Alternative Mitigation:**

Validate in `start_private_shares` before creating `DkgPrivateBegin`:

```rust
// At line 420, before creating signer_ids list:
let threshold: usize = self.config.threshold.try_into().unwrap();
let mut valid_signer_ids = HashSet::new();
for (signer_id, shares) in &self.dkg_public_shares {
    let mut all_valid = true;
    for (_, comm) in &shares.comms {
        if !check_public_shares(comm, threshold, &self.current_dkg_id.to_be_bytes()) {
            all_valid = false;
            break;
        }
    }
    if all_valid {
        valid_signer_ids.insert(*signer_id);
    }
}
self.dkg_wait_signer_ids = valid_signer_ids.clone();
// Use valid_signer_ids for DkgPrivateBegin.signer_ids
```

**Testing Recommendations:**
- Add unit test with invalid Schnorr ID proof in `DkgPublicShares`
- Add unit test with wrong polynomial degree
- Verify coordinator rejects invalid shares before sending `DkgPrivateBegin`
- Verify malicious signers are excluded from private share distribution

**Deployment Considerations:**
- This fix changes the coordinator's behavior to be more restrictive
- May need to tune timeouts if validation adds latency
- Consider logging rejected shares for monitoring

### Proof of Concept

**Exploitation Steps:**

1. **Malicious signer constructs invalid DkgPublicShares:**
   - Create polynomial commitment with invalid Schnorr ID proof (wrong challenge response)
   - OR create polynomial with incorrect degree (not equal to threshold)
   - Sign the message with valid signer ECDSA key

2. **Send to coordinator:**
   - Packet signature verifies (uses signer's valid ECDSA key)
   - `gather_public_shares` accepts it (only checks dkg_id, signer_id, duplicate)
   - Inserted into `self.dkg_public_shares` without validation

3. **Coordinator sends DkgPrivateBegin:**
   - `start_private_shares` includes malicious signer_id in `signer_ids`
   - Broadcast to all signers

4. **Honest signers send private shares:**
   - `dkg_private_begin` trusts the `signer_ids` list
   - Builds `active_key_ids` including malicious signer's key IDs
   - Encrypts private shares for malicious signer's key IDs
   - Sends `DkgPrivateShares` messages

5. **Malicious signer obtains information:**
   - Receives encrypted private shares from honest signers
   - Decrypts using DH shared secret
   - Obtains private polynomial evaluations without contributing valid shares

6. **DKG eventually fails:**
   - In `dkg_ended` phase, honest signers call `check_public_shares`
   - Detect invalid shares from malicious signer
   - Return `DkgStatus::Failure(DkgFailure::BadPublicShares)`
   - But information leakage already occurred

**Expected vs Actual Behavior:**
- **Expected:** Coordinator should only include signers with valid public shares in `DkgPrivateBegin`
- **Actual:** Coordinator includes any signer who sent a `DkgPublicShares` message, regardless of validity

**Reproduction:**
Create a test in `src/state_machine/coordinator/fire.rs` that sends invalid public shares and verifies they are included in `DkgPrivateBegin.signer_ids` before validation occurs.

---

**Notes:**

This vulnerability is specific to the FIRE coordinator implementation. The FROST coordinator uses a different architecture where `signer_ids` includes all configured signers regardless of responses, so the attack surface differs. However, the same principle applies: validation should occur before distributing private shares to any party.

The validation function `check_public_shares` is defined at: [5](#0-4) 

It verifies both the Schnorr ID proof and polynomial degree, which are critical DKG security properties that must be checked before accepting shares.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L419-446)
```rust
    /// Ask signers to send DKG private shares
    pub fn start_private_shares(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_public_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
        info!(
            dkg_id = %self.current_dkg_id,
            "Starting Private Share Distribution"
        );

        let dkg_begin = DkgPrivateBegin {
            dkg_id: self.current_dkg_id,
            signer_ids: self.dkg_public_shares.keys().cloned().collect(),
            key_ids: vec![],
        };
        let dkg_private_begin_msg = Packet {
            sig: dkg_begin
                .sign(&self.config.message_private_key)
                .expect("Failed to sign DkgPrivateBegin"),
            msg: Message::DkgPrivateBegin(dkg_begin),
        };
        self.move_to(State::DkgPrivateGather)?;
        self.dkg_private_start = Some(Instant::now());
        Ok(dkg_private_begin_msg)
    }
```

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/signer/mod.rs (L550-567)
```rust

        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
```

**File:** src/state_machine/signer/mod.rs (L892-956)
```rust
    fn dkg_private_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_private_begin: &DkgPrivateBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let mut private_shares = DkgPrivateShares {
            dkg_id: self.dkg_id,
            signer_id: self.signer_id,
            shares: Vec::new(),
        };
        let mut active_key_ids = HashSet::new();
        for signer_id in &dkg_private_begin.signer_ids {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
                for key_id in key_ids {
                    active_key_ids.insert(*key_id);
                }
            }
        }

        self.dkg_private_begin_msg = Some(dkg_private_begin.clone());
        self.move_to(State::DkgPrivateDistribute)?;

        info!(
            signer_id = %self.signer_id,
            dkg_id = %self.dkg_id,
            "sending DkgPrivateShares"
        );

        trace!(
            "Signer {} shares {:?}",
            self.signer_id,
            &self.signer.get_shares()
        );
        for (party_id, shares) in &self.signer.get_shares() {
            debug!(
                "Signer {} addding dkg private share for party_id {party_id}",
                self.signer_id
            );
            // encrypt each share for the recipient
            let mut encrypted_shares = HashMap::new();

            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }

            private_shares.shares.push((*party_id, encrypted_shares));
        }

        let private_shares = Message::DkgPrivateShares(private_shares);
        msgs.push(private_shares);

        self.move_to(State::DkgPrivateGather)?;
        Ok(msgs)
    }
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```
