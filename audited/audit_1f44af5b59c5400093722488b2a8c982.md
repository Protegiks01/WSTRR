Based on my systematic validation of this security claim against the WSTS codebase, I can confirm this is a **valid Low severity vulnerability**.

# Audit Report

## Title
Signature Share Reordering Denial of Service in v1 Implementation

## Summary
A malicious v1 signer controlling multiple keys can cause signing rounds to fail by deliberately reordering signature shares within their `SignatureShareResponse` message. The coordinator validates only the set of key IDs without checking positional correspondence to nonces, allowing incorrect nonce-share pairings during aggregation that cause signature verification to fail.

## Finding Description

The v1 implementation allows signers to control multiple `Party` objects, each representing a key share. When signing, the signer generates nonces and signature shares by iterating over parties in a deterministic order, establishing positional correspondence where `nonces[i]` pairs with `shares[i]`.

However, the coordinator's validation only verifies that the set of key IDs matches the expected configuration using `HashSet` comparison, without validating ordering or positional correspondence between the previously-received nonces and the newly-received signature shares. [1](#0-0) 

When aggregating signatures, the coordinator flattens nonces and shares separately from different messages: [2](#0-1) 

The aggregator then extracts party IDs from the signature shares and uses `compute::intermediate()` to calculate binding values, which pairs nonces with binding computations by position using `zip()`: [3](#0-2) [4](#0-3) 

**Attack Path:**

1. Malicious signer generates nonces `[N1, N3, N5]` for keys `[1, 3, 5]` in order
2. Signer generates shares `[S1, S3, S5]` correctly
3. **Signer reorders shares to `[S3, S1, S5]` before sending**
4. Coordinator validates key ID set `{1, 3, 5}` matches - passes validation
5. During aggregation:
   - `nonces = [N1, N3, N5]` (from original order)
   - `sig_shares = [S3, S1, S5]` (reordered)
   - `party_ids = [3, 1, 5]` (extracted from reordered shares)
6. `compute::intermediate()` calculates:
   - `Rs[0] = N1.D + binding(3, ...) * N1.E` (wrong: key 3's binding with key 1's nonce)
   - `Rs[1] = N3.D + binding(1, ...) * N3.E` (wrong: key 1's binding with key 3's nonce)
7. Signature verification fails, aborting the signing round

The packet signature verification does not prevent this because the attacker signs their own reordered message with their own key, which passes verification.

## Impact Explanation

This vulnerability enables a **denial-of-service attack** on signing operations. The impact severity is **Low** according to the defined scope: "Any remotely-exploitable denial of service in a node."

**Specific consequences:**
- Each attack causes one signing round to fail
- All participants waste computational resources on failed aggregation
- The attack can be repeated indefinitely to prevent signature generation
- The malicious signer is identified via `check_signature_shares`, but the damage (failed round) has already occurred

**Affected configurations:**
- Systems using the optional `with_v1` feature flag [5](#0-4) 
- Signers controlling multiple keys (common in v1 weighted threshold architecture)

**Not affected:**
The v2 implementation is not vulnerable because each signer returns exactly one nonce and one signature share, eliminating the possibility of reordering: [6](#0-5) [7](#0-6) 

The attack does not:
- Shut down the network entirely
- Cause loss of funds
- Create chain splits
- Compromise cryptographic guarantees
- Affect nodes not using v1

## Likelihood Explanation

**Required attacker capabilities:**
1. Must be a legitimate participant who passed DKG and holds valid private keys (insider threat, explicitly within threat model)
2. Must control multiple keys in the v1 architecture
3. Must be selected for the signing committee
4. Must have network access to send messages to the coordinator

**Attack complexity:** Low
- Attacker receives `SignatureShareRequest` normally
- Generates valid signature shares using normal signing logic
- Simply reorders elements in the `signature_shares` vector before sending
- Signs the reordered message with their own key

**Economic feasibility:** High
- No additional computational cost beyond normal participation
- Minimal cost to attacker while wasting resources of all participants

**Detection:** Immediate but post-impact
- `check_signature_shares` identifies the malicious signer after aggregation fails
- Detection occurs after the signing round has already failed
- Attacker can repeat on subsequent rounds

**Overall probability:** Low-to-Medium
- Requires insider access (legitimate signer)
- Requires v1 feature adoption (v2 is default)
- Conditional on signer controlling multiple keys

## Recommendation

Implement positional validation between nonces and signature shares. The coordinator should enforce that signature shares are provided in the same order as the nonces for each signer.

**Option 1: Validate ordering during signature share reception**

Add validation in `gather_sig_shares()` to check that share IDs match the order of key IDs from the corresponding `NonceResponse`:

```rust
// After existing key_ids validation (line 1076)
let nonce_response = &message_nonce.public_nonces[&sig_share_response.signer_id];
let expected_key_ids = &nonce_response.key_ids;
let actual_key_ids: Vec<u32> = sig_share_response.signature_shares
    .iter()
    .map(|s| s.id)
    .collect();

if expected_key_ids != &actual_key_ids {
    warn!(signer_id = %sig_share_response.signer_id, 
          "SignatureShareResponse key_ids order doesn't match NonceResponse");
    return Err(Error::BadKeyIDsOrderForSigner(sig_share_response.signer_id));
}
```

**Option 2: Match shares to nonces by ID rather than position**

Modify the aggregation logic to match signature shares to nonces using key IDs as the pairing key, eliminating reliance on positional correspondence.

**Option 3: Include ordering commitment in hash**

Enhance `SignatureShareResponse::hash()` to include a reference to the corresponding nonce message hash, creating a cryptographic binding between the two messages that includes ordering information.

## Proof of Concept

```rust
#[cfg(test)]
mod reordering_attack_poc {
    use super::*;
    use crate::traits::{Aggregator, Signer};
    use crate::util::create_rng;
    use crate::v1;
    
    #[test]
    fn test_signature_share_reordering_causes_dos() {
        let mut rng = create_rng();
        let msg = b"test message";
        let n: u32 = 10;
        let t: u32 = 7;
        
        // Create signers with multiple keys
        let key_ids = [1, 3, 5]; // Signer controls 3 keys
        let mut signer = v1::Signer::new(0, &key_ids, n, t, &mut rng);
        
        // Perform DKG
        let ctx = 0u64.to_be_bytes();
        let comms: HashMap<u32, PolyCommitment> = signer
            .get_poly_commitments(&ctx, &mut rng)
            .into_iter()
            .map(|c| (c.id.id.get_u32(), c))
            .collect();
        let shares = signer.get_shares();
        signer.compute_secrets(&shares, &comms, &ctx).unwrap();
        
        // Generate nonces in correct order
        let secret_key = Scalar::random(&mut rng);
        let nonces = signer.gen_nonces(&secret_key, &mut rng);
        assert_eq!(nonces.len(), 3);
        
        // Generate signature shares in correct order
        let key_ids_vec: Vec<u32> = key_ids.to_vec();
        let mut shares = signer.sign(msg, &key_ids_vec, &key_ids_vec, &nonces);
        assert_eq!(shares.len(), 3);
        assert_eq!(shares[0].id, 1);
        assert_eq!(shares[1].id, 3);
        assert_eq!(shares[2].id, 5);
        
        // ATTACK: Reorder shares
        shares.swap(0, 1); // Now: [S3, S1, S5]
        assert_eq!(shares[0].id, 3); // Reordered
        assert_eq!(shares[1].id, 1); // Reordered
        assert_eq!(shares[2].id, 5); // Same position
        
        // Attempt aggregation with reordered shares
        let mut aggregator = v1::Aggregator::new(n, t);
        aggregator.init(&comms).unwrap();
        
        // This should fail due to incorrect nonce-share pairings
        let result = aggregator.sign(msg, &nonces, &shares, &key_ids_vec);
        
        // Verify the attack causes DoS
        assert!(result.is_err(), "Reordered shares should cause signature aggregation to fail");
        
        // Verify bad parties are identified
        if let Err(AggregatorError::BadPartySigs(bad_ids)) = result {
            assert!(bad_ids.contains(&1) || bad_ids.contains(&3), 
                    "Reordered shares should be identified as bad");
        }
    }
}
```

This PoC demonstrates that reordering signature shares causes aggregation to fail, confirming the DoS vulnerability.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1121-1135)
```rust
            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/v1.rs (L372-373)
```rust
        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (Rs, R) = compute::intermediate(msg, &signers, nonces);
```

**File:** src/compute.rs (L85-96)
```rust
pub fn intermediate(msg: &[u8], party_ids: &[u32], nonces: &[PublicNonce]) -> (Vec<Point>, Point) {
    let rhos: Vec<Scalar> = party_ids
        .iter()
        .map(|&i| binding(&id(i), nonces, msg))
        .collect();
    let R_vec: Vec<Point> = zip(nonces, rhos)
        .map(|(nonce, rho)| nonce.D + rho * nonce.E)
        .collect();

    let R = R_vec.iter().fold(Point::zero(), |R, &R_i| R + R_i);
    (R_vec, R)
}
```

**File:** Cargo.toml (L16-16)
```text
with_v1 = []
```

**File:** src/v2.rs (L632-632)
```rust
        vec![self.gen_nonce(secret_key, rng)]
```

**File:** src/v2.rs (L659-659)
```rust
        vec![self.sign(msg, signer_ids, key_ids, nonces)]
```
