# Audit Report

## Title
Unvalidated DKG Failure Reports Enable DoS and False Accusations Against Honest Signers

## Summary
The FIRE and FROST coordinators fail to validate `MissingPublicShares` and `MissingPrivateShares` failure reports during DKG finalization. A malicious signer can exploit this by falsely claiming they did not receive shares from honest signers, causing DKG to fail indefinitely without marking anyone as malicious. This enables denial-of-service attacks and false accusations against honest participants.

## Finding Description

The `DkgFailure` enum defines six failure types that signers can report during DKG finalization: [1](#0-0) 

When signers send `DkgEnd` messages, the coordinator's `gather_dkg_end` function processes these failure reports. For `BadPublicShares` failures, the FIRE coordinator cryptographically validates the claims: [2](#0-1) 

Similarly, for `BadPrivateShares` failures, the coordinator performs cryptographic validation using tuple proofs and share verification: [3](#0-2) 

However, for `MissingPublicShares` and `MissingPrivateShares` failures, no validation occurs: [4](#0-3) 

The FROST coordinator similarly lacks any validation logic for these failure types: [5](#0-4) 

**Root Cause:**

The coordinator stores all received public and private shares locally: [6](#0-5) 

These shares are populated when the coordinator receives them: [7](#0-6) [8](#0-7) 

When a signer reports missing shares from another signer, the coordinator has sufficient information to validate the claim by checking whether it received shares from the accused signer. However, no such validation is implemented.

**Exploit Mechanism:**

Signers detect missing shares by checking their local storage during `dkg_ended()`: [9](#0-8) [10](#0-9) 

A malicious signer can exploit this by:
1. Receiving shares from honest signers
2. Intentionally not storing them (or deleting them)
3. Having `dkg_ended()` automatically report missing shares
4. Causing DKG to fail with no consequences

When DKG fails due to these reports, the error is returned with an empty `malicious_signers` set: [11](#0-10) 

The `malicious_dkg_signer_ids` field is only populated from the `malicious_signers` set: [12](#0-11) 

Furthermore, `malicious_dkg_signer_ids` is not used to exclude signers from future DKG rounds: [13](#0-12) 

## Impact Explanation

This vulnerability enables a denial-of-service attack that prevents DKG completion indefinitely:

1. **DKG Cannot Complete**: Without successful DKG, no aggregate public key is generated, preventing all threshold signature operations.

2. **False Accusations**: Honest signers are falsely blamed in the `reported_failures` map returned to the application: [14](#0-13) 

3. **No Attack Detection**: The `malicious_signers` set remains empty, providing no mechanism to identify or exclude the malicious reporter.

4. **Repeatable Attack**: Since `malicious_dkg_signer_ids` is not populated and not used for exclusion, the attacker can repeat the attack on every DKG retry.

**Severity Assessment**: This maps to **Low** severity per the defined scope: "Any remotely-exploitable denial of service in a node." The attack prevents DKG completion but does not compromise keys, enable fund theft, or cause chain splits.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a participating signer (within protocol threat model of up to threshold-1 malicious signers)
- No special cryptographic knowledge required
- No additional network access needed

**Attack Complexity:**
The attack is trivial to execute because the honest signer code automatically generates the false report when shares are not in local storage. A malicious signer simply needs to not store received shares.

**Detection Difficulty:**
The false reports are indistinguishable from legitimate network failure reports without the missing validation logic. Operators cannot identify the malicious actor.

**Success Rate:**
100% - The lack of validation guarantees every false report will cause DKG failure.

## Recommendation

Implement validation logic for `MissingPublicShares` and `MissingPrivateShares` failures in the coordinator's `gather_dkg_end` function:

```rust
DkgFailure::MissingPublicShares(missing_signers) => {
    for missing_signer_id in missing_signers {
        // Check if coordinator received shares from the accused signer
        if !self.dkg_public_shares.contains_key(missing_signer_id) {
            // Accused signer didn't send shares - mark them malicious
            malicious_signers.insert(*missing_signer_id);
        } else {
            // Accused signer did send shares (at least to coordinator)
            // Could be network issue or false report
            // Don't mark anyone malicious without more evidence
        }
    }
}

DkgFailure::MissingPrivateShares(missing_signers) => {
    for missing_signer_id in missing_signers {
        // Check if coordinator received shares from the accused signer  
        if !self.dkg_private_shares.contains_key(missing_signer_id) {
            // Accused signer didn't send shares - mark them malicious
            malicious_signers.insert(*missing_signer_id);
        } else {
            // Accused signer did send shares (at least to coordinator)
            // Could be network issue or false report
            // Don't mark anyone malicious without more evidence
        }
    }
}
```

Additionally, modify `start_public_shares()` to exclude previously identified malicious DKG signers:

```rust
self.dkg_wait_signer_ids = (0..self.config.num_signers)
    .filter(|id| !self.malicious_dkg_signer_ids.contains(id))
    .collect();
```

## Proof of Concept

```rust
#[test]
fn test_false_missing_shares_report() {
    // Setup coordinator and signers
    let mut coordinator = setup_fire_coordinator();
    let mut honest_signer = setup_signer(0);
    let mut malicious_signer = setup_signer(1);
    
    // Start DKG
    let dkg_begin = coordinator.start_public_shares().unwrap();
    
    // Both signers send public shares
    let honest_shares = honest_signer.dkg_public_begin(&dkg_begin).unwrap();
    let malicious_shares = malicious_signer.dkg_public_begin(&dkg_begin).unwrap();
    
    // Coordinator receives both shares
    coordinator.process_message(&honest_shares).unwrap();
    coordinator.process_message(&malicious_shares).unwrap();
    
    // Continue through private shares phase
    // ... (private shares exchange)
    
    // Honest signer completes DKG successfully
    let honest_end = honest_signer.dkg_ended(&mut rng).unwrap();
    
    // Malicious signer deletes received shares and reports missing
    malicious_signer.dkg_public_shares.clear(); // Delete honest signer's shares
    let malicious_end = malicious_signer.dkg_ended(&mut rng).unwrap();
    
    // Extract the DkgEnd messages
    let Message::DkgEnd(honest_msg) = honest_end else { panic!() };
    let Message::DkgEnd(malicious_msg) = malicious_end else { panic!() };
    
    // Verify malicious signer falsely reports missing shares
    assert!(matches!(malicious_msg.status, 
        DkgStatus::Failure(DkgFailure::MissingPublicShares(_))));
    
    // Process both messages at coordinator
    coordinator.process_message(&Packet::from(honest_end)).unwrap();
    let result = coordinator.process_message(&Packet::from(malicious_end));
    
    // Verify DKG fails
    assert!(matches!(result, 
        Ok((None, Some(OperationResult::DkgError(DkgError::DkgEndFailure { 
            malicious_signers, .. 
        }))))
        if malicious_signers.is_empty() // No one marked malicious!
    ));
}
```

### Citations

**File:** src/net.rs (L58-72)
```rust
/// Final DKG status after receiving public and private shares
pub enum DkgFailure {
    /// DKG threshold not met
    Threshold,
    /// Signer was in the wrong internal state to complete DKG
    BadState,
    /// DKG public shares were missing from these signer_ids
    MissingPublicShares(HashSet<u32>),
    /// DKG public shares were bad from these signer_ids
    BadPublicShares(HashSet<u32>),
    /// DKG private shares were missing from these signer_ids
    MissingPrivateShares(HashSet<u32>),
    /// DKG private shares were bad from these signer_ids
    BadPrivateShares(HashMap<u32, BadPrivateShare>),
}
```

**File:** src/state_machine/coordinator/fire.rs (L40-41)
```rust
    dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L399-399)
```rust
        self.dkg_wait_signer_ids = (0..self.config.num_signers).collect();
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/fire.rs (L785-788)
```rust
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/coordinator/frost.rs (L400-419)
```rust
        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
        }
        Ok(())
```

**File:** src/state_machine/signer/mod.rs (L551-566)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/mod.rs (L48-55)
```rust
    /// DKG end failure
    #[error("DKG end failure")]
    DkgEndFailure {
        /// failures reported by signers during DkgEnd
        reported_failures: HashMap<u32, DkgFailure>,
        /// signers who were discovered to be malicious during this DKG round
        malicious_signers: HashSet<u32>,
    },
```
