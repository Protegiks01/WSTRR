### Title
Aggregate Public Key Mismatch Due to Missing Party ID Uniqueness Validation in DKG

### Summary
The coordinator does not validate that party IDs are unique across received DkgPublicShares messages during DKG. When duplicate party IDs exist, the aggregate public key calculation includes all polynomial commitments (including duplicates), but the aggregator only stores deduplicated polynomials in a HashMap. This mismatch causes signature verification to use an incorrect public key, breaking the protocol's correctness guarantee and leading to signature verification failures.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the DKG flow within the Fire coordinator implementation:

1. **Missing validation in `gather_public_shares()`** [1](#0-0) 
   The coordinator accepts DkgPublicShares without validating that party IDs belong to the sending signer or that party IDs are unique.

2. **Aggregate key calculation in `dkg_end_gathered()`** [2](#0-1) 
   The aggregate public key is calculated by summing ALL polynomial first coefficients, including any duplicates.

3. **Party polynomials storage with HashMap deduplication** [3](#0-2) 
   Party polynomials are stored in a HashMap, causing the second insert of a duplicate party_id to overwrite the first.

4. **Aggregator initialization with deduplicated polynomials** [4](#0-3) 
   The aggregator is initialized with only deduplicated party_polynomials from the HashMap.

**Root Cause:**

The coordinator lacks party ID validation that exists in the signer implementation. While signers validate party IDs using the validate_party_id function [5](#0-4) , the coordinator has no equivalent check.

The ID struct in schnorr.rs provides a Schnorr proof binding the party ID to the polynomial constant [6](#0-5) , but this only proves knowledge of the polynomial—it does not enforce uniqueness of party IDs across different parties.

**Attack Vectors:**

In **v1 (weighted FROST)**, a malicious signer can pass duplicate key_ids when constructing their Signer, which creates multiple Party objects with the same party_id [7](#0-6) . The get_poly_commitments function then returns multiple commitments with duplicate party_ids [8](#0-7) .

In **v2 (standard FROST)**, while each signer creates only one party [9](#0-8) , two different signers could maliciously claim the same party_id, as there is no cross-signer validation.

**Why Existing Mitigations Fail:**

The `set_key_and_party_polynomials()` function does include duplicate detection [10](#0-9) , but this function is only called when manually setting keys (e.g., loading from saved state), not during the normal DKG flow in `dkg_end_gathered()`.

### Impact Explanation

**Specific Harm:**

When duplicate party IDs are present:
1. The `aggregate_public_key` computed in `dkg_end_gathered()` sums all polynomial commitments, including duplicates: `... + P1[0] + P2[0] + ...`
2. The `party_polynomials` HashMap only retains the last polynomial for each party_id due to overwrite
3. The aggregator's `init()` function [11](#0-10)  sums only the deduplicated polynomials: `... + P2[0] + ...`
4. This creates: `aggregate_public_key ≠ aggregator.poly[0]`

**Concrete Impact:**

Signature verification uses the aggregator's polynomial, which is incorrect. Valid signatures computed with the correct aggregate key from DKG will fail verification [12](#0-11) . This breaks the fundamental correctness of the threshold signature protocol.

**Who Is Affected:**

All parties participating in a DKG round where duplicate party IDs are present. Dependent systems relying on WSTS signatures will experience verification failures.

**Severity Justification:**

This maps to **Medium severity** under the protocol scope definition: "Any transient consensus failures." The mismatch causes signature verification failures, disrupting the threshold signature protocol and potentially impacting consensus in dependent systems.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of at least one signer participant in the DKG protocol
- Ability to craft DkgPublicShares messages (v1: pass duplicate key_ids; v2: coordinate with another malicious signer)
- No cryptographic breaks required

**Attack Complexity:**
Low to Medium. In v1, a malicious signer simply needs to pass duplicate values in the key_ids array when constructing their Signer. In v2, requires coordination between two signers to use the same party_id.

**Economic Feasibility:**
Highly feasible. The attack requires no special resources beyond participation in the DKG protocol.

**Detection Risk:**
Low. The duplicate party IDs would not be detected by the coordinator's current validation logic. Other signers would reject the malicious DkgPublicShares due to their party_id validation, but this doesn't prevent the coordinator from accepting it.

**Estimated Probability:**
Medium-High if an attacker controls a signer. The attack is straightforward and requires minimal sophistication.

### Recommendation

**Proposed Code Changes:**

Add party ID validation in the coordinator's `gather_public_shares()` function:

1. Validate that each party_id in the comms field belongs to the sending signer_id by checking against `config.public_keys.signer_key_ids`
2. Track all party_ids received across all DkgPublicShares messages
3. Reject any DkgPublicShares containing party_ids already seen from other signers
4. Reject any DkgPublicShares containing duplicate party_ids within its own comms field

**Alternative Mitigations:**

1. Add a duplicate detection check in `dkg_end_gathered()` before computing the aggregate key
2. Modify `set_key_and_party_polynomials()` duplicate check to also apply during normal DKG flow
3. Enhance v1::Signer construction to validate key_ids are unique

**Testing Recommendations:**

1. Add unit tests with duplicate party_ids within a single signer's DkgPublicShares
2. Add unit tests with duplicate party_ids across different signers' DkgPublicShares  
3. Verify the aggregate key calculation matches the aggregator's polynomial after validation
4. Test both v1 and v2 protocols

**Deployment Considerations:**

This is a protocol-level fix that must be deployed to all coordinators. Existing DKG sessions should be validated for party_id uniqueness before continuing.

### Proof of Concept

**Exploitation Steps:**

1. **Setup (v1 protocol):**
   - Attacker controls signer_id=1
   - Attacker creates `v1::Signer::new(1, &[5, 5, 7], num_keys, threshold, rng)`
   - This creates three parties: Party(id=5), Party(id=5), Party(id=7)

2. **DKG Public Shares:**
   - Attacker's `get_poly_commitments()` returns commitments: `[(5, P1), (5, P2), (7, P3)]`
   - Attacker sends DkgPublicShares with `comms = [(5, P1), (5, P2), (7, P3)]`
   - Coordinator accepts without validation

3. **DKG End:**
   - Aggregate key calculation: `key = ... + P1.poly[0] + P2.poly[0] + P3.poly[0]`
   - Party polynomials storage: `party_polynomials[5] = P2` (P1 overwritten)
   - Result: `aggregate_public_key` includes both P1[0] and P2[0]

4. **Signing:**
   - `aggregator.init(&party_polynomials)` called
   - Aggregator sums: `poly[0] = ... + P2.poly[0] + P3.poly[0]` (missing P1.poly[0])
   - `aggregator.poly[0] ≠ aggregate_public_key`

5. **Verification Failure:**
   - Signature verification uses `aggregator.poly[0]` as the public key
   - Valid signatures under the correct `aggregate_public_key` fail to verify

**Expected vs Actual Behavior:**

Expected: All party IDs are unique, aggregate key equals aggregator's poly[0]
Actual: Duplicate party IDs cause mismatch, signature verification fails

**Reproduction:**

Create a test with duplicate key_ids in v1::Signer::new(), run DKG, attempt to sign and verify. The verification will fail despite all parties behaving honestly after DKG.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L477-518)
```rust
    fn gather_public_shares(&mut self, packet: &Packet) -> Result<(), Error> {
        if let Message::DkgPublicShares(dkg_public_shares) = &packet.msg {
            if dkg_public_shares.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(
                    dkg_public_shares.dkg_id,
                    self.current_dkg_id,
                ));
            }

            // check that the signer_id exists in the config
            let signer_public_keys = &self.config.public_keys.signers;
            if !signer_public_keys.contains_key(&dkg_public_shares.signer_id) {
                warn!(signer_id = %dkg_public_shares.signer_id, "No public key in config");
                return Ok(());
            };

            let have_shares = self
                .dkg_public_shares
                .contains_key(&dkg_public_shares.signer_id);

            if have_shares {
                info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
                return Ok(());
            }

            self.dkg_wait_signer_ids
                .remove(&dkg_public_shares.signer_id);

            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
            debug!(
                dkg_id = %dkg_public_shares.dkg_id,
                signer_id = %dkg_public_shares.signer_id,
                "DkgPublicShares received"
            );
        }

        if self.dkg_wait_signer_ids.is_empty() {
            self.public_shares_gathered()?;
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L796-799)
```rust
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L802-807)
```rust
        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
```

**File:** src/state_machine/coordinator/fire.rs (L1145-1145)
```rust
            self.aggregator.init(&self.party_polynomials)?;
```

**File:** src/state_machine/coordinator/fire.rs (L1398-1402)
```rust
        let party_polynomials_len = party_polynomials.len();
        let party_polynomials = HashMap::from_iter(party_polynomials);
        if party_polynomials.len() != party_polynomials_len {
            return Err(Error::DuplicatePartyId);
        }
```

**File:** src/state_machine/signer/mod.rs (L993-1001)
```rust
        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
```

**File:** src/schnorr.rs (L13-66)
```rust
#[allow(non_snake_case)]
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// ID type which encapsulates the ID and a schnorr proof of ownership of the polynomial
pub struct ID {
    /// The ID
    pub id: Scalar,
    /// The public schnorr response
    pub kG: Point,
    /// The aggregate of the schnorr committed values
    pub kca: Scalar,
}

#[allow(non_snake_case)]
impl ID {
    /// Construct a new schnorr ID which binds the passed `Scalar` `id` and `Scalar` `a`, with a
    /// zero-knowledge proof of ownership of `a`.  The `ctx` is a common reference string used to
    /// prevent replay attacks; it can be any length, but will typically be a `u64` value in
    /// big endian format.
    pub fn new<RNG: RngCore + CryptoRng>(
        id: &Scalar,
        a: &Scalar,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Self {
        let k = Scalar::random(rng);
        let c = Self::challenge(id, &(&k * &G), &(a * &G), ctx);

        Self {
            id: *id,
            kG: &k * G,
            kca: &k + c * a,
        }
    }

    /// Compute the schnorr challenge
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }

    /// Verify the proof
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
}
```

**File:** src/v1.rs (L537-540)
```rust
        let parties = key_ids
            .iter()
            .map(|id| Party::new(*id, num_keys, threshold, rng))
            .collect();
```

**File:** src/v1.rs (L618-625)
```rust
        let mut polys = Vec::new();
        for party in &self.parties {
            let comm = party.get_poly_commitment(ctx, rng);
            if let Some(poly) = &comm {
                polys.push(poly.clone());
            }
        }
        polys
```

**File:** src/v2.rs (L431-444)
```rust
    fn init(&mut self, comms: &HashMap<u32, PolyCommitment>) -> Result<(), AggregatorError> {
        let threshold: usize = self.threshold.try_into()?;
        let mut poly = Vec::with_capacity(threshold);

        for i in 0..poly.capacity() {
            poly.push(Point::zero());
            for (_, comm) in comms {
                poly[i] += &comm.poly[i];
            }
        }

        self.poly = poly;

        Ok(())
```

**File:** src/v2.rs (L447-461)
```rust
    /// Check and aggregate the party signatures
    fn sign(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        key_ids: &[u32],
    ) -> Result<Signature, AggregatorError> {
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, key_ids, None)?;

        if sig.verify(&key, msg) {
            Ok(sig)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, key_ids, None))
        }
```

**File:** src/v2.rs (L505-505)
```rust
pub type Signer = Party;
```
