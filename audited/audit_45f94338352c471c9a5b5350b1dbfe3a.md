### Title
Hash Collision Vulnerability in DkgPrivateShares Enabling Message Forgery and DKG Disruption

### Summary
The `DkgPrivateShares::hash()` function lacks length prefixing for variable-length encrypted share data, allowing an attacker with man-in-the-middle network access to craft messages that produce identical hashes to legitimate messages. This enables signature reuse, allowing attackers to modify messages in transit while maintaining valid signatures, leading to DKG failure and false accusation of honest parties.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The hash function iterates through sorted `dst_ids` and hashes each `dst_id` (4 bytes, fixed-length) followed immediately by the corresponding encrypted share data (`Vec<u8>`, variable-length) without any length prefix or delimiter. This creates a classic length extension ambiguity where different share structures can produce identical hash values.

**The Vulnerability:**
When hashing shares, the function concatenates:
```
hash_input = prefix || dkg_id || signer_id || src_id || dst_id₁ || share₁ || dst_id₂ || share₂ || ...
```

An attacker can craft a collision by embedding `dst_id₂` bytes inside `share₁`:

**Message A (Malicious):** 
- `shares = [(src_id, {dst_id₁: [dst_id₂_bytes] ++ data})]`
- Hash: `... || dst_id₁ || dst_id₂_bytes || data`

**Message B (Honest):**
- `shares = [(src_id, {dst_id₁: [], dst_id₂: data})]`
- Hash: `... || dst_id₁ || (empty) || dst_id₂ || data`
- Which equals: `... || dst_id₁ || dst_id₂_bytes || data`

Both messages produce identical hashes despite having different share structures.

**Why Existing Mitigations Fail:**
The message signature verification [2](#0-1)  only validates that the signature matches the hash and the signer_id is authorized. Since the attacker creates a message with the same hash as the honest message, the original signature remains valid for the malicious message. There is no additional integrity protection (e.g., length prefixing, MACs, or transport-layer encryption) that would detect the structural modification.

### Impact Explanation

**Specific Harm:**
When recipients process the malicious message [3](#0-2) , they encounter:

1. **Missing shares:** Recipients expecting `dst_key_id=2` find no entry in the HashMap
2. **Corrupt data:** Recipients decrypting `dst_key_id=1` receive `[dst_id₂_bytes] ++ encrypted_data` which fails decryption or Scalar parsing
3. **False accusation:** Recipients mark the honest signer as sending `BadPrivateShares` [4](#0-3) 
4. **DKG failure:** The DKG round fails due to missing/invalid shares

**Quantified Impact:**
- **Single attack:** Causes one DKG round to fail, requiring restart (transient failure)
- **Persistent attacks:** Attacker can repeatedly disrupt DKG, preventing threshold key generation indefinitely
- **Selective targeting:** Attacker can target specific signers, creating network partitions where some nodes successfully complete DKG while others cannot
- **Chain-level impact:** In systems relying on WSTS for signing (e.g., Stacks), inability to generate signing keys prevents block production and transaction confirmation

**Who is Affected:**
- Honest signers are falsely accused of sending bad shares
- All participants in the DKG round experience failure
- Dependent systems (blockchains) cannot operate without successful DKG

**Severity Justification:**
**HIGH** - Maps to "Any unintended chain split or network partition" in the scope. Persistent attacks can:
- Prevent successful DKG completion, shutting down signing capability
- Create network partitions by selectively disrupting subsets of signers
- Cause extended network unavailability if DKG must restart repeatedly

### Likelihood Explanation

**Required Attacker Capabilities:**
- Man-in-the-middle network access between signers
- Ability to intercept and modify DkgPrivateShares messages in transit
- No requirement for cryptographic key material or breaking primitives

**Attack Complexity:**
- **Low:** Attack requires only byte manipulation, no complex computation
- Attacker intercepts honest message, identifies share structure, crafts collision with simple byte concatenation
- Collision is deterministic (not probabilistic), works every time

**Economic Feasibility:**
- **Minimal cost:** No computational work beyond basic network interception
- No cryptocurrency or resource expenditure required
- Can be automated for persistent attacks

**Detection Risk:**
- **Medium-Low:** Attack appears as honest signer sending bad data
- Recipients blame the honest party whose signature is on the message
- Network-level monitoring could detect modified messages, but typical deployments may lack such monitoring
- No cryptographic evidence distinguishes attack from honest error

**Estimated Probability:**
- **High** if attacker has network access (e.g., compromised router, ISP, or hosting provider)
- **Medium** in typical cloud/datacenter deployments with multiple network hops
- **Low** in fully end-to-end encrypted deployments (though this isn't visible in the codebase)

### Recommendation

**Primary Fix - Add Length Prefixing:**
Modify the hash function to include length prefixes for all variable-length data:

```rust
impl Signable for DkgPrivateShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PRIVATE_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        
        for (src_id, share) in &self.shares {
            hasher.update(src_id.to_be_bytes());
            let mut dst_ids = share.keys().cloned().collect::<Vec<u32>>();
            dst_ids.sort();
            
            // Hash the number of dst_ids first
            hasher.update((dst_ids.len() as u64).to_be_bytes());
            
            for dst_id in &dst_ids {
                hasher.update(dst_id.to_be_bytes());
                // Add length prefix for the encrypted share data
                let share_data = &share[dst_id];
                hasher.update((share_data.len() as u64).to_be_bytes());
                hasher.update(share_data);
            }
        }
    }
}
```

**Alternative Mitigations:**
1. Use a canonical serialization format (e.g., CBOR, bincode) that includes length information
2. Implement transport-layer encryption with authenticated encryption (AEAD)
3. Add per-message nonces or sequence numbers to prevent replay/modification

**Testing Recommendations:**
1. Add unit tests with collision attempts to verify fix prevents hash collisions
2. Test with various share structures (empty shares, multiple dst_ids, different orderings)
3. Fuzz test the hash function with malformed inputs
4. Integration test full DKG flow with attempted MITM attacks

**Deployment Considerations:**
- This is a breaking change requiring coordinated update of all signers
- Messages hashed with the new format won't validate against old signatures
- Consider version negotiation or migration period for production deployments

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:**
   - Attacker positions themselves on network path between signers
   - Monitors for DkgPrivateShares messages
   - Target: honest signer with `signer_id=S`, `dkg_id=D`

2. **Interception:**
   - Honest party sends: `Message_H` with `shares = [(1, {1: [], 2: encrypted_data})]`
   - Attacker intercepts message and signature `sig_H`

3. **Collision Crafting:**
   - Extract `encrypted_data` from `Message_H.shares[1][2]`
   - Construct `dst_id_2_bytes = [0x00, 0x00, 0x00, 0x02]` (big-endian u32)
   - Create malicious share: `malicious_share = dst_id_2_bytes ++ encrypted_data`
   - Build `Message_M = DkgPrivateShares { dkg_id: D, signer_id: S, shares: [(1, {1: malicious_share})] }`

4. **Verification:**
   - Compute `hash(Message_H)` and `hash(Message_M)`
   - Verify they are identical (collision achieved)

5. **Injection:**
   - Replace `Message_H` with `Message_M` on the wire
   - Keep original `sig_H` (valid for `Message_M` due to hash collision)
   - Forward to recipients

6. **Expected Behavior:**
   - Recipients validate signature: ✓ (hash matches)
   - Recipients try to decrypt:
     - Party with `dst_key_id=1`: Decryption fails on `malicious_share`
     - Party with `dst_key_id=2`: No entry found in HashMap
   - Recipients report signer `S` sent `BadPrivateShares`
   - DKG fails, honest party blamed

**Concrete Example:**
```
dkg_id = 0
signer_id = 5  
src_id = 1
encrypted_data = [0xAA, 0xBB, 0xCC]

Message_H: shares = [(1, {1: [], 2: [0xAA, 0xBB, 0xCC]})]
Hash_H = SHA256("DKG_PRIVATE_SHARES" || [0,0,0,0,0,0,0,0] || [0,0,0,5] || 
                [0,0,0,1] || [0,0,0,1] || [0,0,0,2] || [0xAA,0xBB,0xCC])

Message_M: shares = [(1, {1: [0x00, 0x00, 0x00, 0x02, 0xAA, 0xBB, 0xCC]})]
Hash_M = SHA256("DKG_PRIVATE_SHARES" || [0,0,0,0,0,0,0,0] || [0,0,0,5] || 
                [0,0,0,1] || [0,0,0,1] || [0x00, 0x00, 0x00, 0x02, 0xAA, 0xBB, 0xCC])

Hash_H == Hash_M ✓ (collision achieved)
```

### Citations

**File:** src/net.rs (L201-217)
```rust
impl Signable for DkgPrivateShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PRIVATE_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // make sure we hash consistently by sorting the keys
        for (src_id, share) in &self.shares {
            hasher.update(src_id.to_be_bytes());
            let mut dst_ids = share.keys().cloned().collect::<Vec<u32>>();
            dst_ids.sort();
            for dst_id in &dst_ids {
                hasher.update(dst_id.to_be_bytes());
                hasher.update(&share[dst_id]);
            }
        }
    }
}
```

**File:** src/net.rs (L540-556)
```rust
            Message::DkgPrivateShares(msg) => {
                // Private shares have key IDs from [0, N) to reference IDs from [1, N]
                // in Frost V4 to enable easy indexing hence ID + 1
                // TODO: Once Frost V5 is released, this off by one adjustment will no longer be required
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPrivateShares message with an invalid signature from signer_id {} key {}", msg.signer_id, &public_key);
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPrivateShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L1072-1102)
```rust
        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
```
