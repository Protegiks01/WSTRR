### Title
Plaintext Storage of Cryptographic Secrets in SavedState Enables Complete Key Compromise

### Summary
The `SavedState` struct stores multiple critical cryptographic secrets in plaintext, including the ephemeral DH private key (`kex_private_key`), decrypted polynomial shares (`decrypted_shares`), and the actual signing private keys (`private_keys` in `PartyState`). An attacker with filesystem or memory access can directly extract these secrets to sign unauthorized transactions, leading to fund theft in sBTC contexts.

### Finding Description

**Exact Code Location:**
The vulnerability exists in `src/state_machine/signer/mod.rs`, specifically in the `SavedState` struct definition and its `save()` method. [1](#0-0) 

**Root Cause Analysis:**

The `SavedState` struct stores four categories of sensitive cryptographic material in plaintext:

1. **`kex_private_key` (line 166)**: The ephemeral private key used for Diffie-Hellman key exchange during DKG. This key is generated randomly and stored directly as a `Scalar`. [2](#0-1) 

2. **`decrypted_shares` (line 140)**: A HashMap containing all decrypted polynomial evaluations from other parties, stored as plaintext `Scalar` values. These are the private shares `f_j(i_k)` used to derive signing keys. [3](#0-2) 

3. **`dkg_private_shares` (line 156)**: Encrypted shares that can be decrypted using `kex_private_key` and the public keys. [4](#0-3) 

4. **`signer` field (line 130)**: Contains `SignerSavedState` which includes `PartyState` structures that store the actual derived private keys. [5](#0-4) 

The `PartyState` struct exposes private keys directly: [6](#0-5) 

**Why Existing Mitigations Fail:**

The `save()` method copies all sensitive fields without any encryption or protection: [7](#0-6) 

The encryption/decryption utilities in `src/util.rs` are only used for network transmission, not for state persistence: [8](#0-7) 

During DKG, private shares are decrypted and stored in plaintext in `decrypted_shares`: [9](#0-8) 

The private key derivation shows that `decrypted_shares` contains all information needed to reconstruct signing keys (they are simply summed): [10](#0-9) 

### Impact Explanation

**Specific Harm:**
An attacker who obtains `SavedState` can:
1. Directly read `signer.parties[*].1.private_keys` to extract signing keys
2. Sum values from `decrypted_shares` to derive private keys if not in PartyState
3. Use `kex_private_key` with `kex_public_keys` to decrypt `dkg_private_shares`

**Quantified Impact:**
- **Loss of Signing Authority**: Complete compromise of the signer's cryptographic keys
- **Unauthorized Signatures**: Attacker can sign arbitrary messages as the compromised signer
- **Threshold Breach**: If â‰¥threshold signers are compromised, full group signing key control is lost
- **Fund Loss**: In sBTC context, attackers can sign unauthorized Bitcoin peg transactions, directly stealing funds
- **Invalid Transaction Confirmation**: Attackers can participate in signing invalid transactions that appear valid

**Who Is Affected:**
- Any signer whose `SavedState` is persisted to disk without encryption
- The entire WSTS signing group if threshold signers are compromised
- End users whose funds are controlled by the threshold signature scheme

**Severity Justification:**
This maps to **CRITICAL** severity under the protocol scope:
- "Any causing the direct loss of funds other than through any form of freezing"
- "Any confirmation of an invalid transaction, such as with an incorrect nonce"

### Likelihood Explanation

**Required Attacker Capabilities:**
- Filesystem or memory access to a signer node
- No cryptographic breaks required
- No network position required

**Attack Complexity:**
LOW - The attack is straightforward:
1. Gain access to filesystem (disk theft, backup compromise, cloud breach)
2. Locate `SavedState` in persistent storage or memory dumps
3. Parse the unencrypted structure
4. Extract private keys or decrypted shares
5. Use standard secp256k1 operations to sign messages

**Realistic Attack Vectors:**
- **Cloud Infrastructure**: Signers running on cloud VMs with unencrypted disk snapshots
- **Backup Systems**: Unencrypted backups stored in less secure locations
- **Memory Dumps**: Swap files, hibernation files, or crash dumps containing `SavedState`
- **Insider Threats**: Malicious administrators with system access
- **Physical Security**: Stolen or improperly decommissioned hardware
- **Application Vulnerabilities**: File read bugs, path traversal, or container escapes

**Economic Feasibility:**
HIGH - No specialized equipment or significant resources needed. Standard system access is sufficient.

**Detection Risk:**
LOW - Reading files or memory leaves minimal traces. The attack can be performed offline after data exfiltration.

**Estimated Probability:**
HIGH for production deployments without additional security controls around state persistence.

### Recommendation

**Immediate Mitigation:**
1. **Document Security Requirements**: Add explicit warnings in README and documentation that `SavedState` contains sensitive secrets and must be encrypted at rest
2. **Encrypt Sensitive Fields**: Implement encryption for `kex_private_key`, `decrypted_shares`, and fields in `PartyState` before serialization
3. **Key Derivation for Encryption**: Use a user-provided passphrase or hardware security module to derive encryption keys
4. **Zeroization**: Clear sensitive data from memory when no longer needed using secure zeroization

**Proposed Code Changes:**
1. Add encryption layer to `save()` method:
   - Accept encryption key parameter
   - Encrypt sensitive fields before returning SavedState
   - Document requirement for secure key management

2. Modify `SavedState` struct:
   - Mark sensitive fields as requiring encryption
   - Consider using wrapper types that enforce encryption

3. Clear sensitive data after use:
   - Implement `Drop` traits with zeroization for `PartyState`
   - Clear `decrypted_shares` after `compute_secrets` completes
   - Regenerate `kex_private_key` each DKG round (already done in `reset()`)

4. Add compile-time checks:
   - Remove `Serialize`/`Deserialize` derives from sensitive structs
   - Force consumers to implement custom serialization with encryption

**Alternative Mitigations:**
- Use hardware security modules (HSMs) or secure enclaves for key storage
- Implement memory encryption for sensitive process pages
- Use filesystem-level encryption (LUKS, FileVault) as defense-in-depth
- Implement access controls and audit logging around state files

**Testing Recommendations:**
1. Create test vectors showing private key recovery from unencrypted SavedState
2. Verify encrypted SavedState cannot be parsed without proper key
3. Test secure zeroization of sensitive memory regions
4. Penetration test state persistence mechanisms

**Deployment Considerations:**
- Existing deployments must migrate to encrypted state format
- Provide migration tool to encrypt existing SavedState files
- Update documentation with security best practices for production deployment
- Consider backward compatibility vs security tradeoff

### Proof of Concept

**Exploitation Algorithm:**

```text
Given: SavedState structure obtained from disk or memory

Step 1: Extract Private Keys Directly
  FOR each party in SavedState.signer.parties:
    private_keys = party.1.private_keys
    FOR each (key_id, private_key_scalar) in private_keys:
      // Can now sign messages for key_id using private_key_scalar
      signature = schnorr_sign(message, private_key_scalar)

Step 2: Alternative - Recover from Decrypted Shares
  IF private_keys not available:
    FOR each key_id controlled by this signer:
      private_key = Scalar::zero()
      FOR each (party_id, shares_map) in SavedState.decrypted_shares:
        IF shares_map contains key_id:
          private_key += shares_map[key_id]
      // private_key is now the signing key for key_id

Step 3: Alternative - Decrypt Encrypted Shares
  IF decrypted_shares not available:
    kex_private_key = SavedState.kex_private_key
    FOR each (signer_id, dkg_private_shares) in SavedState.dkg_private_shares:
      kex_public_key = get_public_key_for_signer(signer_id)
      shared_secret = make_shared_secret(kex_private_key, kex_public_key)
      FOR each (party_id, encrypted_shares) in dkg_private_shares.shares:
        FOR each (key_id, encrypted_bytes) in encrypted_shares:
          IF key_id controlled by attacker:
            decrypted_bytes = decrypt(shared_secret, encrypted_bytes)
            private_share_scalar = Scalar::from_bytes(decrypted_bytes)
            // Accumulate and sum to get private key

Step 4: Sign Unauthorized Transaction
  unauthorized_message = craft_malicious_transaction()
  signature = schnorr_sign(unauthorized_message, recovered_private_key)
  broadcast(signature)
```

**Expected vs Actual Behavior:**

**Expected**: SavedState should protect cryptographic secrets through encryption, preventing unauthorized key extraction even with filesystem access.

**Actual**: SavedState stores all cryptographic secrets in plaintext. An attacker with filesystem access can immediately extract private keys and sign arbitrary messages without any additional cryptographic operations.

**Reproduction Instructions:**
1. Run a WSTS signer through DKG completion
2. Call `signer.save()` to obtain SavedState
3. Inspect SavedState structure in memory or after serialization
4. Observe `kex_private_key`, `decrypted_shares`, and `private_keys` are plaintext Scalars
5. Extract any private key and use standard secp256k1 signing to create valid signatures

### Citations

**File:** src/state_machine/signer/mod.rs (L112-169)
```rust
/// The saved state required to reconstruct a signer
#[derive(Clone)]
pub struct SavedState {
    /// current DKG round ID
    pub dkg_id: u64,
    /// current signing round ID
    pub sign_id: u64,
    /// current signing iteration ID
    pub sign_iter_id: u64,
    /// the threshold of the keys needed for a valid signature
    pub threshold: u32,
    /// the threshold of the keys needed for a valid DKG
    pub dkg_threshold: u32,
    /// the total number of signers
    pub total_signers: u32,
    /// the total number of keys
    pub total_keys: u32,
    /// the Signer object
    pub signer: SignerSavedState,
    /// the Signer ID
    pub signer_id: u32,
    /// the current state
    pub state: State,
    /// map of polynomial commitments for each party
    /// party_id => PolyCommitment
    pub commitments: HashMap<u32, PolyCommitment>,
    /// map of decrypted DKG private shares
    /// src_party_id => (dst_key_id => private_share)
    decrypted_shares: HashMap<u32, HashMap<u32, Scalar>>,
    /// shared secrets used to decrypt private shares
    /// src_party_id => (signer_id, dh shared key)
    decryption_keys: HashMap<u32, (u32, Point)>,
    /// invalid private shares
    /// signer_id => {shared_key, tuple_proof}
    pub invalid_private_shares: HashMap<u32, BadPrivateShare>,
    /// public nonces for this signing round
    pub public_nonces: Vec<PublicNonce>,
    /// the private key used to sign messages sent over the network
    network_private_key: Scalar,
    /// the public keys for all signers and coordinator
    pub public_keys: PublicKeys,
    /// the DKG public shares received in this round
    pub dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    /// the DKG private shares received in this round
    pub dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
    /// the DKG private begin message received in this round
    pub dkg_private_begin_msg: Option<DkgPrivateBegin>,
    /// the DKG end begin message received in this round
    pub dkg_end_begin_msg: Option<DkgEndBegin>,
    /// whether to verify the signature on Packets
    pub verify_packet_sigs: bool,
    /// coordinator public key
    pub coordinator_public_key: Option<ecdsa::PublicKey>,
    /// Ephemeral private key for key exchange
    kex_private_key: Scalar,
    /// Ephemeral public keys for key exchange indexed by key_id
    kex_public_keys: HashMap<u32, Point>,
}
```

**File:** src/state_machine/signer/mod.rs (L386-413)
```rust
    pub fn save(&self) -> SavedState {
        SavedState {
            dkg_id: self.dkg_id,
            sign_id: self.sign_id,
            sign_iter_id: self.sign_iter_id,
            threshold: self.threshold,
            dkg_threshold: self.dkg_threshold,
            total_signers: self.total_signers,
            total_keys: self.total_keys,
            signer: self.signer.save(),
            signer_id: self.signer_id,
            state: self.state.clone(),
            commitments: self.commitments.clone(),
            decrypted_shares: self.decrypted_shares.clone(),
            decryption_keys: self.decryption_keys.clone(),
            invalid_private_shares: self.invalid_private_shares.clone(),
            public_nonces: self.public_nonces.clone(),
            network_private_key: self.network_private_key,
            public_keys: self.public_keys.clone(),
            dkg_public_shares: self.dkg_public_shares.clone(),
            dkg_private_shares: self.dkg_private_shares.clone(),
            dkg_private_begin_msg: self.dkg_private_begin_msg.clone(),
            dkg_end_begin_msg: self.dkg_end_begin_msg.clone(),
            verify_packet_sigs: self.verify_packet_sigs,
            coordinator_public_key: self.coordinator_public_key,
            kex_private_key: self.kex_private_key,
            kex_public_keys: self.kex_public_keys.clone(),
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1102)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);

        for (src_id, shares) in &dkg_private_shares.shares {
            let mut decrypted_shares = HashMap::new();
            for (dst_key_id, bytes) in shares {
                if key_ids.contains(dst_key_id) {
                    match decrypt(&shared_secret, bytes) {
                        Ok(plain) => match Scalar::try_from(&plain[..]) {
                            Ok(s) => {
                                decrypted_shares.insert(*dst_key_id, s);
                            }
                            Err(e) => {
                                warn!("Failed to parse Scalar for dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                                self.invalid_private_shares.insert(
                                    src_signer_id,
                                    self.make_bad_private_share(src_signer_id, rng)?,
                                );
                            }
                        },
                        Err(e) => {
                            warn!("Failed to decrypt dkg private share from src_id {src_id} to dst_id {dst_key_id}: {e:?}");
                            self.invalid_private_shares.insert(
                                src_signer_id,
                                self.make_bad_private_share(src_signer_id, rng)?,
                            );
                        }
                    }
                }
            }
            self.decrypted_shares.insert(*src_id, decrypted_shares);
            self.decryption_keys
                .insert(*src_id, (dkg_private_shares.signer_id, shared_key));
        }
```

**File:** src/traits.rs (L15-24)
```rust
#[derive(Clone, Deserialize, Serialize, PartialEq)]
/// The saved state required to reconstruct a party
pub struct PartyState {
    /// The party's private polynomial
    pub polynomial: Option<Polynomial<Scalar>>,
    /// The key IDS and associate private keys for this party
    pub private_keys: Vec<(u32, Scalar)>,
    /// The nonce being used by this party
    pub nonce: Nonce,
}
```

**File:** src/util.rs (L79-116)
```rust
/// Encrypt the passed data using the key
pub fn encrypt<RNG: RngCore + CryptoRng>(
    key: &[u8; 32],
    data: &[u8],
    rng: &mut RNG,
) -> Result<Vec<u8>, EncryptionError> {
    let mut nonce_bytes = [0u8; AES_GCM_NONCE_SIZE];

    rng.fill_bytes(&mut nonce_bytes);

    let nonce_vec = nonce_bytes.to_vec();
    let nonce = Nonce::from_slice(&nonce_vec);
    let cipher = Aes256Gcm::new(key.into());
    let cipher_vec = cipher.encrypt(nonce, data.to_vec().as_ref())?;
    let mut bytes = Vec::new();

    bytes.extend_from_slice(&nonce_vec);
    bytes.extend_from_slice(&cipher_vec);

    Ok(bytes)
}

/// Decrypt the passed data using the key
pub fn decrypt(key: &[u8; 32], data: &[u8]) -> Result<Vec<u8>, EncryptionError> {
    let Some(nonce_data) = data.get(..AES_GCM_NONCE_SIZE) else {
        return Err(EncryptionError::MissingNonce);
    };
    let Some(cipher_data) = data.get(AES_GCM_NONCE_SIZE..) else {
        return Err(EncryptionError::MissingData);
    };
    if cipher_data.is_empty() {
        return Err(EncryptionError::MissingData);
    }
    let nonce = Nonce::from_slice(nonce_data);
    let cipher = Aes256Gcm::new(key.into());

    Ok(cipher.decrypt(nonce, cipher_data)?)
}
```

**File:** src/v1.rs (L149-209)
```rust
    /// Compute this party's share of the group secret key
    pub fn compute_secret(
        &mut self,
        private_shares: HashMap<u32, Scalar>,
        public_shares: &HashMap<u32, PolyCommitment>,
        ctx: &[u8],
    ) -> Result<(), DkgError> {
        self.private_key = Scalar::zero();
        self.group_key = Point::zero();

        let threshold: usize = self.threshold.try_into()?;
        let mut bad_ids = Vec::new(); //: Vec<u32> = polys
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }

        let mut missing_shares = Vec::new();
        for i in public_shares.keys() {
            if private_shares.get(i).is_none() {
                missing_shares.push((self.id, *i));
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }

        // batch verification requires that we multiply each term by a random scalar in order to
        // prevent a bypass attack.  Doing this using p256k1's MultiMult trait is problematic,
        // because it needs to have every term available so it can return references to them,
        // so we wouldn't be able to save any memory since we'd have to multiple each polynomial
        // coefficient by a different random scalar.
        // we could implement a MultiMultCopy trait that allows us to do the multiplication inline,
        // at the cost of many copies, or use large amounts of memory and do a standard multimult.
        // Or we could just verify each set of public and private shares separately, using extra CPU
        let mut bad_shares = Vec::new();
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
            } else {
                warn!("unable to check private share from {}: no corresponding public share, even though we checked for it above", i);
            }
        }

        if !bad_shares.is_empty() {
            return Err(DkgError::BadPrivateShares(bad_shares));
        }

        self.private_key = private_shares.values().sum();
        self.public_key = self.private_key * G;

        Ok(())
    }
```
