### Title
Missing Identity Point Validation in KEX Public Keys Enables DKG Private Share Decryption

### Summary
The key derivation chain for DKG private share encryption fails to validate that ephemeral key exchange (KEX) public keys are not the identity point. A malicious signer can send `Point::identity()` as their `kex_public_key` in `DkgPublicShares`, causing all honest signers to derive a predictable, publicly-computable encryption key when encrypting private shares for that attacker. This completely breaks DKG share confidentiality and allows the attacker (or any observer) to decrypt private polynomial shares, potentially leading to group private key reconstruction and complete fund theft.

### Finding Description

**Exact Code Location:**

The vulnerability exists in the DKG public share handling and key derivation chain:

1. **Missing validation**: [1](#0-0) 

2. **Vulnerable key derivation chain**:
   - [2](#0-1) 
   - [3](#0-2) 
   - [4](#0-3) 

3. **Encryption usage**: [5](#0-4) 

4. **Decryption side**: [6](#0-5) 

**Root Cause:**

When honest signers receive a `DkgPublicShares` message, they store the `kex_public_key` without any validation. The code explicitly validates `PublicNonce` points against the identity point [7](#0-6) , demonstrating awareness of this attack vector. However, the same validation is completely absent for KEX public keys.

When `make_shared_secret(private_key, Point::identity())` is called:
- The ECDH computation yields: `private_key * Point::identity() = Point::identity()`
- `make_shared_secret_from_key(Point::identity())` compresses this to a known byte string
- `ansi_x963_derive_key()` applies deterministic SHA-256 hashing with fixed parameters
- The resulting encryption key is: `SHA256(Point::identity().compress().as_bytes() || 0x00000001 || "DH_SHARED_SECRET_KEY/")`
- This value is constant and publicly computable without knowing any private keys

**Why Existing Mitigations Fail:**

1. No validation occurs in `dkg_public_share()` - the KEX public key is blindly accepted
2. Decryption failure detection doesn't trigger because decryption succeeds with the predictable key
3. The `BadPrivateShare` proof mechanism is bypassed since shares decrypt correctly (though to wrong values)
4. Point deserialization doesn't reject identity points
5. The coordinator performs no validation on KEX public keys

### Impact Explanation

**Specific Harm:**

An attacker controlling a single signer can force all honest signers to encrypt their private polynomial shares using a publicly-known encryption key. The attacker (or any network observer) can then:

1. Decrypt all private shares intended for key IDs controlled by the attacker
2. Learn the polynomial evaluations that should remain secret
3. If the attacker controls â‰¥ threshold key IDs, reconstruct the entire group private key
4. Sign arbitrary transactions, stealing all funds controlled by the threshold wallet

**Quantified Impact:**

- **Complete DKG compromise**: All private shares encrypted for the attacker become public
- **Fund theft**: With threshold key IDs, full control of the group signing key
- **Affects**: All participants in any DKG round where one malicious signer participates
- **No recovery**: Once shares are leaked, the DKG round is permanently compromised

**Severity Justification:**

This maps to **Critical** severity: "Any causing the direct loss of funds other than through any form of freezing." The vulnerability enables complete theft of all funds controlled by the threshold signature scheme without requiring any cryptographic breaks.

### Likelihood Explanation

**Required Attacker Capabilities:**

- Control of exactly one signer in the WSTS network (insider position)
- Ability to send network messages (standard participant capability)
- No cryptographic breaks required
- No secrets needed beyond signer credentials

**Attack Complexity:**

The attack is trivial to execute:
1. During DKG initialization, set `kex_public_key = Point::identity()` in the `DkgPublicShares` message [8](#0-7) 
2. Honest signers encrypt shares using the predictable key [9](#0-8) 
3. Compute the deterministic encryption key: `ansi_x963_derive_key(Point::identity().compress().as_bytes(), b"DH_SHARED_SECRET_KEY/")`
4. Decrypt all encrypted shares from the `DkgPrivateShares` messages

**Economic Feasibility:**

- Near-zero cost: requires only standard network participation
- High reward: direct access to threshold wallet funds
- Undetectable: identity point appears as valid serialized data

**Estimated Probability:**

**Very High** - Any malicious insider can execute this attack with 100% success rate given the complete absence of validation.

### Recommendation

**Immediate Fix:**

Add identity point validation when receiving KEX public keys in `dkg_public_share()`:

```rust
// After line 1016 in src/state_machine/signer/mod.rs
let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
    warn!(%signer_id, "No key_ids configured");
    return Ok(vec![]);
};

// ADD THIS VALIDATION:
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == Point::zero() {
    warn!(%signer_id, "Invalid KEX public key (identity/zero point)");
    return Ok(vec![]);
}

for key_id in signer_key_ids {
    self.kex_public_keys
        .insert(*key_id, dkg_public_shares.kex_public_key);
}
```

**Additional Hardening:**

1. Add validation in `make_shared_secret()` to reject identity points
2. Create a `validate_kex_public_key()` function similar to `PublicNonce::is_valid()`
3. Add coordinator-side validation of KEX public keys
4. Consider validating against generator point `G` as well (similar to nonce validation)

**Testing Recommendations:**

1. Unit test: Verify rejection of `Point::identity()` as KEX public key
2. Integration test: Confirm DKG fails when identity point is sent
3. Regression test: Ensure legitimate KEX keys still work correctly

**Deployment Considerations:**

- This is a protocol-breaking change requiring coordinated upgrade
- All signers must upgrade simultaneously
- Consider adding protocol version negotiation for future changes

### Proof of Concept

**Exploitation Algorithm:**

```
# Attacker (controls Signer A):
1. During dkg_public_begin(), construct DkgPublicShares with:
   - kex_public_key = Point::identity()
   - Normal polynomial commitments

# Honest Signer B encrypts shares for Attacker A:
2. Retrieves kex_public_key = Point::identity() from storage
3. Computes: shared_key = B.kex_private_key * Point::identity() = Point::identity()
4. Derives: encryption_key = SHA256(Point::identity().compress() || 0x00000001 || "DH_SHARED_SECRET_KEY/")
5. Encrypts private_share with AES-GCM using encryption_key

# Attacker (or anyone) decrypts:
6. Receives DkgPrivateShares with encrypted_share
7. Computes same: encryption_key = SHA256(Point::identity().compress() || 0x00000001 || "DH_SHARED_SECRET_KEY/")
8. Decrypts encrypted_share using encryption_key
9. Obtains private polynomial share without knowing B.kex_private_key

# Impact:
10. If attacker controls >= threshold key_ids, reconstruct group_private_key
11. Sign arbitrary transactions, steal all funds
```

**Expected vs Actual Behavior:**

- **Expected**: KEX public key should be validated; identity point rejected; encryption should use unpredictable keys based on ECDH secret
- **Actual**: Identity point accepted; encryption key becomes `SHA256(known_constant)`, publicly computable; complete DKG confidentiality break

**Reproduction:**

1. Set up WSTS DKG with threshold=2, 3 signers
2. Modify one signer to send `Point::identity()` in `DkgPublicShares.kex_public_key`
3. Observe honest signers accept the identity point without validation
4. Compute encryption key independently using the constant identity point
5. Successfully decrypt all private shares intended for malicious signer
6. Verify shares validate against polynomial commitments but were obtained without proper ECDH

### Citations

**File:** src/state_machine/signer/mod.rs (L934-946)
```rust
            for (dst_key_id, private_share) in shares {
                if active_key_ids.contains(dst_key_id) {
                    debug!("encrypting dkg private share for key_id {dst_key_id}");
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;

                    encrypted_shares.insert(*dst_key_id, encrypted_share);
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L55-60)
```rust
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/util.rs (L64-77)
```rust
pub fn ansi_x963_derive_key(shared_key: &[u8], shared_info: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    let counter = 1u32;

    hasher.update(shared_key);
    hasher.update(counter.to_be_bytes());
    hasher.update(shared_info);

    let hash = hasher.finalize();
    let mut bytes = [0u8; 32];

    bytes.clone_from_slice(hash.as_slice());
    bytes
}
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/net.rs (L141-150)
```rust
pub struct DkgPublicShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (party_id, commitment)
    pub comms: Vec<(u32, PolyCommitment)>,
    /// Ephemeral public key for key exchange
    pub kex_public_key: Point,
}
```
