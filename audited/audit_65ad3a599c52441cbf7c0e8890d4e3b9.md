### Title
DKG Can Produce Identity Point as Aggregate Public Key Through Collusion

### Summary
The `dkg_end_gathered()` function in the FIRE coordinator computes the aggregate public key by summing polynomial constant terms from all participants but never validates that the result is not the identity point (point at infinity). Multiple colluding malicious signers can coordinate to choose secrets that sum to zero modulo the curve order, causing the DKG to produce an unusable identity key that breaks the signing protocol. This could lead to network shutdown if the signing group is critical to transaction confirmation.

### Finding Description

**Code Location:** [1](#0-0) 

The `dkg_end_gathered()` function computes the aggregate public key at lines 802-807 by folding over all polynomial constant terms (`comm.poly[0]`), starting from `Point::default()` (the identity element) and summing each contribution. The result is stored directly in `self.aggregate_public_key` at line 810 without any validation that the resulting point is not the identity. [2](#0-1) 

The codebase demonstrates awareness of identity point validation - `PublicNonce::is_valid()` explicitly checks that nonce points are not `Point::identity()` to prevent attacks. However, this same validation is missing for the aggregate public key.

**Root Cause:**
The protocol assumes that if all individual polynomial commitments pass Schnorr ID proof verification, the aggregate must be valid. However, Schnorr ID proofs only verify that each signer knows their individual secret - they do not prevent multiple signers from coordinating to choose secrets that sum to zero. [3](#0-2) 

The Schnorr ID proof verification (`kca * G == kG + c * A`) proves knowledge of the discrete logarithm of each individual commitment, but a malicious signer can create a valid proof even for the identity point (using secret = 0) or for any point whose discrete log they know.

**Why Existing Mitigations Fail:** [4](#0-3) 

The coordinator's malicious signer detection in `gather_dkg_end()` validates individual commitments for bad public/private shares but does not detect coordinated secret selection that produces a zero aggregate. Each colluding signer's commitment passes all individual validations because they correctly prove knowledge of their chosen secret. [5](#0-4) 

Similarly, the signer's `compute_secret()` validates individual polynomial commitments and accumulates the group key (lines 136-140) but never checks if the final `group_key` is the identity point.

### Impact Explanation

**Specific Harm:**
When the aggregate public key is the identity point, the threshold signing protocol becomes fundamentally broken: [6](#0-5) 

For FROST signatures, the verification equation `R == z * G + (-c) * public_key` becomes `R == z * G + (-c) * identity == z * G`. This means any signature where `R = z * G` would verify, requiring no knowledge of private keys. [7](#0-6) 

For BIP-340 Schnorr proofs, the verification equation `Rp = s * G - c * Y` would similarly degenerate when Y is derived from the identity point, potentially allowing forgery or causing verification failures.

**Quantified Impact:**
- The DKG round produces an unusable key that cannot securely sign transactions
- If the WSTS signing group controls critical Stacks blockchain operations (e.g., PoX, cross-chain operations), the network cannot confirm new valid transactions
- The attack can be repeated in subsequent DKG rounds if the same colluding parties participate
- This maps to **Critical** severity: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks"

**Who is Affected:**
All users of the Stacks network if the compromised signing group is critical to network operation. At minimum, all parties relying on the specific WSTS signing group for transaction authorization.

### Likelihood Explanation

**Required Attacker Capabilities:**
- At least 2 malicious signers in the DKG participant set
- Ability to coordinate secret selection before/during DKG (e.g., Party A chooses secret `r`, Party B chooses secret `-r`)
- Network access to participate in DKG protocol

**Attack Complexity:**
The attack is straightforward:
1. Colluding parties agree on secrets that sum to zero modulo curve order
2. Each party generates their polynomial with the agreed constant term
3. Each party creates valid Schnorr ID proofs for their chosen constants (they know the discrete logs)
4. All parties submit valid DkgPublicShares and DkgPrivateShares
5. All individual validations pass (Schnorr proofs verify, shares are consistent)
6. Coordinator computes aggregate: sum of commitments = identity
7. DKG completes "successfully" with unusable key

**Economic Feasibility:**
No additional resources beyond DKG participation required. No cryptographic breaks needed.

**Detection Risk:**
The attack is stealthy - all individual protocol messages are valid. Without the missing validation, neither coordinator nor honest signers detect the problem until attempting to use the key. [8](#0-7) 

The coordinator returns the identity key as a successful DKG result, with no indication of compromise.

**Probability of Success:**
100% if the prerequisite collusion exists. The main barrier is coordinating multiple Byzantine parties, which is within the standard threat model for Byzantine fault-tolerant protocols.

### Recommendation

**Primary Fix:**
Add validation in `dkg_end_gathered()` after computing the aggregate key:

```rust
// After line 807
let key = self
    .dkg_end_messages
    .keys()
    .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
    .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

// Add validation
if key == Point::identity() {
    error!("DKG produced identity as aggregate public key");
    return Err(Error::InvalidAggregatePublicKey);
}

info!("Aggregate public key: {key}");
self.aggregate_public_key = Some(key);
```

**Additional Mitigations:**
1. Add the same validation in signer's `compute_secret()` functions (v1 and v2) after computing `group_key`
2. Add validation in aggregator initialization to reject identity public keys
3. Consider adding validation that individual polynomial constant terms are not identity (defense in depth)

**Testing Recommendations:**
1. Create test case with two signers choosing secrets `r` and `-r`
2. Verify DKG detects and rejects identity aggregate
3. Test that legitimate DKG with valid random secrets continues to work
4. Add property test ensuring aggregate key is always non-identity

**Deployment Considerations:**
This is a protocol-level fix that should be deployed before the signing group handles critical operations. Existing DKG results should be validated to ensure no identity keys were produced.

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup**: Assume 4-party DKG with threshold t=3, where Party 0 and Party 1 are colluding

2. **Collusion Phase**: 
   - Party 0 generates random scalar `r` where `r ≠ 0`
   - Party 0 shares `r` with Party 1 via out-of-band channel
   - Party 1 computes secret `s = -r` (negation mod curve order)

3. **DKG Execution**:
   - Party 0 creates polynomial with constant term `a₀ = r`, creates valid Schnorr ID proof for `A₀ = r*G`
   - Party 1 creates polynomial with constant term `a₁ = -r`, creates valid Schnorr ID proof for `A₁ = (-r)*G`  
   - Parties 2, 3 create polynomials with random constant terms `a₂, a₃`
   - All parties exchange public commitments and private shares normally

4. **Validation**: 
   - All Schnorr ID proofs verify (each party knows their secret)
   - All private shares verify against public commitments
   - No existing checks detect collusion

5. **Result**:
   - Aggregate public key = `A₀ + A₁ + A₂ + A₃ = r*G + (-r)*G + a₂*G + a₃*G = a₂*G + a₃*G`
   - If Parties 2, 3 also collude to make `a₂ + a₃ = 0`, then aggregate = identity
   - With only Parties 0, 1 colluding, aggregate ≠ identity but is compromised (2 parties control full key)

**More Direct Attack (all parties collude)**:
If all 4 parties collude, each chooses their constant term such that the sum is zero:
- Party 0: `a₀ = r₁`
- Party 1: `a₁ = r₂`  
- Party 2: `a₂ = r₃`
- Party 3: `a₃ = -(r₁ + r₂ + r₃)`
- Aggregate = identity

**Expected vs Actual Behavior:**
- Expected: DKG should reject identity aggregate key with error
- Actual: DKG completes successfully, returns identity as valid group public key

**Reproduction**: Deploy modified WSTS with test signers programmed to use coordinated secrets as described above, run DKG, observe identity key returned without error.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L301-309)
```rust
                    } else if self.state == State::Idle {
                        // We are done with the DKG round! Return the operation result
                        return Ok((
                            None,
                            Some(OperationResult::Dkg(
                                self.aggregate_public_key
                                    .ok_or(Error::MissingAggregatePublicKey)?,
                            )),
                        ));
```

**File:** src/state_machine/coordinator/fire.rs (L605-650)
```rust
        if self.dkg_wait_signer_ids.is_empty() {
            // if there are any errors, mark signers malicious and retry
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());

                    match dkg_failure {
                        DkgFailure::BadState => {
                            // signer should not be in a bad state so treat as malicious
                            malicious_signers.insert(*signer_id);
                        }
                        DkgFailure::Threshold => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L794-812)
```rust
    fn dkg_end_gathered(&mut self) -> Result<(), Error> {
        // Cache the polynomials used in DKG for the aggregator
        for signer_id in self.dkg_private_shares.keys() {
            for (party_id, comm) in &self.dkg_public_shares[signer_id].comms {
                self.party_polynomials.insert(*party_id, comm.clone());
            }
        }

        // Calculate the aggregate public key
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
        self.move_to(State::Idle)
    }
```

**File:** src/common.rs (L159-164)
```rust
impl PublicNonce {
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
}
```

**File:** src/common.rs (L242-251)
```rust
impl Signature {
    #[allow(non_snake_case)]
    /// Verify the aggregated group signature
    pub fn verify(&self, public_key: &Point, msg: &[u8]) -> bool {
        let c = challenge(public_key, &self.R, msg);
        let R = &self.z * G + (-c) * public_key;

        R == self.R
    }
}
```

**File:** src/schnorr.rs (L61-65)
```rust
    /// Verify the proof
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```

**File:** src/v2.rs (L123-144)
```rust
    pub fn compute_secret(
        &mut self,
        private_shares: &HashMap<u32, HashMap<u32, Scalar>>,
        public_shares: &HashMap<u32, PolyCommitment>,
        ctx: &[u8],
    ) -> Result<(), DkgError> {
        self.private_keys.clear();
        self.group_key = Point::zero();

        let threshold: usize = self.threshold.try_into()?;

        let mut bad_ids = Vec::new();
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
        if !bad_ids.is_empty() {
            return Err(DkgError::BadPublicShares(bad_ids));
        }
```

**File:** src/taproot.rs (L30-43)
```rust
    /// Verify a BIP-340 schnorr proof
    #[allow(non_snake_case)]
    pub fn verify(&self, public_key: &field::Element, msg: &[u8]) -> bool {
        let Ok(Y) = Point::lift_x(public_key) else {
            return false;
        };
        let Ok(R) = Point::lift_x(&self.r) else {
            return false;
        };
        let c = compute::challenge(&Y, &R, msg);
        let Rp = self.s * G - c * Y;

        Rp.has_even_y() && Rp.x() == self.r
    }
```
