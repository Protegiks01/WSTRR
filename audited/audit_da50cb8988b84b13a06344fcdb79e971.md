### Title
BIP-340 Public Key Returned with Wrong Y-Coordinate Parity in sign_with_tweak()

### Summary
The `Aggregator::sign_with_tweak()` function returns a public key that may have odd Y-coordinate when `tweak = Some(0)` (BIP-340 mode), violating the BIP-340 standard which requires even Y-coordinates. This causes the returned `tweaked_public_key` to be incorrect for the signature created, potentially leading to fund loss if used for address derivation or consensus failures if used inconsistently across nodes.

### Finding Description

**Location**: [1](#0-0) 

The same bug exists in v2.rs: [2](#0-1) 

**Root Cause**: When `tweak = Some(Scalar::from(0))`, the function sets `tweaked_public_key = aggregate_public_key` without applying `Point::lift_x()` to ensure even Y-coordinate. [3](#0-2) 

In contrast, when `tweak` is non-zero (taproot case), the code correctly uses `compute::tweaked_public_key_from_tweak()` which applies `Point::lift_x()` to ensure even Y-coordinate. [4](#0-3) 

**Why This Breaks**: BIP-340 requires all public keys to have even Y-coordinates. [5](#0-4) 

During signing, individual parties correctly adjust their signature shares for the even-Y version of the public key: [6](#0-5) 

The challenge computation uses only X-coordinates, so signatures created for even-Y keys won't verify under odd-Y keys when using standard FROST verification. [7](#0-6) 

### Impact Explanation

**Fund Loss Risk**: If external code calls `sign_with_tweak(..., Some(Scalar::from(0)))` and uses the returned `tweaked_public_key` to derive a Bitcoin taproot address, funds sent to that address would be unspendable. The signature verification would use the even-Y version of the key (per BIP-340), but the address was derived from the odd-Y version - these are different keys with different addresses.

**Signature Verification Failure**: If the returned `tweaked_public_key` is used with `Signature::verify()` instead of `SchnorrProof::verify()`, valid signatures will be rejected because the signature was created for the even-Y version but verification uses the odd-Y version. [8](#0-7) 

**Consensus Impact**: If different Stacks nodes or implementations handle this inconsistently (some using the returned key correctly vs incorrectly), this could cause transient consensus failures when validating BIP-340 signatures.

**Severity**: Medium - maps to "transient consensus failures" in scope, with potential escalation to Critical if fund loss occurs.

### Likelihood Explanation

**Prerequisites**: 
- External code using WSTS library calls `sign_with_tweak()` directly with `Some(Scalar::from(0))`
- Uses returned `tweaked_public_key` for address derivation, storage, or non-BIP-340 verification

**Attack Complexity**: Low - this is a straightforward API misuse scenario, not requiring any attacker intervention. The bug affects legitimate users who reasonably expect the returned public key to be correct.

**Current Mitigations**: Internal callers (`sign_schnorr()`, `sign_taproot()`) happen to use the returned key correctly by only using the X-coordinate. [9](#0-8) 

However, no documentation warns external callers about this issue, and the function is public API.

**Probability**: Medium - requires external usage of low-level API, but this is a reasonable use case for integrators building on WSTS.

### Recommendation

**Fix for v1.rs and v2.rs**: Modify `sign_with_tweak()` to always return the even-Y version of the public key when `tweak.is_some()`:

```rust
let tweaked_public_key = match tweak {
    Some(t) if t != Scalar::zero() => {
        compute::tweaked_public_key_from_tweak(&aggregate_public_key, t)
    }
    Some(_) => {
        // BIP-340 without taproot: use even-Y version of aggregate key
        Point::lift_x(&aggregate_public_key.x()).unwrap()
    }
    _ => aggregate_public_key,
};
```

**Testing**: Add test cases that verify the returned `tweaked_public_key` has even Y-coordinate when `tweak = Some(0)`, and that standard FROST verification succeeds with the returned key.

**Documentation**: Add doc comments warning that for BIP-340 mode, the returned public key will always have even Y-coordinate per the standard.

**Deployment**: This is a breaking change for any external code that might be working around the current behavior. Coordinate with integrators.

### Proof of Concept

**Exploitation Steps**:

1. External code calls: `let (pk, sig) = aggregator.sign_with_tweak(msg, nonces, shares, Some(Scalar::from(0)))?;`

2. If `aggregate_public_key` has odd Y-coordinate, `pk` will be the odd-Y point

3. Code derives taproot address from `pk`: `address = derive_p2tr_address(pk)`

4. User sends funds to `address`

5. Later, attempt to spend requires BIP-340 signature verification which will use `Point::lift_x(&pk.x())` - the even-Y version

6. The even-Y version is a different point: `-pk != pk` when Y is odd

7. Funds are unspendable because the private key adjustments were made for even-Y, but address was derived from odd-Y

**Expected vs Actual**:
- Expected: `tweaked_public_key` has even Y-coordinate per BIP-340 standard
- Actual: `tweaked_public_key` may have odd Y-coordinate
- Result: Returned key is incorrect for the signature created

### Citations

**File:** src/v1.rs (L263-280)
```rust
        let mut cx_sign = Scalar::one();
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                let key = compute::tweaked_public_key_from_tweak(&self.group_key, t);
                if key.has_even_y() ^ self.group_key.has_even_y() {
                    cx_sign = -cx_sign;
                }

                key
            } else {
                if !self.group_key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                self.group_key
            }
        } else {
            self.group_key
        };
```

**File:** src/v1.rs (L314-354)
```rust
    pub fn sign_with_tweak(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        tweak: Option<Scalar>,
    ) -> Result<(Point, Signature), AggregatorError> {
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }

        let signers: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &signers, nonces);
        let mut z = Scalar::zero();
        let mut cx_sign = Scalar::one();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = match tweak {
            Some(t) if t != Scalar::zero() => {
                let key = compute::tweaked_public_key_from_tweak(&aggregate_public_key, t);
                if !key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                key
            }
            _ => aggregate_public_key,
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);

        for sig_share in sig_shares {
            z += sig_share.z_i;
        }

        // The signature shares have already incorporated the private key adjustments, so we just have to add the tweak.  But the tweak itself needs to be adjusted if the tweaked public key is odd
        if let Some(t) = tweak {
            z += cx_sign * c * t;
        }

        let sig = Signature { R, z };

        Ok((tweaked_public_key, sig))
    }
```

**File:** src/v1.rs (L481-490)
```rust
        let tweak = Scalar::from(0);
        let (key, sig) = self.sign_with_tweak(msg, nonces, sig_shares, Some(tweak))?;
        let proof = SchnorrProof::new(&sig);

        if proof.verify(&key.x(), msg) {
            Ok(proof)
        } else {
            Err(self.check_signature_shares(msg, nonces, sig_shares, Some(tweak)))
        }
    }
```

**File:** src/v2.rs (L296-340)
```rust
    pub fn sign_with_tweak(
        &mut self,
        msg: &[u8],
        nonces: &[PublicNonce],
        sig_shares: &[SignatureShare],
        _key_ids: &[u32],
        tweak: Option<Scalar>,
    ) -> Result<(Point, Signature), AggregatorError> {
        if nonces.len() != sig_shares.len() {
            return Err(AggregatorError::BadNonceLen(nonces.len(), sig_shares.len()));
        }

        let party_ids: Vec<u32> = sig_shares.iter().map(|ss| ss.id).collect();
        let (_Rs, R) = compute::intermediate(msg, &party_ids, nonces);
        let mut z = Scalar::zero();
        let mut cx_sign = Scalar::one();
        let aggregate_public_key = self.poly[0];
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                let key = compute::tweaked_public_key_from_tweak(&aggregate_public_key, t);
                if !key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                key
            } else {
                aggregate_public_key
            }
        } else {
            aggregate_public_key
        };
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        // optimistically try to create the aggregate signature without checking for bad keys or sig shares
        for sig_share in sig_shares {
            z += sig_share.z_i;
        }

        // The signature shares have already incorporated the private key adjustments, so we just have to add the tweak.  But the tweak itself needs to be adjusted if the tweaked public key is odd
        if let Some(t) = tweak {
            z += cx_sign * c * t;
        }

        let sig = Signature { R, z };

        Ok((tweaked_public_key, sig))
    }
```

**File:** src/compute.rs (L57-67)
```rust
pub fn challenge(publicKey: &Point, R: &Point, msg: &[u8]) -> Scalar {
    let tag = "BIP0340/challenge";

    let mut hasher = tagged_hash(tag);

    hasher.update(R.x().to_bytes());
    hasher.update(publicKey.x().to_bytes());
    hasher.update(msg);

    hash_to_scalar(&mut hasher)
}
```

**File:** src/compute.rs (L177-179)
```rust
pub fn tweaked_public_key_from_tweak(public_key: &Point, tweak: Scalar) -> Point {
    Point::lift_x(&public_key.x()).unwrap() + tweak * G
}
```

**File:** src/taproot.rs (L32-43)
```rust
    pub fn verify(&self, public_key: &field::Element, msg: &[u8]) -> bool {
        let Ok(Y) = Point::lift_x(public_key) else {
            return false;
        };
        let Ok(R) = Point::lift_x(&self.r) else {
            return false;
        };
        let c = compute::challenge(&Y, &R, msg);
        let Rp = self.s * G - c * Y;

        Rp.has_even_y() && Rp.x() == self.r
    }
```

**File:** src/common.rs (L242-251)
```rust
impl Signature {
    #[allow(non_snake_case)]
    /// Verify the aggregated group signature
    pub fn verify(&self, public_key: &Point, msg: &[u8]) -> bool {
        let c = challenge(public_key, &self.R, msg);
        let R = &self.z * G + (-c) * public_key;

        R == self.R
    }
}
```
