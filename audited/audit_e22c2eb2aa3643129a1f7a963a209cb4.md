### Title
Missing Identity Point Validation in Diffie-Hellman Key Exchange Allows Predictable Encryption Keys

### Summary
The `make_shared_secret()` function does not validate that the computed shared key is not the identity point before deriving encryption keys. Additionally, the `kex_public_key` field in `DkgPublicShares` messages is neither validated nor authenticated (not included in the message signature), allowing man-in-the-middle attackers to force predictable shared secrets even when message authentication is enabled. This enables attackers to decrypt DKG private shares, potentially leading to private key reconstruction and direct loss of funds.

### Finding Description

**Location 1: Missing Identity Validation** [1](#0-0) 

The `make_shared_secret()` function computes `shared_key = private_key * public_key` and immediately passes it to `make_shared_secret_from_key()` without validating that `shared_key != Point::identity()`.

**Location 2: Unauthenticated kex_public_key Field** [2](#0-1) 

The `DkgPublicShares::hash()` method does not include the `kex_public_key` field in the signature hash, meaning this field can be modified without invalidating message signatures.

**Location 3: Missing Point Validation on Receipt** [3](#0-2) 

When processing `DkgPublicShares` messages, the code directly inserts the received `kex_public_key` into storage without validating that it is not the identity point, generator point, or other invalid values.

**Location 4: Usage in Encryption** [4](#0-3) 

The unvalidated `kex_public_key` is used to derive shared secrets for encrypting DKG private shares.

**Root Cause:**
The protocol assumes that kex_public_keys are valid curve points but fails to enforce this cryptographically. The lack of validation combined with the unauthenticated field creates a critical vulnerability.

**Why Existing Mitigations Fail:**
- Message authentication is enabled by default [5](#0-4) , but since `kex_public_key` is not included in the message hash, it remains unauthenticated and can be modified by a MITM without invalidating signatures.
- Point validation exists for nonces [6](#0-5)  but is not applied to key exchange public keys.

### Impact Explanation

**Specific Harm:**
When `kex_public_key` is set to `Point::identity()`, the Diffie-Hellman computation produces:
- `shared_key = any_private_key * identity = identity`
- `shared_secret = KDF(identity.compress().as_bytes(), "DH_SHARED_SECRET_KEY/")`

This results in a deterministic, predictable shared secret that any attacker can compute without knowing private keys.

**Attack Impact:**
1. MITM intercepts DkgPublicShares from honest Signer A
2. MITM replaces A's `kex_public_key` with `Point::identity()` (signature remains valid)
3. Other honest signers encrypt DKG private shares for A using the predictable shared secret
4. MITM decrypts all private shares intended for Signer A
5. With private shares from ≥ threshold signers, MITM reconstructs the group private key
6. MITM gains full control of threshold signature operations and any associated funds

**Quantified Impact:**
- Threshold = t, Total signers = n
- MITM needs to compromise t signers' kex_public_keys
- Each compromised signer leaks all their polynomial shares
- With ≥ t shares, the group private key is fully reconstructed
- All funds controlled by this group key are lost

**Severity: Critical**
Meets "direct loss of funds" criterion from the protocol scope. The group private key controls signing operations that may authorize blockchain transactions worth arbitrary amounts.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Man-in-the-middle position on network communication between signers
- Ability to intercept and modify packets in transit
- No need for cryptographic breaks or private key knowledge

**Attack Complexity: Low**
1. Passive observation to identify DkgPublicShares messages
2. Simple point substitution (`kex_public_key → Point::identity()`)
3. Standard ANSI X9.63 KDF computation to derive predictable shared secret
4. AES-GCM decryption of intercepted encrypted shares

**Economic Feasibility:**
- Network MITM attacks are well-understood and tooling exists
- Attack works even with TLS if attacker controls infrastructure
- Single successful attack compromises entire DKG round
- Cost is minimal compared to potential fund theft

**Detection Risk: Low**
- Modified messages pass signature verification
- No cryptographic errors or exceptions are raised
- Honest signers cannot detect the manipulation
- Malicious decryption happens offline

**Estimated Probability: High**
- Works against default configuration (message auth enabled)
- No special timing or race conditions required
- Repeatable attack across all DKG rounds
- Success rate approaches 100% with MITM access

### Recommendation

**Primary Fix:**
Add validation in both `make_shared_secret()` and when receiving `kex_public_key`:

```rust
// In src/util.rs make_shared_secret():
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> Result<[u8; 32], Error> {
    let shared_key = private_key * public_key;
    
    // Validate shared key is not identity or generator
    if shared_key == Point::identity() || shared_key == G {
        return Err(Error::InvalidSharedKey);
    }
    
    Ok(make_shared_secret_from_key(&shared_key))
}

// In src/state_machine/signer/mod.rs dkg_public_share():
for key_id in signer_key_ids {
    // Validate kex_public_key before storing
    if dkg_public_shares.kex_public_key == Point::identity() 
        || dkg_public_shares.kex_public_key == G {
        warn!(%signer_id, "Invalid kex_public_key (identity or generator)");
        return Ok(vec![]);
    }
    self.kex_public_keys.insert(*key_id, dkg_public_shares.kex_public_key);
}
```

**Secondary Fix:**
Include `kex_public_key` in the `DkgPublicShares` signature hash:

```rust
// In src/net.rs DkgPublicShares::hash():
fn hash(&self, hasher: &mut Sha256) {
    hasher.update("DKG_PUBLIC_SHARES".as_bytes());
    hasher.update(self.dkg_id.to_be_bytes());
    hasher.update(self.signer_id.to_be_bytes());
    hasher.update(self.kex_public_key.compress().as_bytes()); // ADD THIS
    for (party_id, comm) in &self.comms {
        // ... rest unchanged
    }
}
```

**Testing Recommendations:**
1. Unit test: Verify `make_shared_secret()` rejects identity point
2. Unit test: Verify DKG rejects messages with invalid kex_public_keys
3. Integration test: Simulate MITM attack with identity substitution
4. Integration test: Verify encryption fails with predictable shared secrets

**Deployment Considerations:**
- Changes to message hashing break protocol compatibility
- Requires coordinated upgrade across all signers
- Add migration path for existing deployments
- Consider version negotiation for gradual rollout

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup:** Attacker positioned as MITM between Signer A and other signers
2. **Intercept:** Capture DkgPublicShares from Signer A
3. **Modify:** Replace `kex_public_key` with `Point::identity()`
4. **Forward:** Send modified message to other signers (signature still valid)
5. **Compute Predictable Secret:**
   ```
   identity_bytes = Point::identity().compress().as_bytes()  // 33 bytes
   shared_secret = SHA256(identity_bytes || 0x00000001 || "DH_SHARED_SECRET_KEY/")
   ```
6. **Decrypt:** When Signer B encrypts shares for A:
   ```
   encrypted_data = AES-GCM(shared_secret, nonce, plaintext_share)
   ```
   Attacker uses same `shared_secret` to decrypt
7. **Repeat:** Compromise threshold number of signers
8. **Reconstruct:** Use ≥ t private shares to reconstruct group private key via Lagrange interpolation

**Expected Behavior:** Encryption should fail or use unpredictable keys  
**Actual Behavior:** Encryption uses deterministic key derivable by attacker without any secrets

**Reproduction:**
1. Start DKG with message auth enabled
2. Inject identity point as kex_public_key in any DkgPublicShares message
3. Observe that encryption proceeds normally
4. Compute KDF with identity point bytes
5. Successfully decrypt shares intended for victim signer

### Citations

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/state_machine/signer/mod.rs (L347-347)
```rust
            verify_packet_sigs: true,
```

**File:** src/state_machine/signer/mod.rs (L941-942)
```rust
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1018-1021)
```rust
        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```

**File:** src/common.rs (L161-163)
```rust
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```
