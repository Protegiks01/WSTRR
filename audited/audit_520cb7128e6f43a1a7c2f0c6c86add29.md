### Title
Hash Collision Vulnerability in DkgPrivateBegin and DkgEndBegin Message Authentication

### Summary
The hash functions for `DkgPrivateBegin` and `DkgEndBegin` messages fail to encode vector boundaries when hashing their `key_ids` and `signer_ids` fields, allowing messages with different semantic content to produce identical hashes. This enables an attacker to modify coordinator-signed messages while maintaining valid signatures, causing DKG protocol failures and denial of service.

### Finding Description

**Exact Code Location:** [1](#0-0) [2](#0-1) 

**Root Cause:**
Both `DkgPrivateBegin::hash()` and `DkgEndBegin::hash()` iterate through `key_ids` and `signer_ids` vectors sequentially without length prefixes or separators. The hash computation concatenates vector elements directly: [1](#0-0) 

This creates hash collisions where structurally different messages produce identical hashes:
- Message A: `{ dkg_id: 1, key_ids: [2, 3], signer_ids: [] }`
- Message B: `{ dkg_id: 1, key_ids: [2], signer_ids: [3] }`  
- Message C: `{ dkg_id: 1, key_ids: [], signer_ids: [2, 3] }`

All three hash to: `"DKG_PRIVATE_BEGIN" + bytes(1) + bytes(2) + bytes(3)`

**Why Existing Mitigations Fail:**
The signature verification mechanism depends on hash uniqueness: [3](#0-2) 

Since multiple messages can produce the same hash, a signature valid for one message becomes valid for all colliding variants. The Packet verification logic checks signatures but cannot distinguish between messages that hash identically: [4](#0-3) 

### Impact Explanation

**DkgPrivateBegin Exploitation:**
When signers process `DkgPrivateBegin`, they use `signer_ids` to determine which key IDs should receive encrypted private shares: [5](#0-4) 

An attacker can swap vector contents to manipulate which participants receive shares:
- Coordinator sends: `{ key_ids: [], signer_ids: [1,2,3] }` (FIRE mode)
- Attacker modifies to: `{ key_ids: [1,2,3], signer_ids: [] }`
- Result: `active_key_ids` becomes empty, no shares are encrypted, DKG fails

**DkgEndBegin Exploitation:**
When signers finalize DKG, they use `signer_ids` to determine validation scope and threshold: [6](#0-5) 

An attacker can manipulate validation logic:
- Coordinator sends: `{ key_ids: [], signer_ids: [1,2,3] }` 
- Attacker modifies to: `{ key_ids: [1,2,3], signer_ids: [] }`
- Result: `signer_ids_set` becomes empty, threshold check fails, DKG aborts

**Severity Mapping:**
- **Low (minimum)**: "Any remotely-exploitable denial of service in a node" - This attack prevents individual nodes from completing DKG, blocking their ability to participate in threshold signing.
- **Medium (if widespread)**: "Any transient consensus failures" - If attackers intercept messages to multiple signers, the entire signing group cannot form, causing consensus delays until DKG is retried.

In blockchain contexts where WSTS coordinates threshold signatures for block validation or custody, failed DKG prevents new signing groups from forming, delaying transaction processing.

### Likelihood Explanation

**Required Attacker Capabilities:**
1. Network position to intercept coordinator-to-signer messages (man-in-the-middle or compromised relay node)
2. Ability to modify packet contents before forwarding
3. No cryptographic key material or signature forgery needed

**Attack Complexity:**
- **Low**: Simple message field swap, no computational requirements
- Attack succeeds deterministically - hash collision is guaranteed by construction
- No timing windows or race conditions required

**Economic Feasibility:**
- Negligible computational cost (basic message manipulation)
- Network interception ranges from trivial (if attacker controls relays) to moderate (if requiring active MITM)

**Detection Risk:**
- **Moderate to High**: Modified messages have valid signatures, appearing legitimate
- Distinguishable only by comparing coordinator's original message against received version
- Requires out-of-band message verification or coordinator message logging

**Estimated Probability:**
- **High** in scenarios where messages traverse untrusted infrastructure
- **Medium** in federated setups with multiple relay points
- **Low** in direct peer-to-peer communication with authenticated channels

The attack is practical in any multi-hop network topology common in distributed signing systems.

### Recommendation

**Primary Fix - Add Length Prefixes:**
Modify hash functions to encode vector lengths before elements:

```rust
fn hash(&self, hasher: &mut Sha256) {
    hasher.update("DKG_PRIVATE_BEGIN".as_bytes());
    hasher.update(self.dkg_id.to_be_bytes());
    
    // Encode key_ids with length prefix
    hasher.update((self.key_ids.len() as u32).to_be_bytes());
    for key_id in &self.key_ids {
        hasher.update(key_id.to_be_bytes());
    }
    
    // Encode signer_ids with length prefix  
    hasher.update((self.signer_ids.len() as u32).to_be_bytes());
    for signer_id in &self.signer_ids {
        hasher.update(signer_id.to_be_bytes());
    }
}
```

Apply the same pattern to `DkgEndBegin::hash()`.

**Alternative - Add Field Separators:**
Insert distinct domain separators between vector fields:
```rust
hasher.update("KEY_IDS".as_bytes());
for key_id in &self.key_ids { ... }
hasher.update("SIGNER_IDS".as_bytes());
for signer_id in &self.signer_ids { ... }
```

**Testing Recommendations:**
1. Add unit tests verifying hash uniqueness for messages with swapped vectors
2. Test that `{ key_ids: [a,b], signer_ids: [] }` and `{ key_ids: [], signer_ids: [a,b] }` produce different hashes
3. Verify signature validation rejects modified messages after fix

**Deployment Considerations:**
- This is a breaking change requiring coordinated upgrade across all coordinator and signer nodes
- Messages signed by old versions will fail verification by new versions and vice versa
- Requires network-wide deployment window or versioned protocol support

### Proof of Concept

**Step 1: Coordinator creates and signs legitimate message**
```rust
let legitimate_msg = DkgPrivateBegin {
    dkg_id: 1,
    key_ids: vec![],
    signer_ids: vec![2, 3, 4],
};

// Coordinator signs
let sig = legitimate_msg.sign(&coordinator_private_key).unwrap();
let packet = Packet {
    msg: Message::DkgPrivateBegin(legitimate_msg.clone()),
    sig: sig.clone(),
};

// Verify original passes
assert!(packet.verify(&public_keys, &coordinator_public_key));
```

**Step 2: Attacker modifies message while keeping signature**
```rust
let malicious_msg = DkgPrivateBegin {
    dkg_id: 1,
    key_ids: vec![2, 3, 4],  // Swapped from signer_ids
    signer_ids: vec![],       // Swapped from key_ids
};

let malicious_packet = Packet {
    msg: Message::DkgPrivateBegin(malicious_msg.clone()),
    sig: sig,  // Same signature as legitimate message
};

// Verify modified message also passes (vulnerability)
assert!(malicious_packet.verify(&public_keys, &coordinator_public_key));
```

**Step 3: Demonstrate hash collision**
```rust
let mut hasher1 = Sha256::new();
legitimate_msg.hash(&mut hasher1);
let hash1 = hasher1.finalize();

let mut hasher2 = Sha256::new();
malicious_msg.hash(&mut hasher2);
let hash2 = hasher2.finalize();

// Hashes are identical despite different message content
assert_eq!(hash1, hash2);
```

**Expected Behavior:**
Hashes should differ, causing signature verification to fail for the modified message.

**Actual Behavior:**  
Hashes are identical, allowing signature reuse across semantically different messages.

**Reproduction:**
Add this test to `src/net.rs`:
```rust
#[test]
fn test_hash_collision_dkg_private_begin() {
    let msg1 = DkgPrivateBegin {
        dkg_id: 1,
        key_ids: vec![2, 3],
        signer_ids: vec![],
    };
    
    let msg2 = DkgPrivateBegin {
        dkg_id: 1,
        key_ids: vec![],
        signer_ids: vec![2, 3],
    };
    
    let mut h1 = Sha256::new();
    msg1.hash(&mut h1);
    
    let mut h2 = Sha256::new();
    msg2.hash(&mut h2);
    
    assert_ne!(h1.finalize(), h2.finalize(), 
        "Different messages must hash differently");
}
```

This test will fail with the current implementation, confirming the vulnerability.

### Citations

**File:** src/net.rs (L32-45)
```rust
    /// Verify a hash of this object using the passed public key
    fn verify(&self, signature: &[u8], public_key: &ecdsa::PublicKey) -> bool {
        let mut hasher = Sha256::new();

        self.hash(&mut hasher);

        let hash = hasher.finalize();
        let sig = match ecdsa::Signature::try_from(signature) {
            Ok(sig) => sig,
            Err(_) => return false,
        };

        sig.verify(hash.as_slice(), public_key)
    }
```

**File:** src/net.rs (L177-187)
```rust
impl Signable for DkgPrivateBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PRIVATE_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }
        for signer_id in &self.signer_ids {
            hasher.update(signer_id.to_be_bytes());
        }
    }
```

**File:** src/net.rs (L230-240)
```rust
impl Signable for DkgEndBegin {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_END_BEGIN".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        for key_id in &self.key_ids {
            hasher.update(key_id.to_be_bytes());
        }
        for signer_id in &self.signer_ids {
            hasher.update(signer_id.to_be_bytes());
        }
    }
```

**File:** src/net.rs (L488-511)
```rust
    pub fn verify(
        &self,
        signers_public_keys: &PublicKeys,
        coordinator_public_key: &ecdsa::PublicKey,
    ) -> bool {
        match &self.msg {
            Message::DkgBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgBegin message with an invalid signature.");
                    return false;
                }
            }
            Message::DkgPrivateBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgPrivateBegin message with an invalid signature.");
                    return false;
                }
            }
            Message::DkgEndBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgEndBegin message with an invalid signature.");
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L529-549)
```rust
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
        let mut num_dkg_keys = 0u32;
        for id in &signer_ids_set {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(id) {
                let len: u32 = key_ids.len().try_into()?;
                num_dkg_keys = num_dkg_keys.saturating_add(len);
            }
        }

        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L904-910)
```rust
        for signer_id in &dkg_private_begin.signer_ids {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
                for key_id in key_ids {
                    active_key_ids.insert(*key_id);
                }
            }
        }
```
