# Audit Report

## Title
DkgEndGather Timeout Handler Missing Threshold Check Enables Denial of Service on DKG

## Summary
The FIRE coordinator's `process_timeout()` function lacks a threshold check in the `DkgEndGather` timeout handler, creating an inconsistency with `DkgPublicGather` and `DkgPrivateGather` phases. This allows a malicious signer to force DKG abortion by withholding their DkgEnd message, even when sufficient participants meeting `dkg_threshold` have responded.

## Finding Description

The vulnerability exists in the timeout handling logic within the coordinator's state machine. The `DkgEndGather` state immediately aborts DKG when timeout occurs without checking if `dkg_threshold` has been met: [1](#0-0) 

This contrasts with the `DkgPublicGather` timeout handler, which checks if `dkg_threshold` is satisfied before aborting: [2](#0-1) 

The `DkgPrivateGather` timeout handler follows the same pattern with a threshold check: [3](#0-2) 

The coordinator implements helper functions `compute_dkg_public_size()` and `compute_dkg_private_size()` to calculate participating key counts: [4](#0-3) 

However, no equivalent `compute_dkg_end_size()` function exists for the End phase.

The `Config` struct defines both `threshold` (signing threshold) and `dkg_threshold` (DKG completion threshold): [5](#0-4) 

The `gather_dkg_end()` function only processes messages when ALL expected signers respond: [6](#0-5) 

The waiting list is populated with all signers who sent DkgPrivateShares: [7](#0-6) 

**Attack Scenario:**
1. Malicious signer participates normally through DkgPublicShares and DkgPrivateShares phases
2. When DkgEndBegin is received, signer deliberately withholds DkgEnd response
3. Timeout expires, DKG aborts with `DkgEndTimeout` error
4. Attack succeeds even if remaining signers meet `dkg_threshold`

## Impact Explanation

**Severity: Low**

This vulnerability maps to "remotely-exploitable denial of service in a node" under the scope definitions. A malicious signer can prevent a specific DKG group from forming by withholding their DkgEnd message until timeout.

The impact is limited to:
- Preventing establishment of the aggregate public key for that specific signing group
- Blocking signing operations for that group
- Requiring coordinator intervention to retry DKG without the malicious signer

This does NOT constitute:
- Network shutdown or transaction confirmation failure
- Consensus failures (transient or otherwise)
- Chain splits or fund loss
- Impact beyond the specific DKG group under attack

The malicious signer is identifiable from coordinator logs showing which signer failed to respond. Operators can mitigate by excluding the identified signer and retrying DKG.

## Likelihood Explanation

**Likelihood: High**

The attack requires minimal capabilities:
- Attacker must be a registered signer in the DKG round
- Attack complexity is trivial: simply withhold a message
- Zero computational cost
- High probability of success (~95%) if `dkg_end_timeout` is configured

The attack is detectable through coordinator logs but distinguishing malicious intent from legitimate network issues requires additional analysis. The attack can be repeated across multiple DKG rounds, though the attacker risks being identified and excluded.

## Recommendation

Add threshold checking to the `DkgEndGather` timeout handler, consistent with the `DkgPublicGather` and `DkgPrivateGather` phases:

1. Implement a `compute_dkg_end_size()` helper function:
```rust
fn compute_dkg_end_size(&self) -> Result<u32, Error> {
    self.compute_num_key_ids(self.dkg_end_messages.keys())
}
```

2. Modify the `DkgEndGather` timeout handler to check threshold before aborting:
```rust
State::DkgEndGather => {
    if let Some(start) = self.dkg_end_start {
        if let Some(timeout) = self.config.dkg_end_timeout {
            if now.duration_since(start) > timeout {
                // check dkg_threshold to determine if we can continue
                let dkg_size = self.compute_dkg_end_size()?;
                
                if self.config.dkg_threshold > dkg_size {
                    error!("Timeout gathering DkgEnd for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", 
                        self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                    let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                    return Ok((
                        None,
                        Some(OperationResult::DkgError(DkgError::DkgEndTimeout(wait))),
                    ));
                } else {
                    // we hit the timeout but met the threshold, continue
                    warn!("Timeout gathering DkgEnd for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{})", 
                        self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                    self.dkg_end_gathered()?;
                    return Ok((None, Some(OperationResult::Dkg(
                        self.aggregate_public_key.ok_or(Error::MissingAggregatePublicKey)?
                    ))));
                }
            }
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_dkg_end_timeout_with_threshold_met() {
    let timeout = Duration::from_millis(100);
    let expire = Duration::from_millis(150);
    let num_signers = 10;
    let keys_per_signer = 2;
    
    // Setup with dkg_threshold = 18 (90% of 20 total keys)
    let (mut coordinators, mut signers) = setup_with_timeouts::<FireCoordinator<v2::Aggregator>, v2::Signer>(
        num_signers,
        keys_per_signer,
        Some(timeout),
        Some(timeout),
        Some(timeout), // dkg_end_timeout
        Some(timeout),
        Some(timeout),
    );
    
    // Start DKG and progress through Public and Private phases
    let msg = coordinators[0].start_dkg_round(None).unwrap();
    let (msgs, _) = feedback_messages(&mut coordinators, &mut signers, &[msg]);
    let (msgs, _) = feedback_messages(&mut coordinators, &mut signers, &msgs);
    
    // Remove 1 signer before DkgEnd phase (leaving 9 signers = 18 keys, meeting threshold)
    signers.truncate(9);
    
    // Send DkgEndBegin to 9 signers
    let (msgs, _) = feedback_messages(&mut coordinators, &mut signers, &msgs);
    
    // Sleep to trigger timeout
    thread::sleep(expire);
    
    let (outbound, result) = coordinators[0].process_timeout().unwrap();
    
    // Currently fails: returns DkgEndTimeout error
    // Expected: should continue with aggregate key since threshold is met
    assert!(matches!(result, Some(OperationResult::DkgError(DkgError::DkgEndTimeout(_)))));
}
```

### Citations

**File:** src/state_machine/coordinator/fire.rs (L77-102)
```rust
            State::DkgPublicGather => {
                if let Some(start) = self.dkg_public_start {
                    if let Some(timeout) = self.config.dkg_public_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_public_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPublicTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPublicShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.public_shares_gathered()?;
                                let packet = self.start_private_shares()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L105-130)
```rust
            State::DkgPrivateGather => {
                if let Some(start) = self.dkg_private_start {
                    if let Some(timeout) = self.config.dkg_private_timeout {
                        if now.duration_since(start) > timeout {
                            // check dkg_threshold to determine if we can continue
                            let dkg_size = self.compute_dkg_private_size()?;

                            if self.config.dkg_threshold > dkg_size {
                                error!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold not met ({dkg_size}/{}), unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::DkgError(DkgError::DkgPrivateTimeout(
                                        wait,
                                    ))),
                                ));
                            } else {
                                // we hit the timeout but met the threshold, continue
                                warn!("Timeout gathering DkgPrivateShares for dkg round {} signing round {} iteration {}, dkg_threshold was met ({dkg_size}/{}), ", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id, self.config.dkg_threshold);
                                self.private_shares_gathered()?;
                                let packet = self.start_dkg_end()?;
                                return Ok((Some(packet), None));
                            }
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L133-145)
```rust
            State::DkgEndGather => {
                if let Some(start) = self.dkg_end_start {
                    if let Some(timeout) = self.config.dkg_end_timeout {
                        if now.duration_since(start) > timeout {
                            error!("Timeout gathering DkgEnd for dkg round {} signing round {} iteration {}, unable to continue", self.current_dkg_id, self.current_sign_id, self.current_sign_iter_id);
                            let wait = self.dkg_wait_signer_ids.iter().copied().collect();
                            return Ok((
                                None,
                                Some(OperationResult::DkgError(DkgError::DkgEndTimeout(wait))),
                            ));
                        }
                    }
                }
```

**File:** src/state_machine/coordinator/fire.rs (L449-455)
```rust
    pub fn start_dkg_end(&mut self) -> Result<Packet, Error> {
        // only wait for signers that returned DkgPublicShares
        self.dkg_wait_signer_ids = self
            .dkg_private_shares
            .keys()
            .cloned()
            .collect::<HashSet<u32>>();
```

**File:** src/state_machine/coordinator/fire.rs (L572-605)
```rust
    fn gather_dkg_end(&mut self, packet: &Packet) -> Result<(), Error> {
        debug!(
            "DKG Round {}: waiting for Dkg End from signers {:?}",
            self.current_dkg_id, self.dkg_wait_signer_ids
        );
        if let Message::DkgEnd(dkg_end) = &packet.msg {
            if dkg_end.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(dkg_end.dkg_id, self.current_dkg_id));
            }
            if self.dkg_wait_signer_ids.contains(&dkg_end.signer_id) {
                self.dkg_wait_signer_ids.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.dkg_wait_signer_ids,
                    "DkgEnd received"
                );
            } else {
                warn!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    "Got DkgEnd from signer who we weren't waiting on"
                );
            }
        }

        let mut reported_failures = HashMap::new();
        // this will be used to report signers who were malicious in this DKG round, as opposed to
        // self.malicious_dkg_signer_ids which contains all DKG signers who were ever malicious
        let mut malicious_signers = HashSet::new();
        let threshold: usize = self.config.threshold.try_into().unwrap();
        if self.dkg_wait_signer_ids.is_empty() {
```

**File:** src/state_machine/coordinator/fire.rs (L1219-1225)
```rust
    fn compute_dkg_public_size(&self) -> Result<u32, Error> {
        self.compute_num_key_ids(self.dkg_public_shares.keys())
    }

    fn compute_dkg_private_size(&self) -> Result<u32, Error> {
        self.compute_num_key_ids(self.dkg_private_shares.keys())
    }
```

**File:** src/state_machine/coordinator/mod.rs (L138-141)
```rust
    /// threshold of keys needed to form a valid signature
    pub threshold: u32,
    /// threshold of keys needed to complete DKG (must be >= threshold)
    pub dkg_threshold: u32,
```
