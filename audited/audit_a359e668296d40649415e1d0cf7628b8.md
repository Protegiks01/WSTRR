### Title
Missing Identity Element Validation in KEX Public Key Allows Trivial Shared Secret Computation and Private Share Disclosure

### Summary
The `get_kex_public_key()` function and the `dkg_public_shares()` handler do not validate that KEX public keys are not the identity element (point at infinity). A malicious signer can broadcast `Point::identity()` as their KEX public key, causing all Diffie-Hellman shared secrets involving that signer to become a fixed, predictable value. This allows anyone to decrypt the DKG private shares, breaking the confidentiality requirement and potentially enabling reconstruction of the distributed private key.

### Finding Description

**Exact Code Location:**
- File: `src/state_machine/signer/mod.rs`
- Function: `get_kex_public_key()` at lines 1112-1129
- Function: `dkg_public_shares()` at lines 1019-1020  
- Function: `dkg_private_shares()` at line 1043 (usage) and lines 1069-1070 (shared secret computation)

**Root Cause:**
The KEX public keys received in `DkgPublicShares` messages are stored directly into `self.kex_public_keys` without validating that they are not the identity element. [1](#0-0) 

The `get_kex_public_key()` function simply retrieves and returns the stored Point without any validation. [2](#0-1) 

When the retrieved KEX public key is used in `dkg_private_shares()` to compute the shared secret via `make_shared_secret()`, no validation occurs. [3](#0-2) [4](#0-3) 

The `make_shared_secret()` function performs standard Diffie-Hellman key exchange by multiplying the private key with the public key. [5](#0-4)  When the public key is `Point::identity()`, the multiplication `private_key * Point::identity()` always equals `Point::identity()` for any scalar, producing a fixed, predictable shared key. [6](#0-5) 

**Why Existing Mitigations Fail:**
The codebase demonstrates awareness of identity element risks in other contexts - `PublicNonce::is_valid()` explicitly checks that nonce points are not the identity element. [7](#0-6)  However, no such validation is applied to KEX public keys.

While decrypted shares are validated against polynomial commitments later in the protocol, this does not prevent the confidentiality breach. The shares can still be decrypted by unauthorized parties before validation occurs.

### Impact Explanation

**Specific Harm:**
When a malicious signer uses `Point::identity()` as their KEX public key, all Diffie-Hellman shared secrets computed with that signer become the fixed value derived from `Point::identity()`. This makes the encrypted private shares publicly readable to anyone who recognizes the attack.

**Quantified Impact:**
In WSTS's weighted threshold scheme, if an attacker can decrypt shares from/to even one malicious participant, they gain knowledge of polynomial evaluations that are components of the distributed private key. The protocol's security depends on keeping these shares confidential. With sufficient compromised shares (meeting the threshold), an attacker can reconstruct the complete distributed private key using Lagrange interpolation.

**Who is Affected:**
All signers participating in DKG with a malicious signer who broadcasts `Point::identity()` as their KEX public key. Their private shares become readable to any observer.

**Severity Justification:**
This vulnerability maps to **Critical** severity under the protocol scope definition: "Any causing the direct loss of funds other than through any form of freezing." If the distributed private key is reconstructed, the attacker gains full control over funds protected by the threshold signature scheme, enabling unauthorized transactions and direct theft.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Attacker must be a valid participant in the DKG protocol with the ability to send `DkgPublicShares` messages
- No special cryptographic knowledge or computational resources required
- Attack requires no breaking of cryptographic primitives

**Attack Complexity:**
Low. The attacker simply needs to:
1. Generate a `DkgPublicShares` message with `kex_public_key` field set to `Point::identity()`
2. Broadcast this message during the DKG public share distribution phase
3. Observe encrypted private shares on the network
4. Decrypt using the known shared secret derived from `Point::identity()`

**Economic Feasibility:**
Highly feasible. The attack costs no more than participating normally in DKG, with the only modification being setting the KEX public key to the identity element instead of generating a proper ephemeral key.

**Detection Risk:**
Low detection risk. The attack may not be detected until shares fail validation (if they're crafted incorrectly) or until the compromised key is used to sign unauthorized transactions. The protocol does not log or monitor KEX public key values for validity.

**Estimated Probability:**
High. Any malicious participant can execute this attack with near certainty of success in compromising share confidentiality.

### Recommendation

**Proposed Code Changes:**

In `dkg_public_shares()` function, add validation before storing the KEX public key:

```rust
// After line 1017, before the loop at line 1018:
if dkg_public_shares.kex_public_key == Point::identity() {
    warn!(%signer_id, "KEX public key is the identity element");
    return Ok(vec![]);
}
```

Additionally, add a defensive check in `get_kex_public_key()`:

```rust
// After line 1126, before returning:
if kex_public_key == &Point::identity() {
    warn!(%signer_id, %signer_key_id, "KEX public key is the identity element");
    return Err(Error::InvalidKexPublicKey(*signer_key_id));
}
```

**Alternative Mitigations:**
- Add validation in the `DkgPublicShares` message deserialization or construction
- Implement a general point validation function that checks for identity element and other invalid point properties
- Add unit tests that specifically verify identity element rejection

**Testing Recommendations:**
- Add unit test that attempts to process `DkgPublicShares` with `Point::identity()` and verifies rejection
- Add integration test that verifies encrypted shares cannot be decrypted with predictable shared secrets
- Test that legitimate KEX public keys (non-identity points) continue to work correctly

**Deployment Considerations:**
This fix must be deployed to all participants before any DKG round, as a single unpatched participant could still fall victim to the attack if they receive a malicious KEX public key.

### Proof of Concept

**Exploitation Steps:**

1. **Malicious Signer Setup:**
   - Attacker participates in DKG as Signer A
   - Attacker sets their `kex_private_key = Scalar::zero()` (optional, for symmetry)
   - Attacker creates `DkgPublicShares` message with `kex_public_key = Point::identity()`

2. **Broadcast Malicious Message:**
   - Attacker broadcasts the `DkgPublicShares` during the DKG public distribution phase
   - Other signers receive and store `Point::identity()` at lines 1019-1020 without validation

3. **Shared Secret Computation:**
   - When Signer B encrypts shares for Signer A: `shared_secret = B_private * Point::identity() = Point::identity()`
   - When Signer B decrypts shares from Signer A: `shared_secret = B_private * Point::identity() = Point::identity()`
   - Both compute the same fixed shared secret

4. **Decrypt Private Shares:**
   - The shared secret bytes are: `ansi_x963_derive_key(Point::identity().compress().as_bytes(), "DH_SHARED_SECRET_KEY/")`
   - This value is constant and can be precomputed by anyone
   - Attacker (or any observer) can decrypt all encrypted shares involving Signer A

5. **Key Reconstruction:**
   - With sufficient decrypted shares meeting the threshold, use Lagrange interpolation to reconstruct the distributed private key
   - Use the private key to sign unauthorized transactions

**Expected vs Actual Behavior:**
- **Expected:** KEX public keys should be validated as non-identity elements, ensuring shared secrets require knowledge of private keys
- **Actual:** Identity element KEX public keys are accepted, creating predictable shared secrets that anyone can compute

**Reproduction Instructions:**
1. Modify a signer to set `kex_public_key = Point::identity()` in `DkgPublicShares`
2. Run DKG with this malicious signer and observe that other signers accept the message
3. Intercept encrypted `DkgPrivateShares` messages
4. Compute the fixed shared secret from `Point::identity()` compression
5. Successfully decrypt the shares without any private key knowledge

### Citations

**File:** src/state_machine/signer/mod.rs (L1019-1020)
```rust
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
```

**File:** src/state_machine/signer/mod.rs (L1043-1045)
```rust
        let Ok(kex_public_key) = self.get_kex_public_key(src_signer_id) else {
            return Ok(vec![]);
        };
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/state_machine/signer/mod.rs (L1112-1129)
```rust
    fn get_kex_public_key(&self, signer_id: u32) -> Result<Point, Error> {
        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(signer_key_id) = signer_key_ids.iter().next() else {
            warn!(%signer_id, "No key_ids configured");
            return Err(Error::Config(ConfigError::InvalidSignerId(signer_id)));
        };

        let Some(kex_public_key) = self.kex_public_keys.get(signer_key_id) else {
            warn!(%signer_id, %signer_key_id, "No KEX public key configured");
            return Err(Error::MissingKexPublicKey(*signer_key_id));
        };

        Ok(*kex_public_key)
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```

**File:** src/util.rs (L55-60)
```rust
pub fn make_shared_secret_from_key(shared_key: &Point) -> [u8; 32] {
    ansi_x963_derive_key(
        shared_key.compress().as_bytes(),
        "DH_SHARED_SECRET_KEY/".as_bytes(),
    )
}
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```
