### Title
FROST Coordinator Fails to Validate Bad Private Share Claims, Enabling Persistent DKG Denial of Service

### Summary
The FROST coordinator does not validate decrypted private shares against public commitments when signers report bad shares during DKG. A malicious signer can falsely accuse honest participants of sending invalid shares, causing DKG to fail without the coordinator identifying the malicious actor. This enables a persistent denial of service attack that prevents the network from establishing an aggregate public key required for signing operations.

### Finding Description

**Code Location:** [1](#0-0) 

The FROST coordinator's `gather_dkg_end` function collects failure reports from signers but does not validate the claims. When signers report `DkgStatus::Failure(DkgFailure::BadPrivateShares(...))`, the coordinator simply aggregates these reports and returns an error with an empty `malicious_signers` set: [2](#0-1) 

**Root Cause:**
The FROST coordinator lacks the cryptographic validation logic present in the FIRE coordinator. It does not:
1. Import the required validation functions (`decrypt`, `make_shared_secret_from_key`, `check_public_shares`)
2. Verify DH tuple proofs for reported bad shares
3. Decrypt the allegedly bad private shares
4. Validate decrypted shares against polynomial commitments

**Contrasting Implementation:**
The FIRE coordinator correctly validates bad share claims: [3](#0-2) 

The FIRE implementation:
- Verifies the DH tuple proof to ensure the shared key is correct
- Decrypts the private shares using the shared secret
- Validates each share against polynomial commitments by checking `private_eval * G == poly_eval`
- Marks the appropriate party (false accuser or actual sender of bad shares) as malicious [4](#0-3) 

**Why Existing Mitigations Fail:**
Signers do validate shares locally, but the coordinator must independently verify failure reports to attribute malicious behavior. Without coordinator validation, the system cannot distinguish between:
- Honest signers reporting legitimate bad shares
- Malicious signers making false accusations

The DkgFailure structure includes cryptographic proofs specifically for coordinator verification: [5](#0-4) 

However, FROST coordinator never uses these proofs.

### Impact Explanation

**Specific Harm:**
A single malicious signer participating in FROST-based DKG can prevent the network from ever establishing an aggregate public key by repeatedly making false accusations against honest participants.

**Attack Flow:**
1. Malicious signer M joins DKG with honest signers H1, H2, ..., Hn
2. All parties exchange valid public and private shares
3. During DkgEnd phase, M falsely reports `DkgFailure::BadPrivateShares` claiming H1 sent invalid shares
4. FROST coordinator accepts this claim without verification
5. DKG fails with no identification of M as malicious
6. Coordinator retries DKG; M can repeat the attack indefinitely

**Quantified Impact:**
- **Network Shutdown**: DKG cannot complete, preventing signature generation required for block validation
- **Persistent DoS**: Attack is repeatable; malicious signer is never identified or excluded
- **Scope Mapping**: Maps to **Critical** severity - "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks"

In a Stacks blockchain context using WSTS for validator signing:
- No aggregate public key = no threshold signatures
- No threshold signatures = no block confirmations
- Result: Complete network halt until manual intervention

**Who is Affected:**
All participants in FROST-based DKG. The FIRE coordinator implementation is not vulnerable as it performs proper validation.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of one signer in the DKG participant set
- No cryptographic breaks required
- No insider access or special privileges needed beyond being a registered participant

**Attack Complexity:**
Trivial. The attacker simply needs to:
1. Participate normally in public and private share exchange
2. Send a DkgEnd message with false `DkgFailure::BadPrivateShares` claim
3. Repeat as needed

**Economic Feasibility:**
Extremely low cost. The attack:
- Requires no computational resources beyond normal DKG participation
- Cannot be economically disincentivized since malicious party is not identified
- Has no gas costs or on-chain footprint

**Detection Risk:**
Zero. The FROST coordinator:
- Does not log which signers are making false accusations
- Returns empty `malicious_signers` set to calling code
- Cannot distinguish false claims from legitimate failures [6](#0-5) 

**Probability of Success:**
100% given the prerequisites. The vulnerability is deterministic - FROST coordinator will always fail to validate claims and always fail to identify the malicious signer.

### Recommendation

**Primary Fix:**
Port the validation logic from FIRE coordinator to FROST coordinator. The FROST coordinator should:

1. Import required validation utilities: [7](#0-6) [8](#0-7) [9](#0-8) 

2. Implement `BadPrivateShares` validation in `gather_dkg_end`:
   - Verify DH tuple proofs for each reported bad share
   - Decrypt shares using the shared secret
   - Validate against polynomial commitments
   - Mark appropriate parties as malicious based on verification results

3. Maintain a `malicious_signers` HashSet and populate it during validation
4. Return non-empty `malicious_signers` in the DkgFailure error

**Alternative Mitigation:**
If FROST is intended to be a lightweight coordinator without validation capabilities, clearly document this limitation and recommend using FIRE coordinator for production deployments where malicious behavior is a concern.

**Testing Recommendations:**
1. Add test case where one signer falsely reports bad shares from another
2. Verify coordinator correctly identifies the false accuser as malicious
3. Ensure legitimate bad share reports correctly identify the sender as malicious
4. Test that DKG can complete after excluding identified malicious signers

**Deployment Considerations:**
- Existing FROST deployments are vulnerable and should migrate to FIRE coordinator
- If backward compatibility is required, add a configuration flag to enable/disable validation
- Update documentation to clearly state which coordinator implementations provide malicious signer detection

### Proof of Concept

**Attack Algorithm:**
```
Setup:
- Network using FROST coordinator with n signers (signer_0, signer_1, ..., signer_n-1)
- Attacker controls signer_0
- DKG threshold requires participation of all n signers

Exploitation Steps:

1. DKG Round Begins:
   - Coordinator sends DkgBegin(dkg_id=X)
   - All signers (including attacker) generate valid polynomials and send DkgPublicShares

2. Private Share Distribution:
   - Coordinator sends DkgPrivateBegin
   - All signers (including attacker) send valid encrypted DkgPrivateShares
   - All honest signers successfully decrypt and validate shares

3. DKG End Phase (Attack):
   - Coordinator sends DkgEndBegin
   - Honest signers send DkgEnd(status=Success)
   - Attacker sends DkgEnd(status=Failure(BadPrivateShares({1: BadPrivateShare{...}})))
     claiming signer_1 sent bad shares (false claim)

4. Coordinator Response:
   - Coordinator collects all DkgEnd messages
   - Sees failure report from signer_0
   - Returns Error::DkgFailure with malicious_signers={}  (empty!)
   - DKG aborts without identifying signer_0 as malicious

5. Repeat:
   - Next DKG round includes signer_0 again (not excluded)
   - Attacker repeats attack
   - Result: Persistent DoS, DKG never completes
```

**Expected vs Actual Behavior:**

Expected (FIRE coordinator): [10](#0-9) 

Actual (FROST coordinator): [2](#0-1) 

**Reproduction:**
Use the existing test framework with FROST coordinator: [11](#0-10) 

Modify to have one signer send false BadPrivateShares claim. Observe that DKG fails but malicious_signers remains empty, allowing repeated attacks.

### Citations

**File:** src/state_machine/coordinator/frost.rs (L377-420)
```rust
    fn gather_dkg_end(&mut self, packet: &Packet) -> Result<(), Error> {
        debug!(
            dkg_id = %self.current_dkg_id,
            waiting = ?self.ids_to_await,
            "Waiting for Dkg End from signers"
        );
        if let Message::DkgEnd(dkg_end) = &packet.msg {
            if dkg_end.dkg_id != self.current_dkg_id {
                return Err(Error::BadDkgId(dkg_end.dkg_id, self.current_dkg_id));
            }
            if self.ids_to_await.contains(&dkg_end.signer_id) {
                self.ids_to_await.remove(&dkg_end.signer_id);
                self.dkg_end_messages
                    .insert(dkg_end.signer_id, dkg_end.clone());
                debug!(
                    dkg_id = %dkg_end.dkg_id,
                    signer_id = %dkg_end.signer_id,
                    waiting = ?self.ids_to_await,
                    "DkgEnd received"
                );
            }
        }

        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
        }
        Ok(())
    }
```

**File:** src/state_machine/coordinator/fire.rs (L6-6)
```rust
    common::{check_public_shares, PolyCommitment, PublicNonce, Signature, SignatureShare},
```

**File:** src/state_machine/coordinator/fire.rs (L10-10)
```rust
        point::{Point, G},
```

**File:** src/state_machine/coordinator/fire.rs (L26-26)
```rust
    util::{decrypt, make_shared_secret_from_key},
```

**File:** src/state_machine/coordinator/fire.rs (L652-763)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
                                // verify the DH tuple proof first so we know the shared key is correct
                                let Some(signer_key_ids) =
                                    self.config.public_keys.signer_key_ids.get(signer_id)
                                else {
                                    warn!("No key IDs for signer_id {signer_id} DkgEnd");
                                    continue;
                                };
                                let Some(signer_public_shares) =
                                    self.dkg_public_shares.get(signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {signer_id}");
                                    continue;
                                };
                                let signer_public_key = signer_public_shares.kex_public_key;

                                let Some(bad_signer_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but there are no public shares from {bad_signer_id}, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let bad_signer_public_key = bad_signer_public_shares.kex_public_key;

                                let mut is_bad = false;

                                if bad_private_share.tuple_proof.verify(
                                    &signer_public_key,
                                    &bad_signer_public_key,
                                    &bad_private_share.shared_key,
                                ) {
                                    // verify at least one bad private share for one of signer_id's key_ids
                                    let shared_secret =
                                        make_shared_secret_from_key(&bad_private_share.shared_key);

                                    let polys = bad_signer_public_shares
                                        .comms
                                        .iter()
                                        .cloned()
                                        .collect::<HashMap<u32, PolyCommitment>>();
                                    let Some(dkg_private_shares) =
                                        self.dkg_private_shares.get(bad_signer_id)
                                    else {
                                        warn!("Signer {signer_id} reported BadPrivateShare from signer {bad_signer_id} who didn't send public shares, mark {signer_id} as malicious");
                                        malicious_signers.insert(*signer_id);
                                        continue;
                                    };

                                    for (src_party_id, key_shares) in &dkg_private_shares.shares {
                                        let Some(poly) = polys.get(src_party_id) else {
                                            warn!("Signer {signer_id} reported BadPrivateShares from {bad_signer_id} but the private shares from {bad_signer_id} dont have a polynomial for party {src_party_id}");
                                            continue;
                                        };
                                        for key_id in signer_key_ids {
                                            let Some(bytes) = key_shares.get(key_id) else {
                                                warn!("DkgPrivateShares from party_id {src_party_id} did not include a share for key_id {key_id}");
                                                continue;
                                            };
                                            match decrypt(&shared_secret, bytes) {
                                                Ok(plain) => match Scalar::try_from(&plain[..]) {
                                                    Ok(private_eval) => {
                                                        let poly_eval = match compute::poly(
                                                            &compute::id(*key_id),
                                                            &poly.poly,
                                                        ) {
                                                            Ok(p) => p,
                                                            Err(e) => {
                                                                warn!("Failed to evaluate public poly from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                                is_bad = true;
                                                                break;
                                                            }
                                                        };

                                                        if private_eval * G != poly_eval {
                                                            warn!("Invalid dkg private share from signer_id {bad_signer_id} to key_id {key_id}");

                                                            is_bad = true;
                                                            break;
                                                        }
                                                    }
                                                    Err(e) => {
                                                        warn!("Failed to parse Scalar for dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");

                                                        is_bad = true;
                                                        break;
                                                    }
                                                },
                                                Err(e) => {
                                                    warn!("Failed to decrypt dkg private share from signer_id {bad_signer_id} to key_id {key_id}: {e:?}");
                                                    is_bad = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    warn!("TupleProof failed to verify, mark {signer_id} as malicious");
                                    is_bad = false;
                                }

                                // if tuple proof failed or none of the shares were bad sender was malicious
                                if !is_bad {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPrivateShare from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/net.rs (L50-55)
```rust
pub struct BadPrivateShare {
    /// the DH shared key between these participants
    pub shared_key: Point,
    /// prooof that the shared key is a valid DH tuple as per chaum-pedersen
    pub tuple_proof: TupleProof,
}
```

**File:** src/state_machine/coordinator/mod.rs (L1777-1879)
```rust
    pub fn empty_private_shares<Coordinator: CoordinatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
    ) {
        let (mut coordinators, mut signers) =
            setup::<Coordinator, SignerType>(num_signers, keys_per_signer);

        // We have started a dkg round
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_dkg_round(None)
            .unwrap();
        assert!(coordinators
            .first_mut()
            .unwrap()
            .get_aggregate_public_key()
            .is_none());
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::DkgPublicGather
        );

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        for coordinator in coordinators.iter() {
            assert_eq!(coordinator.get_state(), State::DkgPrivateGather);
        }

        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::DkgPrivateBegin(_)),
            "Expected DkgPrivateBegin message"
        );

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) = feedback_mutated_messages(
            &mut coordinators,
            &mut signers,
            &[outbound_messages[0].clone()],
            |signer, packets| {
                if signer.signer_id != 0 {
                    return packets.clone();
                }
                packets
                    .iter()
                    .map(|packet| {
                        let Message::DkgPrivateShares(shares) = &packet.msg else {
                            return packet.clone();
                        };
                        let private_shares = crate::net::DkgPrivateShares {
                            dkg_id: shares.dkg_id,
                            signer_id: shares.signer_id,
                            shares: vec![],
                        };
                        Packet {
                            msg: Message::DkgPrivateShares(private_shares),
                            sig: vec![],
                        }
                    })
                    .collect()
            },
        );
        assert_eq!(operation_results.len(), 0);
        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(&outbound_messages[0].msg, Message::DkgEndBegin(_)),
            "Expected DkgEndBegin message"
        );

        // Send the DkgEndBegin message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &outbound_messages);
        assert_eq!(outbound_messages.len(), 0);
        assert_eq!(operation_results.len(), 1);
        let OperationResult::DkgError(DkgError::DkgEndFailure {
            reported_failures, ..
        }) = &operation_results[0]
        else {
            panic!(
                "Expected OperationResult::DkgError(DkgError::DkgEndFailure) got {:?}",
                operation_results[0]
            );
        };
        assert_eq!(
            reported_failures.len(),
            num_signers as usize,
            "Expected {num_signers} DkgFailures got {}",
            reported_failures.len()
        );
        let expected_signer_ids = (0..1).collect::<HashSet<u32>>();
        for dkg_failure in reported_failures {
            let (_, DkgFailure::MissingPrivateShares(signer_ids)) = dkg_failure else {
                panic!("Expected DkgFailure::MissingPublicShares got {dkg_failure:?}");
            };
            assert_eq!(
                expected_signer_ids, *signer_ids,
                "Expected signer_ids {expected_signer_ids:?} got {signer_ids:?}"
            );
        }
    }
```
