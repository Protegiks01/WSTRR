### Title
Signature Type Not Bound in Nonce Commitment Phase Allows Coordinator to Change Signature Parameters

### Summary
The WSTS protocol fails to bind the `signature_type` parameter during the nonce commitment phase, allowing a malicious coordinator to change the signature type between `NonceRequest` and `SignatureShareRequest`. This breaks the fundamental binding property of the FROST protocol and enables signers to unknowingly create signatures with different cryptographic properties (FROST vs Schnorr vs Taproot) or different Taproot merkle roots than originally intended.

### Finding Description

**Exact Code Locations:**

1. **Missing signature_type in NonceResponse** [1](#0-0) 

2. **Signature_type not included in binding computation** [2](#0-1) 

3. **Signer uses signature_type from SignatureShareRequest without validation** [3](#0-2) 

4. **NonceRequest includes signature_type** [4](#0-3) 

**Root Cause:**

The FROST protocol requires that all signature parameters be cryptographically bound during the nonce commitment phase. However, WSTS has three critical flaws:

1. The `compute::binding()` function only commits to party_id, nonces, and message - it does NOT include `signature_type`

2. The `NonceResponse` message does not echo back the `signature_type` from the `NonceRequest`, making it impossible for signers to verify consistency later

3. When signers receive a `SignatureShareRequest`, they blindly use whatever `signature_type` is provided without checking if it matches what was sent in the original `NonceRequest`

The signature_type determines critical cryptographic properties: [5](#0-4) 

- `SignatureType::Frost`: No tweaks applied
- `SignatureType::Schnorr`: BIP-340 parity adjustments 
- `SignatureType::Taproot(merkle_root)`: BIP-341 tweak with specific merkle root

**Why Existing Mitigations Fail:**

The honest coordinator implementation maintains consistency by carrying `signature_type` through state transitions: [6](#0-5) 

However, this is merely an implementation detail that provides no cryptographic guarantee. A malicious or compromised coordinator can trivially bypass this by:
1. Sending different signature_types between phases
2. Exploiting that signers have no way to detect the change

### Impact Explanation

**Specific Harm:**

A malicious coordinator can trick signers into creating signatures with fundamentally different cryptographic properties than they agreed to:

1. **Taproot Merkle Root Substitution**: Most critically, for `SignatureType::Taproot(merkle_root)`, the coordinator can change the merkle root between nonce and signature phases. The merkle root commits to a tree of Bitcoin scripts. Changing it means signers unknowingly authorize spending to completely different scripts than intended.

2. **Signature Type Substitution**: Coordinator can change from `Frost` (no tweaks) to `Taproot` (with tweaks), causing signers to create BIP-341 tweaked signatures when they expected standard FROST signatures.

3. **Protocol Security Model Violation**: The binding property is fundamental to threshold signature security. Breaking it means signers cannot trust that the signature they're creating matches their intentions.

**Quantified Impact:**

In a Bitcoin/Stacks context with 10 signers (threshold 7):
- Coordinator sends `NonceRequest` with `SignatureType::Taproot(merkle_root_A)` 
- After receiving nonces, coordinator sends `SignatureShareRequest` with `SignatureType::Taproot(merkle_root_B)`
- 7 signers compute shares with merkle_root_B (unknowingly)
- Resulting signature authorizes spending to scripts in tree B, not tree A
- Signers thought they were authorizing tree A

**Severity Justification:**

This maps to **HIGH** severity under "Any unintended chain split or network partition" because:
- In Stacks/Bitcoin integration, different signature types could cause nodes to process transactions differently
- Breaks fundamental security assumptions of threshold signatures
- Enables authorization bypass - signers authorize actions they didn't intend
- Could lead to transient consensus failures if different parties expect different signature types

### Likelihood Explanation

**Required Attacker Capabilities:**
- Position: Malicious or compromised coordinator
- Access: Ability to send network messages to signers
- No cryptographic breaks required
- No secret keys needed

**Attack Complexity:**
- Very Low: Trivial modification to coordinator code
- Coordinator simply sends different signature_type values in NonceRequest vs SignatureShareRequest
- No timing requirements or race conditions
- 100% reliable if coordinator is malicious

**Economic Feasibility:**
- Free to execute (just network messages)
- No resource requirements beyond running coordinator node
- Undetectable by signers (no validation exists)

**Detection Risk:**
- Zero detection risk during attack
- Only discoverable post-facto if resulting signature has unexpected properties
- No logging or alerts would trigger

**Estimated Probability of Success:**
- 100% if coordinator is malicious
- Signers have no mechanism to detect or prevent the attack

### Recommendation

**Primary Fix - Include signature_type in binding:**

1. Modify `compute::binding()` to include signature_type in the hash computation:
```rust
// In src/compute.rs, line 17-33
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8], signature_type: &SignatureType) -> Scalar {
    let prefix = b"WSTS/binding";
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());
    
    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }
    
    buf.extend_from_slice(msg);
    
    // Add signature_type to binding
    match signature_type {
        SignatureType::Frost => buf.extend_from_slice(b"FROST"),
        SignatureType::Schnorr => buf.extend_from_slice(b"SCHNORR"),
        SignatureType::Taproot(merkle_root) => {
            buf.extend_from_slice(b"TAPROOT");
            if let Some(root) = merkle_root {
                buf.extend_from_slice(root);
            }
        }
    }
    
    expand_to_scalar(&buf, prefix).expect("...")
}
```

2. Add `signature_type` field to `NonceResponse` in src/net.rs so signers echo back what they committed to

3. Modify `sign_share_request()` in src/state_machine/signer/mod.rs to validate that the signature_type in SignatureShareRequest matches the signature_type in the cached NonceResponses

**Alternative Mitigation:**

Store the signature_type from NonceRequest in signer state and validate it matches SignatureShareRequest.signature_type before computing shares.

**Testing Recommendations:**
1. Add test case where coordinator sends different signature_types between phases
2. Verify validation correctly rejects mismatched signature_types
3. Test all signature_type combinations (Frost→Schnorr, Schnorr→Taproot, etc.)
4. Test Taproot merkle_root changes specifically

**Deployment Considerations:**
- Breaking protocol change - requires coordinated upgrade of all signers and coordinators
- Signatures created before fix will be incompatible
- Consider versioning in protocol messages

### Proof of Concept

**Exploitation Steps:**

1. **Setup**: Deploy WSTS with 5 signers (threshold 3), coordinator controls signing rounds

2. **Attack Execution:**

```
Step 1: Coordinator initiates signing round
- Sends NonceRequest with:
  - message: "Transfer 100 BTC to address A"
  - signature_type: SignatureType::Taproot(Some(merkle_root_A))
  
Step 2: Signers generate nonces
- Signers compute nonces using their private nonce values
- Signers send NonceResponse (note: does NOT include signature_type)
- Binding computed as: binding(party_id, nonces, message)
  ❌ signature_type NOT included in binding

Step 3: Malicious coordinator switches signature_type  
- Coordinator receives all NonceResponses
- Coordinator sends SignatureShareRequest with:
  - message: "Transfer 100 BTC to address A" (same)
  - signature_type: SignatureType::Taproot(Some(merkle_root_B)) ⚠️ CHANGED
  - nonce_responses: (from step 2)

Step 4: Signers compute shares with wrong type
- Signers receive SignatureShareRequest
- ❌ No validation that signature_type matches original
- Signers compute shares using merkle_root_B tweak
- Binding value is SAME (doesn't include signature_type)
- Shares sent to coordinator

Step 5: Coordinator aggregates
- Coordinator aggregates using merkle_root_B
- Signature is valid for merkle_root_B
- ✓ Signers unknowingly authorized scripts in tree B instead of tree A
```

**Parameter Values:**
- merkle_root_A: 32-byte hash of script tree allowing spending to address A
- merkle_root_B: 32-byte hash of script tree allowing spending to address B (attacker-controlled)

**Expected vs Actual Behavior:**
- Expected: Signers create signature for script tree A (what they saw in NonceRequest)
- Actual: Signers create signature for script tree B (what coordinator substituted)

**Reproduction:**
1. Modify coordinator code to send different signature_types between NonceRequest and SignatureShareRequest
2. Run standard signing round
3. Verify resulting signature validates against the SECOND signature_type, not the first
4. Observe no errors or rejections from signers

### Citations

**File:** src/net.rs (L264-275)
```rust
pub struct NonceRequest {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// The message to sign
    pub message: Vec<u8>,
    /// What type of signature to create
    pub signature_type: SignatureType,
}
```

**File:** src/net.rs (L311-326)
```rust
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/compute.rs (L17-33)
```rust
pub fn binding(id: &Scalar, B: &[PublicNonce], msg: &[u8]) -> Scalar {
    let prefix = b"WSTS/binding";

    // Serialize all input into a buffer
    let mut buf = Vec::new();
    buf.extend_from_slice(&id.to_bytes());

    for b in B {
        buf.extend_from_slice(b.D.compress().as_bytes());
        buf.extend_from_slice(b.E.compress().as_bytes());
    }

    buf.extend_from_slice(msg);

    expand_to_scalar(&buf, prefix)
        .expect("FATAL: DST is less than 256 bytes so operation should not fail")
}
```

**File:** src/state_machine/signer/mod.rs (L808-818)
```rust
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };
```

**File:** src/v2.rs (L238-254)
```rust
        let tweaked_public_key = if let Some(t) = tweak {
            if t != Scalar::zero() {
                let key = compute::tweaked_public_key_from_tweak(&self.group_key, t);
                if key.has_even_y() ^ self.group_key.has_even_y() {
                    cx_sign = -cx_sign;
                }

                key
            } else {
                if !self.group_key.has_even_y() {
                    cx_sign = -cx_sign;
                }
                self.group_key
            }
        } else {
            self.group_key
        };
```

**File:** src/state_machine/coordinator/frost.rs (L560-560)
```rust
            self.move_to(State::SigShareRequest(signature_type))?;
```
