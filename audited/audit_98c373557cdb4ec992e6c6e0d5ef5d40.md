### Title
DKG Round ID Reuse Enables Polynomial Replay Attack via Weak Context Binding

### Summary
The ID proof context binding mechanism in `ID::challenge()` uses `dkg_id` as the replay prevention context, but the coordinator accepts `DkgBegin` messages with previously-used `dkg_id` values, allowing attackers to replay polynomial commitments from earlier DKG rounds. This violates the critical security invariant that "Schnorr ID proofs must bind the party ID and polynomial constant to context" and defeats the intended replay protection mechanism.

### Finding Description

**Root Cause:**

The ID proof system binds proofs to a context value (`ctx`) intended to prevent replay attacks. [1](#0-0)  However, this context is derived from `dkg_id`, which can be reused across different DKG rounds without validation.

The coordinator's `start_dkg_round()` function accepts an optional `dkg_id` parameter and will use any provided value without checking if it was previously used. [2](#0-1) 

When processing incoming `DkgBegin` messages, the coordinator only rejects the message if `dkg_id` equals the current active round ID. [3](#0-2)  This means after completing DKG round X and moving to round Y, a `DkgBegin(X)` message is accepted and processed, setting `current_dkg_id` back to X.

**Exploitation Mechanism:**

Signers create ID proofs with `ctx = dkg_id.to_be_bytes()`. [4](#0-3) 

Verification uses the same context derivation. [5](#0-4) 

The challenge computation includes this context in the hash. [6](#0-5) 

When the same `dkg_id` is used in multiple rounds, the same `ctx` value results, causing ID proofs from the earlier round to verify successfully in the later round despite being stale.

**Why Existing Mitigations Fail:**

1. The deduplication check at line 76 only prevents processing the currently-active `dkg_id`, not previously-completed rounds
2. Signers do not validate `dkg_id` when receiving `DkgPublicShares` messages [7](#0-6) 
3. No persistent history of used `dkg_id` values is maintained
4. The `SavedState` only stores `current_dkg_id`, not a list of historically-used IDs

### Impact Explanation

**Specific Harm:**

A malicious signer can replay their `PolyCommitment` (including ID proof and polynomial public points) from a previous DKG round when the same `dkg_id` is reused. This causes the attacker to contribute the identical polynomial in both rounds, reusing the same private shares.

**Concrete Impact:**

1. **Violates DKG Freshness Invariant**: The protocol requires fresh random polynomials in each DKG round. Reuse breaks this fundamental security property.

2. **Persistent Share Compromise**: If an attacker's shares were compromised or leaked during round X, they remain exploitable when round X is replayed, defeating key rotation attempts.

3. **Deterministic Key Generation**: Multiple DKG rounds using the same `dkg_id` produce related group keys since the attacker's contribution is constant across rounds.

4. **Breaks Protocol Isolation**: Systems relying on DKG round independence (e.g., periodic key rotation for security) are undermined.

**Who is Affected:**

All participants in the replayed DKG round, as the resulting group key incorporates the attacker's replayed (potentially compromised) polynomial contribution.

**Severity Justification:**

This maps to **HIGH** severity under the protocol scope. While it doesn't directly cause immediate loss of funds, it enables scenarios where:
- Keys intended to be rotated away can be reintroduced
- Compromised key material persists across supposedly-independent rounds
- The security guarantees of threshold signature schemes are violated

In systems using WSTS for consensus or transaction signing (e.g., Stacks), this could contribute to chain splits if different nodes process DKG rounds differently, or enable signature forgery if enough replayed shares are compromised.

### Likelihood Explanation

**Required Attacker Capabilities:**

1. Network access to send `DkgBegin` messages to the coordinator
2. Ability to save `PolyCommitment` data from previous DKG rounds
3. Coordinator must be in `Idle` state to process the message
4. No requirement for cryptographic breaks or insider access

**Attack Complexity:**

Moderate. The attacker must:
1. Participate honestly in an initial DKG round X, saving their `PolyCommitment`
2. Wait for the coordinator to complete round X and move to a different round
3. Send `DkgBegin(X)` when coordinator is in `Idle` state
4. Replay their saved `PolyCommitment` when the round restarts

**Economic Feasibility:**

Low cost. Only requires:
- Storage for saved polynomial commitments (~100 bytes)
- Network bandwidth to send DKG messages (standard P2P cost)
- No specialized hardware or significant computational resources

**Detection Risk:**

Low. The replayed `PolyCommitment` is cryptographically valid and passes all verification checks. Honest nodes cannot distinguish replayed polynomials from fresh ones without maintaining a history of all previous commitments.

**Estimated Probability:**

High if:
- Coordinator processes external `DkgBegin` messages with arbitrary `dkg_id` values
- No application-layer validation enforces `dkg_id` monotonicity
- Attacker has network access during DKG rounds

### Recommendation

**Primary Fix:**

Enforce strict monotonicity of `dkg_id` values and maintain a history of used IDs:

```rust
// In Coordinator struct, add:
used_dkg_ids: HashSet<u64>,

// In start_dkg_round():
fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
    let new_dkg_id = if let Some(id) = dkg_id {
        // Validate that this dkg_id hasn't been used before
        if self.used_dkg_ids.contains(&id) {
            return Err(Error::DkgIdReused(id));
        }
        // Enforce monotonicity
        if id <= self.current_dkg_id {
            return Err(Error::BadDkgId(id, self.current_dkg_id));
        }
        id
    } else {
        self.current_dkg_id.wrapping_add(1)
    };
    
    self.used_dkg_ids.insert(new_dkg_id);
    self.current_dkg_id = new_dkg_id;
    // ... rest of function
}
```

**Alternative Mitigations:**

1. Include additional round-specific randomness in `ctx` beyond just `dkg_id`:
   ```rust
   // Combine dkg_id with a round-specific random nonce
   let ctx = hash(dkg_id || round_nonce);
   ```

2. Have signers validate `dkg_id` in `dkg_public_share()`:
   ```rust
   if dkg_public_shares.dkg_id != self.dkg_id {
       return Err(Error::BadDkgId(dkg_public_shares.dkg_id, self.dkg_id));
   }
   ```

**Testing Recommendations:**

1. Add test case: Attempt to start DKG with previously-used `dkg_id`, verify rejection
2. Add test case: Attempt to replay `PolyCommitment` from old round, verify rejection
3. Verify monotonicity is enforced across coordinator restarts (persist `used_dkg_ids`)

**Deployment Considerations:**

- Requires coordinator state migration to add `used_dkg_ids` tracking
- May need to populate initial `used_dkg_ids` from historical data
- Consider bounded storage (e.g., sliding window of recent IDs)

### Proof of Concept

**Exploitation Algorithm:**

```
# Setup: Complete initial DKG round
1. Coordinator starts with current_dkg_id = 100
2. DKG round 100 completes successfully
3. Malicious signer M saves their PolyCommitment_100 from round 100
4. Coordinator increments to current_dkg_id = 101
5. DKG round 101 completes successfully  
6. Coordinator is now in Idle state with current_dkg_id = 101

# Attack: Replay DKG round 100
7. Attacker sends DkgBegin(dkg_id=100) to coordinator
8. Coordinator checks: current_dkg_id (101) != dkg_id (100), so processes it
9. Coordinator calls start_dkg_round(Some(100))
10. Coordinator sets current_dkg_id = 100 and broadcasts DkgBegin(100)

11. Honest signers receive DkgBegin(100):
    - Set self.dkg_id = 100
    - Generate NEW random polynomials
    - Create ID proofs with ctx = (100).to_be_bytes()

12. Malicious signer M receives DkgBegin(100):
    - Sets self.dkg_id = 100
    - Replays saved PolyCommitment_100 (does NOT generate new polynomial)
    - ID proof from PolyCommitment_100 uses ctx = (100).to_be_bytes()

13. All signers broadcast their PolyCommitments

14. Verification phase:
    - Honest signers verify M's replayed PolyCommitment_100
    - Compute challenge: c = H("WSTS/polynomial-constant" || M.id || M.kG || M.A || (100).to_be_bytes())
    - This matches the original challenge from round 100
    - Verification succeeds: M.kca * G == M.kG + c * M.A âœ“

15. DKG completes with M using the same polynomial as round 100
    - M's shares are identical to round 100
    - If M's shares were compromised in round 100, they remain compromised
```

**Expected vs Actual Behavior:**

**Expected:** Each DKG round should use fresh random polynomials. ID proofs should prevent replay across rounds.

**Actual:** When `dkg_id` is reused, ID proofs from previous rounds verify successfully, allowing polynomial replay.

**Reproduction Instructions:**

1. Run DKG round with explicit `dkg_id=100`
2. Save one signer's `PolyCommitment` output
3. Complete the DKG round
4. Start new DKG round with `dkg_id=101`, complete it
5. Send `DkgBegin(dkg_id=100)` to coordinator when in Idle state
6. Replay the saved `PolyCommitment` from step 2
7. Observe that verification succeeds and DKG completes with replayed polynomial

### Citations

**File:** src/schnorr.rs (L27-30)
```rust
    /// Construct a new schnorr ID which binds the passed `Scalar` `id` and `Scalar` `a`, with a
    /// zero-knowledge proof of ownership of `a`.  The `ctx` is a common reference string used to
    /// prevent replay attacks; it can be any length, but will typically be a `u64` value in
    /// big endian format.
```

**File:** src/schnorr.rs (L48-59)
```rust
    pub fn challenge(id: &Scalar, K: &Point, A: &Point, ctx: &[u8]) -> Scalar {
        let mut hasher = Sha256::new();
        let tag = "WSTS/polynomial-constant";

        hasher.update(tag.as_bytes());
        hasher.update(id.to_bytes());
        hasher.update(K.compress().as_bytes());
        hasher.update(A.compress().as_bytes());
        hasher.update(ctx);

        hash_to_scalar(&mut hasher)
    }
```

**File:** src/state_machine/coordinator/frost.rs (L76-82)
```rust
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/frost.rs (L957-962)
```rust
    fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }
```

**File:** src/state_machine/signer/mod.rs (L557-557)
```rust
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
```

**File:** src/state_machine/signer/mod.rs (L862-864)
```rust
        let comms = self
            .signer
            .get_poly_commitments(&self.dkg_id.to_be_bytes(), rng);
```

**File:** src/state_machine/signer/mod.rs (L974-1026)
```rust
    pub fn dkg_public_share(
        &mut self,
        dkg_public_shares: &DkgPublicShares,
    ) -> Result<Vec<Message>, Error> {
        debug!(
            "received DkgPublicShares from signer {} {}/{}",
            dkg_public_shares.signer_id,
            self.commitments.len(),
            self.signer.get_num_parties(),
        );

        let signer_id = dkg_public_shares.signer_id;

        // check that the signer_id exists in the config
        let Some(_signer_public_key) = self.public_keys.signers.get(&signer_id) else {
            warn!(%signer_id, "No public key configured");
            return Ok(vec![]);
        };

        for (party_id, _) in &dkg_public_shares.comms {
            if !SignerType::validate_party_id(
                signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!(%signer_id, %party_id, "signer sent polynomial commitment for wrong party");
                return Ok(vec![]);
            }
        }

        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }

        let Some(signer_key_ids) = self.public_keys.signer_key_ids.get(&signer_id) else {
            warn!(%signer_id, "No key_ids configured");
            return Ok(vec![]);
        };

        for key_id in signer_key_ids {
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }

        self.dkg_public_shares
            .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
        Ok(vec![])
    }
```
