# Audit Report

## Title
Unauthenticated KEX Public Key Allows Private Share Decryption via Low-Order Point Attack

## Summary
The `kex_public_key` field in `DkgPublicShares` messages is not included in the message signature and is never validated against low-order points like `Point::identity()`. An attacker can set or modify this field to a predictable low-order point, causing all private shares encrypted for that recipient to use a constant, publicly-computable shared secret, allowing anyone to decrypt the shares and compromise the DKG protocol's confidentiality guarantee.

## Finding Description

The vulnerability has two critical components that together enable exploitation:

**1. Missing Authentication:**

The `Signable` implementation for `DkgPublicShares` only hashes `dkg_id`, `signer_id`, and `comms` fields but completely omits `kex_public_key`. [1](#0-0) 

This means an attacker can modify the `kex_public_key` field without invalidating the message signature, as the signature verification only validates the signer's identity, not the integrity of the `kex_public_key` field itself.

**2. Missing Validation:**

When `DkgPublicShares` messages are received, the `kex_public_key` is directly inserted into the `kex_public_keys` HashMap without any validation: [2](#0-1) 

This contrasts sharply with how `PublicNonce` is validated - the codebase explicitly checks that nonces are not `Point::identity()` or the generator `G` because such values "can lead to attacks": [3](#0-2) 

The same validation is completely absent for `kex_public_key`.

**Attack Execution Path:**

When private shares are sent, the unvalidated `kex_public_key` is retrieved and used directly for encryption: [4](#0-3) 

When receiving encrypted shares, the same vulnerable pattern occurs: [5](#0-4) 

The `make_shared_secret` function performs scalar multiplication without any point validation: [6](#0-5) 

**Why This Is Exploitable:**

By the mathematical properties of elliptic curves, `scalar * Point::identity() = Point::identity()` for ANY scalar value. The codebase itself confirms this understanding, as it checks for identity points in other contexts: [7](#0-6) 

When `kex_public_key = Point::identity()`:
- All senders computing `make_shared_secret(their_private_key, Point::identity())` get `Point::identity()` as the shared key
- The derived shared secret becomes: `ansi_x963_derive_key(Point::identity().compress().as_bytes(), "DH_SHARED_SECRET_KEY/")`
- This is a **constant, publicly-computable value** that anyone can calculate

**Attack Scenarios:**

*Scenario 1 - Malicious Insider:*
- An attacker who is a registered signer (explicitly allowed up to threshold-1 in the threat model) directly sends `DkgPublicShares` with `kex_public_key = Point::identity()`
- The message signature validates successfully because `kex_public_key` is not covered by the signature
- All private shares encrypted for this attacker use a predictable shared secret

*Scenario 2 - Man-in-the-Middle:*
- An attacker intercepts `DkgPublicShares` messages in transit on the RPC/P2P network
- Modifies legitimate messages to replace `kex_public_key` with `Point::identity()`
- The signature remains valid because the field is not authenticated
- All shares encrypted for the victim use a predictable shared secret

## Impact Explanation

This vulnerability directly violates the DKG protocol's documented security guarantee: "Confidentiality: Private shares are encrypted during transmission using ephemeral DH keys."

**Critical Impact Path:**

In a (T, N) threshold signature scheme, if an attacker compromises the `kex_public_key` for T parties (either T malicious insiders, or MITM attack on T parties, or combination of T-1 malicious + 1 MITM):

1. The attacker can decrypt all private polynomial shares sent to these T parties
2. Each party receives one evaluation of every other party's polynomial at their key_id
3. With T shares at T different evaluation points, the attacker can reconstruct the complete secret polynomial using Lagrange interpolation
4. This yields the group private key
5. With the group private key, the attacker can generate valid signatures on arbitrary messages

This maps to **CRITICAL severity** under the defined scope:
- "Any confirmation of an invalid transaction" - the attacker can sign unauthorized transactions
- "Any causing the direct loss of funds" - if the threshold signature scheme protects custody of funds, breaking it leads to direct theft

Even partial exposure (< T shares) violates the fundamental confidentiality guarantee of the DKG protocol, potentially enabling further attacks when combined with other vulnerabilities.

## Likelihood Explanation

**Attacker Capabilities Required:**

*Malicious Insider Path:*
- The threat model explicitly allows up to threshold-1 malicious signers
- These signers can set their own `kex_public_key = Point::identity()` 
- This exposes T-1 parties' shares to all network observers
- If ANY additional vulnerability exposes one more party's shares, the threshold is broken

*MITM Path:*
- The scope explicitly includes "remotely-exploitable" attacks "restricted to the Stacks blockchain RPC/P2P ports" (High/Critical category)
- Network message interception and modification falls within this scope
- If the attacker can MITM T parties' DkgPublicShares messages, they can decrypt T shares directly

**Attack Complexity: LOW**
- No cryptographic breaks required
- Simple field modification in a message structure
- Standard AES-GCM decryption with a known, publicly-computable key
- The predictable shared secret can be computed by anyone

**Detection Difficulty: HIGH**
- Messages pass signature verification checks
- Encryption/decryption operations succeed without errors
- No validation raises warnings about identity points
- The attack is silent and leaves no obvious traces

**Overall Likelihood: HIGH**

The vulnerability is easily exploitable by adversaries within the defined threat model, requires minimal sophistication, and is difficult to detect.

## Recommendation

Implement the same validation pattern already used for `PublicNonce` to protect `kex_public_key`:

**1. Add validation when receiving DkgPublicShares:**

```rust
// In src/state_machine/signer/mod.rs, after line 1016:
// Validate kex_public_key is not a low-order point
if dkg_public_shares.kex_public_key == Point::identity() 
    || dkg_public_shares.kex_public_key == G {
    warn!(%signer_id, "Invalid kex_public_key: low-order point");
    return Ok(vec![]);
}
```

**2. Include kex_public_key in the signature hash:**

```rust
// In src/net.rs, Signable implementation for DkgPublicShares:
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        // ADD THIS LINE:
        hasher.update(self.kex_public_key.compress().as_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

Both mitigations should be implemented together for defense-in-depth:
- Authentication prevents MITM tampering
- Validation prevents malicious insiders from using low-order points

## Proof of Concept

```rust
#[test]
fn test_kex_public_key_identity_point_vulnerability() {
    use sha2::{Sha256, Digest};
    use crate::curve::point::Point;
    use crate::curve::scalar::Scalar;
    use crate::util::{make_shared_secret, make_shared_secret_from_key};
    use crate::net::{DkgPublicShares, Signable};
    use rand::thread_rng;
    
    let mut rng = thread_rng();
    
    // Create a DkgPublicShares message with kex_public_key = Point::identity()
    let malicious_shares = DkgPublicShares {
        dkg_id: 0,
        signer_id: 1,
        comms: vec![],
        kex_public_key: Point::identity(),  // Attacker sets this to identity
    };
    
    // Demonstrate that signature can still be computed (field not in hash)
    let mut hasher = Sha256::new();
    malicious_shares.hash(&mut hasher);
    let hash1 = hasher.finalize_reset();
    
    // Modify kex_public_key and hash again
    let normal_shares = DkgPublicShares {
        kex_public_key: Point::from(Scalar::random(&mut rng)),
        ..malicious_shares.clone()
    };
    normal_shares.hash(&mut hasher);
    let hash2 = hasher.finalize();
    
    // VULNERABILITY: Hashes are identical despite different kex_public_key
    assert_eq!(hash1, hash2, "kex_public_key not included in signature hash");
    
    // Demonstrate that shared secret is constant and predictable
    let alice_private = Scalar::random(&mut rng);
    let bob_private = Scalar::random(&mut rng);
    
    let secret1 = make_shared_secret(&alice_private, &Point::identity());
    let secret2 = make_shared_secret(&bob_private, &Point::identity());
    let secret3 = make_shared_secret_from_key(&Point::identity());
    
    // VULNERABILITY: All parties get the same predictable shared secret
    assert_eq!(secret1, secret2, "Different private keys produce same shared secret");
    assert_eq!(secret1, secret3, "Shared secret is publicly computable");
    
    println!("VULNERABILITY CONFIRMED:");
    println!("1. kex_public_key can be set to Point::identity() without invalidating signature");
    println!("2. All encryptions use the same constant, publicly-computable shared secret");
    println!("3. Anyone can decrypt shares encrypted with shared_secret: {:?}", secret1);
}
```

This test demonstrates both vulnerability components: the missing authentication (hashes are identical) and the predictable shared secret (all parties derive the same constant value).

### Citations

**File:** src/net.rs (L152-163)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
```

**File:** src/state_machine/signer/mod.rs (L937-942)
```rust
                    let Some(kex_public_key) = self.kex_public_keys.get(dst_key_id) else {
                        error!("No KEX public key for key_id {dst_key_id}");
                        return Err(Error::MissingKexPublicKey(*dst_key_id));
                    };
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1019-1020)
```rust
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
```

**File:** src/state_machine/signer/mod.rs (L1069-1070)
```rust
        let shared_key = self.kex_private_key * kex_public_key;
        let shared_secret = make_shared_secret(&self.kex_private_key, &kex_public_key);
```

**File:** src/common.rs (L160-163)
```rust
    /// Check that the nonces are not zero since that can lead to attacks
    pub fn is_valid(&self) -> bool {
        self.D != Point::identity() && self.E != Point::identity() && self.D != G && self.E != G
    }
```

**File:** src/common.rs (L206-208)
```rust
    fn is_zero(&self) -> bool {
        self.D == Point::identity() && self.E == Point::identity()
    }
```

**File:** src/util.rs (L48-52)
```rust
pub fn make_shared_secret(private_key: &Scalar, public_key: &Point) -> [u8; 32] {
    let shared_key = private_key * public_key;

    make_shared_secret_from_key(&shared_key)
}
```
