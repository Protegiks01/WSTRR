### Title
Unvalidated DKG Failure Reports Enable Denial of Service by Single Malicious Signer

### Summary
The FIRE and FROST coordinators accept `MissingPublicShares` and `MissingPrivateShares` failure reports from signers without validation, allowing a single malicious signer to abort DKG by falsely claiming that honest signers failed to send shares. This enables a persistent denial of service attack that prevents DKG completion and blocks key generation, potentially halting block production if signing keys require rotation.

### Finding Description

The vulnerability exists in both coordinator implementations' `gather_dkg_end` methods:

**FIRE Coordinator (`src/state_machine/coordinator/fire.rs`):** [1](#0-0) 

The FIRE coordinator processes DkgEnd messages and handles various failure types, but for `MissingPublicShares` and `MissingPrivateShares` failures, it performs no validation despite having the necessary data to verify these claims.

**FROST Coordinator (`src/state_machine/coordinator/frost.rs`):** [2](#0-1) 

The FROST coordinator is even more vulnerableâ€”it performs **zero validation** on any reported failures and immediately aborts DKG if any signer reports a failure.

**Root Cause:**

The coordinator stores all received public and private shares in `self.dkg_public_shares` and `self.dkg_private_shares`: [3](#0-2) 

These shares are collected during the DkgPublicGather and DkgPrivateGather states: [4](#0-3) [5](#0-4) 

When a signer reports missing shares, the coordinator has all the data necessary to validate this claim but fails to do so. Instead, it immediately returns an error and aborts the DKG: [6](#0-5) 

**Why Existing Mitigations Fail:**

The FIRE coordinator validates `BadPublicShares` and `BadPrivateShares` failures by checking the actual share data: [7](#0-6) 

However, this validation logic is **not applied** to `MissingPublicShares` and `MissingPrivateShares` claims. The comments at lines 766 and 769 ("this shouldn't happen, maybe mark signer malicious?") indicate awareness of the issue but no actual implementation.

### Impact Explanation

**Specific Harm:**

A malicious signer can prevent DKG completion indefinitely by repeatedly sending false `DkgFailure::MissingPublicShares` or `DkgFailure::MissingPrivateShares` messages. Since DKG is required to:
1. Generate initial signing keys for new signer sets
2. Rotate keys when signers join or leave
3. Recover from compromised key scenarios

This attack directly prevents these critical operations.

**Chain-Level Impact:**

In the Stacks blockchain context where WSTS is deployed:
- If DKG is needed for block signer key rotation, a single malicious signer can prevent new blocks from being signed under updated keys
- If the attack occurs during critical key rotation periods, it could force continued use of potentially compromised or outdated keys
- The network cannot exclude the malicious signer without out-of-band coordination since the DKG phase never completes to identify them

**Quantified Impact:**

- **Number of attackers required:** 1 (single malicious signer)
- **Success rate:** 100% (attack always succeeds)
- **Cost to attacker:** Minimal (no resources beyond existing signer privileges)
- **Affected parties:** All network participants waiting for DKG completion
- **Duration:** Indefinite until manual intervention

**Severity Justification:**

This maps to **High severity** under the protocol scope: "Any remotely-exploitable denial of service in a node" escalating to "Any unintended chain split or network partition" if the DKG failure prevents critical key rotation operations that are required for block production or signature validation.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be an authorized signer in the DKG round (public role)
- Ability to send network messages (standard signer capability)
- No cryptographic secrets or breaks required

**Attack Complexity:**
- **Trivial** - Attacker simply sends a DkgEnd message with fabricated failure data: [8](#0-7) 

The attacker constructs:
```
DkgEnd {
    dkg_id: current_dkg_id,
    signer_id: attacker_signer_id,
    status: DkgStatus::Failure(DkgFailure::MissingPublicShares(fabricated_set))
}
```

**Economic Feasibility:**
- No cost beyond network bandwidth for a single message per DKG round
- Can be automated to repeat indefinitely

**Detection Risk:**
- Low - The coordinator cannot distinguish false reports from legitimate ones without validation
- Other signers may detect the discrepancy if they implement cross-validation, but the coordinator (which makes the final decision) does not

**Estimated Probability of Success:**
- **100%** - The vulnerability is deterministic and requires no race conditions or timing dependencies

### Recommendation

**Primary Fix - Add Validation Logic:**

Modify the FIRE coordinator's `gather_dkg_end` method to validate missing share claims:

```rust
DkgFailure::MissingPublicShares(claimed_missing) => {
    for claimed_signer_id in claimed_missing {
        // Validate the claim
        if self.dkg_public_shares.contains_key(claimed_signer_id) {
            // Shares exist - reporting signer is malicious
            warn!("Signer {} falsely reported MissingPublicShares from {}, mark {} as malicious",
                  signer_id, claimed_signer_id, signer_id);
            malicious_signers.insert(*signer_id);
        } else {
            // Shares actually missing - may need to identify why
            warn!("Confirmed MissingPublicShares from {}", claimed_signer_id);
        }
    }
}

DkgFailure::MissingPrivateShares(claimed_missing) => {
    for claimed_signer_id in claimed_missing {
        // Validate the claim
        if self.dkg_private_shares.contains_key(claimed_signer_id) {
            // Shares exist - reporting signer is malicious
            warn!("Signer {} falsely reported MissingPrivateShares from {}, mark {} as malicious",
                  signer_id, claimed_signer_id, signer_id);
            malicious_signers.insert(*signer_id);
        } else {
            // Shares actually missing
            warn!("Confirmed MissingPrivateShares from {}", claimed_signer_id);
        }
    }
}
```

Apply similar logic to the FROST coordinator at: [2](#0-1) 

**Alternative Mitigation:**

If there are legitimate scenarios where shares might be missing from the coordinator's view (e.g., network partitions), implement a consensus-based validation:
- Require multiple signers to report the same missing shares
- Only abort DKG if threshold number of signers agree on the failures

**Testing Recommendations:**

1. Add unit test demonstrating the attack:
   - Run normal DKG where all shares are received
   - Have one signer send false MissingPublicShares claim
   - Verify coordinator correctly identifies the false claim and marks signer malicious
   - Verify DKG continues successfully

2. Add integration test with mixed scenarios:
   - Some shares actually missing
   - Some false claims
   - Verify correct identification of both

**Deployment Considerations:**

- This fix should be applied before any production deployment
- If already deployed, coordinate an emergency upgrade
- Consider adding metrics to track false failure reports

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup Phase:** Attacker becomes an authorized signer in DKG round
2. **Normal DKG Flow:** All signers (including attacker) successfully send DkgPublicShares and DkgPrivateShares
3. **Attack Execution:** When coordinator sends DkgEndBegin message, attacker responds with:

```rust
DkgEnd {
    dkg_id: current_dkg_id,
    signer_id: attacker_id,
    status: DkgStatus::Failure(
        DkgFailure::MissingPublicShares(
            // Falsely claim honest signers didn't send shares
            HashSet::from([honest_signer_1, honest_signer_2, ...])
        )
    )
}
```

4. **Result:** Coordinator receives the false claim and aborts DKG without validation

**Expected vs Actual Behavior:**

**Expected:**
- Coordinator validates the MissingPublicShares claim
- Finds the shares exist in `self.dkg_public_shares`
- Marks the attacker as malicious
- Continues DKG with remaining honest signers

**Actual:**
- Coordinator accepts the claim without validation
- Returns `Error::DkgFailure` with the false report
- DKG aborts
- Must restart from beginning

**Reproduction Steps:**

Using the existing test infrastructure: [9](#0-8) 

Modify the `feedback_mutated_messages` test helper to inject a false DkgEnd failure:

```rust
let (mut coordinators, mut signers) = setup::<Coordinator, SignerType>(5, 1);
let message = coordinators.first_mut().unwrap().start_dkg_round(None).unwrap();

// Complete public and private share phases normally
let (messages, _) = feedback_messages(&mut coordinators, &mut signers, &[message]);
let (messages, _) = feedback_messages(&mut coordinators, &mut signers, &messages);

// Inject false failure from signer 0
let (messages, results) = feedback_mutated_messages(
    &mut coordinators,
    &mut signers,
    &messages,
    |signer, packets| {
        if signer.signer_id != 0 {
            return packets;
        }
        // Replace honest DkgEnd with false failure claim
        packets.iter().map(|p| {
            Packet {
                msg: Message::DkgEnd(DkgEnd {
                    dkg_id: 1,
                    signer_id: 0,
                    status: DkgStatus::Failure(
                        DkgFailure::MissingPublicShares(HashSet::from([1, 2]))
                    )
                }),
                sig: vec![]
            }
        }).collect()
    }
);

// DKG aborts despite all shares being present
assert!(matches!(results[0], OperationResult::DkgError(_)));
```

This demonstrates that a single malicious signer can arbitrarily abort DKG by sending false failure reports that are never validated.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L40-41)
```rust
    dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L505-506)
```rust
            self.dkg_public_shares
                .insert(dkg_public_shares.signer_id, dkg_public_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L552-553)
```rust
            self.dkg_private_shares
                .insert(dkg_private_shares.signer_id, dkg_private_shares.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L620-650)
```rust
                        DkgFailure::BadPublicShares(bad_shares) => {
                            // bad_shares is a set of signer_ids
                            for bad_signer_id in bad_shares {
                                // verify public shares are bad
                                let Some(dkg_public_shares) =
                                    self.dkg_public_shares.get(bad_signer_id)
                                else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but there are no public shares from that signer, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                    continue;
                                };
                                let mut bad_party_ids = Vec::new();
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }

                                // if none of the shares were bad sender was malicious
                                if bad_party_ids.is_empty() {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id} but the shares were valid, mark {signer_id} as malicious");
                                    malicious_signers.insert(*signer_id);
                                } else {
                                    warn!("Signer {signer_id} reported BadPublicShares from {bad_signer_id}, mark {bad_signer_id} as malicious");
                                    malicious_signers.insert(*bad_signer_id);
                                }
                            }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L779-788)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/state_machine/coordinator/frost.rs (L403-416)
```rust
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
```

**File:** src/net.rs (L59-72)
```rust
pub enum DkgFailure {
    /// DKG threshold not met
    Threshold,
    /// Signer was in the wrong internal state to complete DKG
    BadState,
    /// DKG public shares were missing from these signer_ids
    MissingPublicShares(HashSet<u32>),
    /// DKG public shares were bad from these signer_ids
    BadPublicShares(HashSet<u32>),
    /// DKG private shares were missing from these signer_ids
    MissingPrivateShares(HashSet<u32>),
    /// DKG private shares were bad from these signer_ids
    BadPrivateShares(HashMap<u32, BadPrivateShare>),
}
```

**File:** src/state_machine/coordinator/mod.rs (L738-862)
```rust
    pub fn run_dkg<Coordinator: CoordinatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
    ) -> (Vec<Coordinator>, Vec<Signer<SignerType>>) {
        let (mut coordinators, mut signers) =
            setup::<Coordinator, SignerType>(num_signers, keys_per_signer);

        // We have started a dkg round
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_dkg_round(None)
            .unwrap();
        assert!(coordinators
            .first_mut()
            .unwrap()
            .get_aggregate_public_key()
            .is_none());
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::DkgPublicGather
        );

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        for coordinator in coordinators.iter() {
            assert_eq!(coordinator.get_state(), State::DkgPrivateGather);
        }

        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(&outbound_messages[0].msg, Message::DkgPrivateBegin(_)),
            "Expected DkgPrivateBegin message"
        );

        // persist the state machines before continuing
        let new_coordinators = coordinators
            .iter()
            .map(|c| Coordinator::load(&c.save()))
            .collect::<Vec<Coordinator>>();

        assert_eq!(coordinators, new_coordinators);

        coordinators = new_coordinators;

        let new_signers = signers
            .iter()
            .map(|s| Signer::<SignerType>::load(&s.save()))
            .collect::<Vec<Signer<SignerType>>>();

        assert_eq!(signers, new_signers);

        signers = new_signers;

        // Send the DKG Private Begin message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &outbound_messages);
        assert_eq!(operation_results.len(), 0);
        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::DkgEndBegin(_)),
            "Expected DkgEndBegin message"
        );

        // persist the state machines before continuing
        let new_coordinators = coordinators
            .iter()
            .map(|c| Coordinator::load(&c.save()))
            .collect::<Vec<Coordinator>>();

        assert_eq!(coordinators, new_coordinators);

        coordinators = new_coordinators;

        let new_signers = signers
            .iter()
            .map(|s| Signer::<SignerType>::load(&s.save()))
            .collect::<Vec<Signer<SignerType>>>();

        assert_eq!(signers, new_signers);

        signers = new_signers;

        // Send the DkgEndBegin message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &outbound_messages);
        assert_eq!(outbound_messages.len(), 0);
        assert_eq!(operation_results.len(), 1);
        let OperationResult::Dkg(point) = operation_results[0] else {
            panic!("Expected Dkg Operation result");
        };
        assert_ne!(point, Point::default());
        for coordinator in coordinators.iter() {
            assert_eq!(coordinator.get_aggregate_public_key(), Some(point));
            assert_eq!(coordinator.get_state(), State::Idle);
        }

        // clear the polynomials before persisting
        for signer in &mut signers {
            signer.signer.clear_polys();
        }

        // persist the state machines before continuing
        let new_coordinators = coordinators
            .iter()
            .map(|c| Coordinator::load(&c.save()))
            .collect::<Vec<Coordinator>>();

        assert_eq!(coordinators, new_coordinators);

        coordinators = new_coordinators;

        let new_signers = signers
            .iter()
            .map(|s| Signer::<SignerType>::load(&s.save()))
            .collect::<Vec<Signer<SignerType>>>();

        assert_eq!(signers, new_signers);

        signers = new_signers;

        (coordinators, signers)
    }
```
