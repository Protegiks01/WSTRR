### Title
kex_public_key in DkgPublicShares is not authenticated by signature, allowing MITM key substitution and DKG share compromise

### Summary
The kex_public_key field in DkgPublicShares messages, used for Diffie-Hellman key exchange in DKG share encryption, is not included in the message hash for signature generation or verification. This enables a network attacker to substitute arbitrary keys and decrypt encrypted private shares, compromising key secrecy and the threshold security of the protocol.

### Finding Description
- In `src/net.rs`, the `DkgPublicShares` struct includes a `kex_public_key` used for DH key exchange for encrypted DKG shares. However, in its `Signable` trait implementation, the signature hash does not bind the `kex_public_key`, only the DKG ID, signer_id, and polynomial commitments. This means that an attacker can modify the `kex_public_key` in transit and the message signature remains valid.
- Signers and the coordinator process DkgPublicShares directly, trusting the received kex_public_key for the symmetric encryption of DKG private shares, as seen in `src/state_machine/signer/mod.rs` (uses exchanged kex_public_keys for encryption and decryption).
- No additional proofs of possession or cryptographic commitments cover the kex_public_key in initial DkgPublicShares.
- Enabling packet signature verification (`verify_packet_sigs`) does not resolve this, as the signature verification still does not cover the `kex_public_key` field.
- This enables a MITM to replace a signer's kex_public_key with their own, thus learning all encrypted shares intended for that signer, compromising secret material and potentially key control. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) 

### Impact Explanation
If an attacker can intercept DkgPublicShares messages, they can substitute their own DH public key, causing other signers to encrypt DKG shares to an attacker-controlled key. The attacker can recover partial or full key shares, undermining the threshold and allowing them to participate in or forge group signatures undetected. If protocol is used to protect funds (e.g., via threshold signatures for wallets or consensus systems), this enables direct theft and unauthorized transaction signing—a Critical impact under the audit’s protocol scope.

### Likelihood Explanation
- An attacker only needs MITM capability on the network between signers during the DKG phase.
- No cryptographic break or key compromise is required: only message interception and manipulation.
- The attack is not detectable through the normal signature verification or protocol checks.
- As a result, practical MITM risk exists in non-hardened networks or when signers are distributed globally.

### Recommendation
- Include the kex_public_key in the hash for the Signable implementation of DkgPublicShares, so that the signature covers this value.
- Validate that all uses of DH keys for encryption require their authenticity through signatures or equivalent cryptographic commitments.
- Add regression/unit tests to ensure any modification to kex_public_key breaks signature verification.

### Proof of Concept
1. Attacker intercepts a DkgPublicShares message from signer A to the coordinator (or to the group).
2. Attacker substitutes kex_public_key with a key under their control; forwards message.
3. Other signers, unable to detect the change, encrypt private DKG shares for A using the attacker’s key.
4. Attacker decrypts A’s shares from the DKGPrivateShares messages.
5. Over multiple rounds or groups, attacker collects enough shares to reconstruct A’s secret, violating threshold security.

This attack is low-complexity, does not require cryptographic breaks, and can remain undetected.

---

Notes:
- This vulnerability applies to all protocol deployments unless signature coverage is extended explicitly to kex_public_key.
- This completely undermines DKG security and threshold guarantees, enabling catastrophic key compromise.
- Mitigation is straightforward and urgent: the field must be signed. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4)

### Citations

**File:** src/net.rs (L152-164)
```rust
impl Signable for DkgPublicShares {
    fn hash(&self, hasher: &mut Sha256) {
        hasher.update("DKG_PUBLIC_SHARES".as_bytes());
        hasher.update(self.dkg_id.to_be_bytes());
        hasher.update(self.signer_id.to_be_bytes());
        for (party_id, comm) in &self.comms {
            hasher.update(party_id.to_be_bytes());
            for a in &comm.poly {
                hasher.update(a.compress().as_bytes());
            }
        }
    }
}
```

**File:** src/net.rs (L526-539)
```rust
            Message::DkgPublicShares(msg) => {
                if let Some(public_key) = signers_public_keys.signers.get(&msg.signer_id) {
                    if !msg.verify(&self.sig, public_key) {
                        warn!("Received a DkgPublicShares message with an invalid signature.");
                        return false;
                    }
                } else {
                    warn!(
                        "Received a DkgPublicShares message with an unknown id: {}",
                        msg.signer_id
                    );
                    return false;
                }
            }
```

**File:** src/state_machine/signer/mod.rs (L876-877)
```rust
            kex_public_key: self.kex_private_key * G,
        };
```

**File:** src/state_machine/signer/mod.rs (L941-942)
```rust
                    let shared_secret = make_shared_secret(&self.kex_private_key, kex_public_key);
                    let encrypted_share = encrypt(&shared_secret, &private_share.to_bytes(), rng)?;
```

**File:** src/state_machine/signer/mod.rs (L1019-1021)
```rust
            self.kex_public_keys
                .insert(*key_id, dkg_public_shares.kex_public_key);
        }
```
