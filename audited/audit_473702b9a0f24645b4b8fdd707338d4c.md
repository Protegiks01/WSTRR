### Title
Duplicate key_ids in SignatureShare Bypass Validation and Corrupt Lagrange Interpolation

### Summary
The validation logic for `key_ids` in `SignatureShare` and `NonceResponse` converts the Vec to a HashSet before comparing with the configuration, which silently removes duplicates. However, the original Vec with duplicates is still used in Lagrange interpolation, causing incorrect coefficient calculations. A single malicious signer can inject duplicate key_ids that pass validation but corrupt the signature computation for all participating signers, causing complete signing round failure.

### Finding Description

**Root Cause:**

The coordinator validates `key_ids` by converting them to a HashSet and comparing against the configured set, but this approach fails to detect duplicates within the original Vec. [1](#0-0) 

The validation extracts all key_ids from signature shares into a HashSet (removing duplicates), then compares against `signer_key_ids` (also a HashSet). If a malicious signer sends `SignatureShare { key_ids: vec![1, 1, 2], ... }`, the validation creates HashSet {1, 2}, compares it with the configured {1, 2}, and passes. However, the original Vec [1, 1, 2] is retained in the SignatureShare structure. [2](#0-1) 

Similar validation occurs for NonceResponse: [3](#0-2) 

**Propagation to All Signers:**

When the coordinator sends SignatureShareRequest to all signers, each signer reconstructs the global key_ids list by concatenating all key_ids from all nonce responses: [4](#0-3) 

If any nonce response contains duplicate key_ids, the resulting global list has duplicates. This corrupted list is passed to every signer's sign function.

**Corruption in Lagrange Interpolation:**

The lambda function computes Lagrange interpolation coefficients without validating for duplicates: [5](#0-4) 

When signers compute their signature shares, they iterate over their key_ids and call lambda with the corrupted global key_ids: [6](#0-5) 

If the global `key_ids = [1, 1, 2, 3]` contains a duplicate, computing `lambda(3, [1, 1, 2, 3])` will multiply the (j/(j-i)) term for j=1 twice, producing an incorrect coefficient. For example, lambda(3, [1,1,2,3]) = (1/(1-3)) * (1/(1-3)) * (2/(2-3)) = 1/4 * (-1/2) = -1/8, whereas the correct lambda(3, [1,2,3]) = (1/(1-3)) * (2/(2-3)) = (-1/2) * (-2) = 1.

**Why Existing Mitigations Fail:**

The PublicKeys validation ensures configured key_ids are in range: [7](#0-6) 

However, this validates the configuration only. The runtime validation of incoming messages uses HashSet comparison, which cannot detect duplicates in the original Vec.

### Impact Explanation

**Specific Harm:**

A single malicious signer can cause complete signing round failure by including duplicate key_ids in their NonceResponse. All participating signers (both honest and malicious) will compute their signature shares using incorrect Lagrange coefficients, causing the aggregated signature to fail verification. The coordinator will then attempt to identify the malicious party via check_signature_shares: [8](#0-7) 

However, if the malicious party also includes the duplicates in their SignatureShare.key_ids, the check may incorrectly validate their share (since both signing and checking use the same corrupted key_ids list), potentially misidentifying honest signers as malicious.

**Quantified Impact:**

- With n=10 keys, threshold t=7, a malicious signer controlling 2 keys can prevent any signing round from succeeding
- Attack requires only a single corrupted NonceResponse message
- Affects all signers in the protocol, not just the malicious party's contribution
- Recovery requires identifying and removing the malicious signer, then restarting the signing round

**Who is Affected:**

All participants in a signing round where any single signer includes duplicate key_ids.

**Severity Justification:**

This maps to **Medium severity** per the protocol scope: "Any transient consensus failures." If WSTS is used for critical operations like block signing or transaction confirmation, preventing signature generation causes transient consensus failures until the malicious signer is identified and removed. At minimum, it qualifies as **Low severity**: "Any remotely-exploitable denial of service in a node" since it causes signing operations to fail.

### Likelihood Explanation

**Required Attacker Capabilities:**

- Must be a valid signer in the WSTS protocol with legitimate credentials
- Requires ability to send network messages (NonceResponse or SignatureShareResponse)
- No need to compromise cryptographic keys or break underlying primitives

**Attack Complexity:**

Extremely simple - attacker just needs to duplicate values in the key_ids Vec:
```
NonceResponse { key_ids: vec![1, 1, 2], ... }  // instead of vec![1, 2]
```

**Economic Feasibility:**

Trivial cost - just network message manipulation. No computational resources required.

**Detection Risk:**

Low detection risk during attack. The coordinator will detect signature failure but may have difficulty determining which signer provided duplicate key_ids since the validation logs only show "key_ids didn't match config" without specifying why. Post-attack forensics would require examining raw message contents.

**Estimated Probability of Success:**

Near 100% - the validation logic deterministically fails to catch duplicates in Vecs.

### Recommendation

**Primary Fix:**

Add explicit duplicate detection before HashSet conversion:

```rust
// In gather_sig_shares (fire.rs ~line 1066)
for sig_share in &sig_share_response.signature_shares {
    let key_ids_len = sig_share.key_ids.len();
    let unique_len = sig_share.key_ids.iter().collect::<HashSet<_>>().len();
    if key_ids_len != unique_len {
        warn!(signer_id = %sig_share_response.signer_id, 
              "SignatureShare contains duplicate key_ids");
        return Err(Error::DuplicateKeyIDs(sig_share_response.signer_id));
    }
}

// Apply same check for NonceResponse (fire.rs ~line 881)
let key_ids_len = nonce_response.key_ids.len();
let unique_len = nonce_response_key_ids.len();
if key_ids_len != unique_len {
    warn!(signer_id = %nonce_response.signer_id,
          "NonceResponse contains duplicate key_ids");
    return Err(Error::DuplicateKeyIDs(nonce_response.signer_id));
}
```

**Alternative Mitigation:**

Add validation directly in the lambda function:

```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Result<Scalar, ComputeError> {
    if key_ids.len() != key_ids.iter().collect::<HashSet<_>>().len() {
        return Err(ComputeError::DuplicateKeyIDs);
    }
    // existing implementation
}
```

**Testing Recommendations:**

1. Add unit test for duplicate key_ids in SignatureShare validation
2. Add integration test where malicious signer sends duplicate key_ids
3. Verify error messages clearly identify the duplicate key_ids issue
4. Test that signature rounds fail fast with appropriate error reporting

**Deployment Considerations:**

This is a protocol-level fix that requires coordinated upgrade of all coordinators. Signers should also be updated to validate incoming SignatureShareRequest key_ids for duplicates as a defense-in-depth measure.

### Proof of Concept

**Exploitation Steps:**

1. Setup: 4 signers, 10 total keys, threshold 7
   - Malicious Signer A controls keys [1, 2]
   - Honest Signers B, C, D control keys [3,4], [5,6,7], [8,9,10]

2. During NonceRequest, Malicious Signer A sends:
   ```
   NonceResponse {
       signer_id: A,
       key_ids: vec![1, 1, 2],  // Duplicate key_id 1
       nonces: vec![nonce1, nonce2, nonce3],  // 3 nonces to match length
       ...
   }
   ```

3. Coordinator validation (fire.rs:881-889):
   - Converts to HashSet: {1, 2}
   - Compares with config: {1, 2}
   - Validation PASSES (incorrectly)

4. Coordinator includes this in SignatureShareRequest sent to all signers

5. All signers extract key_ids (signer/mod.rs:800-804):
   ```
   key_ids = [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]  // Contains duplicate
   ```

6. Honest Signer B computes signature for key 3:
   ```
   lambda(3, [1,1,2,3,...,10]) computes incorrectly
   Expected: lambda(3, [1,2,3,...,10]) â‰ˆ some correct value
   Actual: includes extra multiplication term for duplicate 1
   ```

7. Aggregation fails:
   - All signatures computed with wrong Lagrange coefficients
   - Final signature verification fails
   - Signing round aborted

**Expected vs Actual Behavior:**

- Expected: Validation rejects NonceResponse with duplicate key_ids
- Actual: Validation passes, duplicates corrupt Lagrange interpolation for all signers

**Reproduction Instructions:**

Modify test in `src/state_machine/coordinator/fire.rs` to send NonceResponse with `key_ids: vec![1, 1, 2]` for a signer configured with {1, 2}. Observe that validation passes but subsequent signature generation fails.

## Notes

The vulnerability exists in both FIRE and FROST coordinator implementations with identical root cause. The FROST coordinator validation is at lines 631-641 in `src/state_machine/coordinator/frost.rs`. The fix should be applied to both implementations.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L881-889)
```rust
            let nonce_response_key_ids = nonce_response
                .key_ids
                .iter()
                .cloned()
                .collect::<HashSet<u32>>();
            if *signer_key_ids != nonce_response_key_ids {
                warn!(signer_id = %nonce_response.signer_id, "Nonce response key_ids didn't match config");
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/common.rs (L211-220)
```rust
#[derive(Clone, Deserialize, Serialize, PartialEq)]
/// A share of the party signature with related values
pub struct SignatureShare {
    /// The ID of the party
    pub id: u32,
    /// The party signature
    pub z_i: Scalar,
    /// The key IDs of the party
    pub key_ids: Vec<u32>,
}
```

**File:** src/state_machine/signer/mod.rs (L800-804)
```rust
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();
```

**File:** src/compute.rs (L70-80)
```rust
pub fn lambda(i: u32, key_ids: &[u32]) -> Scalar {
    let mut lambda = Scalar::one();
    let i_scalar = id(i);
    for j in key_ids {
        if i != *j {
            let j_scalar = id(*j);
            lambda *= j_scalar / (j_scalar - i_scalar);
        }
    }
    lambda
}
```

**File:** src/v2.rs (L262-265)
```rust
        let mut cx = Scalar::zero();
        for key_id in self.key_ids.iter() {
            cx += c * &self.private_keys[key_id] * compute::lambda(*key_id, key_ids);
        }
```

**File:** src/v2.rs (L389-409)
```rust
        for i in 0..sig_shares.len() {
            let z_i = sig_shares[i].z_i;
            let mut cx = Point::zero();

            for key_id in &sig_shares[i].key_ids {
                let kid = compute::id(*key_id);
                let public_key = match compute::poly(&kid, &self.poly) {
                    Ok(p) => p,
                    Err(_) => {
                        bad_party_keys.push(sig_shares[i].id);
                        Point::zero()
                    }
                };

                cx += compute::lambda(*key_id, key_ids) * c * public_key;
            }

            if z_i * G != (r_sign * Rs[i] + cx_sign * cx) {
                bad_party_sigs.push(sig_shares[i].id);
            }
        }
```

**File:** src/state_machine/mod.rs (L121-133)
```rust
        for (signer_id, key_ids) in &self.signer_key_ids {
            if !validate_signer_id(*signer_id, num_signers) {
                return Err(SignerError::Config(ConfigError::InvalidSignerId(
                    *signer_id,
                )));
            }

            for key_id in key_ids {
                if !validate_key_id(*key_id, num_keys) {
                    return Err(SignerError::Config(ConfigError::InvalidKeyId(*key_id)));
                }
            }
        }
```
