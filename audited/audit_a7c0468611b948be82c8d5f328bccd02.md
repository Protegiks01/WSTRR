# Audit Report

## Title
Unvalidated DKG Failure Reports Allow Malicious Signers to Cause Repeated DKG Denial of Service

## Summary
The FIRE coordinator's `gather_dkg_end()` function does not validate three types of DKG failure reports (`Threshold`, `MissingPublicShares`, `MissingPrivateShares`), allowing a single malicious signer to falsely report these failures and cause indefinite DKG round failures without detection. This enables a compromised signer to prevent distributed key generation from completing, affecting all participants in the threshold signature system.

## Finding Description

The vulnerability exists in the FIRE coordinator's DKG end validation logic. When signers complete DKG processing, they send `DkgEnd` messages reporting either success or failure. The coordinator's `gather_dkg_end()` function validates cryptographic proofs for `BadPublicShares` and `BadPrivateShares` failures, but three failure types have no validation: [1](#0-0) [2](#0-1) 

Any reported failure is unconditionally added to the `reported_failures` map: [3](#0-2) 

If any failures exist after processing all DkgEnd messages, the entire DKG round fails: [4](#0-3) 

**Attack Execution Path:**

1. A malicious signer participates normally in DKG until the end phase
2. When `dkg_ended()` is called, instead of honest validation, the malicious signer returns a false failure report
3. The coordinator receives the `DkgEnd` message with `DkgStatus::Failure(DkgFailure::MissingPrivateShares(victim_signer_ids))`
4. The coordinator processes this at lines 768-770 but performs no validation (only a TODO comment exists)
5. The false failure is added to `reported_failures`
6. The DKG round fails with `Error::DkgFailure`, affecting all participants
7. The malicious signer is NOT added to `malicious_signers`, so they can repeat the attack indefinitely

**Why Existing Data Could Validate These Claims:**

The coordinator tracks which signers sent shares: [5](#0-4) 

The coordinator broadcasts this authoritative information to signers in `DkgPrivateBegin` and `DkgEndBegin` messages: [6](#0-5) [7](#0-6) 

Signers use this coordinator-provided list to detect missing shares: [8](#0-7) [9](#0-8) 

The coordinator has complete knowledge to validate all three unvalidated failure types by checking reported signer IDs against its own `dkg_public_shares`, `dkg_private_shares`, and threshold calculations. However, this validation is not implemented.

## Impact Explanation

This vulnerability breaks the core security guarantee that the DKG protocol should be resilient to up to threshold-1 malicious signers. A single malicious signer (well below the threshold) can prevent DKG completion by sending false failure reports that the coordinator cannot distinguish from legitimate ones.

**Concrete Harm:**
- Prevents formation of new aggregate public keys required for threshold signing
- Blocks initial DKG setup and key rotation operations
- Wastes computational resources (polynomial generation, O(nÂ²) share exchanges, commitment verification) across all honest participants
- Creates indefinite availability issues with no detection or mitigation mechanism

**Severity Assessment:**
This maps to **Low severity** under "Any remotely-exploitable denial of service in a node" or "Any network denial of service impacting more than 10 percent of miners that does not shut down the network." 

If WSTS DKG is used for consensus-critical operations like Stacks signer set formation, this could map to **Medium severity** under "Any transient consensus failures" as it prevents new signers from joining the consensus process.

Existing aggregate keys can continue signing operations, so this does not constitute a complete network shutdown (which would be Critical severity).

## Likelihood Explanation

**Attacker Capabilities Required:**
- Registered signer with valid keys in the WSTS configuration (within standard threat model)
- Network access to send messages to the coordinator (standard protocol operation)
- No cryptographic breaks, insider access, or special privileges required

**Attack Complexity:**
Extremely low. The attacker simply modifies their signer implementation to return false failure status in the `dkg_ended()` method: [10](#0-9) 

Instead of honest checking, return:
```rust
DkgEnd {
    dkg_id: self.dkg_id,
    signer_id: self.signer_id,
    status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(victim_signer_ids)),
}
```

**Detection and Cost:**
- No detection mechanism exists - the coordinator logs the failure but cannot determine it's false
- No economic cost (no slashing, bonds, or reputation system)
- The malicious signer is not added to `malicious_signers` and can repeat indefinitely
- Zero risk to the attacker

**Probability:** High. Any compromised signer can trivially execute this attack with certainty of success.

## Recommendation

Implement validation logic for the three unvalidated failure types in `gather_dkg_end()`:

**1. For `DkgFailure::MissingPublicShares(missing_ids)`:**
```rust
DkgFailure::MissingPublicShares(missing_ids) => {
    for missing_id in missing_ids {
        // Check if the reportedly missing signer actually sent public shares
        if self.dkg_public_shares.contains_key(missing_id) {
            // False report - mark reporter as malicious
            malicious_signers.insert(*signer_id);
            break;
        }
    }
    // If no false reports, the claim may be legitimate due to timing
}
```

**2. For `DkgFailure::MissingPrivateShares(missing_ids)`:**
```rust
DkgFailure::MissingPrivateShares(missing_ids) => {
    for missing_id in missing_ids {
        // Check if the reportedly missing signer actually sent private shares
        if self.dkg_private_shares.contains_key(missing_id) {
            // False report - mark reporter as malicious
            malicious_signers.insert(*signer_id);
            break;
        }
    }
}
```

**3. For `DkgFailure::Threshold`:**
```rust
DkgFailure::Threshold => {
    // Recompute threshold check from coordinator's view
    let signer_ids_set: HashSet<u32> = self.dkg_public_shares.keys().copied().collect();
    let mut num_dkg_keys = 0u32;
    for id in &signer_ids_set {
        if let Some(key_ids) = self.config.public_keys.signer_key_ids.get(id) {
            num_dkg_keys = num_dkg_keys.saturating_add(key_ids.len() as u32);
        }
    }
    
    if num_dkg_keys >= self.config.dkg_threshold {
        // Threshold was actually met - false report
        malicious_signers.insert(*signer_id);
    }
}
```

**4. Implement enforcement:** Ensure `malicious_dkg_signer_ids` is consulted during DKG initialization to exclude previously identified malicious signers from future rounds.

## Proof of Concept

The vulnerability can be demonstrated with the following test case that shows a malicious signer can cause DKG to fail by sending a false `MissingPrivateShares` report even when all signers sent their shares:

```rust
#[test]
fn test_false_missing_private_shares_causes_dkg_failure() {
    // Setup coordinator with 3 signers, threshold of 2
    let mut coordinator = setup_fire_coordinator(3, 2);
    
    // All signers complete DKG normally and send public/private shares
    // Coordinator records all shares in dkg_public_shares and dkg_private_shares
    
    // Malicious signer (signer_id=0) sends false failure report
    let malicious_dkg_end = DkgEnd {
        dkg_id: coordinator.current_dkg_id,
        signer_id: 0,
        status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
            HashSet::from([1, 2]) // False claim - these signers actually sent shares
        )),
    };
    
    // Honest signers send success
    let honest_dkg_end_1 = DkgEnd {
        dkg_id: coordinator.current_dkg_id,
        signer_id: 1,
        status: DkgStatus::Success,
    };
    let honest_dkg_end_2 = DkgEnd {
        dkg_id: coordinator.current_dkg_id,
        signer_id: 2,
        status: DkgStatus::Success,
    };
    
    // Process all DkgEnd messages
    coordinator.gather_dkg_end(&make_packet(malicious_dkg_end));
    coordinator.gather_dkg_end(&make_packet(honest_dkg_end_1));
    let result = coordinator.gather_dkg_end(&make_packet(honest_dkg_end_2));
    
    // Assert: DKG fails due to false report
    assert!(matches!(result, Err(Error::DkgFailure { .. })));
    
    // Assert: Malicious signer is NOT detected
    // (This is the bug - malicious_signers should contain signer 0)
    if let Err(Error::DkgFailure { malicious_signers, .. }) = result {
        assert!(malicious_signers.is_empty()); // BUG: Should contain signer 0
    }
}
```

This test demonstrates that a single malicious signer's false failure report causes DKG to fail for all participants without the malicious signer being identified, allowing indefinite repeated attacks.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L40-41)
```rust
    dkg_public_shares: BTreeMap<u32, DkgPublicShares>,
    dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/fire.rs (L608-610)
```rust
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
```

**File:** src/state_machine/coordinator/fire.rs (L617-619)
```rust
                        DkgFailure::Threshold => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L779-788)
```rust
            if reported_failures.is_empty() {
                debug!("no dkg failures");
                self.dkg_end_gathered()?;
            } else {
                // TODO: see if we have sufficient non-malicious signers to continue
                warn!("got dkg failures");
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers,
                });
```

**File:** src/net.rs (L168-175)
```rust
pub struct DkgPrivateBegin {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    pub signer_ids: Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    pub key_ids: Vec<u32>,
}
```

**File:** src/net.rs (L219-228)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG end begin message from signer to all signers and coordinator
pub struct DkgEndBegin {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer IDs who responded in time for this DKG round
    pub signer_ids: Vec<u32>,
    /// Key IDs who responded in time for this DKG round
    pub key_ids: Vec<u32>,
}
```

**File:** src/state_machine/signer/mod.rs (L528-549)
```rust
        // fist check to see if dkg_threshold has been met
        let signer_ids_set: HashSet<u32> = dkg_end_begin
            .signer_ids
            .iter()
            .filter(|&&id| id < self.total_signers)
            .copied()
            .collect::<HashSet<u32>>();
        let mut num_dkg_keys = 0u32;
        for id in &signer_ids_set {
            if let Some(key_ids) = self.public_keys.signer_key_ids.get(id) {
                let len: u32 = key_ids.len().try_into()?;
                num_dkg_keys = num_dkg_keys.saturating_add(len);
            }
        }

        if num_dkg_keys < self.dkg_threshold {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::Threshold),
            }));
        }
```

**File:** src/state_machine/signer/mod.rs (L551-582)
```rust
        for signer_id in &signer_ids_set {
            if let Some(shares) = self.dkg_public_shares.get(signer_id) {
                if shares.comms.is_empty() {
                    missing_public_shares.insert(*signer_id);
                } else {
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
                }
            } else {
                missing_public_shares.insert(*signer_id);
            }
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L601-608)
```rust
        if !missing_private_shares.is_empty() {
            return Ok(Message::DkgEnd(DkgEnd {
                dkg_id: self.dkg_id,
                signer_id: self.signer_id,
                status: DkgStatus::Failure(DkgFailure::MissingPrivateShares(
                    missing_private_shares,
                )),
            }));
```
