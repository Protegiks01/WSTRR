### Title
Polynomial Replacement Attack via Duplicate DkgBegin Processing

### Summary
The signer state machine fails to prevent processing duplicate `DkgBegin` messages for the same DKG round, allowing a malicious coordinator to force polynomial regeneration mid-round. This causes the signer to replace its polynomial after broadcasting commitments, resulting in a mismatch between committed and actual polynomials that causes DKG failure with `BadPrivateShares` errors.

### Finding Description

The vulnerability exists in the signer's `dkg_begin()` function [1](#0-0) , which unconditionally calls `reset()` without checking if the provided `dkg_id` has already been processed. The `reset()` function regenerates polynomials by calling `reset_polys()` [2](#0-1) , which invokes `random_poly()` [3](#0-2) , violating the invariant that each polynomial should be generated exactly once per DKG round.

The state machine's transition rules allow moving from `DkgPublicGather` back to `DkgPublicDistribute` [4](#0-3) , enabling duplicate `DkgBegin` messages to be accepted during an active DKG round. This differs from the coordinator, which explicitly checks for duplicate `dkg_id` values and returns early [5](#0-4) .

While the signer has duplicate detection for incoming `DkgPublicShares` messages from other signers [6](#0-5) , this only prevents storing multiple shares from the same `signer_id`. When a signer regenerates its own polynomial and broadcasts new commitments, other signers ignore the second broadcast but retain the first commitments. The private shares generated from the new polynomial fail validation against the old commitments [7](#0-6) , causing DKG termination.

### Impact Explanation

This vulnerability enables a malicious coordinator to cause deterministic DKG failure, constituting a **transient consensus failure** (Medium severity per protocol scope). 

**Specific harm:**
- DKG round fails with `BadPrivateShares` error, requiring restart with new `dkg_id`
- All participating signers waste computational resources and time
- Delays threshold signature operations that depend on successful DKG
- No recovery mechanism exists within the same DKG round

**Affected parties:**
- All signers in the DKG round
- Systems depending on timely DKG completion for threshold operations
- Potential blockchain consensus delays if DKG is required for validator key generation

**Quantification:**
For a system with N signers and threshold T:
- One malicious coordinator message causes 100% DKG failure
- Affects all N signers simultaneously
- Requires full DKG restart (multiple round-trip messages)
- No limit on attack repetition

### Likelihood Explanation

**Required attacker capabilities:**
- Control of the coordinator role (holds coordinator private signing key)
- Ability to send signed network messages to signers

**Attack complexity:**
- Trivial: Send two identical `DkgBegin` messages with the same `dkg_id`
- Messages must be validly signed with coordinator key [8](#0-7) 
- No timing constraints or race conditions required

**Economic feasibility:**
- Zero marginal cost for attacker (coordinator role already held)
- Network message overhead is negligible
- Can be automated and repeated indefinitely

**Detection risk:**
- Low: Duplicate `DkgBegin` messages appear valid to signers
- No alerting or rate limiting mechanisms present
- Difficult to distinguish from network retransmissions without logging
- Only detectable post-facto when DKG fails

**Estimated probability:**
- 100% success rate if coordinator is compromised
- Depends on coordinator security model (semi-trusted vs. Byzantine)
- Higher risk in systems where coordinator key management is weak

### Recommendation

**Primary fix:** Add `dkg_id` validation to the signer's `dkg_begin()` function:

```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Prevent processing duplicate DkgBegin for same dkg_id
    if self.dkg_id == dkg_begin.dkg_id && self.state != State::Idle {
        info!(
            signer_id = %self.signer_id,
            dkg_id = %dkg_begin.dkg_id,
            "Ignoring duplicate DkgBegin message"
        );
        return Ok(vec![]);
    }
    
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Alternative mitigation:** Restrict state transitions to prevent `DkgPublicGather -> DkgPublicDistribute` [4](#0-3) , though this may affect legitimate error recovery flows.

**Testing recommendations:**
- Add unit test simulating duplicate `DkgBegin` with same `dkg_id` during `DkgPublicGather` state
- Verify that second message is ignored and polynomial remains unchanged
- Confirm DKG completes successfully despite duplicate coordinator messages
- Test edge case of duplicate with different `dkg_id` (should be accepted)

**Deployment considerations:**
- Non-breaking change: maintains compatibility with existing protocol
- Deploy to all signers before activating
- Consider adding metrics/alerts for duplicate message detection
- Review coordinator implementations for accidental message duplication

### Proof of Concept

**Exploitation algorithm:**

1. **Setup:** Standard DKG configuration with N signers, threshold T, coordinator C with valid signing key

2. **Initial DKG start:**
   - Coordinator C sends `DkgBegin(dkg_id=1)` signed with coordinator key
   - Signer S receives, verifies signature (passes)
   - Signer S calls `reset(dkg_id=1)`, generates polynomial P1 via `random_poly()`
   - Signer S transitions: `Idle -> DkgPublicDistribute -> DkgPublicGather`
   - Signer S broadcasts `DkgPublicShares(dkg_id=1, commitments=[Com(P1)])`

3. **Attack injection:**
   - Coordinator C sends duplicate `DkgBegin(dkg_id=1)` signed with same key
   - Signer S in state `DkgPublicGather`, receives message
   - Signature verification passes (valid coordinator signature)
   - State transition check: `DkgPublicGather -> DkgPublicDistribute` allowed
   - Signer S calls `reset(dkg_id=1)` again, generates NEW polynomial P2 â‰  P1
   - Signer S broadcasts new `DkgPublicShares(dkg_id=1, commitments=[Com(P2)])`

4. **Failure propagation:**
   - Other signers receive first `DkgPublicShares` from S, store `Com(P1)`
   - Other signers receive second `DkgPublicShares` from S, ignore (duplicate by `signer_id`)
   - Signer S computes private shares from P2: `shares_P2 = {eval(P2, i) for i in keyIds}`
   - Signer S distributes encrypted `shares_P2`
   - Other signers decrypt `shares_P2`, attempt validation: `shares_P2 * G ?= Com(P1)`
   - Validation fails: shares from P2 don't match commitments to P1
   - DKG terminates with `DkgStatus::Failure(DkgFailure::BadPrivateShares)`

**Expected vs actual behavior:**
- **Expected:** Duplicate `DkgBegin(dkg_id=1)` ignored, DKG proceeds with P1
- **Actual:** Duplicate accepted, polynomial replaced with P2, DKG fails

**Reproduction steps:**
1. Deploy coordinator and 3 signers with threshold=2
2. Coordinator calls `start_dkg_round(dkg_id=1)`
3. After receiving `DkgPublicGather` state confirmation, coordinator sends second `DkgBegin(dkg_id=1)`
4. Observe signer logs showing polynomial regeneration
5. Observe DKG failure with `BadPrivateShares` error for affected signer

### Notes

The coordinator implementation correctly prevents this issue by checking `current_dkg_id == dkg_begin.dkg_id` before processing, but this protection is absent in the signer implementation. This asymmetry suggests the vulnerability was introduced by incomplete porting of the duplicate detection logic.

### Citations

**File:** src/state_machine/signer/mod.rs (L424-424)
```rust
        self.signer.reset_polys(rng);
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/signer/mod.rs (L1004-1011)
```rust
        let have_shares = self
            .dkg_public_shares
            .contains_key(&dkg_public_shares.signer_id);

        if have_shares {
            info!(signer_id = %dkg_public_shares.signer_id, "received duplicate DkgPublicShares");
            return Ok(vec![]);
        }
```

**File:** src/state_machine/signer/mod.rs (L1161-1165)
```rust
            State::DkgPublicDistribute => {
                prev_state == &State::Idle
                    || prev_state == &State::DkgPublicGather
                    || prev_state == &State::DkgPrivateDistribute
            }
```

**File:** src/v1.rs (L127-128)
```rust
        self.f = Some(VSS::random_poly(self.threshold - 1, rng));
    }
```

**File:** src/v1.rs (L191-195)
```rust
        for (i, s) in private_shares.iter() {
            if let Some(comm) = public_shares.get(i) {
                if s * G != compute::poly(&self.id(), &comm.poly)? {
                    bad_shares.push(*i);
                }
```

**File:** src/state_machine/coordinator/frost.rs (L76-78)
```rust
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
```

**File:** src/net.rs (L494-498)
```rust
            Message::DkgBegin(msg) => {
                if !msg.verify(&self.sig, coordinator_public_key) {
                    warn!("Received a DkgBegin message with an invalid signature.");
                    return false;
                }
```
