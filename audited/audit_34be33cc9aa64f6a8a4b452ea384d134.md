### Title
Coordinator Fails to Validate and Exclude Signers Sending Empty Private Shares During DKG

### Summary
The `empty_private_shares` test correctly verifies that signers detect when one participant sends empty shares, but fails to test whether the coordinator validates these reports and marks the malicious signer. Both Fire and FROST coordinators collect `MissingPrivateShares` failure reports but do not validate them or add the offending signer to `malicious_signers`, enabling persistent DKG denial-of-service attacks where a malicious participant can repeatedly cause DKG failures without being excluded.

### Finding Description

**Test Gap in `src/state_machine/coordinator/mod.rs` (lines 1777-1879):** [1](#0-0) 

The test mutates only signer 0's messages to send empty private shares while other signers send valid shares, correctly simulating the partial failure scenario. However, at lines 1854-1862, the test uses `..` to ignore the `malicious_signers` field: [2](#0-1) 

The test only verifies that `reported_failures` contains the expected failures, but does NOT verify that the malicious signer is added to `malicious_signers`.

**Fire Coordinator Missing Validation in `src/state_machine/coordinator/fire.rs` (lines 765-770):** [3](#0-2) 

When processing `DkgFailure::MissingPrivateShares` reports at line 768, the coordinator only has a TODO comment but performs no validation. Unlike `BadPrivateShares` (lines 652-763) which verifies DH tuple proofs and validates encrypted shares, `MissingPrivateShares` reports are collected at line 610 but never validated: [4](#0-3) 

No signers are added to `malicious_signers` for this failure type, so the offending signer is never added to `self.malicious_dkg_signer_ids` at line 776: [5](#0-4) 

**FROST Coordinator Also Lacks Validation in `src/state_machine/coordinator/frost.rs` (lines 400-417):** [6](#0-5) 

The FROST coordinator always returns an empty `malicious_signers` set (line 415), never validating any failure type.

**Signer Detection Works Correctly in `src/state_machine/signer/mod.rs` (lines 567-582):** [7](#0-6) 

Individual signers correctly detect empty shares at line 569 and report them via `DkgFailure::MissingPrivateShares`, but the coordinator fails to act on these reports.

### Impact Explanation

**Specific Harm:**
A malicious signer can execute a persistent denial-of-service attack on the DKG protocol by repeatedly sending empty private shares. Each attempt causes all honest signers to report `MissingPrivateShares`, the DKG fails, but the malicious signer is not marked in `malicious_dkg_signer_ids` and can participate in retry attempts indefinitely.

**Quantified Impact:**
- In a system with 10 signers where 1 is malicious, the attacker can prevent DKG completion forever
- Each DKG round consumes network bandwidth and computational resources (polynomial generation, encryption, commitment verification)
- If WSTS is used for validator key generation in a blockchain system, this prevents the validator set from establishing threshold signatures, blocking consensus
- The coordinator has access to `dkg_private_shares` (line 261 of SavedState) to validate empty shares but does not use it: [8](#0-7) 

**Affected Parties:**
All participants in the DKG protocol, as well as any dependent systems awaiting DKG completion to establish threshold signing capability.

**Severity Justification:**
This maps to **Medium** severity under "Any transient consensus failures." While the attack doesn't compromise the security of successfully completed DKGs, it prevents the system from establishing consensus on the aggregate public key, which is a prerequisite for threshold signing operations. In blockchain contexts where WSTS is used for validator coordination, this prevents validators from becoming operational.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control of a single signer in the DKG protocol (1 out of N participants)
- Ability to send network messages (standard participant capability)
- No cryptographic breaks required

**Attack Complexity:**
Trivial. The attacker simply modifies their DKG private shares message to contain an empty `shares` vector, or omits sending the message entirely.

**Exploitation Steps:**
1. Attacker participates in DKG public shares phase normally
2. During private shares phase, attacker sends `DkgPrivateShares` with `shares: vec![]`
3. All honest signers detect this at line 569 and report `MissingPrivateShares`
4. Coordinator collects reports but does not validate or mark attacker as malicious
5. DKG fails, system retries
6. Attacker repeats from step 1

**Economic Feasibility:**
No cost to attacker beyond normal participation. The attack requires no special resources.

**Detection Risk:**
Low. The attack appears as a "normal" DKG failure with reported issues. Without explicit validation logic, it's difficult to distinguish malicious behavior from network issues.

**Probability of Success:**
100% - The coordinator code has no validation for this failure type, so the attack always succeeds in causing DKG failure without marking the attacker.

### Recommendation

**Primary Fix - Add Validation in Fire Coordinator:**

In `src/state_machine/coordinator/fire.rs` at lines 768-770, replace the TODO comment with validation logic:

```rust
DkgFailure::MissingPrivateShares(reported_missing) => {
    // Validate each report by checking if shares are actually empty
    for bad_signer_id in reported_missing {
        if let Some(shares) = self.dkg_private_shares.get(bad_signer_id) {
            if shares.shares.is_empty() {
                // Shares are actually empty, mark as malicious
                warn!("Signer {bad_signer_id} sent empty private shares, marking malicious");
                malicious_signers.insert(*bad_signer_id);
            } else {
                // False report, mark reporter as malicious
                warn!("Signer {signer_id} falsely reported missing shares from {bad_signer_id}, marking {signer_id} malicious");
                malicious_signers.insert(*signer_id);
            }
        } else {
            // No shares received at all, mark as malicious
            warn!("Signer {bad_signer_id} did not send private shares, marking malicious");
            malicious_signers.insert(*bad_signer_id);
        }
    }
}
```

**Secondary Fix - Update FROST Coordinator:**
Similar validation logic should be added to `src/state_machine/coordinator/frost.rs` to validate failure reports.

**Testing Fix - Update Test:**
In `src/state_machine/coordinator/mod.rs` at line 1854, change the destructuring to explicitly check `malicious_signers`:

```rust
let OperationResult::DkgError(DkgError::DkgEndFailure {
    reported_failures,
    malicious_signers,
}) = &operation_results[0]
```

Then add assertion:
```rust
let expected_malicious = vec![0].into_iter().collect::<HashSet<u32>>();
assert_eq!(&expected_malicious, malicious_signers, 
    "Expected signer 0 to be marked malicious");
```

**Additional Validation:**
Consider adding similar validation for `MissingPublicShares` (line 765-767) to ensure comprehensive malicious signer detection.

### Proof of Concept

**Reproduction Steps:**

1. Run the existing `empty_private_shares` test - it passes because it doesn't check `malicious_signers`
2. Modify the test to check `malicious_signers` field as shown in the recommendation
3. Test will fail, revealing that signer 0 is not marked malicious
4. Apply the coordinator fix from the recommendation
5. Test will now pass with signer 0 correctly marked as malicious

**Expected vs Actual Behavior:**

**Expected:** When signer 0 sends empty private shares:
- Signers report `MissingPrivateShares([0])`  ✓ (works)
- Coordinator validates reports  ✗ (missing)
- Coordinator marks signer 0 in `malicious_signers`  ✗ (missing)
- Signer 0 added to `malicious_dkg_signer_ids`  ✗ (missing)
- Signer 0 excluded from future DKG rounds  ✗ (missing)

**Actual:** Signer 0 is never marked malicious and can repeat the attack indefinitely.

**Attack Demonstration:**
A malicious signer can create a simple DKG client that sends valid public shares but empty private shares in every DKG round, permanently preventing DKG completion while remaining an "accepted" participant in the protocol.

### Citations

**File:** src/state_machine/coordinator/mod.rs (L260-261)
```rust
    /// map of DkgPrivateShares indexed by signer ID
    pub dkg_private_shares: BTreeMap<u32, DkgPrivateShares>,
```

**File:** src/state_machine/coordinator/mod.rs (L1777-1879)
```rust
    pub fn empty_private_shares<Coordinator: CoordinatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
    ) {
        let (mut coordinators, mut signers) =
            setup::<Coordinator, SignerType>(num_signers, keys_per_signer);

        // We have started a dkg round
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_dkg_round(None)
            .unwrap();
        assert!(coordinators
            .first_mut()
            .unwrap()
            .get_aggregate_public_key()
            .is_none());
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::DkgPublicGather
        );

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        for coordinator in coordinators.iter() {
            assert_eq!(coordinator.get_state(), State::DkgPrivateGather);
        }

        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::DkgPrivateBegin(_)),
            "Expected DkgPrivateBegin message"
        );

        // Send the DKG Begin message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) = feedback_mutated_messages(
            &mut coordinators,
            &mut signers,
            &[outbound_messages[0].clone()],
            |signer, packets| {
                if signer.signer_id != 0 {
                    return packets.clone();
                }
                packets
                    .iter()
                    .map(|packet| {
                        let Message::DkgPrivateShares(shares) = &packet.msg else {
                            return packet.clone();
                        };
                        let private_shares = crate::net::DkgPrivateShares {
                            dkg_id: shares.dkg_id,
                            signer_id: shares.signer_id,
                            shares: vec![],
                        };
                        Packet {
                            msg: Message::DkgPrivateShares(private_shares),
                            sig: vec![],
                        }
                    })
                    .collect()
            },
        );
        assert_eq!(operation_results.len(), 0);
        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(&outbound_messages[0].msg, Message::DkgEndBegin(_)),
            "Expected DkgEndBegin message"
        );

        // Send the DkgEndBegin message to all signers and share their responses with the coordinator and signers
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &outbound_messages);
        assert_eq!(outbound_messages.len(), 0);
        assert_eq!(operation_results.len(), 1);
        let OperationResult::DkgError(DkgError::DkgEndFailure {
            reported_failures, ..
        }) = &operation_results[0]
        else {
            panic!(
                "Expected OperationResult::DkgError(DkgError::DkgEndFailure) got {:?}",
                operation_results[0]
            );
        };
        assert_eq!(
            reported_failures.len(),
            num_signers as usize,
            "Expected {num_signers} DkgFailures got {}",
            reported_failures.len()
        );
        let expected_signer_ids = (0..1).collect::<HashSet<u32>>();
        for dkg_failure in reported_failures {
            let (_, DkgFailure::MissingPrivateShares(signer_ids)) = dkg_failure else {
                panic!("Expected DkgFailure::MissingPublicShares got {dkg_failure:?}");
            };
            assert_eq!(
                expected_signer_ids, *signer_ids,
                "Expected signer_ids {expected_signer_ids:?} got {signer_ids:?}"
            );
        }
    }
```

**File:** src/state_machine/coordinator/fire.rs (L607-620)
```rust
            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());

                    match dkg_failure {
                        DkgFailure::BadState => {
                            // signer should not be in a bad state so treat as malicious
                            malicious_signers.insert(*signer_id);
                        }
                        DkgFailure::Threshold => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::BadPublicShares(bad_shares) => {
```

**File:** src/state_machine/coordinator/fire.rs (L765-770)
```rust
                        DkgFailure::MissingPublicShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
                        DkgFailure::MissingPrivateShares(_) => {
                            // this shouldn't happen, maybe mark signer malicious?
                        }
```

**File:** src/state_machine/coordinator/fire.rs (L775-777)
```rust
            for id in &malicious_signers {
                self.malicious_dkg_signer_ids.insert(*id);
            }
```

**File:** src/state_machine/coordinator/frost.rs (L400-417)
```rust
        if self.ids_to_await.is_empty() {
            let mut reported_failures = HashMap::new();

            for (signer_id, dkg_end) in &self.dkg_end_messages {
                if let DkgStatus::Failure(dkg_failure) = &dkg_end.status {
                    warn!(%signer_id, ?dkg_failure, "DkgEnd failure");
                    reported_failures.insert(*signer_id, dkg_failure.clone());
                }
            }

            if reported_failures.is_empty() {
                self.dkg_end_gathered()?;
            } else {
                return Err(Error::DkgFailure {
                    reported_failures,
                    malicious_signers: Default::default(),
                });
            }
```

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```
