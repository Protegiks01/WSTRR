### Title
Zero Polynomial Constant Term Bypasses DKG Threshold Security

### Summary
A malicious party can set their polynomial constant term to zero during DKG, pass all validation checks including the Schnorr ID proof, and contribute nothing to the group public key. This effectively reduces the threshold security from T-of-N to (T-1)-of-N, allowing T-1 compromised parties to reconstruct the group secret instead of the required T parties.

### Finding Description

**Location:** [1](#0-0) 

The vulnerability exists in the DKG polynomial commitment generation and validation flow. When a party generates a polynomial commitment, the constant term `poly.data()[0]` is used to create a Schnorr ID proof: [2](#0-1) 

The Schnorr ID proof is constructed to prove knowledge of the constant term 'a': [3](#0-2) 

When `a = 0`, the proof becomes `kca = k + c * 0 = k`, and verification checks `k * G == kG + c * Point::identity()`, which simplifies to `k * G == kG` and always passes: [4](#0-3) 

The existing validation in `check_public_shares` only verifies the Schnorr proof and polynomial length, not whether the constant term is non-zero: [5](#0-4) 

During secret computation, each party's polynomial constant term is added to the group key. A zero contribution adds `Point::identity()` (the identity element), contributing nothing: [6](#0-5) 

**Root Cause:** The Schnorr ID proof construction does not enforce that the proven scalar is non-zero. When `a = 0`, the proof degenerates to proving knowledge of a random nonce rather than a meaningful secret contribution.

**Why Existing Mitigations Fail:** 
- The polynomial commitment verification passes because the Schnorr proof is mathematically valid for `a = 0`
- The aggregate key check in the coordinator only validates that the sum matches the expected key, not that individual contributions are non-zero: [7](#0-6) 

- Parties can load arbitrary polynomial data via `Party::load()`, enabling intentional zero constant terms: [8](#0-7) 

### Impact Explanation

**Specific Harm:** A malicious party reduces the effective threshold from T to T-1. An adversary who compromises T-1 honest parties (instead of the required T) can reconstruct the group secret and forge signatures.

**Quantitative Impact:**
- In a 7-of-10 threshold setup with one malicious zero-contributor, the security degrades to 6-of-10
- Each additional zero-contributor further reduces the threshold
- This violates the fundamental security assumption of threshold signatures

**Who is Affected:**
- All participants relying on the T-of-N threshold guarantee
- Systems using WSTS for Bitcoin/Stacks consensus or fund custody
- Any application where threshold security is critical

**Severity Justification:** MEDIUM per scope definition. This enables:
- **Transient consensus failures**: If the threshold is used for validator signing, compromising T-1 validators (instead of T) can produce unauthorized signatures
- **Potential fund theft**: In custody applications, T-1 compromised parties can steal funds
- **Chain-level impact**: In blockchain integrations, this could lead to invalid transaction confirmations if threshold requirements are bypassed

The impact does not reach HIGH/CRITICAL because it requires:
1. A malicious party in the initial DKG ceremony
2. Subsequent compromise of T-1 (not T) honest parties
3. No persistent code execution or immediate fund loss

### Likelihood Explanation

**Required Attacker Capabilities:**
- Must be a participant in the DKG ceremony
- Ability to construct and load custom `PartyState` with zero constant term polynomial
- No cryptographic breaks required

**Attack Complexity:**
1. Malicious party creates a polynomial with `data()[0] = Scalar::zero()`
2. Loads this via `Party::load()` with crafted `PartyState`
3. Generates polynomial commitment via `get_poly_commitment()` - ID proof verifies
4. Broadcasts commitment to other parties
5. All validation checks pass (`check_public_shares`, Schnorr proof verification)
6. Party contributes `Point::identity()` to group key
7. Later, adversary compromises T-1 honest parties and reconstructs secret

**Economic Feasibility:** Low cost - requires only participation in DKG setup, no ongoing resource expenditure.

**Detection Risk:** Low - the zero contribution is not easily detectable without explicit point identity checks. The malicious party appears as a valid participant.

**Probability of Success:** High if the attacker can participate in DKG. The attack is deterministic once the zero polynomial is accepted.

### Recommendation

**Primary Fix:** Add explicit validation that polynomial constant terms are non-zero:

In `src/common.rs`, modify `check_public_shares`:
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) 
        && poly_comm.poly.len() == threshold
        && poly_comm.poly[0] != Point::identity()  // NEW: Reject zero contributions
}
```

**Alternative Mitigation:** Add validation in `ID::new()` to reject zero scalar:
```rust
pub fn new<RNG: RngCore + CryptoRng>(
    id: &Scalar,
    a: &Scalar,
    ctx: &[u8],
    rng: &mut RNG,
) -> Self {
    assert!(a != &Scalar::zero(), "Polynomial constant term must be non-zero");
    // ... existing code
}
```

**Testing Recommendations:**
1. Create test case with zero constant term polynomial
2. Verify it's rejected during DKG
3. Test with multiple zero contributors
4. Verify threshold security is maintained

**Deployment Considerations:**
- Breaking change - existing saved states with zero terms will be rejected
- Coordinate upgrade across all DKG participants
- Audit existing deployments for zero contributions before upgrade

### Proof of Concept

**Attack Algorithm:**

```
1. Attacker Setup:
   - Construct polynomial: P(x) = 0 + a₁x + a₂x² + ... + aₜ₋₁xᵗ⁻¹
   - Create PartyState with this polynomial
   - Load via Party::load()

2. DKG Phase:
   - Call get_poly_commitment() 
   - ID proof: kca = k + c * 0 = k
   - Commitment: poly = [Point::identity(), a₁*G, a₂*G, ..., aₜ₋₁*G]
   - Broadcast to other parties

3. Validation (All Pass):
   - check_public_shares(): 
     * poly_comm.verify(ctx) → TRUE (kca*G == kG + c*Point::identity())
     * poly.len() == threshold → TRUE
   - compute_secret():
     * group_key += Point::identity() → No contribution added

4. Result:
   - Effective threshold: T-1 parties
   - Group key = Σᵢ₌₁ⁿ⁻¹ Pᵢ(0) * G  (missing attacker's contribution)

5. Exploitation:
   - Adversary compromises T-1 honest parties
   - Reconstructs secret via Lagrange interpolation
   - Forges signatures with group key
```

**Expected vs Actual Behavior:**

Expected: DKG should reject polynomial commitments with zero constant terms, maintaining T-of-N threshold security.

Actual: Zero constant terms pass all validation checks, reducing effective threshold to (T-1)-of-N.

**Reproduction Steps:**

1. Create two signers with threshold T=3, num_keys N=5
2. For malicious signer, construct polynomial with constant term = 0
3. Load via `Party::load()` or manually set `f` field
4. Run DKG with `get_poly_commitments()` and `compute_secrets()`
5. Observe: All validations pass
6. Verify: Group public key missing malicious party's contribution
7. Test: Reconstruct secret with only 2 honest parties instead of required 3

### Citations

**File:** src/v1.rs (L68-84)
```rust
    pub fn load(id: u32, n: u32, t: u32, group_key: &Point, state: &traits::PartyState) -> Self {
        assert_eq!(state.private_keys.len(), 1);
        assert_eq!(state.private_keys[0].0, id);

        let private_key = state.private_keys[0].1;

        Self {
            id,
            num_keys: n,
            threshold: t,
            f: state.polynomial.clone(),
            public_key: private_key * G,
            private_key,
            group_key: *group_key,
            nonce: state.nonce.clone(),
        }
    }
```

**File:** src/v1.rs (L107-123)
```rust
    pub fn get_poly_commitment<RNG: RngCore + CryptoRng>(
        &self,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Option<PolyCommitment> {
        if let Some(poly) = &self.f {
            Some(PolyCommitment {
                id: ID::new(&self.id(), &poly.data()[0], ctx, rng),
                poly: (0..poly.data().len())
                    .map(|i| &poly.data()[i] * G)
                    .collect(),
            })
        } else {
            warn!("get_poly_commitment called with no polynomial");
            None
        }
    }
```

**File:** src/v1.rs (L156-167)
```rust
        self.private_key = Scalar::zero();
        self.group_key = Point::zero();

        let threshold: usize = self.threshold.try_into()?;
        let mut bad_ids = Vec::new(); //: Vec<u32> = polys
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
        }
```

**File:** src/schnorr.rs (L31-45)
```rust
    pub fn new<RNG: RngCore + CryptoRng>(
        id: &Scalar,
        a: &Scalar,
        ctx: &[u8],
        rng: &mut RNG,
    ) -> Self {
        let k = Scalar::random(rng);
        let c = Self::challenge(id, &(&k * &G), &(a * &G), ctx);

        Self {
            id: *id,
            kG: &k * G,
            kca: &k + c * a,
        }
    }
```

**File:** src/schnorr.rs (L62-65)
```rust
    pub fn verify(&self, A: &Point, ctx: &[u8]) -> bool {
        let c = Self::challenge(&self.id, &self.kG, A, ctx);
        &self.kca * &G == &self.kG + c * A
    }
```

**File:** src/common.rs (L319-321)
```rust
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/coordinator/fire.rs (L1389-1396)
```rust
        let computed_key = party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);
        if computed_key != aggregate_key {
            return Err(Error::AggregateKeyPolynomialMismatch(
                computed_key,
                aggregate_key,
            ));
```
