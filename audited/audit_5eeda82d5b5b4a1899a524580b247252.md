### Title
FIRE Coordinator Panic Due to Premature Wait List Removal Before Validation

### Summary
The FIRE coordinator's `gather_sig_shares()` function removes signers from the wait list before validating their signature shares, causing a panic when aggregation attempts to access non-existent signature shares from signers whose validation failed. Any malicious signer can exploit this to crash the coordinator by sending invalid signature shares, preventing signature production and potentially blocking network transaction confirmation.

### Finding Description

**Exact Location**: `src/state_machine/coordinator/fire.rs`, function `gather_sig_shares()`, lines 1042-1044 and 1134

**Root Cause**: The coordinator removes a signer from `sign_wait_signer_ids` before performing validation checks: [1](#0-0) 

This occurs before any of the validation checks at lines 1046-1076:
- Signer public key validation [2](#0-1) 
- Key IDs configuration validation [3](#0-2) 
- Key IDs matching validation [4](#0-3) 

When validation fails, the function returns an error without inserting the signature shares [5](#0-4) , but the signer has already been removed from the wait list.

When all signers have responded (wait list becomes empty), aggregation is triggered [6](#0-5) . The aggregation code attempts to collect signature shares for ALL signers who sent nonces by iterating over `public_nonces` and accessing `self.signature_shares[i]`: [7](#0-6) 

For signers whose validation failed, this access panics because Rust's `BTreeMap` index operator panics on missing keys. While errors from `gather_sig_shares()` are caught [8](#0-7) , panics crash the process entirely.

**Contrast with FROST Coordinator**: The FROST coordinator correctly removes signers from the wait list AFTER successful validation and insertion [9](#0-8) , preventing this vulnerability.

### Impact Explanation

**Specific Harm**: A malicious signer can crash the FIRE coordinator process by sending intentionally invalid signature shares after sending valid nonces. The coordinator panic prevents signature production entirely.

**Quantified Impact**: In a deployment where:
- N signers participate (e.g., N=10, threshold=7)
- 1 malicious signer sends valid nonces but invalid signature shares
- When all N signers respond, the coordinator crashes during aggregation
- No signatures can be produced until coordinator restart
- The malicious signer can repeatedly trigger this on every signing attempt

**Who is Affected**: All users of WSTS FIRE coordinator variant. If the coordinator is critical for block signing in systems like Stacks, the entire network's ability to confirm transactions is impacted.

**Severity Justification**: This maps to **Critical** severity per the scope definition: "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks". The coordinator crash prevents signature production, which prevents transaction confirmation. While technically a node-level denial of service, the coordinator is a critical component whose failure prevents network operation.

### Likelihood Explanation

**Attacker Capabilities**: Any signer in the WSTS system can exploit this. No special privileges, cryptographic breaks, or additional access required beyond being a registered signer.

**Attack Complexity**: Trivial. The attacker simply:
1. Responds normally to `NonceRequest` with valid nonces
2. When receiving `SignatureShareRequest`, sends a response with invalid data (e.g., wrong `key_ids`, missing public key, etc.)
3. Coordinator removes attacker from wait list, validation fails
4. When all signers respond, coordinator crashes

**Economic Feasibility**: Zero cost beyond network participation. No computational or financial resources required.

**Detection Risk**: The attacker appears as a signer with validation errors, which could be attributed to implementation bugs or network issues. Repeated crashes would eventually reveal malicious intent, but damage occurs immediately.

**Probability of Success**: 100%. The vulnerability is deterministic - any invalid signature share after valid nonce triggers the panic when the wait list empties.

### Recommendation

**Primary Fix**: Move the wait list removal to occur AFTER successful validation and insertion, matching the FROST coordinator pattern:

1. Remove lines 1042-1044 from their current location
2. Insert the removal immediately after line 1091 (after successful insertion into `signature_shares`)
3. Ensure the removal only happens on the successful validation path

**Code changes**:
- Delete lines 1042-1044
- After line 1091, add:
  ```rust
  response_info
      .sign_wait_signer_ids
      .remove(&sig_share_response.signer_id);
  ```

**Alternative Mitigation**: If maintaining early removal for other reasons, use safe access in aggregation:
- Replace line 1134's index operator with `.get()` and filter out `None` values
- Add threshold check before aggregation to ensure sufficient valid shares

**Testing Recommendations**:
1. Add unit test where one signer sends invalid signature shares
2. Verify coordinator doesn't panic and properly handles the error
3. Test with threshold-1 valid signers to ensure proper error reporting
4. Add integration test for repeated attacks

**Deployment Considerations**: 
- This fix is backward compatible and doesn't change the protocol
- No migration needed
- Should be deployed urgently as any signer can trigger the vulnerability

### Proof of Concept

**Attack Algorithm**:
```
1. Setup: WSTS FIRE coordinator with N=3 signers, threshold=2

2. Normal flow starts:
   - Coordinator sends NonceRequest
   - All 3 signers send valid NonceResponses with valid nonces
   - Coordinator sends SignatureShareRequest

3. Attack execution:
   - Signer 0: Sends valid SignatureShareResponse
     → Removed from wait list, validation passes, shares inserted
   
   - Signer 2 (attacker): Sends SignatureShareResponse with wrong key_ids
     → Removed from wait list at line 1044
     → Validation fails at line 1073-1075 (key_ids mismatch)
     → Returns Error, shares NOT inserted in signature_shares
     
   - Signer 1: Sends valid SignatureShareResponse  
     → Removed from wait list, validation passes, shares inserted
     → Wait list now empty (all 3 removed)

4. Aggregation triggered (line 1113):
   - Collects nonces from all 3 signers in public_nonces (line 1115-1119)
   - Attempts to collect shares from all 3 signers (line 1131-1135)
   - For Signer 2: self.signature_shares[2] accesses non-existent key
   - PANIC: "no entry found for key"

5. Result: Coordinator process crashes, no signature produced
```

**Expected vs Actual**:
- Expected: Signer 2's invalid shares rejected, aggregation proceeds with valid signers 0 and 1
- Actual: Coordinator crashes with panic when attempting aggregation

**Reproduction**:
Create a test with 3 signers where the middle signer deliberately sends signature shares with mismatched `key_ids`. The coordinator will panic during aggregation rather than returning a proper error.

### Citations

**File:** src/state_machine/coordinator/fire.rs (L328-333)
```rust
                    if let Err(e) = self.gather_sig_shares(packet, signature_type) {
                        return Ok((
                            None,
                            Some(OperationResult::SignError(SignError::Coordinator(e))),
                        ));
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1046-1053)
```rust
        // check that the signer_id exists in the config
        let signer_public_keys = &self.config.public_keys.signers;
        if !signer_public_keys.contains_key(&sig_share_response.signer_id) {
            warn!(signer_id = %sig_share_response.signer_id, "No public key in config");
            return Err(Error::MissingPublicKeyForSigner(
                sig_share_response.signer_id,
            ));
        };
```

**File:** src/state_machine/coordinator/fire.rs (L1055-1064)
```rust
        // check that the key_ids match the config
        let Some(signer_key_ids) = self
            .config
            .public_keys
            .signer_key_ids
            .get(&sig_share_response.signer_id)
        else {
            warn!(signer_id = %sig_share_response.signer_id, "No keys IDs configured");
            return Err(Error::MissingKeyIDsForSigner(sig_share_response.signer_id));
        };
```

**File:** src/state_machine/coordinator/fire.rs (L1066-1076)
```rust
        let mut sig_share_response_key_ids = HashSet::new();
        for sig_share in &sig_share_response.signature_shares {
            for key_id in &sig_share.key_ids {
                sig_share_response_key_ids.insert(*key_id);
            }
        }

        if *signer_key_ids != sig_share_response_key_ids {
            warn!(signer_id = %sig_share_response.signer_id, "SignatureShareResponse key_ids didn't match config");
            return Err(Error::BadKeyIDsForSigner(sig_share_response.signer_id));
        }
```

**File:** src/state_machine/coordinator/fire.rs (L1088-1091)
```rust
        self.signature_shares.insert(
            sig_share_response.signer_id,
            sig_share_response.signature_shares.clone(),
        );
```

**File:** src/state_machine/coordinator/fire.rs (L1113-1135)
```rust
        if message_nonce.sign_wait_signer_ids.is_empty() {
            // Calculate the aggregate signature
            let nonce_responses = message_nonce
                .public_nonces
                .values()
                .cloned()
                .collect::<Vec<NonceResponse>>();

            let nonces = nonce_responses
                .iter()
                .flat_map(|nr| nr.nonces.clone())
                .collect::<Vec<PublicNonce>>();

            let key_ids = nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.clone())
                .collect::<Vec<u32>>();

            let shares = message_nonce
                .public_nonces
                .iter()
                .flat_map(|(i, _)| self.signature_shares[i].clone())
                .collect::<Vec<SignatureShare>>();
```

**File:** src/state_machine/coordinator/frost.rs (L652-656)
```rust
            self.signature_shares.insert(
                sig_share_response.signer_id,
                sig_share_response.signature_shares.clone(),
            );
            self.ids_to_await.remove(&sig_share_response.signer_id);
```
