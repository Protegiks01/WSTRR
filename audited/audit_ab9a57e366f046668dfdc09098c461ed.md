### Title
Missing DKG ID Monotonicity Validation Allows Coordinator to Disrupt DKG Operations

### Summary
The `dkg_begin()` function accepts DkgBegin messages without validating that the new `dkg_id` is greater than the current one, allowing a malicious or compromised coordinator to reset signers to arbitrary earlier DKG rounds. This enables denial-of-service attacks that disrupt DKG operations and can cause state inconsistency across signers.

### Finding Description

**Location:** [1](#0-0) 

The `dkg_begin()` function unconditionally calls `reset()` with the coordinator-provided `dkg_id` without verifying that the new ID is greater than the current `self.dkg_id`. [2](#0-1) 

The `reset()` function then unconditionally sets the new `dkg_id` and clears all DKG state including commitments, shares, decryption keys, and regenerates cryptographic material.

**Root Cause:** The code assumes the coordinator will only send monotonically increasing `dkg_id` values, but this assumption is not enforced. While the coordinator implementations include a check for duplicate messages, they only verify equality, not that the new ID is strictly greater: [3](#0-2) [4](#0-3) 

Both coordinators reject duplicate `dkg_id` values but accept backwards IDs, then call `start_dkg_round()` which sets the coordinator's state to the provided ID without validation: [5](#0-4) 

**Why Existing Mitigations Fail:** DkgBegin messages are authenticated via packet signatures when `verify_packet_sigs` is enabled, but this only prevents forgery by third parties, not abuse by the coordinator itself. The coordinator is trusted to send valid DkgBegin messages, but the code does not enforce that these messages maintain monotonic `dkg_id` progression. [6](#0-5) 

### Impact Explanation

**Severity: Low** (per audit scope definition: "Any remotely-exploitable denial of service in a node")

A malicious or compromised coordinator can:

1. **Disrupt DKG operations** by repeatedly sending DkgBegin messages with varying `dkg_id` values, forcing signers to reset and lose all current progress
2. **Create state inconsistency** if different signers process messages at different times, some may reset to earlier rounds while others continue, causing DKG to fail
3. **Prevent signing operations** by resetting signers during an active DKG round, requiring a complete restart

**Quantified Impact:**
- All signers must restart DKG from the beginning when reset
- If DKG was 90% complete, all work is lost
- Signing operations fail if signers have inconsistent `dkg_id` values
- Recovery requires coordinated restart with all signers

**Who is Affected:**
All signers participating in the WSTS threshold signing system. In a blockchain context using WSTS for transaction signing, this could impact miners/validators who cannot produce signatures until DKG completes successfully.

**Note on Severity:** While the question labels this as [High], the actual impact maps to Low severity per the audit scope definitions. This does not cause fund loss, chain splits, invalid signature acceptance, or other Critical/High severity impacts. It is a denial-of-service vulnerability that disrupts the signing service.

### Likelihood Explanation

**Prerequisites:**
1. Coordinator must be malicious or compromised, OR
2. Attacker can replay old coordinator messages (if additional network-level replay protection is absent)

**Attack Complexity:** Low
- Coordinator can trivially send a DkgBegin message with `dkg_id` less than current value
- No cryptographic operations required
- Single malicious message disrupts all signers

**Economic Feasibility:** High if coordinator is compromised
- No computational cost beyond sending network messages
- Coordinator compromise could occur through software vulnerabilities, social engineering, or insider threat

**Detection Risk:** Medium
- Abnormal DKG resets would be visible in logs
- However, distinguishing malicious resets from legitimate restarts may be difficult
- No automatic detection mechanism exists in the code

**Estimated Probability:** 
- If coordinator is untrusted/external: Medium to High
- If coordinator is properly secured: Low
- Overall: Medium (depends on deployment security posture)

### Recommendation

**Primary Fix:** Add validation in `dkg_begin()` to reject non-monotonic `dkg_id` values:

```rust
fn dkg_begin<R: RngCore + CryptoRng>(
    &mut self,
    dkg_begin: &DkgBegin,
    rng: &mut R,
) -> Result<Vec<Message>, Error> {
    // Validate that new dkg_id is strictly greater than current
    if dkg_begin.dkg_id <= self.dkg_id {
        warn!(
            "Rejecting DkgBegin with non-monotonic dkg_id: received {}, current {}",
            dkg_begin.dkg_id, self.dkg_id
        );
        return Ok(vec![]); // Silently ignore, or return error
    }
    
    self.reset(dkg_begin.dkg_id, rng);
    self.move_to(State::DkgPublicDistribute)?;
    self.dkg_public_begin(rng)
}
```

**Alternative Mitigations:**
1. Add coordinator-side validation in `start_dkg_round()` to prevent backwards `dkg_id` assignment
2. Implement session-level replay protection with timestamps/nonces
3. Add audit logging for all DKG ID changes to detect anomalies

**Testing Recommendations:**
1. Unit test: Verify that `dkg_begin()` rejects `dkg_id <= self.dkg_id`
2. Integration test: Simulate coordinator sending backwards DKG IDs and verify signer rejection
3. Fuzz test: Send random `dkg_id` sequences and verify state consistency

**Deployment Considerations:**
- This fix is backwards compatible with honest coordinators
- Existing deployments should upgrade signers first, then coordinators
- Monitor logs for rejected DkgBegin messages to detect potential attacks

### Proof of Concept

**Attack Steps:**

1. **Initial State:** All signers have `dkg_id = 10`, DKG is in progress at `DkgPrivateGather` state with 80% of shares collected

2. **Coordinator Action:** Malicious coordinator sends `DkgBegin { dkg_id: 5 }` to all signers

3. **Signer Processing:**
   - Each signer receives the packet
   - Packet signature verifies (signed by coordinator)
   - `process()` routes to `dkg_begin()`
   - No validation occurs on line 849
   - `reset(5, rng)` is called, which:
     - Sets `self.dkg_id = 5`
     - Clears all commitments, shares, and decryption keys
     - Generates new random values
     - Resets to `State::Idle`

4. **Result:** All signers are now at `dkg_id = 5` with empty state, all progress for `dkg_id = 10` is lost

5. **Signing Attempt Fails:** If signing was requested with `dkg_id = 10`, it now fails because signers have `dkg_id = 5` and have no derived secrets

**Expected vs Actual Behavior:**
- **Expected:** Signers reject DkgBegin messages with `dkg_id <= current_dkg_id`
- **Actual:** Signers accept and reset to any coordinator-provided `dkg_id` value

**Reproduction:**
Create a malicious coordinator that calls `start_dkg_round(Some(old_dkg_id))` where `old_dkg_id < current_dkg_id`, then observe that all signers reset their state to the older round.

### Citations

**File:** src/state_machine/signer/mod.rs (L417-432)
```rust
    pub fn reset<T: RngCore + CryptoRng>(&mut self, dkg_id: u64, rng: &mut T) {
        self.dkg_id = dkg_id;
        self.commitments.clear();
        self.decrypted_shares.clear();
        self.decryption_keys.clear();
        self.invalid_private_shares.clear();
        self.public_nonces.clear();
        self.signer.reset_polys(rng);
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_private_begin_msg = None;
        self.dkg_end_begin_msg = None;
        self.kex_private_key = Scalar::random(rng);
        self.kex_public_keys.clear();
        self.state = State::Idle;
    }
```

**File:** src/state_machine/signer/mod.rs (L463-470)
```rust
        if self.verify_packet_sigs {
            let Some(coordinator_public_key) = self.coordinator_public_key else {
                return Err(Error::MissingCoordinatorPublicKey);
            };
            if !packet.verify(&self.public_keys, &coordinator_public_key) {
                return Err(Error::InvalidPacketSignature);
            }
        }
```

**File:** src/state_machine/signer/mod.rs (L844-855)
```rust
    fn dkg_begin<R: RngCore + CryptoRng>(
        &mut self,
        dkg_begin: &DkgBegin,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        self.reset(dkg_begin.dkg_id, rng);
        self.move_to(State::DkgPublicDistribute)?;

        //let _party_state = self.signer.save();

        self.dkg_public_begin(rng)
    }
```

**File:** src/state_machine/coordinator/frost.rs (L75-82)
```rust
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```

**File:** src/state_machine/coordinator/frost.rs (L957-966)
```rust
    fn start_dkg_round(&mut self, dkg_id: Option<u64>) -> Result<Packet, Error> {
        if let Some(id) = dkg_id {
            self.current_dkg_id = id;
        } else {
            self.current_dkg_id = self.current_dkg_id.wrapping_add(1);
        }
        info!("Starting DKG round {}", self.current_dkg_id);
        self.move_to(State::DkgPublicDistribute)?;
        self.start_public_shares()
    }
```

**File:** src/state_machine/coordinator/fire.rs (L230-237)
```rust
                    if let Message::DkgBegin(dkg_begin) = &packet.msg {
                        if self.current_dkg_id == dkg_begin.dkg_id {
                            // We have already processed this DKG round
                            return Ok((None, None));
                        }
                        // use dkg_id from DkgBegin
                        let packet = self.start_dkg_round(Some(dkg_begin.dkg_id))?;
                        return Ok((Some(packet), None));
```
