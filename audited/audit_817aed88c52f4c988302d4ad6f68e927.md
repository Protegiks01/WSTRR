# Audit Report

## Title
Empty Polynomial Vector in PolyCommitment Causes Panic During DKG Validation

## Summary
The `PolyCommitment` struct allows deserialization of empty polynomial vectors, which causes an unchecked index-out-of-bounds panic when validated via `verify()` or when accessed during aggregate key computation. A malicious signer can exploit this to crash all participants in a DKG round by sending a single malformed `DkgPublicShares` message.

## Finding Description

The `PolyCommitment` struct derives `Deserialize` without custom validation, allowing the `poly` vector field to be deserialized as empty: [1](#0-0) 

The `verify()` method unconditionally accesses `self.poly[0]` without bounds checking: [2](#0-1) 

When a malformed `PolyCommitment` with an empty `poly` vector is processed, multiple code paths trigger the panic:

**Path 1 - Validation via check_public_shares():**
The `check_public_shares()` function calls `verify()` before checking the vector length due to short-circuit evaluation: [3](#0-2) 

This validation is invoked by:
- **Signers during DKG validation:** [4](#0-3) 

- **Fire Coordinator when validating BadPublicShares reports:** [5](#0-4) 

- **v1 Parties during compute_secret():** [6](#0-5) 

- **v2 Parties during compute_secret():** [7](#0-6) 

**Path 2 - Direct access during aggregate key computation:**
Even if validation were bypassed, direct access to `poly[0]` occurs during aggregate key computation: [8](#0-7) [9](#0-8) 

**Exploit Mechanism:**
A malicious signer constructs a `DkgPublicShares` message containing a `PolyCommitment` with `poly: vec![]`, signs it with their legitimate private key, and broadcasts it during the DKG public share phase. The test suite demonstrates such commitments can be created: [10](#0-9) 

Since message authentication only verifies the signature comes from a legitimate signer (not the content validity), the malformed message passes authentication but crashes all nodes during validation.

## Impact Explanation

This vulnerability causes a **remotely-exploitable denial of service** affecting all participants in a DKG round:

1. **Node Crashes**: All honest signers and coordinators processing the malicious message experience an immediate panic and crash
2. **DKG Failure**: The DKG round cannot complete, preventing new distributed key generation
3. **Operational Impact**: Key rotation and new signer onboarding are blocked until the malicious signer is identified and excluded

The severity aligns with **Low** per the defined scope: "Any remotely-exploitable denial of service in a node" and "Any network denial of service impacting more than 10 percent of miners that does not shut down the network."

This does NOT constitute a Critical or High severity issue because:
- No fund loss occurs
- No consensus failures or chain splits result
- Ongoing signing operations are unaffected (only DKG)
- The network can recover by restarting nodes and excluding the malicious participant
- No persistent state corruption occurs

## Likelihood Explanation

**Attack Requirements:**
- Attacker must be a registered signer (within protocol threat model)
- Attacker must participate in a DKG round
- Standard network access to broadcast messages

**Attack Complexity:**
Trivial. The attack requires only:
1. Constructing a `DkgPublicShares` with `PolyCommitment { id: valid_id, poly: vec![] }`
2. Signing with the attacker's legitimate private key
3. Broadcasting during DKG public share phase

**Economic Feasibility:**
Negligible cost - a single malformed network message with no computational expense.

**Likelihood Assessment:**
**High** if an adversary controls even one signer position and wishes to disrupt DKG. The only barrier is being a legitimate protocol participant, which is within the defined threat model for malicious signers (up to threshold-1).

## Recommendation

Add bounds checking before accessing `poly[0]`. Implement custom deserialization or add explicit validation:

```rust
impl PolyCommitment {
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        if self.poly.is_empty() {
            return false;
        }
        self.id.verify(&self.poly[0], ctx)
    }
}
```

Alternatively, enforce non-empty polynomials at the type level using a newtype wrapper or custom deserializer that validates the vector length matches the expected threshold during deserialization.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_empty_poly_panic() {
    use crate::common::PolyCommitment;
    use crate::schnorr::ID;
    use crate::curve::scalar::Scalar;
    use crate::util::create_rng;
    
    let mut rng = create_rng();
    let ctx = 0u64.to_be_bytes();
    
    // Create a PolyCommitment with empty poly vector
    let malicious_comm = PolyCommitment {
        id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
        poly: vec![], // Empty vector
    };
    
    // This panics with index out of bounds
    malicious_comm.verify(&ctx);
}
```

### Citations

**File:** src/common.rs (L26-33)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
/// A commitment to a polynonial, with a Schnorr proof of ownership bound to the ID
pub struct PolyCommitment {
    /// The party ID with a schnorr proof
    pub id: ID,
    /// The public polynomial which commits to the secret polynomial
    pub poly: Vec<Point>,
}
```

**File:** src/common.rs (L35-40)
```rust
impl PolyCommitment {
    /// Verify the wrapped schnorr ID
    pub fn verify(&self, ctx: &[u8]) -> bool {
        self.id.verify(&self.poly[0], ctx)
    }
}
```

**File:** src/common.rs (L318-321)
```rust
/// Check that the PolyCommitment is properly signed and has the correct degree polynomial
pub fn check_public_shares(poly_comm: &PolyCommitment, threshold: usize, ctx: &[u8]) -> bool {
    poly_comm.verify(ctx) && poly_comm.poly.len() == threshold
}
```

**File:** src/state_machine/signer/mod.rs (L556-562)
```rust
                    for (party_id, comm) in shares.comms.iter() {
                        if !check_public_shares(comm, threshold, &self.dkg_id.to_be_bytes()) {
                            bad_public_shares.insert(*signer_id);
                        } else {
                            self.commitments.insert(*party_id, comm.clone());
                        }
                    }
```

**File:** src/state_machine/coordinator/fire.rs (L632-640)
```rust
                                for (party_id, comm) in &dkg_public_shares.comms {
                                    if !check_public_shares(
                                        comm,
                                        threshold,
                                        &self.current_dkg_id.to_be_bytes(),
                                    ) {
                                        bad_party_ids.push(party_id);
                                    }
                                }
```

**File:** src/state_machine/coordinator/fire.rs (L803-810)
```rust
        let key = self
            .dkg_end_messages
            .keys()
            .flat_map(|signer_id| self.dkg_public_shares[signer_id].comms.clone())
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!("Aggregate public key: {key}");
        self.aggregate_public_key = Some(key);
```

**File:** src/v1.rs (L161-166)
```rust
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
```

**File:** src/v2.rs (L135-140)
```rust
        for (i, comm) in public_shares.iter() {
            if !check_public_shares(comm, threshold, ctx) {
                bad_ids.push(*i);
            } else {
                self.group_key += comm.poly[0];
            }
```

**File:** src/state_machine/coordinator/frost.rs (L435-444)
```rust
        let key = self
            .party_polynomials
            .iter()
            .fold(Point::default(), |s, (_, comm)| s + comm.poly[0]);

        info!(
            %key,
            "Aggregate public key"
        );
        self.aggregate_public_key = Some(key);
```

**File:** src/net.rs (L721-732)
```rust
        let public_shares = DkgPublicShares {
            dkg_id: 0,
            signer_id: 0,
            comms: vec![(
                0,
                PolyCommitment {
                    id: ID::new(&Scalar::new(), &Scalar::new(), &ctx, &mut rng),
                    poly: vec![],
                },
            )],
            kex_public_key: Point::from(Scalar::random(&mut rng)),
        };
```
