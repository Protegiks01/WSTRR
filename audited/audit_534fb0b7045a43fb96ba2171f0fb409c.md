# Audit Report

## Title
Incomplete Party ID Validation in DKG Private Shares Allows Undetected Malicious Signer Attacks

## Summary
The DKG protocol contains a critical validation gap that allows malicious signers to send incomplete private shares without detection. The `can_dkg_end()` function only verifies existence of a signer's entry in `dkg_private_shares`, not completeness of party_ids. Combined with incomplete error handling in `dkg_ended()` that only processes `DkgError::BadPrivateShares` while ignoring `DkgError::MissingPrivateShares`, this enables malicious signers to repeatedly cause DKG failures without being identified or marked as malicious.

## Finding Description

The vulnerability exists across three interconnected validation stages:

**Stage 1: Incomplete Entry Check**
The `can_dkg_end()` function performs only a shallow validation, checking if a signer_id key exists in the `dkg_private_shares` HashMap without verifying that all expected party_ids from that signer are present in the shares vector. [1](#0-0) 

**Stage 2: Partial Share Validation**
When `dkg_ended()` executes, it validates that party_ids which ARE present in the received shares contain shares for all required destination key_ids, but fails to check whether ALL expected party_ids from `signer_key_ids[signer_id]` are included. [2](#0-1) 

**Stage 3: Incomplete Error Handling**
The `compute_secrets` function properly detects missing party_ids and returns `DkgError::MissingPrivateShares`: [3](#0-2) 

However, the error handling in `dkg_ended()` only processes `DkgError::BadPrivateShares` variant. Any other error type, including `MissingPrivateShares`, is logged as "unexpected" but NOT added to the `bad_private_shares` map: [4](#0-3) 

This results in a `DkgEnd` message with `DkgFailure::BadPrivateShares(empty_map)` being sent to the coordinator: [5](#0-4) 

**Stage 4: Coordinator Processing Failure**
When the coordinator receives the failure with an empty map, the loop that identifies malicious signers doesn't execute: [6](#0-5) 

**Why Existing Validations Fail**
The `DkgPrivateShares` structure contains a shares vector where each element is a tuple of (party_id, destination shares): [7](#0-6) 

When processing incoming shares, validation occurs via `validate_party_id` to ensure each party_id belongs to the sender: [8](#0-7) 

The v1 implementation checks if party_id is in the sender's key_ids set: [9](#0-8) 

However, this only validates that present party_ids belong to the sender, not that ALL expected party_ids are present.

**Attack Flow:**
1. Malicious signer with `signer_key_ids[malicious_id] = {10, 11, 12}` sends valid `DkgPublicShares` with commitments for all three party_ids
2. Malicious signer sends `DkgPrivateShares` containing shares only from party_ids {10, 11}, deliberately omitting party_id 12
3. In `dkg_private_shares()`, validation at lines 1047-1056 passes since both 10 and 11 belong to the sender
4. The incomplete message is stored at line 1064
5. `can_dkg_end()` returns true since the key exists
6. In `dkg_ended()`, lines 567-582 validate present party_ids but don't detect missing party_id 12
7. `compute_secrets` detects missing party_id 12 and returns `DkgError::MissingPrivateShares`
8. Error handling at line 626 only processes `BadPrivateShares`, so the error is logged but not processed
9. Empty `bad_private_shares` map is sent to coordinator
10. Coordinator's loop at line 654 doesn't execute, no malicious signer identified

## Impact Explanation

This vulnerability breaks the Byzantine fault tolerance mechanism of the DKG protocol. The security guarantee that malicious participants will be identified and prevented from participating in future rounds is violated.

**Concrete Protocol Impact:**
- DKG fails to complete, preventing distributed key generation
- Signature generation cannot proceed without completed DKG
- Malicious signer is never added to `malicious_dkg_signer_ids` list
- Attack can be repeated every DKG round indefinitely
- All honest participants are affected by the DoS

This maps to **Medium** severity per the scope definition: "Any transient consensus failures." While this doesn't directly cause invalid signatures or permanent chain splits, it prevents the cryptographic infrastructure from being established, causing a transient denial of service on the signing functionality which is required for block production.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized participant in the DKG protocol (within threat model)
- Must be able to construct and send `DkgPrivateShares` messages with a subset of their party_ids
- No special cryptographic capabilities required

**Attack Complexity:**
Low. The attacker simply:
1. Generates valid `DkgPublicShares` for all their party_ids (normal protocol behavior)
2. Constructs `DkgPrivateShares` with only a subset of party_ids in the shares vector
3. Sends both messages through normal protocol channels

**Economic Feasibility:**
Very high. The attack is essentially free - it requires no additional computational resources beyond normal DKG participation. The attacker incurs no penalty since they're never detected or identified.

**Detection Risk:**
Very low. The malicious signer is never identified by the coordinator. The only evidence is a log warning about "unexpected dkg_error" in honest signers' logs, which doesn't identify the attacker.

**Estimated Probability:**
Near certain (>95%) for v1 implementations where signers can control multiple party_ids. Any malicious DKG participant can successfully execute this attack. In v2 mode where `party_id == signer_id`, the attack surface is reduced but the error handling bug still exists for other error types.

## Recommendation

**Fix 1: Add Completeness Check in `can_dkg_end()`**
Before returning true, verify that all expected party_ids from `signer_key_ids[signer_id]` are present in the received `DkgPrivateShares`:

```rust
for signer_id in &dkg_end_begin.signer_ids {
    if let Some(shares) = self.dkg_private_shares.get(signer_id) {
        // NEW: Check that all expected party_ids are present
        if let Some(expected_key_ids) = self.public_keys.signer_key_ids.get(signer_id) {
            let received_party_ids: HashSet<u32> = shares.shares.iter().map(|(pid, _)| *pid).collect();
            for expected_party_id in expected_key_ids {
                if !received_party_ids.contains(expected_party_id) {
                    debug!("can_dkg_end: false, signer {} missing party_id {}", signer_id, expected_party_id);
                    return false;
                }
            }
        }
    } else {
        // existing check
        return false;
    }
}
```

**Fix 2: Handle All DkgError Variants in `dkg_ended()`**
Process `DkgError::MissingPrivateShares` by mapping the party_ids to signer_ids and adding them to the bad_private_shares map:

```rust
Err(dkg_error_map) => {
    let mut bad_private_shares = HashMap::new();
    for (_my_party_id, dkg_error) in dkg_error_map {
        match dkg_error {
            DkgError::BadPrivateShares(party_ids) => {
                for party_id in party_ids {
                    if let Some((party_signer_id, _shared_key)) = &self.decryption_keys.get(&party_id) {
                        bad_private_shares.insert(*party_signer_id, self.make_bad_private_share(*party_signer_id, rng)?);
                    }
                }
            }
            DkgError::MissingPrivateShares(missing_pairs) => {
                // NEW: Handle missing shares
                for (_src_party_id, dst_party_id) in missing_pairs {
                    if let Some((party_signer_id, _shared_key)) = &self.decryption_keys.get(&dst_party_id) {
                        bad_private_shares.insert(*party_signer_id, self.make_bad_private_share(*party_signer_id, rng)?);
                    }
                }
            }
            _ => {
                warn!("Got unexpected dkg_error {dkg_error:?}");
            }
        }
    }
    // rest of handling...
}
```

## Proof of Concept

```rust
#[test]
fn test_incomplete_party_ids_not_detected() {
    use crate::state_machine::signer::Signer;
    use crate::v1;
    use crate::net::{DkgPrivateShares, DkgPublicShares, DkgBegin, DkgPrivateBegin, DkgEndBegin, Message, Packet};
    use hashbrown::{HashMap, HashSet};
    
    let mut rng = rand::thread_rng();
    let mut public_keys = PublicKeys::default();
    
    // Setup: Signer 0 has party_ids {1, 2, 3}
    let key_ids_0 = HashSet::from([1, 2, 3]);
    public_keys.signer_key_ids.insert(0, key_ids_0);
    
    // Create honest signer
    let mut signer = Signer::<v1::Signer>::new(
        2, 3, 3, 1, 0, vec![1], 
        Scalar::random(&mut rng), 
        public_keys.clone(), 
        &mut rng
    ).unwrap();
    
    // Start DKG
    let dkg_begin = Packet { msg: Message::DkgBegin(DkgBegin { dkg_id: 1 }), sig: vec![] };
    signer.process(&dkg_begin, &mut rng).unwrap();
    
    // Malicious signer sends complete public shares (all 3 party_ids)
    let mut public_shares = DkgPublicShares {
        dkg_id: 1,
        signer_id: 0,
        comms: vec![(1, poly_commit), (2, poly_commit), (3, poly_commit)],
        kex_public_key: Point::default(),
    };
    
    // But sends incomplete private shares (only party_ids 1, 2, missing 3)
    let mut private_shares = DkgPrivateShares {
        dkg_id: 1,
        signer_id: 0,
        shares: vec![
            (1, HashMap::from([(1, vec![0u8; 32])])),
            (2, HashMap::from([(1, vec![0u8; 32])])),
            // Deliberately omitting party_id 3
        ],
    };
    
    // Process messages
    signer.dkg_public_shares(&public_shares).unwrap();
    signer.dkg_private_shares(&private_shares, &mut rng).unwrap();
    
    // Trigger end
    signer.dkg_private_begin(&DkgPrivateBegin { 
        dkg_id: 1, signer_ids: vec![0], key_ids: vec![] 
    }).unwrap();
    signer.dkg_end_begin(&DkgEndBegin { 
        dkg_id: 1, signer_ids: vec![0], key_ids: vec![] 
    }).unwrap();
    
    // BUG: can_dkg_end returns true even though party_id 3 is missing
    assert!(signer.can_dkg_end());
    
    // BUG: dkg_ended sends DkgFailure with empty bad_private_shares
    let result = signer.dkg_ended(&mut rng).unwrap();
    if let Message::DkgEnd(end) = result {
        if let DkgStatus::Failure(DkgFailure::BadPrivateShares(bad_map)) = end.status {
            // BUG: Map is empty, so malicious signer 0 is not identified
            assert!(bad_map.is_empty());
        }
    }
}
```

### Citations

**File:** src/state_machine/signer/mod.rs (L567-582)
```rust
            if let Some(shares) = self.dkg_private_shares.get(signer_id) {
                // signer_id sent shares, but make sure that it sent shares for every one of this signer's key_ids
                if shares.shares.is_empty() {
                    missing_private_shares.insert(*signer_id);
                } else {
                    for dst_key_id in self.signer.get_key_ids() {
                        for (_src_key_id, shares) in &shares.shares {
                            if shares.get(&dst_key_id).is_none() {
                                missing_private_shares.insert(*signer_id);
                            }
                        }
                    }
                }
            } else {
                missing_private_shares.insert(*signer_id);
            }
```

**File:** src/state_machine/signer/mod.rs (L622-641)
```rust
                Err(dkg_error_map) => {
                    // we've handled everything except BadPrivateShares and Point both of which should map to DkgFailure::BadPrivateShares
                    let mut bad_private_shares = HashMap::new();
                    for (_my_party_id, dkg_error) in dkg_error_map {
                        if let DkgError::BadPrivateShares(party_ids) = dkg_error {
                            for party_id in party_ids {
                                if let Some((party_signer_id, _shared_key)) =
                                    &self.decryption_keys.get(&party_id)
                                {
                                    bad_private_shares.insert(
                                        *party_signer_id,
                                        self.make_bad_private_share(*party_signer_id, rng)?,
                                    );
                                } else {
                                    warn!("DkgError::BadPrivateShares from party_id {party_id} but no (signer_id, shared_secret) cached");
                                }
                            }
                        } else {
                            warn!("Got unexpected dkg_error {dkg_error:?}");
                        }
```

**File:** src/state_machine/signer/mod.rs (L643-649)
```rust
                    DkgEnd {
                        dkg_id: self.dkg_id,
                        signer_id: self.signer_id,
                        status: DkgStatus::Failure(DkgFailure::BadPrivateShares(
                            bad_private_shares,
                        )),
                    }
```

**File:** src/state_machine/signer/mod.rs (L705-709)
```rust
                    for signer_id in &dkg_end_begin.signer_ids {
                        if !self.dkg_private_shares.contains_key(signer_id) {
                            debug!("can_dkg_end: false, missing private shares from signer {signer_id}");
                            return false;
                        }
```

**File:** src/state_machine/signer/mod.rs (L1047-1056)
```rust
        for (party_id, _shares) in &dkg_private_shares.shares {
            if !SignerType::validate_party_id(
                src_signer_id,
                *party_id,
                &self.public_keys.signer_key_ids,
            ) {
                warn!("Signer {src_signer_id} sent a polynomial commitment for party {party_id}");
                return Ok(vec![]);
            }
        }
```

**File:** src/v1.rs (L172-180)
```rust
        let mut missing_shares = Vec::new();
        for i in public_shares.keys() {
            if private_shares.get(i).is_none() {
                missing_shares.push((self.id, *i));
            }
        }
        if !missing_shares.is_empty() {
            return Err(DkgError::MissingPrivateShares(missing_shares));
        }
```

**File:** src/v1.rs (L696-705)
```rust
    fn validate_party_id(
        signer_id: u32,
        party_id: u32,
        signer_key_ids: &HashMap<u32, HashSet<u32>>,
    ) -> bool {
        match signer_key_ids.get(&signer_id) {
            Some(key_ids) => key_ids.contains(&party_id),
            None => false,
        }
    }
```

**File:** src/state_machine/coordinator/fire.rs (L652-654)
```rust
                        DkgFailure::BadPrivateShares(bad_shares) => {
                            // bad_shares is a map of signer_id to BadPrivateShare
                            for (bad_signer_id, bad_private_share) in bad_shares {
```

**File:** src/net.rs (L190-199)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, PartialEq)]
/// DKG private shares message from signer to all signers and coordinator
pub struct DkgPrivateShares {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// List of (src_party_id, Map(dst_key_id, encrypted_share))
    pub shares: Vec<(u32, HashMap<u32, Vec<u8>>)>,
}
```
