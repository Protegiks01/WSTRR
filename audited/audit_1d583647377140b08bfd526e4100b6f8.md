### Title
Fire Coordinator Timeout Logic Incorrectly Marks Honest Signers as Malicious on Network Delays

### Summary
The fire coordinator's signature share timeout handler indiscriminately marks all non-responding signers as malicious without validating whether they are actually malicious or simply experiencing network delays. This creates false positives that permanently exclude honest signers from future signing rounds, progressively reducing signing capacity and potentially causing permanent denial of service if enough honest signers are incorrectly flagged.

### Finding Description

The vulnerability exists in the `process_timeout()` function of the fire coordinator when handling signature share gathering timeouts. [1](#0-0) 

When the `sign_timeout` fires during the `SigShareGather` state, the coordinator iterates through all signers in `sign_wait_signer_ids` and marks each one as malicious. The `sign_wait_signer_ids` set contains all signers who sent nonce responses but have not yet sent their signature shares. [2](#0-1) 

Signers are added to this wait list when they send valid nonce responses, and are only removed when they successfully send signature share responses. [3](#0-2) 

Once marked as malicious, signers are permanently excluded from future rounds. When a signer marked as malicious sends a nonce response in subsequent rounds, it is silently rejected. [4](#0-3) 

The `malicious_signer_ids` set is never cleared - not during reset operations, and there is no other mechanism to remove signers from this set. [5](#0-4) 

**Root Cause**: The timeout logic conflates two fundamentally different situations: (1) legitimate network delays or high processing load causing slow responses, and (2) actual malicious behavior such as sending cryptographically invalid signatures or protocol violations. Only the latter should result in permanent exclusion, but the current implementation treats both identically.

**No Existing Mitigations**: There is no validation of cryptographic correctness before marking signers as malicious on timeout. There is no recovery mechanism to restore falsely-flagged signers. There is no distinction between temporary unavailability and malicious behavior.

### Impact Explanation

**Specific Harm**: Honest signers experiencing network delays are permanently excluded from signing, progressively reducing the total available signing capacity. If this occurs repeatedly, the system can fall below the threshold required to produce valid signatures, causing permanent inability to sign messages.

**Quantified Impact**: Consider a deployment with 10 signers, each controlling 2 key IDs (20 total keys), with a threshold of 14 keys:
- Initial capacity: 20 keys available
- After first timeout affecting 3 slow signers: 14 keys available (exactly at threshold)
- After second timeout affecting 2 more signers: 10 keys available (below threshold - **permanent DoS**)

In blockchain contexts where WSTS is used for block production or transaction signing (like Stacks), this results in:
- Inability to confirm new blocks
- Network unable to process transactions for multiple blocks
- Potential chain halt requiring manual intervention

**Who is Affected**: All users depending on the WSTS coordinator for signature generation. In blockchain deployments, this affects the entire network's ability to produce blocks and confirm transactions.

**Severity Justification**: This maps to **High severity** under the protocol scope as "Any remotely-exploitable denial of service." It can escalate to **Critical severity** as it may cause "Any network to shut down or otherwise not confirm new valid transactions for multiple blocks."

### Likelihood Explanation

**Required Attacker Capabilities**: 
- Low barrier: Attacker only needs ability to introduce network delays or packet loss on paths between signers and coordinator
- Alternatively, can occur naturally through normal network congestion, high system load, or transient connectivity issues
- No cryptographic capabilities required
- No privileged access required

**Attack Complexity**: 
- Low: Simply delay or drop signature share response packets before they reach the coordinator
- Can use network-level attacks (packet delay, traffic shaping) or application-level delays
- Each successful timeout event progressively weakens the system

**Economic Feasibility**: 
- Very low cost: Network delay attacks are cheap and easy to execute
- No specialized hardware or significant computational resources needed
- Can be sustained over time with minimal effort

**Detection Risk**: 
- Low: Delayed packets appear as normal network behavior
- Legitimate network issues produce identical symptoms
- No distinguishing characteristics to separate malicious delays from benign ones

**Probability of Success**: 
- High: Attack succeeds whenever timeout fires before honest signers respond
- Probability increases with network latency, system load, or number of signers
- Cumulative effect - each successful timeout permanently reduces capacity
- Natural occurrence possible without attacker intervention

### Recommendation

**Primary Fix**: Remove automatic malicious marking on timeout. Only mark signers as malicious when they provide cryptographically invalid responses that fail validation:

1. In the timeout handler, do NOT add signers to `malicious_signer_ids`
2. Instead, track slow/unresponsive signers separately in a temporary set that resets each round
3. Implement cryptographic validation in `gather_sig_shares()` and only mark signers as malicious when their signature shares fail verification
4. Add a mechanism to clear or expire malicious flags after a configurable period or allow manual clearing

**Code Changes**:
- Modify `process_timeout()` to remove lines that insert into `malicious_signer_ids` on signature share timeout
- Create a separate `slow_signer_ids` tracking structure that resets each signing round
- Add explicit cryptographic validation checks in signature share processing that mark signers malicious only on validation failure
- Modify `reset()` to clear `malicious_signer_ids` or implement time-based expiration

**Testing Recommendations**:
- Add test cases that simulate network delays and verify honest signers are not permanently excluded
- Test that cryptographically invalid responses correctly mark signers as malicious
- Verify that slow signers can participate in subsequent rounds
- Test threshold edge cases where temporary unavailability should not cause permanent DoS

**Deployment Considerations**:
- Coordinate update across all coordinators to maintain consistent behavior
- Consider implementing gradual rollout with monitoring
- Document new behavior for operators regarding signer availability tracking

### Proof of Concept

**Exploitation Algorithm**:

1. **Setup**: Deploy coordinator with 10 signers (20 keys), threshold of 14, sign_timeout of 5 seconds
2. **Round 1**: Coordinator initiates signing round, all 10 signers respond with nonces
3. **Attack**: Delay signature share responses from signers 7, 8, 9 by 6 seconds (network delay attack)
4. **Timeout Fires**: After 5 seconds, coordinator marks signers 7, 8, 9 as malicious (6 keys lost)
5. **Round 2**: Coordinator initiates second signing round
   - Signers 7, 8, 9 send nonce responses but are silently rejected (line 903-915)
   - Only 7 signers participate (14 keys available - exactly at threshold)
6. **Attack Repeat**: Delay responses from signers 5, 6 by 6 seconds
7. **Permanent DoS**: After timeout, signers 5, 6 marked malicious (4 more keys lost)
   - Total capacity: 10 keys remaining
   - Threshold: 14 keys required
   - **Result: System permanently unable to generate signatures**

**Expected vs Actual Behavior**:
- **Expected**: Honest signers experiencing temporary delays should be able to participate in subsequent rounds. Only signers providing cryptographically invalid responses should be excluded.
- **Actual**: All signers who fail to respond before timeout are permanently marked malicious and excluded from all future rounds, regardless of the reason for delay.

**Reproduction Steps**:
1. Setup coordinator with timeouts enabled
2. Start signing round with multiple signers
3. Introduce 6-second network delay for subset of signers (higher than timeout)
4. Observe timeout fires and marks these signers as malicious
5. Start second signing round
6. Observe that previously-delayed signers' nonce responses are now rejected
7. Verify no recovery mechanism exists to restore these signers

Notes:
- This vulnerability violates the stated invariant that "Malicious signer detection and timeouts must not be bypassable"
- The current implementation makes honest signers indistinguishable from malicious ones based solely on response timing
- The permanent nature of the malicious flag (never cleared) amplifies the impact over time

### Citations

**File:** src/state_machine/coordinator/fire.rs (L173-208)
```rust
            State::SigShareGather(signature_type) => {
                if let Some(start) = self.sign_start {
                    if let Some(timeout) = self.config.sign_timeout {
                        if now.duration_since(start) > timeout {
                            warn!("Timeout gathering signature shares for signing round {} iteration {}", self.current_sign_id, self.current_sign_iter_id);
                            for signer_id in &self
                                .message_nonces
                                .get(&self.message)
                                .ok_or(Error::MissingMessageNonceInfo)?
                                .sign_wait_signer_ids
                            {
                                warn!("Mark signer {signer_id} as malicious");
                                self.malicious_signer_ids.insert(*signer_id);
                            }

                            let num_malicious_keys: u32 =
                                self.compute_num_key_ids(self.malicious_signer_ids.iter())?;

                            if self.config.num_keys - num_malicious_keys < self.config.threshold {
                                error!("Insufficient non-malicious signers, unable to continue");
                                let mal = self.malicious_signer_ids.iter().copied().collect();
                                return Ok((
                                    None,
                                    Some(OperationResult::SignError(
                                        SignError::InsufficientSigners(mal),
                                    )),
                                ));
                            }

                            self.move_to(State::NonceRequest(signature_type))?;
                            let packet = self.request_nonces(signature_type)?;
                            return Ok((Some(packet), None));
                        }
                    }
                }
            }
```

**File:** src/state_machine/coordinator/fire.rs (L903-915)
```rust
            if self
                .malicious_signer_ids
                .contains(&nonce_response.signer_id)
            {
                warn!(
                    sign_id = %nonce_response.sign_id,
                    sign_iter_id = %nonce_response.sign_iter_id,
                    signer_id = %nonce_response.signer_id,
                    "Received malicious NonceResponse"
                );
                //return Err(Error::MaliciousSigner(nonce_response.signer_id));
                return Ok(());
            }
```

**File:** src/state_machine/coordinator/fire.rs (L940-942)
```rust
            nonce_info
                .sign_wait_signer_ids
                .insert(nonce_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1042-1044)
```rust
        response_info
            .sign_wait_signer_ids
            .remove(&sig_share_response.signer_id);
```

**File:** src/state_machine/coordinator/fire.rs (L1478-1490)
```rust
    // Reset internal state
    fn reset(&mut self) {
        self.state = State::Idle;
        self.dkg_public_shares.clear();
        self.dkg_private_shares.clear();
        self.dkg_end_messages.clear();
        self.party_polynomials.clear();
        self.message_nonces.clear();
        self.signature_shares.clear();
        self.dkg_wait_signer_ids.clear();
        self.nonce_start = None;
        self.sign_start = None;
    }
```
