### Title
Message Substitution Attack via Unchecked NonceResponse Message Fields in SignatureShareRequest

### Summary
Signers do not validate that the `message` fields in `NonceResponse` objects within `SignatureShareRequest.nonce_responses` are consistent with each other or match `SignatureShareRequest.message`. This allows a malicious coordinator to trick signers into signing arbitrary messages by substituting the message field after collecting nonces, violating the fundamental security property that signers control which messages they authorize.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `sign_share_request()` function processes `SignatureShareRequest` messages but performs no validation on the `message` fields within the `NonceResponse` objects. The function only validates:
1. Signer ID uniqueness and validity (lines 762-779)
2. Nonce cryptographic validity (lines 787-795)

**Root Cause:**

The `NonceResponse` struct contains a `message` field that represents the message the signer committed to when generating their nonces: [2](#0-1) 

When a signer responds to a `NonceRequest`, they copy the message from the request and cryptographically sign the entire `NonceResponse`, creating a binding commitment: [3](#0-2) 

However, when processing a `SignatureShareRequest`, the signer extracts nonces from all `NonceResponse` objects without verifying their `message` fields: [4](#0-3) 

The signer directly uses `sign_request.message` (line 807) to compute signature shares, ignoring the `message` values embedded in each `NonceResponse`. This breaks the commitment that signers made when generating their nonces.

**Why Existing Mitigations Fail:**

The test suite validates various nonce-related errors but does NOT test message consistency: [5](#0-4) 

The tests check for zero nonces, generator nonces, duplicate responses, and invalid signer IDs, but never tamper with the `message` fields to verify consistency checking.

### Impact Explanation

**Specific Harm:**
A malicious or compromised coordinator can execute a message substitution attack:

1. Send `NonceRequest(message=M1)` to signers A, B
2. Send `NonceRequest(message=M2)` to signers C, D  
3. Collect `NonceResponse` objects containing different messages
4. Create `SignatureShareRequest` with all collected nonces but `message=M3`
5. Signers process this request and all use M3 to compute signature shares
6. Result: Valid threshold signature on M3, even though no signer intended to sign M3

**Impact Quantification:**
- **Direct Impact**: Signers can be tricked into signing arbitrary messages they never authorized
- **Chain-Level Impact**: Maps to "confirmation of an invalid transaction" (CRITICAL severity per scope)
- **Transaction Impact**: If M3 represents an unauthorized fund transfer or invalid transaction, it will be cryptographically valid despite no signer authorizing it

**Who Is Affected:**
All WSTS deployments where the coordinator role could be compromised or where multiple coordinators with different trust levels might interact with the same signers.

**Severity Justification:**
CRITICAL - This vulnerability directly enables "confirmation of an invalid transaction" as defined in the protocol scope. The threshold signature scheme's fundamental security property—that signers have explicit control over which messages they sign—is completely bypassed.

### Likelihood Explanation

**Required Attacker Capabilities:**
- Control or compromise of the coordinator node
- Ability to send messages to multiple signers
- No cryptographic breaks required

**Attack Complexity:**
LOW - The attack is straightforward:
1. Coordinator sends different `NonceRequest` messages to different signer subsets
2. Coordinator combines responses with an arbitrary message in `SignatureShareRequest`
3. Signers automatically process without detecting the substitution

**Economic Feasibility:**
HIGH - The coordinator is a privileged but not infallible component. Scenarios include:
- Compromised coordinator through software vulnerabilities
- Malicious coordinator operator
- Coordinator key theft
- Man-in-the-middle if coordinator authentication is weak

**Detection Risk:**
LOW - The attack leaves no obvious traces since:
- All cryptographic operations succeed normally
- The resulting signature is mathematically valid
- Signers have no way to detect they signed a different message post-facto
- No audit trail of the message substitution exists

**Probability of Success:**
VERY HIGH - Once coordinator access is obtained, the attack succeeds with 100% probability because:
- No validation prevents the attack
- The protocol design assumes coordinator honesty for message content
- Signers have no mechanism to detect or prevent the substitution

### Recommendation

**Proposed Code Changes:**

Add message consistency validation to `sign_share_request()` in `src/state_machine/signer/mod.rs` after line 795:

```rust
// Validate that all NonceResponse messages are consistent
let first_message = &sign_request.nonce_responses[0].message;
for nonce_response in &sign_request.nonce_responses {
    if nonce_response.message != *first_message {
        warn!(
            signer_id = %self.signer_id,
            "NonceResponse messages are inconsistent"
        );
        return Err(Error::InvalidNonceResponse);
    }
}

// Validate that NonceResponse messages match SignatureShareRequest message
if first_message != &sign_request.message {
    warn!(
        signer_id = %self.signer_id,
        "NonceResponse message does not match SignatureShareRequest message"
    );
    return Err(Error::InvalidNonceResponse);
}
```

**Alternative Mitigations:**
1. Remove the `message` field from `NonceResponse` entirely and rely solely on `SignatureShareRequest.message` (breaking change)
2. Add cryptographic binding between nonces and messages at generation time that can be verified later
3. Implement signer-side message approval before nonce generation

**Testing Recommendations:**
Add test cases to `src/state_machine/coordinator/mod.rs`:
1. Test with mixed `NonceResponse.message` values in `nonce_responses`
2. Test with `NonceResponse.message` != `SignatureShareRequest.message`
3. Test that legitimate requests still pass validation

**Deployment Considerations:**
- This is a backward-incompatible change requiring coordinated upgrade
- Existing signed messages in flight may be rejected after upgrade
- Consider a transition period with warning-only mode before enforcement

### Proof of Concept

**Exploitation Algorithm:**

1. **Setup**: Assume coordinator controls message flow to N signers with threshold T

2. **Nonce Collection Phase**:
   ```
   For signer_id in [0..T-1]:
     Send NonceRequest(dkg_id, sign_id, sign_iter_id, message=M1, ...)
   For signer_id in [T..N-1]:
     Send NonceRequest(dkg_id, sign_id, sign_iter_id, message=M2, ...)
   
   Collect all NonceResponse objects:
     nonces_M1 = [NonceResponse(message=M1, ...) from signers 0..T-1]
     nonces_M2 = [NonceResponse(message=M2, ...) from signers T..N-1]
   ```

3. **Message Substitution**:
   ```
   Create malicious_request = SignatureShareRequest {
     dkg_id, sign_id, sign_iter_id,
     nonce_responses: nonces_M1 + nonces_M2,  // Mixed messages
     message: M3,  // Arbitrary target message
     signature_type
   }
   ```

4. **Signature Generation**:
   ```
   Send malicious_request to all signers
   Each signer:
     - Extracts nonces from nonce_responses (no message validation)
     - Computes signature_share using M3
     - Returns valid signature share
   ```

5. **Result**:
   ```
   Coordinator aggregates signature shares
   Output: Valid threshold signature on M3
   ```

**Expected vs Actual Behavior:**
- **Expected**: Signers reject `SignatureShareRequest` if `NonceResponse.message` fields are inconsistent or don't match `SignatureShareRequest.message`
- **Actual**: Signers accept the request and produce valid signature shares on M3, despite never authorizing that message

**Reproduction Instructions:**
1. Modify coordinator code to send different `NonceRequest` messages to different signers
2. Collect all `NonceResponse` objects
3. Create `SignatureShareRequest` with combined nonces but substitute a different message
4. Observe that signers successfully generate signature shares
5. Verify the aggregated signature is cryptographically valid for the substituted message

**Notes:**
The vulnerability exists in both FireCoordinator and FrostCoordinator implementations, as both rely on the signer's `sign_share_request()` function which lacks the message consistency check. The cryptographic binding computed in `compute::binding()` uses the substituted message M3, not the original messages M1/M2, so the signature is mathematically valid but unauthorized. [6](#0-5)

### Citations

**File:** src/state_machine/signer/mod.rs (L723-755)
```rust
    fn nonce_request<R: RngCore + CryptoRng>(
        &mut self,
        nonce_request: &NonceRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let mut msgs = vec![];
        let signer_id = self.signer_id;
        let key_ids = self.signer.get_key_ids();
        let nonces = self.signer.gen_nonces(&self.network_private_key, rng);

        let response = NonceResponse {
            dkg_id: nonce_request.dkg_id,
            sign_id: nonce_request.sign_id,
            sign_iter_id: nonce_request.sign_iter_id,
            signer_id,
            key_ids,
            nonces,
            message: nonce_request.message.clone(),
        };

        let response = Message::NonceResponse(response);

        info!(
            %signer_id,
            dkg_id = %nonce_request.dkg_id,
            sign_id = %nonce_request.sign_id,
            sign_iter_id = %nonce_request.sign_iter_id,
            "sending NonceResponse"
        );
        msgs.push(response);

        Ok(msgs)
    }
```

**File:** src/state_machine/signer/mod.rs (L757-842)
```rust
    fn sign_share_request<R: RngCore + CryptoRng>(
        &mut self,
        sign_request: &SignatureShareRequest,
        rng: &mut R,
    ) -> Result<Vec<Message>, Error> {
        let signer_id_set = sign_request
            .nonce_responses
            .iter()
            .map(|nr| nr.signer_id)
            .collect::<BTreeSet<u32>>();

        // The expected usage is that Signer IDs start at zero and
        // increment by one until self.total_signers - 1. So the checks
        // here should be sufficient for catching empty signer ID sets,
        // duplicate signer IDs, or unknown signer IDs.
        let is_invalid_request = sign_request.nonce_responses.len() != signer_id_set.len()
            || signer_id_set.is_empty()
            || signer_id_set.last() >= Some(&self.total_signers);

        if is_invalid_request {
            warn!("received an invalid SignatureShareRequest");
            return Err(Error::InvalidNonceResponse);
        }

        let nonces = sign_request
            .nonce_responses
            .iter()
            .flat_map(|nr| nr.nonces.clone())
            .collect::<Vec<PublicNonce>>();

        for nonce in &nonces {
            if !nonce.is_valid() {
                warn!(
                    signer_id = %self.signer_id,
                    "received an SignatureShareRequest with invalid nonce"
                );
                return Err(Error::InvalidNonceResponse);
            }
        }

        debug!(signer_id = %self.signer_id, "received a valid SignatureShareRequest");

        if signer_id_set.contains(&self.signer_id) {
            let key_ids: Vec<u32> = sign_request
                .nonce_responses
                .iter()
                .flat_map(|nr| nr.key_ids.iter().copied())
                .collect::<Vec<u32>>();

            let signer_ids = signer_id_set.into_iter().collect::<Vec<_>>();
            let msg = &sign_request.message;
            let signature_shares = match sign_request.signature_type {
                SignatureType::Taproot(merkle_root) => {
                    self.signer
                        .sign_taproot(msg, &signer_ids, &key_ids, &nonces, merkle_root)
                }
                SignatureType::Schnorr => {
                    self.signer
                        .sign_schnorr(msg, &signer_ids, &key_ids, &nonces)
                }
                SignatureType::Frost => self.signer.sign(msg, &signer_ids, &key_ids, &nonces),
            };

            self.signer.gen_nonces(&self.network_private_key, rng);

            let response = SignatureShareResponse {
                dkg_id: sign_request.dkg_id,
                sign_id: sign_request.sign_id,
                sign_iter_id: sign_request.sign_iter_id,
                signer_id: self.signer_id,
                signature_shares,
            };
            info!(
                signer_id = %self.signer_id,
                dkg_id = %sign_request.dkg_id,
                sign_id = %sign_request.sign_id,
                sign_iter_id = %sign_request.sign_iter_id,
                "sending SignatureShareResponse"
            );

            Ok(vec![Message::SignatureShareResponse(response)])
        } else {
            debug!(signer_id = %self.signer_id, "signer not included in SignatureShareRequest");
            Ok(Vec::new())
        }
    }
```

**File:** src/net.rs (L309-326)
```rust
#[derive(Clone, Serialize, Deserialize, PartialEq)]
/// Nonce response message from signers to coordinator
pub struct NonceResponse {
    /// DKG round ID
    pub dkg_id: u64,
    /// Signing round ID
    pub sign_id: u64,
    /// Signing round iteration ID
    pub sign_iter_id: u64,
    /// Signer ID
    pub signer_id: u32,
    /// Key IDs
    pub key_ids: Vec<u32>,
    /// Public nonces
    pub nonces: Vec<PublicNonce>,
    /// Bytes being signed
    pub message: Vec<u8>,
}
```

**File:** src/state_machine/coordinator/mod.rs (L1546-1671)
```rust
    pub fn invalid_nonce<Coordinator: CoordinatorTrait, SignerType: SignerTrait>(
        num_signers: u32,
        keys_per_signer: u32,
    ) {
        let (mut coordinators, mut signers) =
            run_dkg::<Coordinator, SignerType>(num_signers, keys_per_signer);

        let msg = "It was many and many a year ago, in a kingdom by the sea"
            .as_bytes()
            .to_vec();

        // Start a signing round
        let signature_type = SignatureType::Frost;
        let message = coordinators
            .first_mut()
            .unwrap()
            .start_signing_round(&msg, signature_type, None)
            .unwrap();
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::NonceGather(signature_type)
        );

        // Send the message to all signers and gather responses by sharing with all other signers and coordinator
        let (outbound_messages, operation_results) =
            feedback_messages(&mut coordinators, &mut signers, &[message]);
        assert!(operation_results.is_empty());
        assert_eq!(
            coordinators.first_mut().unwrap().get_state(),
            State::SigShareGather(signature_type)
        );

        assert_eq!(outbound_messages.len(), 1);
        assert!(
            matches!(outbound_messages[0].msg, Message::SignatureShareRequest(_)),
            "Expected SignatureShareRequest message"
        );

        let messages = outbound_messages.clone();
        let result = feedback_messages_with_errors(&mut coordinators, &mut signers, &messages);
        assert!(result.is_ok());

        // test request with NonceResponse having zero nonce
        let mut packet = outbound_messages[0].clone();
        let Message::SignatureShareRequest(ref mut request) = packet.msg else {
            panic!("failed to match message");
        };
        for nonce_response in &mut request.nonce_responses {
            for nonce in &mut nonce_response.nonces {
                nonce.D = Point::new();
                nonce.E = Point::new();
            }
        }

        // Send the SignatureShareRequest message to all signers and share
        // their responses with the coordinator and signers
        let result = feedback_messages_with_errors(&mut coordinators, &mut signers, &[packet]);
        assert!(
            matches!(
                result,
                Err(StateMachineError::Signer(SignerError::InvalidNonceResponse))
            ),
            "Should have received signer invalid nonce response error, got {result:?}"
        );

        // test request with NonceResponse having generator nonce
        let mut packet = outbound_messages[0].clone();
        let Message::SignatureShareRequest(ref mut request) = packet.msg else {
            panic!("failed to match message");
        };
        for nonce_response in &mut request.nonce_responses {
            for nonce in &mut nonce_response.nonces {
                nonce.D = G;
                nonce.E = G;
            }
        }

        // Send the SignatureShareRequest message to all signers and share
        // their responses with the coordinator and signers
        let result = feedback_messages_with_errors(&mut coordinators, &mut signers, &[packet]);
        assert!(
            matches!(
                result,
                Err(StateMachineError::Signer(SignerError::InvalidNonceResponse))
            ),
            "Should have received signer invalid nonce response error, got {result:?}"
        );

        // test request with a duplicate NonceResponse
        let mut packet = outbound_messages[0].clone();
        let Message::SignatureShareRequest(ref mut request) = packet.msg else {
            panic!("failed to match message");
        };
        request
            .nonce_responses
            .push(request.nonce_responses[0].clone());

        // Send the SignatureShareRequest message to all signers and share
        // their responses with the coordinator and signers
        let result = feedback_messages_with_errors(&mut coordinators, &mut signers, &[packet]);
        assert!(
            matches!(
                result,
                Err(StateMachineError::Signer(SignerError::InvalidNonceResponse))
            ),
            "Should have received signer invalid nonce response error, got {result:?}"
        );

        // test request with an out of range signer_id
        let mut packet = outbound_messages[0].clone();
        let Message::SignatureShareRequest(ref mut request) = packet.msg else {
            panic!("failed to match message");
        };
        request.nonce_responses[0].signer_id = num_signers;

        // Send the SignatureShareRequest message to all signers and share
        // their responses with the coordinator and signers
        let result = feedback_messages_with_errors(&mut coordinators, &mut signers, &[packet]);
        assert!(
            matches!(
                result,
                Err(StateMachineError::Signer(SignerError::InvalidNonceResponse))
            ),
            "Should have received signer invalid nonce response error, got {result:?}"
        );
    }
```

**File:** src/v2.rs (L255-257)
```rust
        let (_, R) = compute::intermediate(msg, party_ids, nonces);
        let c = compute::challenge(&tweaked_public_key, &R, msg);
        let mut r = &self.nonce.d + &self.nonce.e * compute::binding(&self.id(), nonces, msg);
```
